/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./anviz-protocol/connection/connection.js":
/*!*************************************************!*\
  !*** ./anviz-protocol/connection/connection.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const net = __webpack_require__(/*! net */ "net");
const { Message } = __webpack_require__(/*! ./message */ "./anviz-protocol/connection/message.js");
const { Record } = __webpack_require__(/*! ../model/record */ "./anviz-protocol/model/record.js");
const { getInt16BigEndian, getInt32BigEndian, getInt16LittleEndian, setInt32BigEndian, setInt16BigEndian, setInt16LittleEndian } = __webpack_require__(/*! ../utils/bitwise-utils */ "./anviz-protocol/utils/bitwise-utils.js");
const { calculateChecksum } = __webpack_require__(/*! ../utils/crc16 */ "./anviz-protocol/utils/crc16.js");
const {toString} = __webpack_require__(/*! ../utils/utils */ "./anviz-protocol/utils/utils.js");
const { connected } = __webpack_require__(/*! process */ "process");

class Connection {

    static STX = 0xA5; // START TEXT

    static ACK_SUCCESS = 0x0;

    constructor(host, port) {
        this.host = host;
        this.port = port;

        this.buffer = Buffer.from([]);
    }

    connect = ()=> {
        
        this.disconnect();

        this.queue = [];

        this.busy = false;

        const socket = new net.Socket();
        socket.on('error', (e) => {
            if(this.isConnected()) {
                this.disconnect();
                this.listener.onError(e);
            }
        });

        socket.on('close', ()=> {
            if(this.isConnected()) {
                this.disconnect();
                this.listener.onConnectionLost();
            }
        });

        socket.on("data", (data)=> {
            try {
                this.buffer = this.handleData(Buffer.concat([this.buffer, data]));
            } catch (e) { // Unhandled exception
                console.log(e);
            }
        });
        
        socket.connect({ port: this.port, host: this.host });
        
        this.socket = socket;

    }

    handleData = (buffer)=> {

        while(buffer.length > 9) {
            if(buffer[0] != Connection.STX ) {
                buffer = buffer.slice(1); // ignore byte index 0
            } else {
                // LEN （data length） 2 Byte
                const len = getInt16BigEndian(buffer, 7) + 11; 
                if(buffer.length  < len) {
                    break; // wait for data
                }
                this._handleResponse(buffer.slice(0, len));
                buffer = buffer.slice(len, buffer.length); // remove frame
            }
        }

        return buffer; // return data
    }

    _handleResponse = (data)=> {

        const n = data.length - 2;
        let crc1 = calculateChecksum(data, n);
		let crc2 = getInt16LittleEndian(data, n) & 0xFFFF;
		if(crc1 != crc2) {
			const message = "Invalid Checksum: " + toString(data, 0, data.length);
			this.listener.onError(new Error(message));
		} else {

            const message = new Message();
            message.deviceCode = getInt32BigEndian(data, 1);
            message.command = data[5] - 0x80;
            message.returnValue = data[6];
            message.data = data.slice(9, n);

            if((message.command & 0xFF) == 0x13) { // it only happens when the device starts up
                // Message data:
                // 05 00 01 00 00 00 00 00 2a 47 53 c4 00 05 00 00
            } else if((message.command & 0xFF) == 0x5F) { // RealTime mode
                const record = Record.valueOf(message.data, 0);
                record.deviceCode = message.deviceCode;
                this.listener.onRecord(record);
            } else {
                const cmd = this.queue.shift();
                const next = cmd.onResponse(message);
                if(next) {
                    this.queue.unshift(next);
                    this.socket.write(this.toBuffer(next));
                } else if(this.queue.length > 0) {
                    this.socket.write(this.toBuffer(this.queue[0]));
                } else {
                    this.busy = false;
                }
            }

        }

    }

    isConnected = ()=> {
        return this.socket != null; 
    }

    disconnect = ()=> {
        if(this.socket != null) {
            try {
                this.socket.destroy();
            } catch(e) { // ignore
            } finally {
                this.socket = null;
            }
        }
    }

    send = (cmd) => {
       this.queue.push(cmd);
       if(!this.busy) {
           this.busy = true;
           this.socket.write(this.toBuffer(cmd));
       }
    }

    getQueueInfo() {
        let value = [];
        for(let i = 0; i < this.queue.length; ++i) {
            value.push(this.getInfo(this.queue[i]));
        }
        return value;
    }

    getInfo(cmd) {
        return cmd.info + ':' + cmd.command;
    }

    toBuffer(cmd) {
		const data = cmd.data;
		const dataLen = data != null ? data.length : 0;
		const cmdData = Buffer.alloc(10 + dataLen);
		// STX
		cmdData[0] = Connection.STX;
		// CH （device code)
		setInt32BigEndian(cmdData, 1, cmd.deviceCode);
		// CMD （command)
		cmdData[5] = cmd.command;
		if(dataLen > 0) {
			// LEN (data length)
			setInt16BigEndian(cmdData, 6, dataLen);
			// DATA
            data.copy(cmdData, 8, 0, dataLen);
		}
		// CRC16
		const crc = calculateChecksum(cmdData, cmdData.length - 2); 
		setInt16LittleEndian(cmdData, cmdData.length - 2, crc);
		return cmdData;
	}

    /*print(b) {
        let str = "";
        for(let i = 0; i < b.length; ++i) {
            str += b[i] + ", ";
        }
        console.log(str);
    }*/

}

module.exports = { Connection };


/***/ }),

/***/ "./anviz-protocol/connection/message.js":
/*!**********************************************!*\
  !*** ./anviz-protocol/connection/message.js ***!
  \**********************************************/
/***/ ((module) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

class Message {

    static MAX_RESULTS = 0x8;
	
	static GET_DEVICE_ID = 0x74;
	static SET_DEVICE_ID = 0x75;
	
	static GET_DEVICE_INFO1  = 0x30; // Get the information of T&A device 1
	static SET_DEVICE_INFO1  = 0x31; // Set the configure information of T&A 1
	static GET_DEVICE_INFO2  = 0x32; // Get the information of T&A device 2
	static SET_DEVICE_INFO2  = 0x33; // Set the configure information of T&A 2
	static GET_SERIAL_NUMBER = 0x24;
	
	static GET_DATE_TIME = 0x38; // Get the date and time of T&A
	static SET_DATE_TIME = 0x39; // Set the date and time of T&A
	
	static GET_RECORD_INFORMATION = 0x3C;
	
	static GET_RECORDS   = 0x40;
	static CLEAR_RECORDS = 0x4E;

	static GET_USER_INFO = 0x72;
	static SET_USER_INFO = 0x73;
	static DELETE_USER   = 0x4C;
	
	static GET_FP_TEMPLATE = 0x44;
	static SET_FP_TEMPLATE = 0x45;
		
	static OPEN_LOCK = 0x5E;

    constructor() {

    }

}

module.exports = { Message };

/***/ }),

/***/ "./anviz-protocol/device.js":
/*!**********************************!*\
  !*** ./anviz-protocol/device.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const { Connection } = __webpack_require__(/*! ./connection/connection */ "./anviz-protocol/connection/connection.js");
const { Message } = __webpack_require__(/*! ./connection/message */ "./anviz-protocol/connection/message.js");
const { DeviceInfo1 } = __webpack_require__(/*! ./model/device-info1 */ "./anviz-protocol/model/device-info1.js");
const { DeviceInfo2 } = __webpack_require__(/*! ./model/device-info2 */ "./anviz-protocol/model/device-info2.js");
const { Record } = __webpack_require__(/*! ./model/record */ "./anviz-protocol/model/record.js");
const { RecordInformation } = __webpack_require__(/*! ./model/record-information */ "./anviz-protocol/model/record-information.js");
const { UserInfo } = __webpack_require__(/*! ./model/user-info */ "./anviz-protocol/model/user-info.js");
const { setInt32BigEndian, setLong40BigEndian } = __webpack_require__(/*! ./utils/bitwise-utils */ "./anviz-protocol/utils/bitwise-utils.js");

class Device extends Connection {

    constructor(host, port = 5010, deviceId = 0) { // When deviceId (CH) is 0，all devices connected will response to this command.
        super(host, port);
        this.deviceId = deviceId;
    }

    handleResponse = (cmd, callback)=> {
        cmd.onResponse = (response) => {
            if (response.command != cmd.command) {
                let message = `Command code mismatch, expected: ${cmd.command}, received: ${response.command}`;
                throw new Error(message);
            }
            if(response.returnValue != Connection.ACK_SUCCESS) {
                throw new Error("ACK Error: " + response.returnValue);
            }
            return callback(response);
        };
        this.send(cmd);
    }

    setDeviceId = (id) => {
        const cmd = new Message();
        cmd.info = 'setDeviceId';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.SET_DEVICE_ID;
        const data = Buffer.alloc(4);
        setInt32BigEndian(data, 0, id);
        cmd.data = data;
        this.handleResponse(cmd, (response)=> {
            this.deviceId = id;
        });
    }

    getDeviceId = (callback)=> { // there's no answer
		/*const cmd = new Message();
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_DEVICE_ID;
        this.handleResponse(cmd, (response)=> {
            callback(getInt32BigEndian(response.data, 0));
        });*/
        if(callback) callback(this.deviceId);
        return this.deviceId;
    }

    getDeviceInfo1 = (callback) => {
		const cmd = new Message();
        cmd.info = 'getDeviceInfo1';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_DEVICE_INFO1;
        this.handleResponse(cmd, (response)=> {
            callback(DeviceInfo1.valueOf(response.data));
        });
	}

    setDeviceInfo1 = (deviceInfo) => {
        const cmd = new Message();
        cmd.info = 'setDeviceInfo1';
		cmd.deviceCode = this.deviceId;
        const data = Buffer.alloc(12);
        deviceInfo.getBytes(data, 0);
        cmd.data = data;
		cmd.command = Message.SET_DEVICE_INFO1;
        this.handleResponse(cmd, (response)=> {});
    }

    getDeviceInfo2 = (callback) => {
		const cmd = new Message();
        cmd.info = 'getDeviceInfo2';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_DEVICE_INFO2;
        this.handleResponse(cmd, (response)=> {
            callback(DeviceInfo2.valueOf(response.data));
        });
	}

    setDeviceInfo2 = (deviceInfo) => {
        const cmd = new Message();
        cmd.info = 'setDeviceInfo2';
		cmd.deviceCode = this.deviceId;
        const data = Buffer.alloc(15);
        deviceInfo.getBytes(data, 0);
        cmd.data = data;
		cmd.command = Message.SET_DEVICE_INFO2;
        this.handleResponse(cmd, (response)=> {});
    }

    getRecordInformation = (callback)=> {
        const cmd = new Message();
        cmd.info = 'getRecordInformation';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_RECORD_INFORMATION;
        this.handleResponse(cmd, (response)=> {
            callback(RecordInformation.valueOf(response.data));
        });
    }

    getAllRecords(callback) {
        this.getRecordInformation((info)=> {
            this._getRecords(0x1, info.allRecordAmount, callback);
        });
    }

    getNewRecords(callback) {
        this.getRecordInformation((info)=> {
            this._getRecords(0x2, info.newRecordAmount, callback);
        });
    }

    _getRecords = (mode, amount, callback)=> {
        
        const cmd = new Message();
        cmd.info = '_getRecords';
        cmd.deviceCode = this.deviceId;
        cmd.command = Message.GET_RECORDS;
        cmd.data = Buffer.from([mode, Math.min(amount, Message.MAX_RESULTS)]);
        
        let retries = 2;
        let records = [];

        const handler = (response)=> { 
            try {
                const count = response.data[0] & 0xFF; // valid records
                for(let i = 0; i < count; ++i) {
                    let offset = i * 14 + 1;
                    const record = Record.valueOf(response.data, offset);
                    record.deviceCode = response.deviceCode;
                    records.push(record);
                }
                amount -= count;
                if(count > 0 && amount > 0) {
                    retries = 2;
                    cmd.data[0] = 0x0; // Download normal;
                    cmd.data[1] = Math.min(amount, Message.MAX_RESULTS); 
                } else {
                    callback(records);
                    return null;
                }
            } catch(e) {
                if(retries === 0) throw e;
                retries--;
                cmd.data[0] = 0x10; // Send last packet again
            }
            // this.handleResponse(cmd, handler);
            return cmd;
        }
        this.handleResponse(cmd, handler);
  
    }

    clearAllRecords = (callback)=> {
        const cmd = new Message();
        cmd.info = 'clearAllRecords';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.CLEAR_RECORDS;
        cmd.data = Buffer.from([0, 0, 0, 0]);
        this.handleResponse(cmd, (response)=> {
            const data = response.data;
            if(callback) callback(data[0] << 16 | (data[1] & 0xFF) << 8 | (data[2] & 0xFF));
        });
    }

    clearAllRecordsSign = (callback)=> {
        this.clearRecordsSign(0, callback);
    }

    /**
	 * Cancel all records, or cancel all/part new records sign
	 * @param amount 0 = all redords sign
	 */
    clearRecordsSign = (amount, callback)=>{
        let code;
		if(amount < 1) {
			amount = 0;
			code = 0x1; // all sign
		} else {
			code = 0x2; // amount sign
		}
		const cmd = new Message();
        cmd.info = 'clearRecordSign';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.CLEAR_RECORDS;
        cmd.data = Buffer.from([code, (amount >> 16) & 0xFF, (amount >> 8) & 0xFF, amount & 0xFF]);

        this.handleResponse(cmd, (response)=> {
            const data = response.data;
            if(callback) callback(data[0] << 16 | (data[1] & 0xFF) << 8 | (data[2] & 0xFF));
        })
    }

    getSerialNumber = (callback) => {
		const cmd = new Message();
        cmd.info = 'getSerialNumber';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_SERIAL_NUMBER;
        this.handleResponse(cmd, (response)=> {
            callback(response.data.toString('utf8', 0, 16));
        });
	}

    openLock = ()=> {
        const cmd = new Message();
        cmd.info = 'openLock';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.OPEN_LOCK;
        this.handleResponse(cmd, (response)=> {});
    }

    getDateTime = (callback) => {
		const cmd = new Message();
        cmd.info = 'getDateTime';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_DATE_TIME;
        this.handleResponse(cmd, (response)=> {
            const data = response.data;
            const millis = Date.UTC(
                (data[0] & 0xFF) + 2000, // YEAR
                data[1], // MONTH
                data[2], // DAY_OF_MONTH
                data[3], // HOUR_OF_DAY
                data[4], // MINUTE
                data[5], // SECOND
                0 // MILLISECOND
            );
            const date = new Date(millis);
            callback(date);
        });
    }

    setDateTime = (date) => {
        const cmd = new Message();
        cmd.info = 'setDateTime';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.SET_DATE_TIME;
        const data = Buffer.alloc(6);
        data[0] = date.getFullYear() - 2000;
		data[1] = date.getMonth() + 1;
		data[2] = date.getDate();
		data[3] = date.getHours();
		data[4] = date.getMinutes();
		data[5] = date.getSeconds();
        cmd.data = data;
        this.handleResponse(cmd, (response)=> {});
    }

    /**
	 * Download fingerprint/face template from T&A device
	 * Note: The template information contains the userId, and cannot be used with a different id (setFpTemplate)
	 * @param userId
	 * @param backupCode 11 -> Facepass 7, 1 -> fingerprint
     */
    getFpTemplate = (userId, backupCode, callback)=> {
        const cmd = new Message();
        cmd.info = 'getFpTemplate';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_FP_TEMPLATE;
        const data = Buffer.alloc(6);
        setLong40BigEndian(data, 0, userId);
		data[5] = backupCode;
        cmd.data = data;
        this.handleResponse(cmd, (response)=> {
            callback(response.data);
        });
    }

    /**
	 * Upload fingerprint/face template to the T&A device
	 * Note: The template information contains the userId, and cannot be used with a different id.
	 * @param userId
	 * @param backupCode 11 -> Facepass 7, 1 -> fingerprint
	 * @param ftTemplate
     */
    setFpTemplate = (userId, backupCode, ftTemplate) => {
        const cmd = new Message();
        cmd.info = 'setFpTemplate';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.SET_FP_TEMPLATE;
        const data = Buffer.alloc(6);
        setLong40BigEndian(data, 0, userId);
		data[5] = backupCode;
        cmd.data = Buffer.concat([data, ftTemplate]);
        this.handleResponse(cmd, (response)=> { });
    }

    getUserInfos = (callback)=> {

        const cmd = new Message();
        cmd.info = 'getUserInfos';
        cmd.deviceCode = this.deviceId;
        cmd.command = Message.GET_USER_INFO;
        cmd.data = Buffer.from([0x1, Message.MAX_RESULTS]); // 0x1 = Download Start
        
        let retries = 2;
        let records = [];

        const handler = (response)=> {
            try {
                const count = response.data[0] & 0xFF;
                for(let i = 0; i < count; ++i) {
                    let offset = i * 40 + 1;
                    const userInfo = UserInfo.valueOf(response.data, offset);
                    userInfo.deviceCode = response.deviceCode;
                    records.push(userInfo);
                }
                if(count > 0) {
                    retries = 2;
                    cmd.data[0] = 0x0; // Download normal;
                } else {
                    callback(records);
                    return null;
                }
            } catch(e) {
                if(retries === 0) throw e;
                retries--;
                cmd.data[0] = 0x10; // Send last packet again
            }
            // this.handleResponse(cmd, handler);
            return cmd;
        }
        this.handleResponse(cmd, handler);

    }

    deleteUser = (userId) => {
        const cmd = new Message();
        cmd.info = 'deleteUser';
        cmd.deviceCode = this.deviceId;
        cmd.command = Message.DELETE_USER;
        var data = Buffer.alloc(6); 
        setLong40BigEndian(data, 0, userId);
        data[5] = 0xFF;
        cmd.data = data;
        this.handleResponse(cmd, (response) => {});
    }

    setUserInfo = (userInfo) => {
        this.setUserInfos([userInfo]);
    }

    setUserInfos = (userInfos) => {
        for(let i = 0; i < userInfos.length;) {
			let j = Math.min(userInfos.length, i + 12); // sub list max 12 items
			this._setUserInfos(userInfos.slice(i, j));
			i = j;
		}
    }

    _setUserInfos(userInfos) {
        const cmd = new Message();
        cmd.info = '_setUserInfos';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.SET_USER_INFO;
        const n = userInfos.length;
		const data = Buffer.alloc(1 + n * 40);
		data[0] = n; // Information Num
		for (let i = 0; i < n; ++i) {
			const userInfo = userInfos[i];
			userInfo.getBytes(data, i * 40 + 1);
		}
		cmd.data = data;
        this.handleResponse(cmd, (response) => {});
    }

}

module.exports = { Device };

/***/ }),

/***/ "./anviz-protocol/index.js":
/*!*********************************!*\
  !*** ./anviz-protocol/index.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Device } = __webpack_require__(/*! ./device.js */ "./anviz-protocol/device.js");
const { Record } = __webpack_require__(/*! ./model/record.js */ "./anviz-protocol/model/record.js");
const { RecordInformation } = __webpack_require__(/*! ./model/record-information.js */ "./anviz-protocol/model/record-information.js");
const { DeviceInfo1 } = __webpack_require__(/*! ./model/device-info1.js */ "./anviz-protocol/model/device-info1.js");
const { DeviceInfo2 } = __webpack_require__(/*! ./model/device-info2.js */ "./anviz-protocol/model/device-info2.js");

module.exports = { Device, Record, RecordInformation, DeviceInfo1, DeviceInfo2 };

/***/ }),

/***/ "./anviz-protocol/model/device-info1.js":
/*!**********************************************!*\
  !*** ./anviz-protocol/model/device-info1.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const { getInt16BigEndian } = __webpack_require__(/*! ../utils/bitwise-utils */ "./anviz-protocol/utils/bitwise-utils.js");

class DeviceInfo1 {

	getBytes(data, offset) {
		data[offset] = ((this.communicationPassword >> 16) & 0xF) | ((this.communicationPasswordLength & 0xF) << 4);
		data[offset + 1] = (this.communicationPassword >> 8) & 0xFF;
		data[offset + 2] = this.communicationPassword & 0xFF;
		data[offset + 3] = this.sleepTime;
		data[offset + 4] = this.volume;
		data[offset + 5] = this.language;
		data[offset + 6] = this.timeFormat | ((this.dateFormat & 0xF) << 4);
		data[offset + 7] = this.attendanceState;
		data[offset + 8] = this.languageSetting;
	}

   static valueOf(data) {
		const deviceInfo = new DeviceInfo1();
		deviceInfo.firmwareVersion = data.toString('utf-8', 0, 8);
		deviceInfo.communicationPasswordLength = (data[8] >> 4) & 0xF; 
		const v1 = (data[8] & 0xF) << 16;
		const v2 = (getInt16BigEndian(data, 9) & 0xFFFF);
		deviceInfo.communicationPassword = v1 | v2;
		deviceInfo.sleepTime = data[11];
		deviceInfo.volume = data[12];
		deviceInfo.language = data[13];
		deviceInfo.timeFormat = data[14] & 0xF;
		deviceInfo.dateFormat = (data[14] >> 4) & 0xF;
		deviceInfo.attendanceState = data[15];
		deviceInfo.languageSetting = data[16];
		deviceInfo.commandVersion = data[17];
		return deviceInfo;
	}

}

module.exports = {DeviceInfo1};

/***/ }),

/***/ "./anviz-protocol/model/device-info2.js":
/*!**********************************************!*\
  !*** ./anviz-protocol/model/device-info2.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const { getInt24BigEndian, setInt24BigEndian } = __webpack_require__(/*! ../utils/bitwise-utils */ "./anviz-protocol/utils/bitwise-utils.js");

class DeviceInfo2 {

	getBytes(data, offset) {
		data[offset] = this.fingerprintPrecision;
		data[offset + 1] = this.wiegandHeadCode;
		data[offset + 2] = this.wieganOption;
		data[offset + 3] = this.workCodePermission;
		data[offset + 4] = this.realTimeModeSetting;
		data[offset + 5] = this.autoUpdateFpSetting;
		data[offset + 6] = this.relayMode;
		data[offset + 7] = this.lockDelay;
		setInt24BigEndian(data, offset + 8, this.memoryFullAlarm);
		data[offset + 11] = this.repeatAttendanceDelay;
		data[offset + 12] = this.doorSensorDelay;
		data[offset + 13] = this.scheduledBellDelay;
		data[offset + 14] = this.reserved;
	}

    static valueOf(data) {
        const deviceInfo = new DeviceInfo2();
		deviceInfo.fingerprintPrecision = data[0];
		deviceInfo.wiegandHeadCode = data[1];
		deviceInfo.wieganOption = data[2];
		deviceInfo.workCodePermission = data[3];
		deviceInfo.realTimeModeSetting = data[4];
		deviceInfo.autoUpdateFpSetting = data[5];
		deviceInfo.relayMode = data[6];
		deviceInfo.lockDelay = data[7];
		deviceInfo.memoryFullAlarm = getInt24BigEndian(data, 8);
		deviceInfo.repeatAttendanceDelay = data[11];
		deviceInfo.doorSensorDelay = data[12];
		deviceInfo.scheduledBellDelay = data[13];
		deviceInfo.reserved = data[14];
		return deviceInfo;
    }

}

module.exports = { DeviceInfo2 };

/***/ }),

/***/ "./anviz-protocol/model/record-information.js":
/*!****************************************************!*\
  !*** ./anviz-protocol/model/record-information.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const { getInt24BigEndian } = __webpack_require__(/*! ../utils/bitwise-utils */ "./anviz-protocol/utils/bitwise-utils.js");

class RecordInformation {

	static valueOf(data) {
		const result = new RecordInformation();
		result.userAmount = getInt24BigEndian(data, 0);
		result.fpAmount = getInt24BigEndian(data, 3);
		result.passwordAmount =getInt24BigEndian(data, 6);
		result.cardAmount = getInt24BigEndian(data, 9);
		result.allRecordAmount = getInt24BigEndian(data, 12);
		result.newRecordAmount = getInt24BigEndian(data, 15);
		return result;
	}

}

module.exports = {RecordInformation};

/***/ }),

/***/ "./anviz-protocol/model/record.js":
/*!****************************************!*\
  !*** ./anviz-protocol/model/record.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const { getInt32BigEndian, getLong40BigEndian } = __webpack_require__(/*! ../utils/bitwise-utils */ "./anviz-protocol/utils/bitwise-utils.js");

class Record {

    static MILLIS_INC = 946771200000; // 01/02/2000 in milliseconds since 01/01/1970

    static valueOf(data, offset) {
		const result = new Record();
		result.userId = getLong40BigEndian(data, offset);
		result.dateTime = Record.toDateTime(getInt32BigEndian(data, offset + 5));
		result.backupCode = data[offset + 9];
		result.type = data[offset + 10];
		result.workTypes = [data[offset + 11], data[offset + 12], data[offset + 13]];
		return result;
	}

	static toDateTime(seconds) {
		const time = seconds * 1000 + Record.MILLIS_INC;
		return time; /* time - TimeZone.getDefault().getOffset(time); */
	}

}

module.exports = {Record};

/***/ }),

/***/ "./anviz-protocol/model/user-info.js":
/*!*******************************************!*\
  !*** ./anviz-protocol/model/user-info.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const { getInt16BigEndian, getInt32BigEndian, getLong40BigEndian, setInt16BigEndian, setInt32BigEndian, setLong40BigEndian } = __webpack_require__(/*! ../utils/bitwise-utils */ "./anviz-protocol/utils/bitwise-utils.js");
const { toString } = __webpack_require__(/*! ../utils/utils */ "./anviz-protocol/utils/utils.js");

class UserInfo {

    constructor() {
        this.password = 0;
        this.passwordLength = 0;
        this.card = 0;
        this.dpt = 0;
        this.group = 0;
        this.attendanceMode = 0;
        this.enrollFpState = 0;
        this.keep = 0;
        this.specialMessage = 0;
    }

    getBytes(data, offset) {

        setLong40BigEndian(data, offset, this.userId);
		
		//result.passwordLength = (data[offset + 5] >> 4) & 0xF; 
		//int v1 = ((data[offset + 5] & 0xF) << 16) | getInt16BigEndian(data, offset + 6);
		//int v2 = data[offset + 27] << 12;
		
		data[offset + 5] = (this.passwordLength << 4) | ((this.password >> 16) & 0xF);
		setInt16BigEndian(data, offset + 6, this.password & 0xFFFF);
		setInt16BigEndian(data, offset + 27, this.password >> 12); // 8 bits
		
		setInt32BigEndian(data, offset + 8, this.card);

		for(let i = offset + 12, n = i + 19; i < n; ++i) { // Clear name bytes
            data[i] = 0;
        }
        
		if(this.name != null) { // set name bytes
            let index = offset + 12;
            let n = Math.min(index + 19, index + (this.name.length * 2 + 2));
            data[index++] = -2;
            data[index++] = -1;
            let i = 0;
            while(index < n) {
                data[index++] = 0;
                data[index++] = this.name.charCodeAt(i++);
            }
		}

		data[offset + 32] = this.dpt;
		data[offset + 33] = this.group;
		data[offset + 34] = this.attendanceMode;
		setInt16BigEndian(data, offset + 35, this.enrollFpState);
		data[offset + 38] = this.keep;
		data[offset + 39] = this.specialMessage;
    }

    static valueOf(data, offset) { // UNICODE version 
		const result = new UserInfo();
		result.userId = getLong40BigEndian(data, offset);
		result.passwordLength = (data[offset + 5] >> 4) & 0xF; 
        // The low 20bits of password is saved in Byte 6-8, high 8 bits saved in Byte28
		const v1 = (((data[offset + 5] & 0xF) << 16) | getInt16BigEndian(data, offset + 6));
		const v2 = data[offset + 27] << 12;
        result.password = v1 | v2;
		result.card = getInt32BigEndian(data, offset + 8);
        const d = data.slice(offset + 12, offset + 19);
		result.name = toString(data, offset + 12, offset + 31);
		result.dpt   = data[offset + 32];
		result.group = data[offset + 33];
		result.attendanceMode = data[offset + 34];
		result.enrollFpState = getInt16BigEndian(data, offset + 35);
		result.keep = data[offset + 38];
		result.specialMessage = data[offset + 39];
		return result;
	}

}

module.exports = {UserInfo};

/***/ }),

/***/ "./anviz-protocol/utils/bitwise-utils.js":
/*!***********************************************!*\
  !*** ./anviz-protocol/utils/bitwise-utils.js ***!
  \***********************************************/
/***/ ((module) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const setLong40BigEndian = (data, offset, value) => {
    data[offset    ] = Number(BigInt(value) >> 32n);
    data[offset + 1] = value >> 24;
    data[offset + 2] = value >> 16;
    data[offset + 3] = value >> 8 ;
    data[offset + 4] = value;
}

const getLong40BigEndian = (data, offset) => {
    return data[offset] << 32 
        | (data[offset + 1] & 0xFF) << 24
        | (data[offset + 2] & 0xFF) << 16
        | (data[offset + 3] & 0xFF) << 8 
        | (data[offset + 4] & 0xFF);
}

const getInt32BigEndian = (data, offset) => {
    return data[offset] << 24 
        | (data[offset + 1] & 0xFF) << 16
        | (data[offset + 2] & 0xFF) << 8 
        | (data[offset + 3] & 0xFF);
}

const setInt32BigEndian = (data, offset, value) => {
    data[offset    ] = value >> 24;
    data[offset + 1] = value >> 16;
    data[offset + 2] = value >> 8;
    data[offset + 3] = value;
}

const getInt24BigEndian = (data, offset) => {
    return data[offset] << 16 
        | (data[offset + 1] & 0xFF) << 8 
        | (data[offset + 2] & 0xFF);
}

const setInt24BigEndian = (data, offset, value) => {
    data[offset    ] = value >> 16;
    data[offset + 1] = value >> 8;
    data[offset + 2] = value;
}

const getInt16BigEndian = (data, offset) => {
    return data[offset] << 8 | (data[offset + 1] & 0xFF);
}

const setInt16BigEndian = (data, offset, value) => {
    data[offset    ] = value >> 8;
    data[offset + 1] = value;
}

const getInt16LittleEndian = (data, offset) => {
    return (data[offset] & 0XFF) | (data[offset + 1] << 8);
}

const setInt16LittleEndian = (data, offset, value) => {
    data[offset    ] = value;
    data[offset + 1] = value >> 8;
}

module.exports = {getLong40BigEndian, setLong40BigEndian, getInt32BigEndian, setInt32BigEndian, getInt24BigEndian, setInt24BigEndian, getInt16BigEndian, setInt16BigEndian, getInt16LittleEndian, setInt16LittleEndian};

/***/ }),

/***/ "./anviz-protocol/utils/crc16.js":
/*!***************************************!*\
  !*** ./anviz-protocol/utils/crc16.js ***!
  \***************************************/
/***/ ((module) => {

const table = [];
const polynomial = 0x8408;
for (let b = 0; b < 256; b++) {
    let crc = b;
    for (let i = 0; i < 8; i++) {
        crc = (crc >> 1) ^ ((crc & 1) == 1 ? polynomial : 0);
    }
    table[b] = 0xFFFF & crc;
}

const calculateChecksum = (data, len) => {
    let crc = 0xFFFF;
    for(let i = 0; i < len; ++i) {
        let b = data[i];
        crc = (crc >> 8) ^ table[(crc ^ b) & 0xFF];
    }
    return crc & 0xFFFF;
}

module.exports = {calculateChecksum};

/***/ }),

/***/ "./anviz-protocol/utils/utils.js":
/*!***************************************!*\
  !*** ./anviz-protocol/utils/utils.js ***!
  \***************************************/
/***/ ((module) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const toString = (data, start, end) => {
    let result = "";
    for(var i = start; i < end; i++) {
        let code = String.fromCharCode(data[i]);
        if(code !== '\x00') {
            result += code;
        }
    } 
    return result;
}

module.exports = {toString};

/***/ }),

/***/ "./src/app.module.ts":
/*!***************************!*\
  !*** ./src/app.module.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AppModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const common_module_1 = __webpack_require__(/*! ./common/common.module */ "./src/common/common.module.ts");
const config_module_1 = __webpack_require__(/*! ./config/config.module */ "./src/config/config.module.ts");
const database_module_1 = __webpack_require__(/*! ./database/database.module */ "./src/database/database.module.ts");
const account_management_module_1 = __webpack_require__(/*! ./modules/account-management/account-management.module */ "./src/modules/account-management/account-management.module.ts");
const addresses_module_1 = __webpack_require__(/*! ./modules/addresses/addresses.module */ "./src/modules/addresses/addresses.module.ts");
const attendance_management_module_1 = __webpack_require__(/*! ./modules/attendance-management/attendance-management.module */ "./src/modules/attendance-management/attendance-management.module.ts");
const biometrics_module_1 = __webpack_require__(/*! ./modules/biometrics/biometrics.module */ "./src/modules/biometrics/biometrics.module.ts");
const compliance_management_module_1 = __webpack_require__(/*! ./modules/compliance-management/compliance-management.module */ "./src/modules/compliance-management/compliance-management.module.ts");
const documents_module_1 = __webpack_require__(/*! ./modules/documents/documents.module */ "./src/modules/documents/documents.module.ts");
const emails_module_1 = __webpack_require__(/*! ./modules/emails/emails.module */ "./src/modules/emails/emails.module.ts");
const employee_management_module_1 = __webpack_require__(/*! ./modules/employee-management/employee-management.module */ "./src/modules/employee-management/employee-management.module.ts");
const files_module_1 = __webpack_require__(/*! ./modules/files/files.module */ "./src/modules/files/files.module.ts");
const logs_module_1 = __webpack_require__(/*! ./modules/logs/logs.module */ "./src/modules/logs/logs.module.ts");
const notifications_module_1 = __webpack_require__(/*! ./modules/notifications/notifications.module */ "./src/modules/notifications/notifications.module.ts");
const organization_management_module_1 = __webpack_require__(/*! ./modules/organization-management/organization-management.module */ "./src/modules/organization-management/organization-management.module.ts");
const payroll_management_module_1 = __webpack_require__(/*! ./modules/payroll-management/payroll-management.module */ "./src/modules/payroll-management/payroll-management.module.ts");
const shift_management_module_1 = __webpack_require__(/*! ./modules/shift-management/shift-management.module */ "./src/modules/shift-management/shift-management.module.ts");
let AppModule = class AppModule {
};
exports.AppModule = AppModule;
exports.AppModule = AppModule = __decorate([
    (0, common_1.Module)({
        imports: [
            config_module_1.ConfigModule,
            database_module_1.DatabaseModule,
            common_module_1.CommonModule,
            logs_module_1.LogsModule,
            files_module_1.FilesModule,
            notifications_module_1.NotificationsModule,
            documents_module_1.DocumentsModule,
            employee_management_module_1.EmployeeManagementModule,
            account_management_module_1.AccountManagementModule,
            organization_management_module_1.OrganizationManagementModule,
            attendance_management_module_1.AttendanceManagementModule,
            shift_management_module_1.ShiftManagementModule,
            addresses_module_1.AddressesModule,
            documents_module_1.DocumentsModule,
            biometrics_module_1.BiometricsModule,
            payroll_management_module_1.PayrollManagementModule,
            emails_module_1.EmailsModule,
            compliance_management_module_1.ComplianceManagementModule,
        ],
        controllers: [],
    })
], AppModule);


/***/ }),

/***/ "./src/bull/bull.module.ts":
/*!*********************************!*\
  !*** ./src/bull/bull.module.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BullModule_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BullModule = void 0;
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const queues_config_1 = __webpack_require__(/*! ../config/queues.config */ "./src/config/queues.config.ts");
const queue_factory_service_1 = __webpack_require__(/*! ./services/queue-factory.service */ "./src/bull/services/queue-factory.service.ts");
let BullModule = BullModule_1 = class BullModule {
    static forRoot() {
        return {
            module: BullModule_1,
            imports: [
                bull_1.BullModule.forRootAsync({
                    imports: [config_1.ConfigModule],
                    inject: [config_1.ConfigService],
                    useFactory: (configService) => ({
                        redis: {
                            host: configService.get('REDIS_HOST', 'localhost'),
                            port: configService.get('REDIS_PORT', 6379),
                            password: configService.get('REDIS_PASSWORD', undefined),
                        },
                        defaultJobOptions: {
                            attempts: 3,
                            backoff: { type: 'exponential', delay: 1000 },
                            removeOnComplete: true,
                            removeOnFail: false,
                        },
                    }),
                }),
                bull_1.BullModule.registerQueue(...queues_config_1.queues.map((queueConfig) => ({
                    name: queueConfig.name,
                    options: queueConfig.options,
                }))),
            ],
            providers: [queue_factory_service_1.QueueFactoryService],
            exports: [bull_1.BullModule],
        };
    }
};
exports.BullModule = BullModule;
exports.BullModule = BullModule = BullModule_1 = __decorate([
    (0, common_1.Module)({})
], BullModule);


/***/ }),

/***/ "./src/bull/services/queue-factory.service.ts":
/*!****************************************************!*\
  !*** ./src/bull/services/queue-factory.service.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueueFactoryService = void 0;
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const bull_2 = __webpack_require__(/*! bull */ "bull");
let QueueFactoryService = class QueueFactoryService {
    constructor(notificationsQueue, scheduleQueue, payrollQueue, workHourQueue) {
        this.notificationsQueue = notificationsQueue;
        this.scheduleQueue = scheduleQueue;
        this.payrollQueue = payrollQueue;
        this.workHourQueue = workHourQueue;
        this.queues = new Map();
        this.queues.set('notifications', notificationsQueue);
        this.queues.set('schedule-generation', scheduleQueue);
        this.queues.set('payroll-processing', payrollQueue);
        this.queues.set('work-hour-calculation', workHourQueue);
    }
    getQueue(name) {
        return this.queues.get(name);
    }
    async addJob(queueName, jobName, data, options) {
        const queue = this.getQueue(queueName);
        if (!queue) {
            return null;
        }
        return queue.add(jobName, data, options);
    }
};
exports.QueueFactoryService = QueueFactoryService;
exports.QueueFactoryService = QueueFactoryService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, bull_1.InjectQueue)('notifications')),
    __param(1, (0, bull_1.InjectQueue)('schedule-generation')),
    __param(2, (0, bull_1.InjectQueue)('payroll-processing')),
    __param(3, (0, bull_1.InjectQueue)('work-hour-calculation')),
    __metadata("design:paramtypes", [typeof (_a = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _a : Object, typeof (_b = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _b : Object, typeof (_c = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _c : Object, typeof (_d = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _d : Object])
], QueueFactoryService);


/***/ }),

/***/ "./src/common/common.module.ts":
/*!*************************************!*\
  !*** ./src/common/common.module.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonModule = void 0;
const employee_management_module_1 = __webpack_require__(/*! @/modules/employee-management/employee-management.module */ "./src/modules/employee-management/employee-management.module.ts");
const cutoffs_module_1 = __webpack_require__(/*! @/modules/payroll-management/cutoffs/cutoffs.module */ "./src/modules/payroll-management/cutoffs/cutoffs.module.ts");
const shift_management_module_1 = __webpack_require__(/*! @/modules/shift-management/shift-management.module */ "./src/modules/shift-management/shift-management.module.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const employee_group_assignement_listener_1 = __webpack_require__(/*! ./listeners/employee-group-assignement.listener */ "./src/common/listeners/employee-group-assignement.listener.ts");
const common_service_1 = __webpack_require__(/*! ./services/common.service */ "./src/common/services/common.service.ts");
const transaction_service_1 = __webpack_require__(/*! ./services/transaction.service */ "./src/common/services/transaction.service.ts");
let CommonModule = class CommonModule {
};
exports.CommonModule = CommonModule;
exports.CommonModule = CommonModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [cutoffs_module_1.CutoffsModule, shift_management_module_1.ShiftManagementModule, employee_management_module_1.EmployeeManagementModule,
            core_1.RouterModule.register([
                {
                    path: 'common',
                    module: CommonModule
                }
            ])
        ],
        providers: [
            common_service_1.CommonService, transaction_service_1.TransactionService,
            employee_group_assignement_listener_1.EmployeeGroupAssignmentListener,
        ],
        exports: [common_service_1.CommonService, transaction_service_1.TransactionService, employee_group_assignement_listener_1.EmployeeGroupAssignmentListener],
    })
], CommonModule);


/***/ }),

/***/ "./src/common/controllers/base.controller.ts":
/*!***************************************************!*\
  !*** ./src/common/controllers/base.controller.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseController = void 0;
const paginated_response_dto_1 = __webpack_require__(/*! @/common/dtos/paginated-response.dto */ "./src/common/dtos/paginated-response.dto.ts");
const pagination_dto_1 = __webpack_require__(/*! @/common/dtos/pagination.dto */ "./src/common/dtos/pagination.dto.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const authorize_decorator_1 = __webpack_require__(/*! ../decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const current_user_decorator_1 = __webpack_require__(/*! ../decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const generic_api_responses_decorator_1 = __webpack_require__(/*! ../decorators/generic-api-responses.decorator */ "./src/common/decorators/generic-api-responses.decorator.ts");
const action_enum_1 = __webpack_require__(/*! ../enums/action.enum */ "./src/common/enums/action.enum.ts");
const utility_helper_1 = __webpack_require__(/*! ../helpers/utility.helper */ "./src/common/helpers/utility.helper.ts");
class BaseController {
    constructor(baseService, getDtoClass, entityName) {
        this.baseService = baseService;
        this.getDtoClass = getDtoClass;
        this.entityName = entityName;
        // Static permissions map that all instances share
        this.permissions = { Create: [], Read: [], Update: [], Delete: [] };
        this.logger = new common_1.Logger(this.constructor.name);
    }
    async create(entityDto, createdById) {
        const entity = await this.baseService.create(entityDto, createdById);
        return (0, class_transformer_1.plainToInstance)(this.getDtoClass, entity);
    }
    async update(id, entityDto, updatedById) {
        const updatedEntity = await this.baseService.update(id, entityDto, updatedById);
        return (0, class_transformer_1.plainToInstance)(this.getDtoClass, updatedEntity);
    }
    async findAllAdvanced(req, paginationDto) {
        const entityResult = await this.baseService.findAllComplex(req.resourceScope.type, paginationDto);
        // Transform using class-transformer
        const dtoResult = {
            data: (0, class_transformer_1.plainToInstance)(this.getDtoClass, entityResult.data, {
                enableCircularCheck: true,
                exposeUnsetFields: false,
            }),
            totalCount: entityResult.totalCount,
            meta: entityResult.meta
        };
        return dtoResult;
    }
    async findOne(fieldsString, relations, select) {
        // Create options object for the service
        const options = {};
        // Parse search criteria from query string (format: field1:value1,field2:value2)
        const criteria = {};
        if (fieldsString) {
            const fieldPairs = fieldsString.split(',');
            for (const pair of fieldPairs) {
                const [key, value] = pair.trim().split(':');
                if (key && value !== undefined) {
                    // Convert value types appropriately
                    if (value === 'true') {
                        criteria[key] = true;
                    }
                    else if (value === 'false') {
                        criteria[key] = false;
                    }
                    else if (value === 'null') {
                        criteria[key] = null;
                    }
                    else if (!isNaN(Number(value))) {
                        criteria[key] = Number(value);
                    }
                    else {
                        criteria[key] = value;
                    }
                }
            }
        }
        // Parse relations if provided
        if (relations) {
            options.relations = utility_helper_1.UtilityHelper.parseRelations(relations);
        }
        // Parse select fields if provided
        if (select) {
            options.select = utility_helper_1.UtilityHelper.parseSelect(select);
        }
        try {
            // Use the service with proper typing and options
            const entity = await this.baseService.findOneByOrFail(criteria, options);
            return (0, class_transformer_1.plainToInstance)(this.getDtoClass, entity);
        }
        catch (error) {
            if (error instanceof common_1.NotFoundException) {
                throw error;
            }
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            throw new common_1.InternalServerErrorException(`Error retrieving ${this.entityName.toLowerCase()} with criteria ${JSON.stringify(criteria)}: ${errorMessage}`);
        }
    }
    async findById(id, relations, select) {
        return this.findOne(`id:${id}`, relations, select);
    }
    // @Get()
    // @ApiOperation({ summary: 'Get all entities' })
    // @ApiResponse({ status: 200, description: 'Return all entities with pagination.' })
    // @ApiQuery({ name: 'skip', required: false, type: Number, description: 'Number of items to skip' })
    // @ApiQuery({ name: 'take', required: false, type: Number, description: 'Number of items to take' })
    // @ApiQuery({ name: 'filter', required: false, type: String, description: 'Filter criteria in JSON format' })
    // @ApiQuery({ name: 'sort', required: false, type: String, description: 'Sort criteria in JSON format' })
    // async findAll(@Query() paginationDto: PaginationDto<T>): Promise<PaginatedResponseDto<T>> {
    //     return await this.baseService.findAll(paginationDto);
    // }
    async softDelete(id, deletedBy) {
        return await this.baseService.softDelete(id, deletedBy);
    }
    async delete(id) {
        return await this.baseService.delete(id);
    }
    // @Delete()
    async deleteMany(ids, hardDelete = false) {
        await this.baseService.deleteMany(ids, hardDelete);
    }
}
exports.BaseController = BaseController;
__decorate([
    (0, common_1.Post)(),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.CREATE }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], BaseController.prototype, "create", null);
__decorate([
    (0, common_1.Put)(':id'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, String]),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], BaseController.prototype, "update", null);
__decorate([
    (0, common_1.Get)(),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiQuery)({
        name: 'filter',
        required: false,
        type: String,
        examples: {
            basic: {
                summary: 'Basic Equality Filter',
                value: '{"status":"active"}',
            },
            textSearch: {
                summary: 'Case-insensitive Text Search',
                value: '{"name":{"ilike":"john"}}',
            },
            numeric: {
                summary: 'Numeric Range Filter',
                value: '{"age":{"gte":18,"lt":65}}',
            },
            dates: {
                summary: 'Date Range Filter',
                value: '{"createdAt":{"between":["2023-01-01","2023-12-31"]}}',
            },
            relation: {
                summary: 'Relation Filter',
                value: '{"user.profile.firstName":{"ilike":"jo"}}',
            },
            logicalOr: {
                summary: 'Logical OR',
                value: '{"OR":[{"status":"active"},{"featured":true}]}',
            },
            complex: {
                summary: 'Complex Combined Filter',
                value: '{"status":{"in":["active","pending"]},"age":{"gte":21},"user.profile.firstName":{"ilike":"jo"}}',
            },
        },
    }),
    (0, swagger_1.ApiQuery)({
        name: 'sort',
        required: false,
        type: String,
        examples: {
            single: {
                summary: 'Sort by one field',
                value: '{"createdAt":"DESC"}',
            },
            multiple: {
                summary: 'Sort by multiple fields',
                value: '{"status":"ASC","createdAt":"DESC"}',
            },
            relation: {
                summary: 'Sort by relation field',
                value: '{"user.firstName":"ASC"}',
            },
        },
    }),
    (0, swagger_1.ApiQuery)({
        name: 'relations',
        required: false,
        type: String,
        examples: {
            simple: {
                summary: 'Simple relations',
                value: '["user","roles"]',
            },
            nested: {
                summary: 'Nested relations',
                value: '["user","user.profile","user.profile.address"]',
            },
        },
    }),
    (0, swagger_1.ApiQuery)({
        name: 'select',
        required: false,
        type: String,
        examples: {
            basic: {
                summary: 'Basic field selection',
                value: '["id","name","email"]',
            },
            withRelations: {
                summary: 'Fields with relations',
                value: '["id","employeeNumber","user.id","user.email","user.profile.firstName"]',
            },
        },
    }),
    (0, swagger_1.ApiQuery)({ name: 'skip', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'take', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({
        name: 'userId',
        required: false,
        type: String,
        description: 'Filter by user ID',
    }),
    (0, swagger_1.ApiQuery)({
        name: 'departmentId',
        required: false,
        type: String,
        description: 'Filter by department ID',
    }),
    (0, swagger_1.ApiQuery)({
        name: 'branchId',
        required: false,
        type: String,
        description: 'Filter by branch ID',
    }),
    (0, swagger_1.ApiQuery)({
        name: 'organizationId',
        required: false,
        type: String,
        description: 'Filter by organization ID',
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Successfully retrieved entities',
        type: (paginated_response_dto_1.PaginatedResponseDto),
    }),
    (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_c = typeof pagination_dto_1.PaginationDto !== "undefined" && pagination_dto_1.PaginationDto) === "function" ? _c : Object]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], BaseController.prototype, "findAllAdvanced", null);
__decorate([
    (0, common_1.Get)('find'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    __param(0, (0, common_1.Query)('fields')),
    __param(1, (0, common_1.Query)('relations')),
    __param(2, (0, common_1.Query)('select')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], BaseController.prototype, "findOne", null);
__decorate([
    (0, common_1.Get)('find/:id'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Query)('relations')),
    __param(2, (0, common_1.Query)('select')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], BaseController.prototype, "findById", null);
__decorate([
    (0, common_1.Delete)('delete/soft/:id'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.DELETE }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], BaseController.prototype, "softDelete", null);
__decorate([
    (0, common_1.Delete)('delete/:id'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.DELETE }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], BaseController.prototype, "delete", null);
__decorate([
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.DELETE }),
    (0, swagger_1.ApiOperation)({ summary: 'Delete multiple entities' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                ids: {
                    type: 'array',
                    items: {
                        type: 'string',
                        format: 'uuid',
                    },
                },
                hardDelete: {
                    type: 'boolean',
                    default: false,
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NO_CONTENT, description: 'The entities have been successfully deleted.' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Invalid input data.' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.UNAUTHORIZED, description: 'Unauthorized.' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.INTERNAL_SERVER_ERROR, description: 'Internal' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.FORBIDDEN, description: 'Forbidden.' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: 'Entity not found.' }),
    __param(0, (0, common_1.Body)('ids')),
    __param(1, (0, common_1.Body)('hardDelete')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Boolean]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], BaseController.prototype, "deleteMany", null);


/***/ }),

/***/ "./src/common/decorators/authorize.decorator.ts":
/*!******************************************************!*\
  !*** ./src/common/decorators/authorize.decorator.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PERMISSION_ENDPOINT_TYPE = exports.PERMISSIONS_FUNCTION_KEY = void 0;
exports.Authorize = Authorize;
const jwt_auth_guard_1 = __webpack_require__(/*! @/common/guards/jwt-auth.guard */ "./src/common/guards/jwt-auth.guard.ts");
const permissions_guard_1 = __webpack_require__(/*! @/common/guards/permissions.guard */ "./src/common/guards/permissions.guard.ts");
const roles_guard_1 = __webpack_require__(/*! @/common/guards/roles.guard */ "./src/common/guards/roles.guard.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const scope_guard_1 = __webpack_require__(/*! ../guards/scope.guard */ "./src/common/guards/scope.guard.ts");
const resource_access_interceptor_1 = __webpack_require__(/*! ../interceptors/resource-access.interceptor */ "./src/common/interceptors/resource-access.interceptor.ts");
const permissions_decorator_1 = __webpack_require__(/*! ./permissions.decorator */ "./src/common/decorators/permissions.decorator.ts");
const roles_decorator_1 = __webpack_require__(/*! ./roles.decorator */ "./src/common/decorators/roles.decorator.ts");
exports.PERMISSIONS_FUNCTION_KEY = 'permissions_function';
exports.PERMISSION_ENDPOINT_TYPE = 'permission_endpoint_type';
function Authorize(options) {
    var _a, _b;
    const decorators = [
        (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard, permissions_guard_1.PermissionsGuard, scope_guard_1.ScopeGuard),
        (0, common_1.UseInterceptors)(resource_access_interceptor_1.ResourceAccessInterceptor),
        (0, roles_decorator_1.Roles)(options === null || options === void 0 ? void 0 : options.roles),
        (0, swagger_1.ApiBearerAuth)('access-token'),
    ];
    // Only add ScopeGuard for endpoints that need scope checking
    if (options === null || options === void 0 ? void 0 : options.endpointType) {
        decorators.push((0, common_1.SetMetadata)(exports.PERMISSION_ENDPOINT_TYPE, options.endpointType));
    }
    else {
        // For regular array-based permissions
        decorators.push((0, permissions_decorator_1.Permissions)(options === null || options === void 0 ? void 0 : options.permissions));
    }
    decorators.push((0, common_1.SetMetadata)('onlyAllowRoles', (_a = options === null || options === void 0 ? void 0 : options.allowRoles) !== null && _a !== void 0 ? _a : true), // default to true: // only allow users with roles to access this endpoint
    (0, common_1.SetMetadata)('allowEmployee', (_b = options === null || options === void 0 ? void 0 : options.allowEmployee) !== null && _b !== void 0 ? _b : false));
    return (0, common_1.applyDecorators)(...decorators);
}


/***/ }),

/***/ "./src/common/decorators/current-user.decorator.ts":
/*!*********************************************************!*\
  !*** ./src/common/decorators/current-user.decorator.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurrentUser = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
/**
 * Custom decorator to extract the current user from the request.
 *
 * @param data - The specific key of the user object to extract. If undefined, the entire user object is returned.
 * @param context - The execution context which provides access to the request object.
 *
 * @returns The user object or a specific property of the user object.
 *
 * @throws {UnauthorizedException} If the user is not authenticated.
 *
 * @example
 * // Usage in a controller to get the entire user object
 * @Get('profile')
 * getProfile(@CurrentUser() user: User) {
 *   return user;
 * }
 *
 * @example
 * Usage in a controller to get a specific property of the user object
 * @Get('profile/email')
 * getEmail(@CurrentUser('email') email: string) {
 *   return email;
 * }
 */
exports.CurrentUser = (0, common_1.createParamDecorator)((data, context) => {
    const request = context.switchToHttp().getRequest();
    if (!request.user) {
        throw new common_1.UnauthorizedException('User claims is missing.');
    }
    if (!data) {
        return request.user;
    }
    return request === null || request === void 0 ? void 0 : request.user[data];
});


/***/ }),

/***/ "./src/common/decorators/generic-api-responses.decorator.ts":
/*!******************************************************************!*\
  !*** ./src/common/decorators/generic-api-responses.decorator.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiGenericResponses = ApiGenericResponses;
exports.ApiCreateResponses = ApiCreateResponses;
exports.ApiUpdateResponses = ApiUpdateResponses;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const generalresponse_dto_1 = __webpack_require__(/*! ../dtos/generalresponse.dto */ "./src/common/dtos/generalresponse.dto.ts");
function ApiGenericResponses() {
    return (0, common_1.applyDecorators)((0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Bad Request - Invalid input data',
        type: generalresponse_dto_1.GeneralResponseDto,
    }), (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized - Authentication required',
        type: generalresponse_dto_1.GeneralResponseDto,
    }), (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden - Insufficient permissions',
        type: generalresponse_dto_1.GeneralResponseDto,
    }), (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal Server Error',
        type: generalresponse_dto_1.GeneralResponseDto,
    }));
}
// CRUD Operation Specific Decorators
function ApiCreateResponses(entity, getDtoClass) {
    return (0, common_1.applyDecorators)((0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        description: `${entity} has been successfully created.`,
        type: getDtoClass
    }), (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CONFLICT,
        description: `Conflict - ${entity} already exists`,
        type: generalresponse_dto_1.GeneralResponseDto,
    }), (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Not Found - Related entity not found.',
        type: generalresponse_dto_1.GeneralResponseDto
    }), (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
        description: 'Unprocessable Entity - Validation failed',
        type: generalresponse_dto_1.GeneralResponseDto,
    }));
}
function ApiUpdateResponses(entity, getDtoClass) {
    return (0, common_1.applyDecorators)((0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Not Found - Resource not found',
        type: generalresponse_dto_1.GeneralResponseDto,
    }), (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: `${entity} has been successfully updated.`,
        type: getDtoClass
    }), (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
        description: 'Unprocessable Entity - Validation failed',
        type: generalresponse_dto_1.GeneralResponseDto,
    }), (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: `${entity} not found.`,
        type: generalresponse_dto_1.GeneralResponseDto
    }), (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CONFLICT,
        description: 'Data conflict during update.',
        type: generalresponse_dto_1.GeneralResponseDto
    }));
}


/***/ }),

/***/ "./src/common/decorators/is-time-string.decorator.ts":
/*!***********************************************************!*\
  !*** ./src/common/decorators/is-time-string.decorator.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsTimeString = IsTimeString;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
function IsTimeString(validationOptions) {
    return function (target, propertyName) {
        (0, class_validator_1.registerDecorator)({
            name: 'isTimeString',
            target: target.constructor,
            propertyName: propertyName,
            options: validationOptions,
            validator: {
                validate(value) {
                    if (typeof value !== 'string')
                        return false;
                    // Regular expression to match HH:MM:SS format
                    const timeRegex = /^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/;
                    return timeRegex.test(value);
                },
                defaultMessage(args) {
                    return `${args.property} must be a valid time string in the format HH:MM:SS`;
                }
            }
        });
    };
}


/***/ }),

/***/ "./src/common/decorators/override.decorator.ts":
/*!*****************************************************!*\
  !*** ./src/common/decorators/override.decorator.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Override = Override;
__webpack_require__(/*! reflect-metadata */ "reflect-metadata");
/**
 * A decorator function that copies metadata from the overridden method
 * in the parent class to the overriding method in the child class.
 *
 * @returns A decorator function that can be applied to a method.
 *
 * @example
 * ```typescript
 * import { Override } from './override.decorator';
 *
 * class ParentClass {
 *   @SomeDecorator()
 *   someMethod() {
 *     // Parent method implementation
 *   }
 * }
 *
 * class ChildClass extends ParentClass {
 *   @Override()
 *   someMethod() {
 *     // Child method implementation
 *   }
 * }
 * ```
 *
 * @param target - The prototype of the class.
 * @param propertyKey - The name of the method being decorated.
 * @param descriptor - The property descriptor of the method.
 */
function Override() {
    return (target, propertyKey, descriptor) => {
        const parentTarget = Object.getPrototypeOf(target);
        const parentDescriptor = Object.getOwnPropertyDescriptor(parentTarget, propertyKey);
        if (parentDescriptor) {
            Reflect.getMetadataKeys(parentDescriptor.value).forEach((metadataKey) => {
                const metadataValue = Reflect.getMetadata(metadataKey, parentDescriptor.value);
                Reflect.defineMetadata(metadataKey, metadataValue, descriptor.value);
            });
        }
    };
}


/***/ }),

/***/ "./src/common/decorators/permissions.decorator.ts":
/*!********************************************************!*\
  !*** ./src/common/decorators/permissions.decorator.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Permissions = exports.PERMISSIONS_KEY = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
exports.PERMISSIONS_KEY = 'permissions';
/**
 * A decorator to set permissions metadata for a route handler.
 *
 * @param requirements - An array of permission objects that are required to access the route.
 * @returns A decorator function that sets the permissions metadata.
 *
 * @example
 * ```typescript
 * import { Permissions } from './permissions.decorator';
 * import { Controller, Get } from '@nestjs/common';
 *
 * @Controller('example')
 * export class ExampleController {
 *   @Get()
 *   @Permissions([{ name: 'read', level: 'admin' }])
 *   getExample() {
 *     return 'This route requires read permission with admin level';
 *   }
 * }
 * ```
 */
const Permissions = (requirements = []) => (0, common_1.SetMetadata)(exports.PERMISSIONS_KEY, requirements);
exports.Permissions = Permissions;


/***/ }),

/***/ "./src/common/decorators/roles.decorator.ts":
/*!**************************************************!*\
  !*** ./src/common/decorators/roles.decorator.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Roles = exports.ROLES_KEY = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
exports.ROLES_KEY = 'roles';
/**
 * Decorator that assigns roles to a route or controller.
 * This metadata can be used with a guard to control access to specific endpoints.
 *
 * @param roles - An array of role names that are allowed to access the decorated endpoint.
 * Defaults to an empty array if not provided.
 * @returns A decorator function that sets the roles metadata on the target.
 *
 * @example
 * ```typescript
 * // Apply to a controller to restrict all routes
 * @Controller('users')
 * @Roles(['admin'])
 * export class UsersController {
 *   // ...
 * }
 *
 * // Apply to a specific route
 * @Get('profile')
 * @Roles(['admin', 'user'])
 * getProfile() {
 *   return 'This is a protected route';
 * }
 * ```
 */
const Roles = (roles = []) => (0, common_1.SetMetadata)(exports.ROLES_KEY, roles);
exports.Roles = Roles;


/***/ }),

/***/ "./src/common/dtos/base.dto.ts":
/*!*************************************!*\
  !*** ./src/common/dtos/base.dto.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class BaseDto {
}
exports.BaseDto = BaseDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Organization ID - Identifies the organization that owns or scopes this resource. Used for multi-tenant access control and resource partitioning.',
        type: String,
        format: 'uuid',
        example: '123e4567-e89b-12d3-a456-426614174000',
        nullable: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BaseDto.prototype, "organizationId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Branch ID - Specifies the organizational branch that owns or scopes this resource. Represents a subdivision within the parent organization.',
        required: false,
        type: String,
        format: 'uuid',
        example: '123e4567-e89b-12d3-a456-426614174001',
        nullable: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BaseDto.prototype, "branchId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Department ID - Indicates the specific department that owns or scopes this resource. Used for departmental-level access control and resource organization.',
        type: String,
        format: 'uuid',
        example: '123e4567-e89b-12d3-a456-426614174002',
        nullable: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BaseDto.prototype, "departmentId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'User ID - Identifies the specific user who owns or has primary responsibility for this resource. Used for user-level permissions and audit trails.',
        type: String,
        format: 'uuid',
        example: '123e4567-e89b-12d3-a456-426614174003',
        nullable: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BaseDto.prototype, "userId", void 0);


/***/ }),

/***/ "./src/common/dtos/generalresponse.dto.ts":
/*!************************************************!*\
  !*** ./src/common/dtos/generalresponse.dto.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeneralResponseDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class GeneralResponseDto {
}
exports.GeneralResponseDto = GeneralResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'HTTP status code of the response',
        example: 404,
        type: Number,
    }),
    __metadata("design:type", Number)
], GeneralResponseDto.prototype, "statusCode", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Timestamp when the response was generated',
        example: '2025-04-07T02:04:20.545Z',
        type: String,
    }),
    __metadata("design:type", String)
], GeneralResponseDto.prototype, "timestamp", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier for tracking the request',
        example: 'dfed434d-9516-4ae3-975e-175df199dd01',
        type: String,
    }),
    __metadata("design:type", String)
], GeneralResponseDto.prototype, "traceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Request path that triggered this response',
        example: '/api/modules',
        type: String,
    }),
    __metadata("design:type", String)
], GeneralResponseDto.prototype, "path", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of exception or error that occurred',
        example: 'NotFoundException',
        type: String,
    }),
    __metadata("design:type", String)
], GeneralResponseDto.prototype, "detail", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Error message or messages describing the issue',
        example: 'Cannot GET /api/modules',
        oneOf: [
            { type: 'string' },
            { type: 'array', items: { type: 'string' } }
        ]
    }),
    __metadata("design:type", Object)
], GeneralResponseDto.prototype, "message", void 0);


/***/ }),

/***/ "./src/common/dtos/paginated-response.dto.ts":
/*!***************************************************!*\
  !*** ./src/common/dtos/paginated-response.dto.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaginatedResponseDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const pagination_dto_1 = __webpack_require__(/*! ./pagination.dto */ "./src/common/dtos/pagination.dto.ts");
class PaginatedResponseDto {
    constructor() {
        this.data = [];
        this.totalCount = 0;
        this.meta = new pagination_dto_1.PaginationDto();
    }
}
exports.PaginatedResponseDto = PaginatedResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({ isArray: true, description: 'Array of items' }),
    __metadata("design:type", Array)
], PaginatedResponseDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total number of items', example: 100 }),
    __metadata("design:type", Number)
], PaginatedResponseDto.prototype, "totalCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Pagination metadata' }),
    __metadata("design:type", typeof (_a = typeof pagination_dto_1.PaginationDto !== "undefined" && pagination_dto_1.PaginationDto) === "function" ? _a : Object)
], PaginatedResponseDto.prototype, "meta", void 0);


/***/ }),

/***/ "./src/common/dtos/pagination.dto.ts":
/*!*******************************************!*\
  !*** ./src/common/dtos/pagination.dto.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaginationDto = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const role_scope_type_enum_1 = __webpack_require__(/*! ../enums/role-scope-type.enum */ "./src/common/enums/role-scope-type.enum.ts");
/**
 * Data Transfer Object for pagination, filtering, sorting, and relation loading in API requests.
 *
 * This class provides a standardized way to handle common database query parameters
 * such as pagination (skip/take), filtering with advanced operators, sorting,
 * relation loading, and field selection. It's designed to work with TypeORM's
 * FindManyOptions interface.
 *
 * @example
 * // Basic usage in a controller
 * @Get()
 * async findAll(@Query() paginationDto: PaginationDto<User>) {
 *   return this.userService.findAll(paginationDto.toFindManyOptions());
 * }
 *
 * @example
 * Query example
 * GET /users?skip=0&take=10&filter={"name":{"like":"John"}}&sort={"createdAt":"DESC"}
 *
 * @template T The entity type this pagination will be applied to
 */
class PaginationDto {
    constructor() {
        this.skip = 0;
        this.take = 10;
    }
    toFindManyOptions(scope, baseWhere = {}) {
        const filterObj = this.parseStringInput(this.filter);
        const sortObj = this.parseStringInput(this.sort);
        // Process where conditions with advanced operators
        let filterWhere = this.applyFilterOperators(filterObj);
        // Add resource filtering
        const resourceFilters = this.getResourceFilters(scope);
        // Merge resource filters with other filters
        filterWhere = Object.assign(Object.assign({}, filterWhere), resourceFilters);
        // Simplify the deleted logic
        if (!filterWhere.hasOwnProperty('isDeleted')) {
            filterWhere = Object.assign(Object.assign({}, filterWhere), { isDeleted: false });
        }
        // Process relations
        let relations = undefined;
        if (this.relations) {
            if (typeof this.relations === 'string') {
                try {
                    relations = JSON.parse(this.relations);
                }
                catch (e) {
                    relations = undefined;
                }
            }
            else {
                relations = this.relations;
            }
        }
        // Process select
        let select = undefined;
        if (this.select) {
            if (typeof this.select === 'string') {
                try {
                    const selectArray = JSON.parse(this.select);
                    if (Array.isArray(selectArray)) {
                        select = selectArray.reduce((acc, field) => {
                            acc[field] = true;
                            return acc;
                        }, {});
                    }
                }
                catch (e) {
                    select = undefined;
                }
            }
            else if (Array.isArray(this.select)) {
                select = this.select.reduce((acc, field) => {
                    acc[field] = true;
                    return acc;
                }, {});
            }
        }
        const options = {
            skip: this.skip,
            take: this.take,
            where: Object.assign(Object.assign({}, baseWhere), filterWhere),
            order: sortObj || undefined,
            relations,
            select,
        };
        return options;
    }
    // Parse string inputs to proper objects
    parseStringInput(input) {
        if (typeof input === 'string') {
            try {
                return JSON.parse(input);
            }
            catch (error) {
                return {};
            }
        }
        return input || {};
    }
    // Apply advanced filter operators
    applyFilterOperators(filterObj) {
        const result = {};
        Object.entries(filterObj).forEach(([key, value]) => {
            // Skip null/undefined values
            if (value === null || value === undefined)
                return;
            // Handle special logical operators
            if (key === 'or' && Array.isArray(value)) {
                // For OR, TypeORM accepts an array of conditions
                return value.map(condition => this.applyFilterOperators(condition));
            }
            if (key === 'and' && Array.isArray(value)) {
                // Process each condition in the AND array and merge them
                const andConditions = value.reduce((acc, condition) => {
                    return Object.assign(Object.assign({}, acc), this.applyFilterOperators(condition));
                }, {});
                // Merge with the current result
                Object.assign(result, andConditions);
                return;
            }
            // Handle nested objects (potential operators)
            if (typeof value === 'object' && !Array.isArray(value)) {
                const operators = value;
                // Equal
                if (operators.eq !== undefined) {
                    result[key] = operators.eq;
                }
                // Not Equal
                if (operators.ne !== undefined) {
                    result[key] = (0, typeorm_1.Not)(operators.ne);
                }
                // Greater Than
                if (operators.gt !== undefined) {
                    result[key] = (0, typeorm_1.MoreThan)(operators.gt);
                }
                // Greater Than or Equal
                if (operators.gte !== undefined) {
                    result[key] = (0, typeorm_1.MoreThanOrEqual)(operators.gte);
                }
                // Less Than
                if (operators.lt !== undefined) {
                    result[key] = (0, typeorm_1.LessThan)(operators.lt);
                }
                // Less Than or Equal
                if (operators.lte !== undefined) {
                    result[key] = (0, typeorm_1.LessThanOrEqual)(operators.lte);
                }
                // Between
                if (operators.between && Array.isArray(operators.between) && operators.between.length === 2) {
                    result[key] = (0, typeorm_1.Between)(operators.between[0], operators.between[1]);
                }
                // Like (case sensitive)
                if (operators.like !== undefined) {
                    result[key] = (0, typeorm_1.Like)(`%${operators.like}%`);
                }
                // ILike (case insensitive)
                if (operators.ilike !== undefined) {
                    result[key] = (0, typeorm_1.ILike)(`%${operators.ilike}%`);
                }
                // In
                if (operators.in && Array.isArray(operators.in)) {
                    result[key] = (0, typeorm_1.In)(operators.in);
                }
                // Not In
                if (operators.nin && Array.isArray(operators.nin)) {
                    result[key] = (0, typeorm_1.Not)((0, typeorm_1.In)(operators.nin));
                }
                // Is Null
                if (operators.isNull !== undefined) {
                    result[key] = (operators.isNull ? null : (0, typeorm_1.Not)(null));
                }
            }
            else {
                // Simple equality match
                result[key] = value;
            }
        });
        // console.log('Filter Result:', result);
        return result;
    }
    /**
     * Extract resource filters from the DTO properties
     */
    getResourceFilters(scope) {
        const resourceFilters = {};
        if (scope === role_scope_type_enum_1.RoleScopeType.ORGANIZATION && this.organizationId) {
            resourceFilters.organizationId = this.organizationId;
        }
        if (scope === role_scope_type_enum_1.RoleScopeType.BRANCH && this.branchId) {
            resourceFilters.branchId = this.branchId;
        }
        if (scope === role_scope_type_enum_1.RoleScopeType.DEPARTMENT && this.departmentId) {
            resourceFilters.departmentId = this.departmentId;
        }
        if (scope === role_scope_type_enum_1.RoleScopeType.OWNED && this.userId) {
            resourceFilters.userId = this.userId;
        }
        return resourceFilters;
    }
}
exports.PaginationDto = PaginationDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Organization ID for resource filtering',
        required: false,
        example: 'uuid-here'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], PaginationDto.prototype, "organizationId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Branch ID for resource filtering',
        required: false,
        example: 'uuid-here'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], PaginationDto.prototype, "branchId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Department ID for resource filtering',
        required: false,
        example: 'uuid-here'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], PaginationDto.prototype, "departmentId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User ID for resource filtering',
        required: false,
        example: 'uuid-here'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], PaginationDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Number of items to skip',
        required: false,
        minimum: 0,
        default: 0,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], PaginationDto.prototype, "skip", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Number of items to take',
        required: false,
        minimum: 1,
        default: 10,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], PaginationDto.prototype, "take", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Filter criteria in JSON string format or object',
        required: false,
        example: '{"name":{"like":"%John%"},"age":{"gte":18}}',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => {
        try {
            return typeof value === 'string' ? JSON.parse(value) : value;
        }
        catch (e) {
            const errorMessage = e instanceof Error ? e.message : String(e);
            throw new common_1.BadRequestException(`Invalid JSON in filter: ${errorMessage}`);
        }
    }),
    __metadata("design:type", Object)
], PaginationDto.prototype, "filter", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Sort criteria in JSON string format or object',
        required: false,
        example: '{"createdAt":"DESC"}',
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], PaginationDto.prototype, "sort", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Relations to include in the query',
        required: false,
        example: '["user","category"]',
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], PaginationDto.prototype, "relations", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Fields to select',
        required: false,
        example: '["id","name","email"]',
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], PaginationDto.prototype, "select", void 0);


/***/ }),

/***/ "./src/common/dtos/reference.dto.ts":
/*!******************************************!*\
  !*** ./src/common/dtos/reference.dto.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReferenceDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class ReferenceDto {
}
exports.ReferenceDto = ReferenceDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier',
        example: '123e4567-e89b-12d3-a456-426614174000'
    }),
    (0, class_validator_1.IsUUID)('4'),
    __metadata("design:type", String)
], ReferenceDto.prototype, "id", void 0);


/***/ }),

/***/ "./src/common/enums/action.enum.ts":
/*!*****************************************!*\
  !*** ./src/common/enums/action.enum.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Action = void 0;
var Action;
(function (Action) {
    Action["MANAGE"] = "manage";
    Action["CREATE"] = "create";
    Action["READ"] = "read";
    Action["UPDATE"] = "update";
    Action["DELETE"] = "delete";
})(Action || (exports.Action = Action = {}));


/***/ }),

/***/ "./src/common/enums/attendance-status.enum.ts":
/*!****************************************************!*\
  !*** ./src/common/enums/attendance-status.enum.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendanceStatus = void 0;
var AttendanceStatus;
(function (AttendanceStatus) {
    AttendanceStatus["EARLY"] = "EARLY";
    AttendanceStatus["NO_CHECKED_IN"] = "NO_CHECKED_IN";
    AttendanceStatus["NO_CHECKED_OUT"] = "NO_CHECKED_OUT";
    AttendanceStatus["CHECKED_IN"] = "CHECKED_IN";
    AttendanceStatus["CHECKED_OUT"] = "CHECKED_OUT";
    AttendanceStatus["OVERTIME"] = "OVER_TIME";
    AttendanceStatus["UNDER_TIME"] = "UNDER_TIME";
    AttendanceStatus["LATE"] = "LATE";
    AttendanceStatus["ABSENT"] = "ABSENT";
    AttendanceStatus["REST_DAY"] = "REST_DAY";
    AttendanceStatus["HOLIDAY"] = "HOLIDAY";
    AttendanceStatus["LEAVE"] = "LEAVE";
    AttendanceStatus["OFFSET"] = "OFFSET";
})(AttendanceStatus || (exports.AttendanceStatus = AttendanceStatus = {}));


/***/ }),

/***/ "./src/common/enums/biometrics-device-type.enum.ts":
/*!*********************************************************!*\
  !*** ./src/common/enums/biometrics-device-type.enum.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricDeviceType = void 0;
var BiometricDeviceType;
(function (BiometricDeviceType) {
    BiometricDeviceType["ZKTECO"] = "zkteco";
    BiometricDeviceType["ANVIZ"] = "anviz";
})(BiometricDeviceType || (exports.BiometricDeviceType = BiometricDeviceType = {}));


/***/ }),

/***/ "./src/common/enums/compliance/policy-category.enum.ts":
/*!*************************************************************!*\
  !*** ./src/common/enums/compliance/policy-category.enum.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PolicyCategory = void 0;
var PolicyCategory;
(function (PolicyCategory) {
    PolicyCategory["ATTENDANCE"] = "ATTENDANCE";
    PolicyCategory["PERFORMANCE"] = "PERFORMANCE";
    PolicyCategory["CONDUCT"] = "CONDUCT";
    PolicyCategory["REGULATORY"] = "REGULATORY";
    PolicyCategory["SAFETY"] = "SAFETY";
    PolicyCategory["OTHER"] = "OTHER";
})(PolicyCategory || (exports.PolicyCategory = PolicyCategory = {}));


/***/ }),

/***/ "./src/common/enums/compliance/rule-operator.enum.ts":
/*!***********************************************************!*\
  !*** ./src/common/enums/compliance/rule-operator.enum.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RuleOperator = void 0;
var RuleOperator;
(function (RuleOperator) {
    RuleOperator["EQUALS"] = "equals";
    RuleOperator["NOT_EQUALS"] = "not_equals";
    RuleOperator["GREATER_THAN"] = "greater_than";
    RuleOperator["LESS_THAN"] = "less_than";
    RuleOperator["CONTAINS"] = "contains";
    RuleOperator["NOT_CONTAINS"] = "not_contains";
    RuleOperator["BETWEEN"] = "between";
    RuleOperator["NOT_BETWEEN"] = "not_between";
    RuleOperator["IN"] = "in";
    RuleOperator["NOT_IN"] = "not_in";
})(RuleOperator || (exports.RuleOperator = RuleOperator = {}));


/***/ }),

/***/ "./src/common/enums/compliance/violation-severity.enum.ts":
/*!****************************************************************!*\
  !*** ./src/common/enums/compliance/violation-severity.enum.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViolationSeverity = void 0;
var ViolationSeverity;
(function (ViolationSeverity) {
    ViolationSeverity["LOW"] = "LOW";
    ViolationSeverity["MEDIUM"] = "MEDIUM";
    ViolationSeverity["HIGH"] = "HIGH";
    ViolationSeverity["CRITICAL"] = "CRITICAL";
})(ViolationSeverity || (exports.ViolationSeverity = ViolationSeverity = {}));


/***/ }),

/***/ "./src/common/enums/compliance/violation-status.enum.ts":
/*!**************************************************************!*\
  !*** ./src/common/enums/compliance/violation-status.enum.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViolationStatus = void 0;
var ViolationStatus;
(function (ViolationStatus) {
    ViolationStatus["OPEN"] = "OPEN";
    ViolationStatus["ACKNOWLEDGED"] = "ACKNOWLEDGED";
    ViolationStatus["IN_PROGRESS"] = "IN_PROGRESS";
    ViolationStatus["RESOLVED"] = "RESOLVED";
    ViolationStatus["ESCALATED"] = "ESCALATED";
    ViolationStatus["DISMISSED"] = "DISMISSED";
})(ViolationStatus || (exports.ViolationStatus = ViolationStatus = {}));


/***/ }),

/***/ "./src/common/enums/data-source.enum.ts":
/*!**********************************************!*\
  !*** ./src/common/enums/data-source.enum.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataSource = void 0;
var DataSource;
(function (DataSource) {
    DataSource["ATTENDANCE"] = "attendance";
    DataSource["EMPLOYEE"] = "employee";
    DataSource["WORK_HOURS"] = "work_hours";
    DataSource["PERFORMANCE"] = "performance";
})(DataSource || (exports.DataSource = DataSource = {}));


/***/ }),

/***/ "./src/common/enums/day.enum.ts":
/*!**************************************!*\
  !*** ./src/common/enums/day.enum.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Day = void 0;
var Day;
(function (Day) {
    Day["MONDAY"] = "MONDAY";
    Day["TUESDAY"] = "TUESDAY";
    Day["WEDNESDAY"] = "WEDNESDAY";
    Day["THURSDAY"] = "THURSDAY";
    Day["FRIDAY"] = "FRIDAY";
    Day["SATURDAY"] = "SATURDAY";
    Day["SUNDAY"] = "SUNDAY";
})(Day || (exports.Day = Day = {}));


/***/ }),

/***/ "./src/common/enums/decision.enum.ts":
/*!*******************************************!*\
  !*** ./src/common/enums/decision.enum.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Decision = void 0;
var Decision;
(function (Decision) {
    Decision["APPROVED"] = "APPROVED";
    Decision["REJECTED"] = "REJECTED";
    Decision["PENDING"] = "PENDING";
})(Decision || (exports.Decision = Decision = {}));


/***/ }),

/***/ "./src/common/enums/email-status.enum.ts":
/*!***********************************************!*\
  !*** ./src/common/enums/email-status.enum.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailStatus = void 0;
var EmailStatus;
(function (EmailStatus) {
    EmailStatus["SENT"] = "SENT";
    EmailStatus["FAILED"] = "FAILED";
    EmailStatus["PENDING"] = "PENDING";
    EmailStatus["QUEUED"] = "QUEUED";
    EmailStatus["DELIVERED"] = "DELIVERED";
    EmailStatus["OPENED"] = "OPENED";
    EmailStatus["CLICKED"] = "CLICKED";
    EmailStatus["UNSUBSCRIBED"] = "UNSUBSCRIBED";
    EmailStatus["SPAM"] = "SPAM";
    EmailStatus["BOUNCED"] = "BOUNCED";
    EmailStatus["COMPLAINED"] = "COMPLAINED";
    EmailStatus["DELAYED"] = "DELAYED";
    EmailStatus["REJECTED"] = "REJECTED";
    EmailStatus["INVALID"] = "INVALID";
})(EmailStatus || (exports.EmailStatus = EmailStatus = {}));


/***/ }),

/***/ "./src/common/enums/employment/employment-condition.enum.ts":
/*!******************************************************************!*\
  !*** ./src/common/enums/employment/employment-condition.enum.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmploymentCondition = void 0;
var EmploymentCondition;
(function (EmploymentCondition) {
    EmploymentCondition["PROBATIONARY"] = "probationary";
    EmploymentCondition["REGULAR"] = "regular";
})(EmploymentCondition || (exports.EmploymentCondition = EmploymentCondition = {}));


/***/ }),

/***/ "./src/common/enums/employment/employment-status.enum.ts":
/*!***************************************************************!*\
  !*** ./src/common/enums/employment/employment-status.enum.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmploymentStatus = void 0;
var EmploymentStatus;
(function (EmploymentStatus) {
    EmploymentStatus["ACTIVE"] = "active";
    EmploymentStatus["INACTIVE"] = "inactive";
    EmploymentStatus["PENDING"] = "pending";
    EmploymentStatus["SUSPENDED"] = "suspended";
    EmploymentStatus["ON_LEAVE"] = "on_leave";
    EmploymentStatus["RESIGNED"] = "resigned";
    EmploymentStatus["TERMINATED"] = "terminated";
    EmploymentStatus["RETIRED"] = "retired";
    EmploymentStatus["DECEASED"] = "deceased";
})(EmploymentStatus || (exports.EmploymentStatus = EmploymentStatus = {}));


/***/ }),

/***/ "./src/common/enums/employment/employment-type.enum.ts":
/*!*************************************************************!*\
  !*** ./src/common/enums/employment/employment-type.enum.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmploymentType = void 0;
var EmploymentType;
(function (EmploymentType) {
    EmploymentType["FULL_TIME"] = "full_time";
    EmploymentType["PART_TIME"] = "part_time";
    EmploymentType["CONTRACTUAL"] = "contractual";
    EmploymentType["TEMPORARY"] = "temporary";
    EmploymentType["FREELANCE"] = "freelance";
    EmploymentType["INTERNSHIP"] = "internship";
    EmploymentType["TRAINEE"] = "trainee";
    EmploymentType["CONSULTANT"] = "consultant";
    EmploymentType["VOLUNTEER"] = "volunteer";
    EmploymentType["OTHER"] = "other";
})(EmploymentType || (exports.EmploymentType = EmploymentType = {}));


/***/ }),

/***/ "./src/common/enums/holiday-type.enum.ts":
/*!***********************************************!*\
  !*** ./src/common/enums/holiday-type.enum.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HolidayType = void 0;
var HolidayType;
(function (HolidayType) {
    HolidayType["REGULAR"] = "REGULAR";
    HolidayType["SPECIAL_NON_WORKING"] = "SPECIAL_NON_WORKING";
    HolidayType["SPECIAL_WORKING"] = "SPECIAL_WORKING";
    HolidayType["LOCAL"] = "LOCAL";
})(HolidayType || (exports.HolidayType = HolidayType = {}));


/***/ }),

/***/ "./src/common/enums/log-level.enum.ts":
/*!********************************************!*\
  !*** ./src/common/enums/log-level.enum.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogLevel = void 0;
var LogLevel;
(function (LogLevel) {
    LogLevel["LOG"] = "log";
    LogLevel["ERROR"] = "error";
    LogLevel["WARN"] = "warn";
    LogLevel["DEBUG"] = "debug";
    LogLevel["VERBOSE"] = "verbose";
})(LogLevel || (exports.LogLevel = LogLevel = {}));


/***/ }),

/***/ "./src/common/enums/memo-status.enum.ts":
/*!**********************************************!*\
  !*** ./src/common/enums/memo-status.enum.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemoStatus = void 0;
var MemoStatus;
(function (MemoStatus) {
    MemoStatus["DRAFT"] = "draft";
    MemoStatus["PENDING"] = "pending";
    MemoStatus["ISSUED"] = "issued";
    MemoStatus["REJECTED"] = "rejected";
    MemoStatus["ARCHIVED"] = "archived";
    MemoStatus["COMPLIED"] = "complied";
})(MemoStatus || (exports.MemoStatus = MemoStatus = {}));


/***/ }),

/***/ "./src/common/enums/memo-type.enum.ts":
/*!********************************************!*\
  !*** ./src/common/enums/memo-type.enum.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemoType = void 0;
var MemoType;
(function (MemoType) {
    MemoType["MEMO"] = "memo";
    MemoType["ANNOUNCEMENT"] = "announcement";
    MemoType["CIRCULAR"] = "circular";
    MemoType["NOTICE"] = "notice";
    MemoType["WARNING"] = "warning";
    MemoType["INSTRUCTION"] = "instruction";
    MemoType["DIRECTIVE"] = "directive";
    MemoType["POLICY"] = "policy";
    MemoType["PROCEDURE"] = "procedure";
    MemoType["GUIDELINE"] = "guideline";
    MemoType["REPORT"] = "report";
    MemoType["OTHER"] = "other";
})(MemoType || (exports.MemoType = MemoType = {}));


/***/ }),

/***/ "./src/common/enums/notification-type.enum.ts":
/*!****************************************************!*\
  !*** ./src/common/enums/notification-type.enum.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationType = void 0;
var NotificationType;
(function (NotificationType) {
    NotificationType["INFO"] = "info";
    NotificationType["SUCCESS"] = "success";
    NotificationType["WARNING"] = "warning";
    NotificationType["DANGER"] = "danger";
})(NotificationType || (exports.NotificationType = NotificationType = {}));


/***/ }),

/***/ "./src/common/enums/occurrence.enum.ts":
/*!*********************************************!*\
  !*** ./src/common/enums/occurrence.enum.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Occurrence = void 0;
var Occurrence;
(function (Occurrence) {
    Occurrence["HOURLY"] = "HOURLY";
    Occurrence["DAILY"] = "DAILY";
    Occurrence["MONTHLY"] = "MONTHLY";
    Occurrence["YEARLY"] = "YEARLY";
    Occurrence["ONCE"] = "ONCE";
    Occurrence["WEEKLY"] = "WEEKLY";
    Occurrence["BIWEEKLY"] = "BIWEEKLY";
    Occurrence["SEMIMONTHLY"] = "SEMIMONTHLY";
    Occurrence["BIYEARLY"] = "BIYEARLY";
    Occurrence["QUARTERLY"] = "QUARTERLY";
    Occurrence["ANNUALLY"] = "ANNUALLY";
    Occurrence["SEMIANNUALLY"] = "SEMIANNUALLY";
})(Occurrence || (exports.Occurrence = Occurrence = {}));


/***/ }),

/***/ "./src/common/enums/payroll/cutoff-status.enum.ts":
/*!********************************************************!*\
  !*** ./src/common/enums/payroll/cutoff-status.enum.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CutoffStatus = void 0;
var CutoffStatus;
(function (CutoffStatus) {
    CutoffStatus["ACTIVE"] = "ACTIVE";
    CutoffStatus["INACTIVE"] = "INACTIVE";
    CutoffStatus["COMPLETED"] = "COMPLETED";
    CutoffStatus["PENDING"] = "PENDING";
    CutoffStatus["PROCESSING"] = "PROCESSING";
    CutoffStatus["CANCELLED"] = "CANCELLED";
})(CutoffStatus || (exports.CutoffStatus = CutoffStatus = {}));


/***/ }),

/***/ "./src/common/enums/payroll/cutoff-type.enum.ts":
/*!******************************************************!*\
  !*** ./src/common/enums/payroll/cutoff-type.enum.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CutoffType = void 0;
var CutoffType;
(function (CutoffType) {
    CutoffType["BI_WEEKLY"] = "BI_WEEKLY";
    CutoffType["MONTHLY"] = "MONTHLY";
    CutoffType["WEEKLY"] = "WEEKLY";
    CutoffType["DAILY"] = "DAILY";
    CutoffType["ANNUAL"] = "ANNUAL";
    CutoffType["QUARTERLY"] = "QUARTERLY";
    CutoffType["SEMI_ANNUAL"] = "SEMI_ANNUAL";
    CutoffType["BI_ANNUAL"] = "BI_ANNUAL";
})(CutoffType || (exports.CutoffType = CutoffType = {}));


/***/ }),

/***/ "./src/common/enums/payroll/government-contribution-type.enum.ts":
/*!***********************************************************************!*\
  !*** ./src/common/enums/payroll/government-contribution-type.enum.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GovernmentMandatedType = void 0;
var GovernmentMandatedType;
(function (GovernmentMandatedType) {
    GovernmentMandatedType["SSS"] = "SSS";
    GovernmentMandatedType["PHILHEALTH"] = "PHILHEALTH";
    GovernmentMandatedType["PAGIBIG"] = "PAGIBIG";
    GovernmentMandatedType["TAX"] = "TAX";
    GovernmentMandatedType["THIRTEENTH_MONTH_PAY"] = "THIRTEENTH_MONTH_PAY";
    GovernmentMandatedType["OTHER"] = "OTHER";
})(GovernmentMandatedType || (exports.GovernmentMandatedType = GovernmentMandatedType = {}));


/***/ }),

/***/ "./src/common/enums/payroll/payroll-item-category.enum.ts":
/*!****************************************************************!*\
  !*** ./src/common/enums/payroll/payroll-item-category.enum.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemCategory = void 0;
var PayrollItemCategory;
(function (PayrollItemCategory) {
    PayrollItemCategory["COMPENSATION"] = "Compensation";
    PayrollItemCategory["BENEFIT"] = "Benefit";
    PayrollItemCategory["ADJUSTMENT"] = "Adjustment";
    PayrollItemCategory["DEDUCTION"] = "Deduction";
    PayrollItemCategory["ALLOWANCE"] = "Allowance";
    PayrollItemCategory["REIMBURSEMENT"] = "Reimbursement";
})(PayrollItemCategory || (exports.PayrollItemCategory = PayrollItemCategory = {}));


/***/ }),

/***/ "./src/common/enums/payroll/payroll-state.enum.ts":
/*!********************************************************!*\
  !*** ./src/common/enums/payroll/payroll-state.enum.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollState = void 0;
var PayrollState;
(function (PayrollState) {
    PayrollState["DRAFT"] = "DRAFT";
    PayrollState["CALCULATING"] = "CALCULATING";
    PayrollState["PENDING_APPROVAL"] = "PENDING_APPROVAL";
    PayrollState["APPROVED"] = "APPROVED";
    PayrollState["PAID"] = "PAID";
    PayrollState["ARCHIVED"] = "ARCHIVED";
    PayrollState["FAILED"] = "FAILED";
    PayrollState["REJECTED"] = "REJECTED";
    PayrollState["CANCELLED"] = "CANCELLED";
    PayrollState["VOID"] = "VOID";
})(PayrollState || (exports.PayrollState = PayrollState = {}));


/***/ }),

/***/ "./src/common/enums/punch-method.enum.ts":
/*!***********************************************!*\
  !*** ./src/common/enums/punch-method.enum.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PunchMethod = void 0;
var PunchMethod;
(function (PunchMethod) {
    PunchMethod["FINGERPRINT"] = "fingerprint";
    PunchMethod["RFID"] = "rfid";
    PunchMethod["PASSWORD"] = "password";
    PunchMethod["FACE"] = "face";
    PunchMethod["QR_CODE"] = "qr_code";
    PunchMethod["NFC"] = "nfc";
    PunchMethod["MANUAL"] = "manual";
    PunchMethod["UNKNOWN"] = "unknown";
})(PunchMethod || (exports.PunchMethod = PunchMethod = {}));


/***/ }),

/***/ "./src/common/enums/punch-type.enum.ts":
/*!*********************************************!*\
  !*** ./src/common/enums/punch-type.enum.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PunchType = void 0;
var PunchType;
(function (PunchType) {
    PunchType[PunchType["CHECK_IN"] = 0] = "CHECK_IN";
    PunchType[PunchType["CHECK_OUT"] = 1] = "CHECK_OUT";
    PunchType[PunchType["BREAK_OUT"] = 2] = "BREAK_OUT";
    PunchType[PunchType["BREAK_IN"] = 3] = "BREAK_IN";
    PunchType[PunchType["OVERTIME_IN"] = 4] = "OVERTIME_IN";
    PunchType[PunchType["OVERTIME_OUT"] = 5] = "OVERTIME_OUT";
})(PunchType || (exports.PunchType = PunchType = {}));


/***/ }),

/***/ "./src/common/enums/request-status.enum.ts":
/*!*************************************************!*\
  !*** ./src/common/enums/request-status.enum.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestStatus = void 0;
var RequestStatus;
(function (RequestStatus) {
    RequestStatus["PENDING"] = "PENDING";
    RequestStatus["APPROVED"] = "APPROVED";
    RequestStatus["REJECTED"] = "REJECTED";
})(RequestStatus || (exports.RequestStatus = RequestStatus = {}));


/***/ }),

/***/ "./src/common/enums/role-scope-type.enum.ts":
/*!**************************************************!*\
  !*** ./src/common/enums/role-scope-type.enum.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleScopeType = void 0;
var RoleScopeType;
(function (RoleScopeType) {
    RoleScopeType["GLOBAL"] = "global";
    RoleScopeType["ORGANIZATION"] = "organization";
    RoleScopeType["BRANCH"] = "branch";
    RoleScopeType["DEPARTMENT"] = "department";
    RoleScopeType["OWNED"] = "owned";
})(RoleScopeType || (exports.RoleScopeType = RoleScopeType = {}));


/***/ }),

/***/ "./src/common/enums/role.enum.ts":
/*!***************************************!*\
  !*** ./src/common/enums/role.enum.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Role = void 0;
var Role;
(function (Role) {
    Role["SUPERADMIN"] = "SuperAdmin";
    Role["ADMIN"] = "Admin";
    Role["EMPLOYEE"] = "Employee";
})(Role || (exports.Role = Role = {}));


/***/ }),

/***/ "./src/common/enums/schedule-change-request-type.enum.ts":
/*!***************************************************************!*\
  !*** ./src/common/enums/schedule-change-request-type.enum.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeRequestType = void 0;
var ScheduleChangeRequestType;
(function (ScheduleChangeRequestType) {
    // Request for general time off from scheduled work
    ScheduleChangeRequestType["TIME_OFF"] = "TIME_OFF";
    // Request for time off due to illness or medical reasons
    ScheduleChangeRequestType["SICK_LEAVE"] = "SICK_LEAVE";
    // Request for time off for personal reasons
    ScheduleChangeRequestType["PERSONAL_LEAVE"] = "PERSONAL_LEAVE";
    // Request for time off due to bereavement or loss
    ScheduleChangeRequestType["BEREAVEMENT"] = "BEREAVEMENT";
    // Request for time off for maternity or paternity leave
    ScheduleChangeRequestType["MATERNITY_PATERNITY_LEAVE"] = "MATERNITY_PATERNITY_LEAVE";
    // Request for time off for jury duty or legal obligations
    ScheduleChangeRequestType["JURY_DUTY"] = "JURY_DUTY";
    // Request for time off for religious observances
    ScheduleChangeRequestType["RELIGIOUS_OBSERVANCE"] = "RELIGIOUS_OBSERVANCE";
    // Request for time off for family-related matters
    ScheduleChangeRequestType["FAMILY_LEAVE"] = "FAMILY_LEAVE";
    // Request for time off for educational purposes
    ScheduleChangeRequestType["EDUCATIONAL_LEAVE"] = "EDUCATIONAL_LEAVE";
    // Request for time off for relocation or moving
    ScheduleChangeRequestType["RELOCATION"] = "RELOCATION";
    // Request for time off for parental leave
    ScheduleChangeRequestType["PARENTAL_LEAVE"] = "PARENTAL_LEAVE";
    // Request for time off for bereavement or loss of a family member
    ScheduleChangeRequestType["FAMILY_BEREAVEMENT"] = "FAMILY_BEREAVEMENT";
    // Request for time off for personal emergencies
    ScheduleChangeRequestType["PERSONAL_EMERGENCY"] = "PERSONAL_EMERGENCY";
    // Request for business travel or work-related trips
    ScheduleChangeRequestType["BUSINESS_TRAVEL"] = "BUSINESS_TRAVEL";
    // Request for scheduled time off for vacation purposes
    ScheduleChangeRequestType["VACATION"] = "VACATION";
    // Request for schedule swap to a rest day
    ScheduleChangeRequestType["REST_DAY_SWAP"] = "REST_DAY_SWAP";
    // Request for time allocation for training or development activities
    ScheduleChangeRequestType["TRAINING"] = "TRAINING";
    // Any other type of schedule change request not covered by specific categories
    ScheduleChangeRequestType["OTHER"] = "OTHER";
})(ScheduleChangeRequestType || (exports.ScheduleChangeRequestType = ScheduleChangeRequestType = {}));


/***/ }),

/***/ "./src/common/enums/schedule-status.ts":
/*!*********************************************!*\
  !*** ./src/common/enums/schedule-status.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleStatus = void 0;
var ScheduleStatus;
(function (ScheduleStatus) {
    ScheduleStatus["DEFAULT"] = "DEFAULT";
    ScheduleStatus["MODIFIED"] = "MODIFIED";
    ScheduleStatus["SWAPPED"] = "SWAPPED";
    ScheduleStatus["LEAVE"] = "LEAVE";
    ScheduleStatus["CANCELLED"] = "CANCELLED";
})(ScheduleStatus || (exports.ScheduleStatus = ScheduleStatus = {}));


/***/ }),

/***/ "./src/common/events/attendance.event.ts":
/*!***********************************************!*\
  !*** ./src/common/events/attendance.event.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RecalculateFinalWorkHoursEvent = exports.FinalWorkHoursCalculationEvent = exports.AttendanceProcessedEvent = exports.AttendanceRecordedEvent = exports.ATTENDANCE_EVENTS = void 0;
exports.ATTENDANCE_EVENTS = {
    ATTENDANCE_RECORDED: 'attendance.recorded',
    ATTENDANCE_PROCESSED: 'attendance.processed',
    FINAL_WORK_HOURS_CALCULATION: 'attendance.final_work_hours_calculation',
    RECALCULATE_FINAL_WORK_HOURS: 'attendance.recalculate_final_work_hours',
};
class AttendanceRecordedEvent {
    constructor(attendances, deviceId) {
        this.attendances = attendances;
        this.deviceId = deviceId;
    }
}
exports.AttendanceRecordedEvent = AttendanceRecordedEvent;
class AttendanceProcessedEvent {
    constructor(attendances, processedBy = 'SYSTEM') {
        this.attendances = attendances;
        this.processedBy = processedBy;
    }
}
exports.AttendanceProcessedEvent = AttendanceProcessedEvent;
class FinalWorkHoursCalculationEvent {
    constructor(attendanceIds, batchId, processedBy) {
        this.attendanceIds = attendanceIds;
        this.batchId = batchId;
        this.processedBy = processedBy;
    }
}
exports.FinalWorkHoursCalculationEvent = FinalWorkHoursCalculationEvent;
class RecalculateFinalWorkHoursEvent {
    constructor(recalculatedBy, cutoffId, specificAttendanceIds) {
        this.recalculatedBy = recalculatedBy;
        this.cutoffId = cutoffId;
        this.specificAttendanceIds = specificAttendanceIds;
    }
}
exports.RecalculateFinalWorkHoursEvent = RecalculateFinalWorkHoursEvent;


/***/ }),

/***/ "./src/common/events/employee-assigned.event.ts":
/*!******************************************************!*\
  !*** ./src/common/events/employee-assigned.event.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeeAssignedEvent = exports.SCHEDULE_EVENTS = exports.GROUP_EVENTS = void 0;
exports.GROUP_EVENTS = {
    EMPLOYEE_ASSIGNED: 'employee.assigned.to.group',
    EMPLOYEE_REMOVED: 'employee.removed.from.group',
};
exports.SCHEDULE_EVENTS = {
    GENERATION_REQUESTED: 'schedule.generation.requested',
    GENERATION_COMPLETED: 'schedule.generation.completed',
    GENERATION_FAILED: 'schedule.generation.failed',
};
class EmployeeAssignedEvent {
    constructor(group, employees, assignedBy) {
        this.group = group;
        this.employees = employees;
        this.assignedBy = assignedBy;
    }
}
exports.EmployeeAssignedEvent = EmployeeAssignedEvent;


/***/ }),

/***/ "./src/common/events/schedule-change.event.ts":
/*!****************************************************!*\
  !*** ./src/common/events/schedule-change.event.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeRespondedEvent = exports.SCHEDULE_CHANGE_EVENTS = void 0;
exports.SCHEDULE_CHANGE_EVENTS = {
    SCHEDULE_CHANGE_RESPONDED: 'schedule_change.responded',
    SCHEDULE_CHANGE_REQUESTED: 'schedule_change.requested',
};
class ScheduleChangeRespondedEvent {
    constructor(scheduleChangeRequestId, isApproved, respondedBy) {
        this.scheduleChangeRequestId = scheduleChangeRequestId;
        this.isApproved = isApproved;
        this.respondedBy = respondedBy;
    }
}
exports.ScheduleChangeRespondedEvent = ScheduleChangeRespondedEvent;


/***/ }),

/***/ "./src/common/events/work-time.event.ts":
/*!**********************************************!*\
  !*** ./src/common/events/work-time.event.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeRespondedEvent = exports.WORK_TIME_EVENTS = void 0;
exports.WORK_TIME_EVENTS = {
    WORK_TIME_RESPONDED: 'work_time.responded',
    WORK_TIME_REQUESTED: 'work_time.requested',
};
class WorkTimeRespondedEvent {
    constructor(workTimeRequestId, isApproved, respondedBy) {
        this.workTimeRequestId = workTimeRequestId;
        this.isApproved = isApproved;
        this.respondedBy = respondedBy;
    }
}
exports.WorkTimeRespondedEvent = WorkTimeRespondedEvent;


/***/ }),

/***/ "./src/common/factories/create-controller.factory.ts":
/*!***********************************************************!*\
  !*** ./src/common/factories/create-controller.factory.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createController = createController;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const pluralize_1 = __importStar(__webpack_require__(/*! pluralize */ "pluralize"));
const base_controller_1 = __webpack_require__(/*! ../controllers/base.controller */ "./src/common/controllers/base.controller.ts");
const current_user_decorator_1 = __webpack_require__(/*! ../decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const generic_api_responses_decorator_1 = __webpack_require__(/*! ../decorators/generic-api-responses.decorator */ "./src/common/decorators/generic-api-responses.decorator.ts");
const override_decorator_1 = __webpack_require__(/*! ../decorators/override.decorator */ "./src/common/decorators/override.decorator.ts");
const generalresponse_dto_1 = __webpack_require__(/*! ../dtos/generalresponse.dto */ "./src/common/dtos/generalresponse.dto.ts");
const pagination_dto_1 = __webpack_require__(/*! ../dtos/pagination.dto */ "./src/common/dtos/pagination.dto.ts");
function createController(EntityClass, ServiceClass, getDtoClass, createDtoClass, updateDtoClass) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    // Extract entity name from class (removing "Entity" suffix if present)
    const entityName = EntityClass.name.replace(/Entity$/, '');
    // Add spaces before capital letters (except the first letter)
    const spacedEntityName = entityName.replace(/([A-Z])/g, ' $1').trim();
    // For the first character, ensure it's capitalized without a preceding space
    const formattedEntityName = spacedEntityName.charAt(0).toUpperCase() + spacedEntityName.slice(1);
    // Determine plural name for controller routes (used in swagger docs)
    const pluralName = (0, pluralize_1.default)(formattedEntityName);
    let DynamicController = class DynamicController extends base_controller_1.BaseController {
        constructor(baseService) {
            super(baseService, getDtoClass, formattedEntityName);
        }
        async create(entityDto, createdById) {
            return await super.create(entityDto, createdById);
        }
        async update(id, entityDto, updatedById) {
            return await super.update(id, entityDto, updatedById);
        }
        async delete(id) {
            return await super.delete(id);
        }
        async softDelete(id, deletedBy) {
            return await super.softDelete(id, deletedBy);
        }
        async findById(id, relations, select) {
            return await super.findById(id, relations, select);
        }
        async findOne(fieldsString, relations, select) {
            return await super.findOne(fieldsString, relations, select);
        }
        findAllAdvanced(req, paginationDto) {
            return super.findAllAdvanced(req, paginationDto);
        }
    };
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Create a New ${(0, pluralize_1.singular)(formattedEntityName)}`,
            description: `Creates a new ${(0, pluralize_1.singular)(formattedEntityName.toLowerCase())} record in the database with the provided data.`
        }),
        (0, swagger_1.ApiBody)({
            type: createDtoClass,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} creation data`,
            required: true
        }),
        (0, generic_api_responses_decorator_1.ApiCreateResponses)((0, pluralize_1.singular)(formattedEntityName), getDtoClass),
        (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
        __param(0, (0, common_1.Body)()),
        __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, String]),
        __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
    ], DynamicController.prototype, "create", null);
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Update an Existing ${(0, pluralize_1.singular)(formattedEntityName)}`,
            description: `Updates an existing ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} record in the database with the provided data.`
        }),
        (0, swagger_1.ApiParam)({
            name: 'id',
            description: `The unique identifier of the ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} to update`,
            required: true
        }),
        (0, swagger_1.ApiBody)({
            type: updateDtoClass,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} update data`,
            required: true
        }),
        (0, generic_api_responses_decorator_1.ApiUpdateResponses)((0, pluralize_1.singular)(formattedEntityName), getDtoClass),
        (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
        __param(0, (0, common_1.Param)('id')),
        __param(1, (0, common_1.Body)()),
        __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String, Object, String]),
        __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
    ], DynamicController.prototype, "update", null);
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Hard Delete a Specific ${(0, pluralize_1.singular)(formattedEntityName)}`,
            description: `Removes a ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} record from the database by its unique identifier.`
        }),
        (0, swagger_1.ApiParam)({
            name: 'id',
            description: `The unique identifier of the ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} to delete`,
            required: true
        }),
        (0, swagger_1.ApiResponse)({
            status: common_1.HttpStatus.NO_CONTENT,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} has been successfully deleted.`,
            type: generalresponse_dto_1.GeneralResponseDto
        }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: `${(0, pluralize_1.singular)(formattedEntityName)} not found.`, type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.CONFLICT, description: 'Cannot delete due to existing references.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
        __param(0, (0, common_1.Param)('id')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
    ], DynamicController.prototype, "delete", null);
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Soft Delete a Specific ${(0, pluralize_1.singular)(formattedEntityName)}`,
            description: `Marks a ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} record as deleted without removing it from the database.`
        }),
        (0, swagger_1.ApiParam)({
            name: 'id',
            description: `The unique identifier of the ${(0, pluralize_1.singular)(formattedEntityName.toLowerCase())} to soft delete`,
            required: true
        }),
        (0, swagger_1.ApiResponse)({
            status: common_1.HttpStatus.NO_CONTENT,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} has been successfully soft-deleted.`,
            type: generalresponse_dto_1.GeneralResponseDto
        }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: `${(0, pluralize_1.singular)(formattedEntityName)} not found.`, type: generalresponse_dto_1.GeneralResponseDto }),
        (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
        __param(0, (0, common_1.Param)('id')),
        __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String, String]),
        __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
    ], DynamicController.prototype, "softDelete", null);
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Find a Specific ${(0, pluralize_1.singular)(formattedEntityName)} by ID`,
            description: `Retrieve a single ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} from the database using its unique identifier.`
        }),
        (0, swagger_1.ApiParam)({
            name: 'id',
            description: `The unique identifier of the ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} to retrieve`,
            required: true
        }),
        (0, swagger_1.ApiQuery)({
            name: 'relations',
            required: false,
            type: String,
            description: 'Relations to include (comma-separated)',
            example: 'user,profile,permissions'
        }),
        (0, swagger_1.ApiQuery)({
            name: 'select',
            required: false,
            type: String,
            description: 'Fields to select (comma-separated)',
            example: 'id,name,email,createdAt'
        }),
        (0, swagger_1.ApiResponse)({
            status: common_1.HttpStatus.OK,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} was successfully retrieved.`,
            type: getDtoClass
        }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: `${(0, pluralize_1.singular)(formattedEntityName)} not found.`, type: generalresponse_dto_1.GeneralResponseDto }),
        (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
        __param(0, (0, common_1.Param)('id')),
        __param(1, (0, common_1.Query)('relations')),
        __param(2, (0, common_1.Query)('select')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String, String, String]),
        __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
    ], DynamicController.prototype, "findById", null);
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Find ${(0, pluralize_1.singular)(formattedEntityName)} by Any Field`,
            description: `Search for ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} using field-value pairs. Multiple criteria can be combined.`
        }),
        (0, swagger_1.ApiQuery)({
            name: 'fields',
            required: true,
            type: String,
            description: 'Search fields in format field:value (comma-separated)',
            example: `id:123,name:example${(0, pluralize_1.singular)(entityName).toLowerCase()}`
        }),
        (0, swagger_1.ApiQuery)({
            name: 'relations',
            required: false,
            type: String,
            description: 'Relations to include in the response (comma-separated)',
            example: 'user,category,tags'
        }),
        (0, swagger_1.ApiQuery)({
            name: 'select',
            required: false,
            type: String,
            description: 'Fields to select in the response (comma-separated). Only these fields will be returned.',
            example: 'id,name,createdAt'
        }),
        (0, swagger_1.ApiResponse)({
            status: common_1.HttpStatus.OK,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} found successfully`,
            type: getDtoClass
        }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: `${(0, pluralize_1.singular)(formattedEntityName)} not found with the specified criteria`, type: generalresponse_dto_1.GeneralResponseDto }),
        (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
        __param(0, (0, common_1.Query)('fields')),
        __param(1, (0, common_1.Query)('relations')),
        __param(2, (0, common_1.Query)('select')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String, String, String]),
        __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
    ], DynamicController.prototype, "findOne", null);
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Find all ${(0, pluralize_1.singular)(formattedEntityName)} with Advanced Filtering`,
            description: `
        # Advanced Filtering Guide
        
        This endpoint supports complex filtering using JSON objects in the filter parameter.
        
        ## Basic Filters
        Simple equality: \`?filter={"status":"active"}\`
        
        ## Advanced Operators
        - Equal: \`?filter={"name":{"eq":"John"}}\`
        - Not equal: \`?filter={"status":{"ne":"deleted"}}\`
        - Greater than: \`?filter={"age":{"gt":18}}\`
        - Greater than or equal: \`?filter={"age":{"gte":21}}\`
        - Less than: \`?filter={"age":{"lt":65}}\`
        - Less than or equal: \`?filter={"price":{"lte":100}}\`
        - Like (contains): \`?filter={"name":{"like":"oh"}}\`
        - Case-insensitive like: \`?filter={"name":{"ilike":"john"}}\`
        - Between: \`?filter={"price":{"between":[10,50]}}\`
        - In array: \`?filter={"status":{"in":["active","pending"]}}\`
        - Not in array: \`?filter={"status":{"nin":["deleted","archived"]}}\`
        - Is null: \`?filter={"deletedAt":{"isNull":true}}\`
        
        ## Logical Operators
        
        ### AND (Default)
        Multiple conditions combined with AND logic (all must match):
        \`?filter={"status":"active","age":{"gte":21}}\`
        
        ### OR
        Any condition can match (using the special OR property):
        \`?filter={"OR":[{"status":"active"},{"featured":true}]}\`
        
        ## Relational Filtering
        
        ### Basic relation filtering:
        \`?filter={"user.email":"example@email.com"}\`
        
        ### Advanced relation filtering with operators:
        \`?filter={"user.profile.firstName":{"ilike":"jo"}}\`
        
        ### Complex nested relation filtering:
        \`?filter={"user.profile.address.city":{"eq":"New York"}}\`
        
        ### Combining relation filters with logical operators:
        \`?filter={"OR":[{"user.profile.firstName":{"ilike":"jo"}},{"user.email":{"like":"gmail"}}]}\`
        
        ## Field Selection
        Select specific fields: \`?select=["id","name","email"]\`
        Select fields from relations: \`?select=["id","name","user.id","user.email","category.name"]\`
        
        ## Sorting
        Sort by field: \`?sort={"createdAt":"DESC"}\`
        Multiple fields: \`?sort={"status":"ASC","createdAt":"DESC"}\`
        Sort by relation field: \`?sort={"user.name":"ASC"}\`
        
        ## Pagination
        Page size: \`?take=10\`
        Skip records: \`?skip=10\` (for page 2 with size 10)
        
        ## Relations
        Include related entities: \`?relations=["user","category"]\`
        Include nested relations: \`?relations=["user","user.profile","user.profile.address"]\`
        Alternative format: \`?relations={"user":true,"category":{"subcategories":true}}\`
        `,
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, typeof (_g = typeof pagination_dto_1.PaginationDto !== "undefined" && pagination_dto_1.PaginationDto) === "function" ? _g : Object]),
        __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
    ], DynamicController.prototype, "findAllAdvanced", null);
    DynamicController = __decorate([
        (0, swagger_1.ApiTags)(pluralName),
        (0, common_1.Controller)(),
        __param(0, (0, common_1.Inject)(ServiceClass)),
        __metadata("design:paramtypes", [void 0])
    ], DynamicController);
    return DynamicController;
}


/***/ }),

/***/ "./src/common/factories/create-gateway.factory.ts":
/*!********************************************************!*\
  !*** ./src/common/factories/create-gateway.factory.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createGateway = createGateway;
const jwt_service_1 = __webpack_require__(/*! @/modules/account-management/auth/services/jwt.service */ "./src/modules/account-management/auth/services/jwt.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const user_connection_service_1 = __webpack_require__(/*! @/modules/notifications/services/user-connection.service */ "./src/modules/notifications/services/user-connection.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const websockets_1 = __webpack_require__(/*! @nestjs/websockets */ "@nestjs/websockets");
const base_gateway_1 = __webpack_require__(/*! ../gateways/base.gateway */ "./src/common/gateways/base.gateway.ts");
function createGateway(namespace) {
    var _a, _b, _c, _d;
    let DynamicGateway = class DynamicGateway extends base_gateway_1.BaseGateway {
        constructor(userConnectionService, jwtService, usersService, configService) {
            super(userConnectionService, jwtService, usersService, configService);
            this.userConnectionService = userConnectionService;
            this.jwtService = jwtService;
            this.usersService = usersService;
            this.configService = configService;
            this.namespace = namespace;
        }
    };
    DynamicGateway = __decorate([
        (0, websockets_1.WebSocketGateway)({ namespace }),
        (0, common_1.Injectable)(),
        __metadata("design:paramtypes", [typeof (_a = typeof user_connection_service_1.UserConnectionService !== "undefined" && user_connection_service_1.UserConnectionService) === "function" ? _a : Object, typeof (_b = typeof jwt_service_1.JwtService !== "undefined" && jwt_service_1.JwtService) === "function" ? _b : Object, typeof (_c = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _c : Object, typeof (_d = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _d : Object])
    ], DynamicGateway);
    return DynamicGateway;
}


/***/ }),

/***/ "./src/common/factories/create-get-dto.factory.ts":
/*!********************************************************!*\
  !*** ./src/common/factories/create-get-dto.factory.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createGetDto = createGetDto;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
/**
 * Creates a Data Transfer Object (DTO) class for GET operations by extending the provided DTO
 * with standard entity metadata fields such as id, timestamps, and soft-delete information.
 *
 * This utility automatically copies all properties and decorators from the source DTO
 * and adds standardized tracking fields like creation date, update date, etc. The resulting
 * class is dynamically named with the pattern `Get${originalClassName}`.
 *
 * @template T - The type of the DTO class to extend
 * @param {new () => T} dto - The DTO class constructor to extend with metadata fields
 * @returns {any} A new DTO class that extends the original with standard entity metadata fields
 *
 * @remarks
 * The returned class includes the following additional fields:
 * - id: Unique identifier for the entity
 * - createdAt: Timestamp of entity creation
 * - updatedAt: Timestamp of last update (nullable)
 * - createdBy: ID of the user who created the entity (nullable)
 * - updatedBy: ID of the user who last updated the entity (nullable)
 * - isDeleted: Flag indicating if the entity is soft-deleted
 * - deletedBy: ID of the user who deleted the entity (nullable)
 * - deletedAt: Timestamp of entity deletion (nullable)
 *
 * @example
 * ```typescript
 * // Define a base DTO
 * class UserDto {
 *   @ApiProperty()
 *   name: string;
 *
 *   @ApiProperty()
 *   email: string;
 * }
 *
 * // Create a GetUserDto with all standard metadata fields
 * const GetUserDto = createGetDto(UserDto);
 * ```
 */
function createGetDto(dto, entity = "entity") {
    var _a, _b, _c;
    class GetDto extends dto {
        constructor(partial) {
            super();
            Object.assign(this, partial);
        }
    }
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: 'Unique identifier',
            example: '123e4567-e89b-12d3-a456-426614174000'
        }),
        __metadata("design:type", String)
    ], GetDto.prototype, "id", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `Date when this ${entity} was created`,
            example: '2023-01-01T00:00:00Z',
            type: Date
        }),
        __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
    ], GetDto.prototype, "createdAt", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `Date when this ${entity} was last updated`,
            example: '2023-01-02T00:00:00Z',
            type: Date,
            nullable: true
        }),
        __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
    ], GetDto.prototype, "updatedAt", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `ID of the user who created this ${entity}}`,
            example: '123e4567-e89b-12d3-a456-426614174000',
            nullable: true
        }),
        __metadata("design:type", String)
    ], GetDto.prototype, "createdBy", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `ID of the user who last updated this ${entity}`,
            example: '123e4567-e89b-12d3-a456-426614174000',
            nullable: true
        }),
        __metadata("design:type", String)
    ], GetDto.prototype, "updatedBy", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `Whether this ${entity} is marked as deleted`,
            example: false,
            default: false
        }),
        __metadata("design:type", Boolean)
    ], GetDto.prototype, "isDeleted", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `ID of the user who deleted this ${entity}`,
            example: '123e4567-e89b-12d3-a456-426614174000',
            nullable: true
        }),
        __metadata("design:type", String)
    ], GetDto.prototype, "deletedBy", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `Date when this ${entity} was deleted`,
            example: '2023-01-03T00:00:00Z',
            type: Date,
            nullable: true
        }),
        __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
    ], GetDto.prototype, "deletedAt", void 0);
    // Copy properties and decorators from the source DTO
    const prototype = dto.prototype;
    Reflect.ownKeys(prototype).forEach(key => {
        if (key === 'constructor')
            return;
        const descriptor = Object.getOwnPropertyDescriptor(prototype, key);
        if (descriptor) {
            Object.defineProperty(GetDto.prototype, key, descriptor);
        }
    });
    // Rename the class
    Object.defineProperty(GetDto, 'name', { value: `Get${dto.name}` });
    return GetDto;
}


/***/ }),

/***/ "./src/common/filters/http-exception.filter.ts":
/*!*****************************************************!*\
  !*** ./src/common/filters/http-exception.filter.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var HttpExceptionFilter_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpExceptionFilter = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const crypto = __importStar(__webpack_require__(/*! crypto */ "crypto"));
/**
 * HttpExceptionFilter is a global filter that handles all exceptions thrown in the application.
 * It logs the error details, sanitizes sensitive information, and sends a user-friendly response to the client.
 */
let HttpExceptionFilter = HttpExceptionFilter_1 = class HttpExceptionFilter {
    constructor() {
        this.logger = new common_1.Logger(HttpExceptionFilter_1.name);
        this.errorCount = new Map();
        this.SENSITIVE_PATTERNS = [
            /(?:confirm)?password/i,
            /token/i,
            /credit.?card/i,
            /secret/i,
            /ssn/i,
            /social.?security.?number/i,
            /api.?key/i,
            /private.?key/i,
            /pin/i,
            /passcode/i
        ];
    }
    /**
     * Catches and handles exceptions thrown in the application.
     * @param exception - The exception that was thrown.
     * @param host - The arguments host containing request and response objects.
     */
    catch(exception, host) {
        const ctx = host.switchToHttp();
        const response = ctx.getResponse();
        const request = ctx.getRequest();
        const traceId = crypto.randomUUID();
        // Determine error details
        const status = this.getHttpStatus(exception);
        const error = this.normalizeError(exception);
        const timestamp = new Date().toISOString();
        // Get client IP with fallbacks
        const clientIp = request.socket.remoteAddress ||
            request.ip ||
            'unknown';
        // Track error frequency
        this.trackErrorFrequency(clientIp, status);
        // Prepare client response
        const clientResponse = {
            statusCode: status,
            timestamp,
            traceId,
            path: request.url,
            detail: error.name,
            message: exception instanceof common_1.HttpException
                ? exception.getResponse().message || error.message
                : this.getClientMessage(error.message, status),
        };
        response.status(status).json(clientResponse);
    }
    /**
     * Determines the HTTP status code from the exception.
     * @param exception - The exception to evaluate.
     * @returns The HTTP status code.
     */
    getHttpStatus(exception) {
        if (exception instanceof common_1.HttpException) {
            return exception.getStatus();
        }
        return common_1.HttpStatus.INTERNAL_SERVER_ERROR;
    }
    /**
     * Normalizes the exception to an Error object.
     * @param exception - The exception to normalize.
     * @returns The normalized Error object.
     */
    normalizeError(exception) {
        if (exception instanceof Error) {
            return exception;
        }
        return new Error(String(exception));
    }
    /**
     * Sanitizes sensitive headers from the request.
     * @param headers - The headers to sanitize.
     * @returns The sanitized headers.
     */
    sanitizeHeaders(headers) {
        const sanitized = Object.assign({}, headers);
        const sensitiveHeaders = ['authorization', 'cookie', 'x-auth-token'];
        sensitiveHeaders.forEach(header => {
            if (header in sanitized) {
                sanitized[header] = '[REDACTED]';
            }
        });
        return sanitized;
    }
    /**
     * Generates a user-friendly message for the client.
     * @param message - The original error message.
     * @param status - The HTTP status code.
     * @returns The user-friendly message.
     */
    getClientMessage(message, status) {
        return this.sanitizeSensitiveData(message);
    }
    /**
     * Sanitizes sensitive data in the error message.
     * @param message - The message to sanitize.
     * @returns The sanitized message.
     */
    sanitizeSensitiveData(message) {
        let sanitized = message;
        this.SENSITIVE_PATTERNS.forEach(pattern => {
            sanitized = sanitized.replace(pattern, '[REDACTED]');
        });
        return sanitized;
    }
    /**
     * Tracks the frequency of errors from a specific IP address.
     * @param ip - The IP address of the client.
     * @param status - The HTTP status code of the error.
     */
    trackErrorFrequency(ip, status) {
        const key = `${ip}:${status}`;
        const count = (this.errorCount.get(key) || 0) + 1;
        this.errorCount.set(key, count);
        if (count > 10) {
            this.logger.warn({
                type: 'POTENTIAL_ATTACK',
                ip,
                errorCount: count,
                status,
            });
        }
    }
    /**
     * Logs the error details.
     * @param errorContext - The context of the error to log.
     */
    logError(errorContext) {
        if (errorContext.status >= 500) {
            this.logger.error(errorContext);
        }
        else {
            this.logger.warn(errorContext);
        }
    }
};
exports.HttpExceptionFilter = HttpExceptionFilter;
exports.HttpExceptionFilter = HttpExceptionFilter = HttpExceptionFilter_1 = __decorate([
    (0, common_1.Catch)()
], HttpExceptionFilter);


/***/ }),

/***/ "./src/common/gateways/base.gateway.ts":
/*!*********************************************!*\
  !*** ./src/common/gateways/base.gateway.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseGateway = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const websockets_1 = __webpack_require__(/*! @nestjs/websockets */ "@nestjs/websockets");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const socket_io_1 = __webpack_require__(/*! socket.io */ "socket.io");
const uuid_1 = __webpack_require__(/*! uuid */ "uuid");
class BaseGateway {
    constructor(userConnectionService, jwtService, usersService, configService) {
        this.userConnectionService = userConnectionService;
        this.jwtService = jwtService;
        this.usersService = usersService;
        this.configService = configService;
        this.logger = new common_1.Logger(this.constructor.name);
        this.connections = new Map();
        // Organized client tracking
        this.connectedClients = new Map();
        this.userRooms = new Map();
        // Add middleware support
        this.middlewares = [];
        // Rate limiting protection
        this.messageRateLimit = new Map();
        this.MAX_MESSAGES_PER_MINUTE = 60;
        this.HEARTBEAT_INTERVAL = 60000; // ms
        this.CONNECTION_TIMEOUT = 300000; // 5 minutes in ms
        this.AUTH_TOKEN_EXPIRY_BUFFER = 300; // 5 minutes in seconds
        this.eventHandlers = new Map();
        this.metrics = {
            totalConnections: 0,
            activeConnections: 0,
            messagesProcessed: 0,
            authFailures: 0,
            rateLimitHits: 0
        };
    }
    // Lifecycle hooks
    onModuleInit() {
        // this.logger.log(`Gateway ${this.constructor.name} initialized`);
        this.setupHeartbeat();
        this.setupEventHandlers();
    }
    onModuleDestroy() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
        }
        this.logger.log(`Gateway ${this.constructor.name} destroyed`);
    }
    afterInit(server) {
        var _a, _b;
        if (!server || !server.engine) {
            // this.logger.warn('Server or server.engine not available in afterInit');
            return; // Exit early if server or server.engine is not available
        }
        // Configure compression
        const compressionThreshold = this.configService.get('websocket.compressionThreshold', 1024);
        (_b = (_a = this.server) === null || _a === void 0 ? void 0 : _a.engine) === null || _b === void 0 ? void 0 : _b.on('connection', (socket) => {
            socket.compress = (data) => {
                return data.length > compressionThreshold;
            };
        });
        const corsConfig = {
            origin: this.configService.getOrThrow('CORS_ORIGINS'),
            credentials: true,
            methods: '*',
            allowedHeaders: 'Content-Type, Accept, Authorization',
            maxAge: 86400 // 24 hours
        };
        // Apply CORS configuration to the server
        server.engine.on('headers', (headers, req) => {
            const origin = req.headers.origin;
            if (corsConfig.origin.includes(origin) || corsConfig.origin.includes('*')) {
                headers['Access-Control-Allow-Origin'] = origin;
                headers['Access-Control-Allow-Credentials'] = corsConfig.credentials;
                headers['Access-Control-Allow-Methods'] = typeof corsConfig.methods === 'string' ?
                    corsConfig.methods : corsConfig.methods.join(', ');
                headers['Access-Control-Allow-Headers'] = corsConfig.allowedHeaders;
                headers['Access-Control-Max-Age'] = corsConfig.maxAge;
                // Security headers
                headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains';
                headers['X-Content-Type-Options'] = 'nosniff';
                headers['X-XSS-Protection'] = '1; mode=block';
                headers['X-Frame-Options'] = 'SAMEORIGIN'; // Prevents clickjacking
                headers['Content-Security-Policy'] = "default-src 'self'"; // Restrictive CSP
            }
        });
    }
    handleConnection(client) {
        try {
            const ip = client.handshake.address;
            const current = this.connections.get(ip) || { count: 0, lastConnect: new Date() };
            // Rate limiting logic
            const now = new Date();
            const timeDiff = now.getTime() - current.lastConnect.getTime();
            if (timeDiff < 1000 && current.count > 5) {
                client.disconnect();
                this.logger.warn(`Rate limit exceeded for IP: ${ip}`);
                return;
            }
            // Update connection tracking
            this.connections.set(ip, {
                count: timeDiff < 10000 ? current.count + 1 : 1,
                lastConnect: now
            });
            this.metrics.totalConnections++;
            this.metrics.activeConnections++;
            // Generate a unique connection ID for this socket
            client.connectionId = (0, uuid_1.v4)();
            // Apply middlewares before proceeding with connection
            this.applyMiddlewares(client, async (err) => {
                if (err) {
                    this.logger.error(`Middleware error: ${err.message}`);
                    client.disconnect();
                    return;
                }
                // Continue with existing connection logic
                const isAuthenticated = await this.authenticateClient(client);
                if (!isAuthenticated) {
                    this.logger.warn(`Authentication failed for connection ${client.id}`);
                    client.disconnect();
                    return;
                }
                // Rest of your existing connection logic...
                if (!client.user) {
                    this.logger.warn(`User not defined after authentication for connection ${client.id}`);
                    client.disconnect();
                    return;
                }
                const user = client.user.sub;
                this.connectedClients.set(user, client);
                this.messageRateLimit.set(user, 0);
                this.logger.log(`${this.constructor.name} active connections: ${this.metrics.activeConnections}`);
                this.afterConnect(client);
            });
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Connection error: ${error.message}`, error.stack);
            }
            else {
                this.logger.error('Connection error: Unknown error');
            }
            client.disconnect();
        }
    }
    // Add to BaseGateway class
    async handleShutdown() {
        this.logger.log(`Gateway ${this.constructor.name} shutting down gracefully`);
        // Send disconnect warning to all clients
        this.broadcast('server_shutdown', {
            message: 'Server is shutting down for maintenance',
            reconnectIn: 10000 // ms
        });
        // Wait to allow clients to process the message
        await new Promise(resolve => setTimeout(resolve, 1000));
        // Close all connections
        this.connectedClients.forEach((client) => {
            client.disconnect(true);
        });
        // Clear data structures
        this.connectedClients.clear();
        this.userRooms.clear();
        this.messageRateLimit.clear();
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
        }
    }
    validatePayload(payload, schema) {
        try {
            return (0, class_transformer_1.plainToClass)(schema, payload, { excludeExtraneousValues: true });
        }
        catch (error) {
            throw new websockets_1.WsException('Invalid payload format');
        }
    }
    addMiddleware(middleware) {
        this.middlewares.push(middleware);
    }
    applyMiddlewares(client, callback) {
        let index = 0;
        const next = (err) => {
            if (err)
                return callback(err);
            if (index >= this.middlewares.length)
                return callback();
            const middleware = this.middlewares[index++];
            try {
                middleware(client, next);
            }
            catch (error) {
                next(error instanceof Error ? error : new Error('Middleware error'));
            }
        };
        next();
    }
    handleDisconnect(client) {
        try {
            this.metrics.activeConnections--;
            if (!client.user || !client.user.sub || !client.user.email) {
                return;
            }
            const user = client.user.email || client.user.sub;
            // Clean up resources
            this.connectedClients.delete(user);
            this.messageRateLimit.delete(user);
            // Leave all rooms
            const rooms = this.userRooms.get(user);
            if (rooms) {
                rooms.forEach(room => {
                    client.leave(room);
                });
                this.userRooms.delete(user);
            }
            this.logger.log(`${this.constructor.name} total active connections: ${this.metrics.activeConnections}`);
            this.afterDisconnect(client);
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Disconnect error: ${error.message}`, error.stack);
            }
            else {
                this.logger.error('Disconnect error: Unknown error');
            }
        }
    }
    // A centralized error handler
    handleError(context, error, client) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        const stack = error instanceof Error ? error.stack : undefined;
        this.logger.error(`${context}: ${errorMessage}`, stack);
        if (client) {
            client.emit('error', {
                message: 'An error occurred',
                code: 'INTERNAL_ERROR',
                context
            });
        }
    }
    // Authentication - override this in derived classes for specific auth logic
    async authenticateClient(client) {
        try {
            const token = this.extractTokenFromSocket(client);
            if (!token) {
                this.logger.debug('No token provided');
                return false;
            }
            // Verify token hasn't expired
            const payload = await this.jwtService.verifyToken(token);
            // Check token expiration with buffer time to avoid edge cases
            const currentTime = Math.floor(Date.now() / 1000);
            if (payload.exp && payload.exp - this.AUTH_TOKEN_EXPIRY_BUFFER < currentTime) {
                this.logger.debug(`Token expiring soon: ${payload.exp - currentTime}s remaining`);
            }
            // Find and verify the user exists and is active
            const user = await this.usersService.findOneBy({
                id: payload.sub
            });
            if (!user) {
                this.logger.debug(`User not found or inactive: ${payload.sub}`);
                return false;
            }
            // Store minimal user data on socket
            client.user = payload;
            // Track connection with timestamp
            client.connectionId = `${user.id}-${Date.now()}`;
            client.handshake.auth.connectedAt = Date.now();
            return true;
        }
        catch (error) {
            this.handleError('Authentication', error);
            return false;
        }
    }
    // Helper method to extract token from socket connection
    extractTokenFromSocket(client) {
        // const origin = client.handshake.headers.origin;
        // // log origin
        // const allowedOrigins = this.configService.get<string[]>('cors.origins', []);
        // if (!origin || !allowedOrigins.includes(origin)) {
        //     this.logger.warn(`Connection attempt from unauthorized origin: ${origin}`);
        //     return null;
        // }
        // Try to get from handshake auth
        const authHeader = client.handshake.headers.authorization;
        if (authHeader && authHeader.startsWith('Bearer ')) {
            return authHeader.substring(7);
        }
        // Try to get from query parameters
        const { token } = client.handshake.query;
        if (token && typeof token === 'string') {
            return token;
        }
        return null;
    }
    // Room management
    joinRoom(client, room) {
        try {
            client.join(room);
            if (!client.user) {
                throw new websockets_1.WsException('User not authenticated');
            }
            const user = client.user.email || client.user.sub;
            if (!this.userRooms.has(user)) {
                this.userRooms.set(user, new Set());
            }
            const userRoomSet = this.userRooms.get(user);
            userRoomSet.add(room);
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error joining room: ${error.message}`, error.stack);
                throw new websockets_1.WsException(`Failed to join room: ${error.message}`);
            }
            else {
                this.logger.error('Error joining room: Unknown error');
                throw new websockets_1.WsException('Failed to join room: Unknown error');
            }
        }
    }
    leaveRoom(client, room) {
        try {
            client.leave(room);
            if (!client.user) {
                throw new websockets_1.WsException('User not authenticated');
            }
            const user = client.user.email || client.user.sub;
            const rooms = this.userRooms.get(user);
            if (rooms) {
                rooms.delete(room);
            }
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error leaving room: ${error.message}`, error.stack);
                throw new websockets_1.WsException(`Failed to leave room: ${error.message}`);
            }
            else {
                this.logger.error('Error leaving room: Unknown error');
                throw new websockets_1.WsException('Failed to leave room: Unknown error');
            }
        }
    }
    // Messaging Methods
    pingUser(userId) {
        this.emitToUser({ event: 'ping' }, userId);
    }
    pingAll() {
        this.broadcast(this.namespace, { event: 'ping' });
    }
    emitToUser(data, userId) {
        if (!userId || !this.connectedClients.has(userId)) {
            this.logger.warn(`User ${userId} not connected`);
            return;
        }
        const userRoom = `user:${userId}:${this.namespace}`;
        this.emitToRoom(userRoom, this.namespace, data);
    }
    emitToRoom(room, event, data) {
        try {
            this.server.to(room).emit(event, data);
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error emitting to room: ${error.message}`, error.stack);
                throw new websockets_1.WsException(`Failed to emit to room: ${error.message}`);
            }
            else {
                this.logger.error('Error emitting to room: Unknown error');
                throw new websockets_1.WsException('Failed to emit to room: Unknown error');
            }
        }
    }
    broadcast(event, data, exceptUser) {
        try {
            if (exceptUser) {
                // Send to all clients except the one with exceptUserId
                for (const [userId, client] of this.connectedClients.entries()) {
                    if (userId !== exceptUser) {
                        client.emit(event, data);
                    }
                }
            }
            else {
                // Send to all clients
                this.server.emit(event, data);
            }
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error broadcasting: ${error.message}`, error.stack);
                throw new websockets_1.WsException(`Failed to broadcast: ${error.message}`);
            }
            else {
                this.logger.error('Error broadcasting: Unknown error');
                throw new websockets_1.WsException('Failed to broadcast: Unknown error');
            }
        }
    }
    // Rate limiting
    isRateLimited(userId) {
        const currentRate = this.messageRateLimit.get(userId) || 0;
        if (currentRate >= this.MAX_MESSAGES_PER_MINUTE) {
            return true;
        }
        this.messageRateLimit.set(userId, currentRate + 1);
        return false;
    }
    // Heartbeat management
    setupHeartbeat() {
        // Reset rate limits every minute
        this.heartbeatInterval = setInterval(() => {
            this.messageRateLimit.clear();
            // Check for stale connections
            this.checkConnections();
        }, 60000); // 1 minute
    }
    checkConnections() {
        const now = Date.now();
        // Check each connection for activity
        this.connectedClients.forEach((client, user) => {
            if (!client.connected) {
                this.logger.debug(`Removing disconnected client: ${user}`);
                this.connectedClients.delete(user);
                return;
            }
            // Check for timeout (no activity for X minutes)
            const connectedAt = client.handshake.auth.connectedAt || 0;
            if (now - connectedAt > this.CONNECTION_TIMEOUT) {
                this.logger.debug(`Connection timeout for user: ${user}`);
                client.disconnect(true);
                this.connectedClients.delete(user);
            }
        });
    }
    // Event handling setup
    setupEventHandlers() {
        this.server.on('connection', (socket) => {
            // Register all event handlers from the derived class
            if (this.eventHandlers) {
                this.eventHandlers.forEach((handler, event) => {
                    socket.on(event, (payload) => {
                        try {
                            // Validate user is authenticated
                            if (!socket.user || !socket.user.sub) {
                                socket.emit('error', { message: 'Not authenticated' });
                                return;
                            }
                            // Check rate limiting
                            if (this.isRateLimited(socket.user.sub)) {
                                socket.emit('error', { message: 'Rate limit exceeded' });
                                return;
                            }
                            // Execute the handler
                            handler(socket, payload);
                        }
                        catch (error) {
                            if (error instanceof Error) {
                                this.logger.error(`Error handling event ${event}: ${error.message}`, error.stack);
                            }
                            else {
                                this.logger.error(`Error handling event ${event}: Unknown error`);
                            }
                            socket.emit('error', { message: 'Internal server error' });
                        }
                    });
                });
            }
        });
    }
    // Hooks for derived classes
    afterConnect(client) {
        if (client.user) {
            const userRoom = `user:${client.user.sub}:${this.namespace}`;
            this.joinRoom(client, userRoom);
            this.logger.log(`${client.user.email} subscribed to ${this.namespace}`);
        }
    }
    afterDisconnect(client) { }
}
exports.BaseGateway = BaseGateway;
__decorate([
    (0, websockets_1.WebSocketServer)(),
    __metadata("design:type", typeof (_a = typeof socket_io_1.Server !== "undefined" && socket_io_1.Server) === "function" ? _a : Object)
], BaseGateway.prototype, "server", void 0);


/***/ }),

/***/ "./src/common/guards/google-auth.guard.ts":
/*!************************************************!*\
  !*** ./src/common/guards/google-auth.guard.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoogleAuthGuard = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const passport_1 = __webpack_require__(/*! @nestjs/passport */ "@nestjs/passport");
let GoogleAuthGuard = class GoogleAuthGuard extends (0, passport_1.AuthGuard)('google-auth') {
};
exports.GoogleAuthGuard = GoogleAuthGuard;
exports.GoogleAuthGuard = GoogleAuthGuard = __decorate([
    (0, common_1.Injectable)()
], GoogleAuthGuard);


/***/ }),

/***/ "./src/common/guards/jwt-auth.guard.ts":
/*!*********************************************!*\
  !*** ./src/common/guards/jwt-auth.guard.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JwtAuthGuard = void 0;
// jwt-auth.guard.ts
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const passport_1 = __webpack_require__(/*! @nestjs/passport */ "@nestjs/passport");
let JwtAuthGuard = class JwtAuthGuard extends (0, passport_1.AuthGuard)('jwt') {
};
exports.JwtAuthGuard = JwtAuthGuard;
exports.JwtAuthGuard = JwtAuthGuard = __decorate([
    (0, common_1.Injectable)()
], JwtAuthGuard);


/***/ }),

/***/ "./src/common/guards/permissions.guard.ts":
/*!************************************************!*\
  !*** ./src/common/guards/permissions.guard.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var PermissionsGuard_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionsGuard = void 0;
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const permissions_service_1 = __webpack_require__(/*! @/modules/employee-management/roles/permissions/permissions.service */ "./src/modules/employee-management/roles/permissions/permissions.service.ts");
const activity_logs_service_1 = __webpack_require__(/*! @/modules/logs/activity-logs/activity-logs.service */ "./src/modules/logs/activity-logs/activity-logs.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const pluralize_1 = __webpack_require__(/*! pluralize */ "pluralize");
const authorize_decorator_1 = __webpack_require__(/*! ../decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const permissions_decorator_1 = __webpack_require__(/*! ../decorators/permissions.decorator */ "./src/common/decorators/permissions.decorator.ts");
const action_enum_1 = __webpack_require__(/*! ../enums/action.enum */ "./src/common/enums/action.enum.ts");
const role_enum_1 = __webpack_require__(/*! ../enums/role.enum */ "./src/common/enums/role.enum.ts");
let PermissionsGuard = PermissionsGuard_1 = class PermissionsGuard {
    constructor(reflector, usersService, permissionsService, activityLogsService) {
        this.reflector = reflector;
        this.usersService = usersService;
        this.permissionsService = permissionsService;
        this.activityLogsService = activityLogsService;
        this.logger = new common_1.Logger(PermissionsGuard_1.name);
    }
    async canActivate(context) {
        var _a, _b, _c, _d;
        try {
            // First check for endpoint type
            const endpointType = this.reflector.getAllAndOverride(authorize_decorator_1.PERMISSION_ENDPOINT_TYPE, [context.getHandler(), context.getClass()]);
            let requiredPermissions = [];
            const controllerClass = context.getClass();
            const controllerName = controllerClass.name;
            const baseName = (0, pluralize_1.singular)(controllerName.replace(/controller$/i, ''));
            if (endpointType) {
                // get the permissions for the controller in the database
                const permissions = await this.permissionsService.getPermissionsByControllerName(baseName);
                // Filter permissions based on the endpoint type action
                if (permissions && permissions.length > 0) {
                    // Filter permissions that match the endpoint type action
                    requiredPermissions = permissions.filter(permission => {
                        // For CREATE endpoints, match against CREATE or MANAGE actions
                        if (endpointType === action_enum_1.Action.CREATE) {
                            return permission.action === action_enum_1.Action.CREATE || permission.action === action_enum_1.Action.MANAGE;
                        }
                        // For READ endpoints, match against READ or MANAGE actions
                        else if (endpointType === action_enum_1.Action.READ) {
                            return permission.action === action_enum_1.Action.READ || permission.action === action_enum_1.Action.MANAGE;
                        }
                        // For UPDATE endpoints, match against UPDATE or MANAGE actions
                        else if (endpointType === action_enum_1.Action.UPDATE) {
                            return permission.action === action_enum_1.Action.UPDATE || permission.action === action_enum_1.Action.MANAGE;
                        }
                        // For DELETE endpoints, match against DELETE or MANAGE actions
                        else if (endpointType === action_enum_1.Action.DELETE) {
                            return permission.action === action_enum_1.Action.DELETE || permission.action === action_enum_1.Action.MANAGE;
                        }
                        return false;
                    });
                }
            }
            else {
                // Fall back to standard permissions check
                requiredPermissions = this.reflector.getAllAndOverride(permissions_decorator_1.PERMISSIONS_KEY, [context.getHandler(), context.getClass()]) || [];
            }
            // If no permissions are required, allow access
            if (!requiredPermissions || requiredPermissions.length === 0) {
                return true;
            }
            // Get the user payload from the request
            const request = context.switchToHttp().getRequest();
            const userClaims = request.user;
            const resourceId = this.getResourceInfo(request);
            // get user with their role and role permissions
            let user;
            try {
                user = await this.usersService.findOneByOrFail({ id: userClaims.sub }, { relations: { employee: { roles: { permissions: true } } } });
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error(`Error fetching user permissions: ${errorMessage}`);
                // Log failed permission check due to user lookup error
                await this.logUserActivity(userClaims, endpointType, baseName, false, 'Permission check failed - User not found', resourceId);
                throw new common_1.ForbiddenException('Error processing permissions');
            }
            // check if user is an employee if user is not an employee only allow access to their own resource
            if (!user.employee) {
                // Check if the user is trying to access their own resource
                const userId = request.params.userId || request.query.userId || request.body.userId;
                if (userId !== userClaims.sub && userId) {
                    this.logger.warn(`User is trying to access another user's resource: ${userId}`);
                    // Log unauthorized access attempt
                    await this.logUserActivity(userClaims, endpointType, baseName, false, `Attempted to access another user's resource: ${userId}`, resourceId, userClaims.sub);
                    throw new common_1.ForbiddenException('You do not have the permission to access or manage this resource.');
                }
                // Log successful access to own resource
                await this.logUserActivity(userClaims, endpointType, baseName, true, `Accessed resource`, resourceId, userClaims.sub);
                return true;
            }
            // If user has the super admin role, allow access
            const hasSuperAdminRole = (_b = (_a = user.employee) === null || _a === void 0 ? void 0 : _a.roles) === null || _b === void 0 ? void 0 : _b.some(role => role.name === role_enum_1.Role.SUPERADMIN);
            if (hasSuperAdminRole) {
                // Log successful access with super admin privileges
                await this.logUserActivity(userClaims, endpointType, baseName, true, `Access granted with SUPERADMIN role`, resourceId, userClaims.sub);
                return true;
            }
            // Check if the user has every required permissions for some role
            const userPermissions = [
                ...new Set(((_d = (_c = user.employee) === null || _c === void 0 ? void 0 : _c.roles) === null || _d === void 0 ? void 0 : _d.flatMap(role => role.permissions).filter(Boolean)) || [])
            ];
            const hasRequiredPermissions = requiredPermissions.every(requiredPermission => {
                return userPermissions === null || userPermissions === void 0 ? void 0 : userPermissions.some(userPermission => {
                    // Direct permission match
                    const exactMatch = userPermission &&
                        userPermission.action === requiredPermission.action &&
                        userPermission.subject === requiredPermission.subject;
                    // Check if user has MANAGE permission for the same subject
                    // MANAGE is equivalent to having all other permissions
                    const hasManagePermission = userPermission &&
                        userPermission.action === action_enum_1.Action.MANAGE &&
                        userPermission.subject === requiredPermission.subject;
                    return exactMatch || hasManagePermission;
                });
            });
            if (!hasRequiredPermissions) {
                // Log failed permission check
                await this.logUserActivity(userClaims, endpointType, baseName, false, `Missing required permissions: ${JSON.stringify(requiredPermissions.map(p => `${p.action} ${p.subject}`))}`, resourceId, userClaims.sub);
                return true;
                throw new common_1.ForbiddenException('You do not have the permissions to access or manage this resource.');
            }
            // Log successful permission check
            await this.logUserActivity(userClaims, endpointType, baseName, true, `Successfully performed action`, resourceId, userClaims.sub);
            return true;
        }
        catch (error) {
            if (error instanceof common_1.ForbiddenException) {
                throw error;
            }
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Unexpected error in permissions guard: ${errorMessage}`);
            throw new common_1.ForbiddenException('Permission check failed');
        }
    }
    /**
     * Extract resource information from the request
     */
    getResourceInfo(request) {
        var _a, _b;
        return ((_a = request.params) === null || _a === void 0 ? void 0 : _a.id) || ((_b = request.body) === null || _b === void 0 ? void 0 : _b.id);
    }
    /**
     * Log user activity with detailed information
     */
    async logUserActivity(userClaims, endpointType, subject, successful, message, resourceId, userId) {
        try {
            const userEmail = userClaims.email || 'Unknown User';
            const action = endpointType || action_enum_1.Action.READ;
            const logMessage = successful
                ? `${userEmail} ${action} ${subject}${resourceId ? ` (ID: ${resourceId})` : ''}. ${message}`
                : `${userEmail} tried to ${action} ${subject}${resourceId ? ` (ID: ${resourceId})` : ''} but was denied. ${message}`;
            await this.activityLogsService.create({
                action,
                subject,
                user: { id: userId },
                message: logMessage
            });
            this.logger.log(logMessage);
        }
        catch (error) {
            // Don't let logging errors affect the app's operation
            this.logger.error(`Failed to log user activity: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
};
exports.PermissionsGuard = PermissionsGuard;
exports.PermissionsGuard = PermissionsGuard = PermissionsGuard_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof core_1.Reflector !== "undefined" && core_1.Reflector) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof permissions_service_1.PermissionsService !== "undefined" && permissions_service_1.PermissionsService) === "function" ? _c : Object, typeof (_d = typeof activity_logs_service_1.ActivityLogsService !== "undefined" && activity_logs_service_1.ActivityLogsService) === "function" ? _d : Object])
], PermissionsGuard);


/***/ }),

/***/ "./src/common/guards/roles.guard.ts":
/*!******************************************!*\
  !*** ./src/common/guards/roles.guard.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var RolesGuard_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RolesGuard = void 0;
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const roles_decorator_1 = __webpack_require__(/*! ../decorators/roles.decorator */ "./src/common/decorators/roles.decorator.ts");
const role_enum_1 = __webpack_require__(/*! ../enums/role.enum */ "./src/common/enums/role.enum.ts");
let RolesGuard = RolesGuard_1 = class RolesGuard {
    constructor(reflector, usersService) {
        this.reflector = reflector;
        this.usersService = usersService;
        this.logger = new common_1.Logger(RolesGuard_1.name);
    }
    async canActivate(context) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        try {
            const requiredRoles = this.reflector.getAllAndOverride(roles_decorator_1.ROLES_KEY, [context.getHandler(), context.getClass()]);
            const onlyAllowRoles = this.reflector.getAllAndOverride('onlyAllowRoles', [context.getHandler(), context.getClass()]);
            // log only allow roles
            this.logger.log(`Only allow roles: ${onlyAllowRoles}`);
            const allowEmployee = this.reflector.getAllAndOverride('allowEmployee', [context.getHandler(), context.getClass()]);
            // If no roles are required, allow access
            if (!requiredRoles || requiredRoles.length === 0) {
                return true;
            }
            // Get the user payload from the request
            const request = context.switchToHttp().getRequest();
            const userClaims = request.user;
            var user = await this.usersService.findOneBy({ id: userClaims.sub }, { relations: { employee: { roles: true } } });
            if (!user) {
                this.logger.warn(`User with ID ${userClaims.sub} not found`);
                throw new common_1.ForbiddenException('User not found');
            }
            // TODO: Do not allow access to users with no role
            // log user email and user roles
            this.logger.log(`User email: ${user.email}`);
            this.logger.log(`User roles: ${((_b = (_a = user.employee) === null || _a === void 0 ? void 0 : _a.roles) === null || _b === void 0 ? void 0 : _b.map(role => role.name).join(', ')) || 'None'}`);
            // Do not allow access to users with no role
            if ((!((_c = user.employee) === null || _c === void 0 ? void 0 : _c.roles) || user.employee.roles.length === 0) && onlyAllowRoles) {
                this.logger.warn(`User with ID ${userClaims.sub} has no roles assigned`);
                throw new common_1.ForbiddenException('You do not have a role to access this resource.');
            }
            // If allowEmployee is true, check if the user has only the employee role
            if (allowEmployee && ((_e = (_d = user.employee) === null || _d === void 0 ? void 0 : _d.roles) === null || _e === void 0 ? void 0 : _e.length) === 1 && user.employee.roles[0].name === role_enum_1.Role.EMPLOYEE) {
                this.logger.warn(`User with ID ${userClaims.sub} has only the employee role`);
                throw new common_1.ForbiddenException('You do not have sufficient permissions to access this resource.');
            }
            // If user has the super admin role, allow access
            const hasSuperAdminRole = (_g = (_f = user.employee) === null || _f === void 0 ? void 0 : _f.roles) === null || _g === void 0 ? void 0 : _g.some(role => role.name === role_enum_1.Role.SUPERADMIN);
            if (hasSuperAdminRole) {
                return true;
            }
            // Check if the user has the required roles
            const hasRequiredRoles = (_j = (_h = user === null || user === void 0 ? void 0 : user.employee) === null || _h === void 0 ? void 0 : _h.roles) === null || _j === void 0 ? void 0 : _j.some(role => requiredRoles.includes(role.name));
            if (!hasRequiredRoles) {
                throw new common_1.ForbiddenException('You are not authorized to access this resource.');
            }
            return hasRequiredRoles;
        }
        catch (error) {
            if (error instanceof common_1.ForbiddenException) {
                throw error;
            }
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Unexpected error in Roles guard: ${errorMessage}`);
            throw new common_1.ForbiddenException('Role check failed');
        }
    }
};
exports.RolesGuard = RolesGuard;
exports.RolesGuard = RolesGuard = RolesGuard_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof core_1.Reflector !== "undefined" && core_1.Reflector) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], RolesGuard);


/***/ }),

/***/ "./src/common/guards/scope.guard.ts":
/*!******************************************!*\
  !*** ./src/common/guards/scope.guard.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ScopeGuard_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScopeGuard = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const role_scope_type_enum_1 = __webpack_require__(/*! ../enums/role-scope-type.enum */ "./src/common/enums/role-scope-type.enum.ts");
const utility_helper_1 = __webpack_require__(/*! ../helpers/utility.helper */ "./src/common/helpers/utility.helper.ts");
let ScopeGuard = ScopeGuard_1 = class ScopeGuard {
    constructor(reflector) {
        this.reflector = reflector;
        this.logger = new common_1.Logger(ScopeGuard_1.name);
    }
    async canActivate(context) {
        var _a, _b, _c;
        try {
            const request = context.switchToHttp().getRequest();
            const user = request.user;
            const method = request.method;
            const path = request.path;
            if (user) {
                try {
                    // this.logger.log(`Processing ${method} request to ${path}`);
                    request.resourceScope = {
                        type: role_scope_type_enum_1.RoleScopeType.OWNED,
                        userId: user === null || user === void 0 ? void 0 : user.sub // This will be undefined if no user
                    };
                    // this.logger.log(`Setting resource scope for user: ${user.sub}`);
                    try {
                        // Determine effective scope
                        const roleScope = utility_helper_1.UtilityHelper.determineEffectiveScope(user.roles || []);
                        this.logger.log(`Determined effective scope: ${roleScope.scope}`);
                        // Store scope information with correct property names
                        const resourceScope = {
                            roleName: roleScope.name,
                            type: (roleScope === null || roleScope === void 0 ? void 0 : roleScope.scope) || role_scope_type_enum_1.RoleScopeType.OWNED,
                            userId: user.sub,
                            departments: ((_a = user.roles) === null || _a === void 0 ? void 0 : _a.flatMap(role => role.departmentId).filter((id) => id !== undefined && id !== null)) || [],
                            branches: ((_b = user.roles) === null || _b === void 0 ? void 0 : _b.flatMap(role => role.branchId).filter((id) => id !== undefined && id !== null)) || [],
                            organizations: ((_c = user.roles) === null || _c === void 0 ? void 0 : _c.flatMap(role => role.organizationId).filter((id) => id !== undefined && id !== null)) || [],
                        };
                        request.resourceScope = resourceScope;
                        // log resource scope
                    }
                    catch (error) {
                        this.logger.error(`Error setting up resource scope: ${error.message}`, error.stack);
                        throw new common_1.InternalServerErrorException('Failed to process authorization scope');
                    }
                }
                catch (error) {
                    this.logger.error(`ScopeInterceptor error: ${error.message}`, error.stack);
                    throw error;
                }
            }
            // Log access attempt
            this.logger.log(`Access attempt: ${method} ${path}`);
            // Check if role is super admin
            // const hasSuperAdminRole = user.roles?.some(role => role.name === Role.SUPERADMIN);
            // if (hasSuperAdminRole) {
            //   return true;
            // }
            // Check if resourceScope exists
            const resourceScope = request.resourceScope;
            if (!resourceScope) {
                this.logger.warn(`Missing resourceScope in request`);
                throw new common_1.InternalServerErrorException('Resource scope not defined');
            }
            const body = (() => {
                // Check if request.body exists and is not empty
                if (request.body && Object.keys(request.body).length > 0) {
                    return request.body;
                }
                // Check if request.query exists and is not empty
                if (request.query && Object.keys(request.query).length > 0) {
                    return request.query;
                }
                // Fallback to request.params (even if empty)
                return request.params || {};
            })();
            // log body
            this.logger.log(`Request body: ${JSON.stringify(body)}`);
            // Log the attempt with scope information
            this.logger.log(`Checking permissions for ${method} with scope type: ${resourceScope.type}`);
            // Check creation permissions based on scope
            if (!this.canDoInScope(body, resourceScope, method)) {
                const errorMessage = this.generateErrorMessage(resourceScope.type, body);
                this.logger.warn(`Permission denied: ${errorMessage} with your scope ${resourceScope.type}`);
                throw new common_1.ForbiddenException(errorMessage);
            }
            this.logger.log('Permission check passed');
            return true;
        }
        catch (error) {
            // Handle and log any unexpected errors
            if (!(error instanceof common_1.ForbiddenException) && !(error instanceof common_1.InternalServerErrorException)) {
                this.logger.error(`Unexpected error in scope guard: ${error.message}`, error.stack);
                throw new common_1.InternalServerErrorException('An error occurred while checking permissions');
            }
            throw error;
        }
    }
    canDoInScope(data, resourceScope, method) {
        var _a, _b, _c, _d, _e, _f;
        switch (resourceScope.type) {
            case role_scope_type_enum_1.RoleScopeType.GLOBAL:
                // Global scope can create anywhere
                return true;
            case role_scope_type_enum_1.RoleScopeType.ORGANIZATION:
                // Can only create within their organizations
                if (data.organizationId) {
                    const hasAccess = (_b = (_a = resourceScope.organizations) === null || _a === void 0 ? void 0 : _a.includes(data.organizationId)) !== null && _b !== void 0 ? _b : false;
                    if (!hasAccess) {
                        this.logger.log(`Organization access denied: user tried to access org ${data.organizationId}`);
                    }
                    return hasAccess;
                }
                else if (!data.organizationId && method === 'GET') {
                    throw new common_1.ForbiddenException('You must provide an organizationId to access this resource');
                }
                return true;
            case role_scope_type_enum_1.RoleScopeType.BRANCH:
                // Can only create within their branches
                if (data.branchId) {
                    const hasAccess = (_d = (_c = resourceScope.branches) === null || _c === void 0 ? void 0 : _c.includes(data.branchId)) !== null && _d !== void 0 ? _d : false;
                    if (!hasAccess) {
                        this.logger.log(`Branch access denied: user tried to access branch ${data.branchId}`);
                    }
                    return hasAccess;
                }
                else if (!data.branchId && method === 'GET') {
                    throw new common_1.ForbiddenException('You must provide a branchId to access this resource');
                }
                return true;
            case role_scope_type_enum_1.RoleScopeType.DEPARTMENT:
                // Can only create within their departments
                if (data.departmentId) {
                    const hasAccess = (_f = (_e = resourceScope.departments) === null || _e === void 0 ? void 0 : _e.includes(data.departmentId)) !== null && _f !== void 0 ? _f : false;
                    if (!hasAccess) {
                        this.logger.log(`Department access denied: user tried to access dept ${data.departmentId}`);
                    }
                    else if (!data.departmentId && method === 'GET') {
                        throw new common_1.ForbiddenException('You must provide a departmentId to access this resource');
                    }
                    return hasAccess;
                }
                return true;
            case role_scope_type_enum_1.RoleScopeType.OWNED:
                // Usually can't create resources for others
                if (data.userId) {
                    const hasAccess = resourceScope.userId === data.userId;
                    if (!hasAccess) {
                        this.logger.log(`User resource access denied: user tried to access another user's resource`);
                    }
                    return hasAccess;
                }
                else if (method === 'GET' && !data.userId) {
                    throw new common_1.ForbiddenException('You must provide a userId to access this resource');
                }
                // If no userId is provided, allow creation
                return true;
            default:
                this.logger.warn(`Unknown scope type encountered: ${resourceScope.type}`);
                return false;
        }
    }
    generateErrorMessage(scopeType, data) {
        switch (scopeType) {
            case role_scope_type_enum_1.RoleScopeType.ORGANIZATION:
                return data.organizationId
                    ? `You don't have access to manage resources in organization ${data.organizationId}`
                    : `You don't have permission to access or manage organization resources`;
            case role_scope_type_enum_1.RoleScopeType.BRANCH:
                return data.branchId
                    ? `You don't have access to manage resources in branch ${data.branchId}`
                    : `You don't have permission to access or manage branch resources`;
            case role_scope_type_enum_1.RoleScopeType.DEPARTMENT:
                return data.departmentId
                    ? `You don't have access to manage resources in department ${data.departmentId}`
                    : `You don't have access to manage department resources`;
            case role_scope_type_enum_1.RoleScopeType.OWNED:
                return data.userId
                    ? `You don't have access to manage resources for user ${data.userId}`
                    : `You don't have access to manage user resources`;
            default:
                return `You don't have access to manage this resource`;
        }
    }
};
exports.ScopeGuard = ScopeGuard;
exports.ScopeGuard = ScopeGuard = ScopeGuard_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof core_1.Reflector !== "undefined" && core_1.Reflector) === "function" ? _a : Object])
], ScopeGuard);


/***/ }),

/***/ "./src/common/helpers/utility.helper.ts":
/*!**********************************************!*\
  !*** ./src/common/helpers/utility.helper.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UtilityHelper = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const role_scope_type_enum_1 = __webpack_require__(/*! ../enums/role-scope-type.enum */ "./src/common/enums/role-scope-type.enum.ts");
class UtilityHelper {
    static isEmpty(value) {
        return value === null || value === undefined || value === '';
    }
    static isEmailValid(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
    static generateRandomString(length) {
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * characters.length));
        }
        return result;
    }
    static hashPassword(password) {
        // Implement password hashing logic here (e.g., using bcrypt)
        return password; // Placeholder, replace with actual hashing
    }
    static comparePasswords(plainPassword, hashedPassword) {
        // Implement password comparison logic here (e.g., using bcrypt)
        return plainPassword === hashedPassword; // Placeholder, replace with actual comparison
    }
    static formatCriteria(criteria) {
        return Object.entries(criteria)
            .map(([key, value]) => `${key}: ${value}`)
            .join(', ');
    }
    static determineEffectiveScope(roles) {
        if (!roles.length) {
            return { scope: role_scope_type_enum_1.RoleScopeType.OWNED, name: 'Staff' };
        }
        let effectiveScopeType = role_scope_type_enum_1.RoleScopeType.OWNED;
        let effectiveRoleName = 'Staff';
        for (const role of roles) {
            const roleScope = role.scope || role_scope_type_enum_1.RoleScopeType.OWNED;
            if (roleScope === role_scope_type_enum_1.RoleScopeType.GLOBAL) {
                return role;
            }
            if (this.isBroaderScope(roleScope, effectiveScopeType)) {
                effectiveScopeType = roleScope;
                effectiveRoleName = role.name || 'Staff';
            }
        }
        return { scope: effectiveScopeType, name: effectiveRoleName };
    }
    static isBroaderScope(scopeA, scopeB) {
        const scopePriority = {
            [role_scope_type_enum_1.RoleScopeType.GLOBAL]: 4,
            [role_scope_type_enum_1.RoleScopeType.ORGANIZATION]: 3,
            [role_scope_type_enum_1.RoleScopeType.BRANCH]: 2,
            [role_scope_type_enum_1.RoleScopeType.DEPARTMENT]: 1,
            [role_scope_type_enum_1.RoleScopeType.OWNED]: 0
        };
        return scopePriority[scopeA] > scopePriority[scopeB];
    }
    /**
     * Ensures a value is a Date object
     */
    static ensureDate(date) {
        if (date instanceof Date) {
            return date;
        }
        return new Date(date);
    }
    /**
     * Calculate business days between two dates
     */
    static getBusinessDays(start, end) {
        const startDate = this.ensureDate(start);
        const endDate = this.ensureDate(end);
        let count = 0;
        const currentDate = new Date(startDate.getTime());
        // Iterate from start to end date
        while (currentDate <= endDate) {
            const dayOfWeek = currentDate.getDay();
            // Count if it's not a weekend (0 = Sunday, 6 = Saturday)
            if (dayOfWeek !== 0 && dayOfWeek !== 6) {
                count++;
            }
            // Move to the next day
            currentDate.setDate(currentDate.getDate() + 1);
        }
        return count;
    }
    /**
     * Validates tenant access for file operations and returns the effective tenant directory
     * @param scope The user's resource scope
     * @param tenantContext The requested tenant context from DTO
     * @returns The validated tenant directory path
     */
    static validateAndGetTenantDirectory(scope, // ResourceScope type
    tenantContext) {
        const { type, organizations, branches, departments, userId } = scope;
        switch (type) {
            case role_scope_type_enum_1.RoleScopeType.GLOBAL:
                // Global scope can access any directory structure
                if (tenantContext.userId) {
                    return `users/${tenantContext.userId}`;
                }
                if (tenantContext.organizationId) {
                    let path = `organizations/${tenantContext.organizationId}`;
                    if (tenantContext.branchId) {
                        path += `/branches/${tenantContext.branchId}`;
                        if (tenantContext.departmentId) {
                            path += `/departments/${tenantContext.departmentId}`;
                        }
                    }
                    return path;
                }
                return '';
            case role_scope_type_enum_1.RoleScopeType.ORGANIZATION:
                // Must provide organizationId and it must be in their allowed organizations
                if (!tenantContext.organizationId) {
                    throw new common_1.ForbiddenException('Organization scope requires organizationId');
                }
                if (!(organizations === null || organizations === void 0 ? void 0 : organizations.includes(tenantContext.organizationId))) {
                    throw new common_1.ForbiddenException(`You don't have access to organization: ${tenantContext.organizationId}`);
                }
                let orgPath = `organizations/${tenantContext.organizationId}`;
                if (tenantContext.branchId) {
                    orgPath += `/branches/${tenantContext.branchId}`;
                    if (tenantContext.departmentId) {
                        orgPath += `/departments/${tenantContext.departmentId}`;
                    }
                }
                return orgPath;
            case role_scope_type_enum_1.RoleScopeType.BRANCH:
                // Must provide branchId and it must be in their allowed branches
                if (!tenantContext.branchId) {
                    throw new common_1.ForbiddenException('You must provide branchId to upload files');
                }
                // Check if user has access to the branch resource
                if (!(branches === null || branches === void 0 ? void 0 : branches.includes(tenantContext.branchId))) {
                    throw new common_1.ForbiddenException(`You don't have access to branch: ${tenantContext.branchId}`);
                }
                // For branch scope, we need to validate organization-branch relationship
                let userOrgId;
                // Check if user provided organization Id
                if (tenantContext.organizationId) {
                    // If organizationId is provided, validate that the branch belongs to this organization
                    userOrgId = tenantContext.organizationId;
                    // Check if the user has access to this organization
                    if (!(organizations === null || organizations === void 0 ? void 0 : organizations.includes(userOrgId))) {
                        throw new common_1.ForbiddenException(`You don't have access to organization: ${userOrgId}`);
                    }
                    // Find the index of the branch to get corresponding organization
                    const branchIndex = branches === null || branches === void 0 ? void 0 : branches.indexOf(tenantContext.branchId);
                    const correspondingOrgId = organizations === null || organizations === void 0 ? void 0 : organizations[branchIndex];
                    if (correspondingOrgId !== userOrgId) {
                        throw new common_1.ForbiddenException(`Branch ${tenantContext.branchId} does not belong to organization ${userOrgId}`);
                    }
                }
                else {
                    // If no organizationId provided, derive it from branch scope
                    const branchIndex = branches === null || branches === void 0 ? void 0 : branches.indexOf(tenantContext.branchId);
                    userOrgId = organizations === null || organizations === void 0 ? void 0 : organizations[branchIndex];
                    if (!userOrgId) {
                        throw new common_1.ForbiddenException('Cannot determine organization context for the specified branch');
                    }
                }
                let branchPath = `organizations/${userOrgId}/branches/${tenantContext.branchId}`;
                // If user provided departmentId, validate it
                if (tenantContext.departmentId) {
                    // Validate that the department exists and belongs to the user's accessible branch
                    if (!(departments === null || departments === void 0 ? void 0 : departments.includes(tenantContext.departmentId))) {
                        throw new common_1.ForbiddenException(`You don't have access to department: ${tenantContext.departmentId}`);
                    }
                    // Additional validation: ensure department belongs to the specified branch
                    // This assumes departments array corresponds to branches array by index
                    const departmentBranchIndex = departments.indexOf(tenantContext.departmentId);
                    const associatedBranchId = branches === null || branches === void 0 ? void 0 : branches[departmentBranchIndex];
                    if (associatedBranchId !== tenantContext.branchId) {
                        throw new common_1.ForbiddenException(`Department ${tenantContext.departmentId} does not belong to branch ${tenantContext.branchId}`);
                    }
                    branchPath += `/departments/${tenantContext.departmentId}`;
                }
                return branchPath;
            case role_scope_type_enum_1.RoleScopeType.DEPARTMENT:
                // Must provide departmentId and it must be in their allowed departments
                if (!tenantContext.departmentId) {
                    throw new common_1.ForbiddenException('You must provide departmentId to upload files');
                }
                if (!(departments === null || departments === void 0 ? void 0 : departments.includes(tenantContext.departmentId))) {
                    throw new common_1.ForbiddenException(`You don't have access to department: ${tenantContext.departmentId}`);
                }
                // For department scope, we need to validate organization-branch-department relationship
                let departmentOrgId;
                let departmentBranchId;
                // Check if user provided organizationId
                if (tenantContext.organizationId) {
                    // If organizationId is provided, validate that the department belongs to this organization
                    departmentOrgId = tenantContext.organizationId;
                    // Check if the user has access to this organization
                    if (!(organizations === null || organizations === void 0 ? void 0 : organizations.includes(departmentOrgId))) {
                        throw new common_1.ForbiddenException(`You don't have access to organization: ${departmentOrgId}`);
                    }
                    // Find the index of the department to get corresponding branch
                    const departmentIndex = departments === null || departments === void 0 ? void 0 : departments.indexOf(tenantContext.departmentId);
                    departmentBranchId = branches === null || branches === void 0 ? void 0 : branches[departmentIndex];
                    if (!departmentBranchId) {
                        throw new common_1.ForbiddenException(`Department ${tenantContext.departmentId} does not belong to organization ${departmentOrgId}`);
                    }
                }
                else {
                    // If no organizationId provided, derive it from department scope
                    const departmentIndex = departments === null || departments === void 0 ? void 0 : departments.indexOf(tenantContext.departmentId);
                    departmentOrgId = organizations === null || organizations === void 0 ? void 0 : organizations[departmentIndex];
                    departmentBranchId = branches === null || branches === void 0 ? void 0 : branches[departmentIndex];
                    if (!departmentOrgId || !departmentBranchId) {
                        throw new common_1.ForbiddenException('Cannot determine organization or branch context for the specified department');
                    }
                }
                // Check if user provided branchId
                if (tenantContext.branchId) {
                    // Validate that the branchId matches the department's branch
                    if (tenantContext.branchId !== departmentBranchId) {
                        throw new common_1.ForbiddenException(`Department ${tenantContext.departmentId} does not belong to branch ${tenantContext.branchId}`);
                    }
                    // Validate that the branchId belongs to the user's accessible organization
                    if (!(branches === null || branches === void 0 ? void 0 : branches.includes(tenantContext.branchId))) {
                        throw new common_1.ForbiddenException(`You don't have access to branch: ${tenantContext.branchId}`);
                    }
                }
                else {
                    // If no branchId provided, dervice it from department scope
                    const departmentIndex = departments === null || departments === void 0 ? void 0 : departments.indexOf(tenantContext.departmentId);
                    departmentBranchId = branches === null || branches === void 0 ? void 0 : branches[departmentIndex];
                    if (!departmentBranchId) {
                        throw new common_1.ForbiddenException(`Cannot determine branch context for the specified department ${tenantContext.departmentId}`);
                    }
                }
                // Construct the department path
                return `organizations/${departmentOrgId}/branches/${departmentBranchId}/departments/${tenantContext.departmentId}`;
            case role_scope_type_enum_1.RoleScopeType.OWNED:
                // Can only upload to their own user directory
                if (tenantContext.userId && tenantContext.userId !== userId) {
                    throw new common_1.ForbiddenException('You can only upload files to your own directory');
                }
                return `users/${userId}`;
            default:
                throw new common_1.ForbiddenException('Invalid scope type');
        }
    }
    /**
     * Validates that a file path is within the allowed tenant directory
     * @param filePath The file path to validate
     * @param allowedTenantPath The allowed tenant directory path
     * @returns boolean indicating if the path is valid
     */
    static validateFilePath(filePath, allowedTenantPath) {
        // Normalize paths to prevent directory traversal attacks
        const normalizedFilePath = path_1.default.normalize(filePath).replace(/^(\.\.[\/\\])+/, '');
        const normalizedTenantPath = path_1.default.normalize(allowedTenantPath);
        // Check if the file path starts with the allowed tenant path
        return normalizedFilePath.startsWith(normalizedTenantPath);
    }
    /**
     * Check if a resource has access based on its scope configuration
     * @param resource The resource to check access for
     * @param resourceScope The scope configuration containing access rules
     * @returns boolean indicating if access is granted
     */
    static checkScopeAccess(resource, resourceScope) {
        var _a, _b, _c;
        const { type, organizations, branches, departments, userId } = resourceScope;
        let hasAccess = false;
        switch (type) {
            case role_scope_type_enum_1.RoleScopeType.GLOBAL:
                return true;
            case role_scope_type_enum_1.RoleScopeType.ORGANIZATION:
                if (!resource.organizationId) {
                    console.warn('Resource missing organizationId for ORGANIZATION scope check');
                    return true;
                }
                hasAccess = (_a = organizations === null || organizations === void 0 ? void 0 : organizations.includes(resource.organizationId)) !== null && _a !== void 0 ? _a : false;
                if (!hasAccess) {
                    throw new common_1.ForbiddenException(`You do not have access or manage this resource in organization: ${resource.organizationId}`);
                }
                return hasAccess;
            case role_scope_type_enum_1.RoleScopeType.BRANCH:
                if (!resource.branchId) {
                    console.warn('Resource missing branchId for BRANCH scope check');
                    return true;
                }
                hasAccess = (_b = branches === null || branches === void 0 ? void 0 : branches.includes(resource.branchId)) !== null && _b !== void 0 ? _b : false;
                if (!hasAccess) {
                    throw new common_1.ForbiddenException(`You do not have access or manage this resource in branch: ${resource.branchId}`);
                }
                return hasAccess;
            case role_scope_type_enum_1.RoleScopeType.DEPARTMENT:
                if (!resource.departmentId) {
                    console.warn('Resource missing departmentId for DEPARTMENT scope check');
                    return true;
                }
                hasAccess = (_c = departments === null || departments === void 0 ? void 0 : departments.includes(resource.departmentId)) !== null && _c !== void 0 ? _c : false;
                if (!hasAccess) {
                    throw new common_1.ForbiddenException(`You do not have access or manage this resource in department: ${resource.departmentId}`);
                }
                return hasAccess;
            case role_scope_type_enum_1.RoleScopeType.OWNED:
                if (!resource.userId) {
                    console.warn('Resource missing userId for OWNED scope check');
                    return true;
                }
                hasAccess = userId === resource.userId;
                if (!hasAccess) {
                    throw new common_1.ForbiddenException(`You do not have access or manage this resource owned by user: ${resource.userId}`);
                }
                return hasAccess;
            default:
                return false;
        }
    }
    /**
     * Get business days in a month of a given date
     */
    static getBusinessDaysInMonth(date) {
        const inputDate = this.ensureDate(date);
        // Create first and last day of the month
        const firstDay = new Date(inputDate.getFullYear(), inputDate.getMonth(), 1);
        const lastDay = new Date(inputDate.getFullYear(), inputDate.getMonth() + 1, 0);
        // Calculate business days between these dates
        return this.getBusinessDays(firstDay, lastDay);
    }
    // Helper method to parse relations string into TypeORM relations object
    static parseRelations(relations) {
        const relationsObj = {};
        relations.split(',').forEach(relation => {
            relation = relation.trim();
            if (!relation)
                return;
            if (relation.includes('.')) {
                // Handle nested relation (e.g., "comments.author")
                const parts = relation.split('.');
                let currentLevel = relationsObj;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (i === parts.length - 1) {
                        // Last part in the chain
                        currentLevel[part] = true;
                    }
                    else {
                        // Create nested object if it doesn't exist
                        if (!currentLevel[part] || currentLevel[part] === true) {
                            currentLevel[part] = {};
                        }
                        // Move to next level in the object
                        currentLevel = currentLevel[part];
                    }
                }
            }
            else {
                // Handle simple relation
                relationsObj[relation] = true;
            }
        });
        return relationsObj;
    }
    // Helper method to parse select string into TypeORM select object
    static parseSelect(select) {
        const selectObj = {};
        select.split(',').forEach(field => {
            field = field.trim();
            if (!field)
                return;
            if (field.includes('.')) {
                // Handle nested selection (e.g., "profile.avatar")
                const parts = field.split('.');
                let currentLevel = selectObj;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (i === parts.length - 1) {
                        // Last part in the chain
                        currentLevel[part] = true;
                    }
                    else {
                        // Create nested object if it doesn't exist
                        if (!currentLevel[part] || typeof currentLevel[part] === 'boolean') {
                            currentLevel[part] = {};
                        }
                        // Move to next level in the object
                        currentLevel = currentLevel[part];
                    }
                }
            }
            else {
                // Handle simple field
                selectObj[field] = true;
            }
        });
        return selectObj;
    }
    // Helper method to check if a string is a valid email
    static isEmail(email) {
        if (!email)
            return false;
        // Regular expression for email validation
        const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
        return emailRegex.test(email);
    }
}
exports.UtilityHelper = UtilityHelper;


/***/ }),

/***/ "./src/common/interceptors/resource-access.interceptor.ts":
/*!****************************************************************!*\
  !*** ./src/common/interceptors/resource-access.interceptor.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResourceAccessInterceptor = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const operators_1 = __webpack_require__(/*! rxjs/operators */ "rxjs/operators");
const utility_helper_1 = __webpack_require__(/*! ../helpers/utility.helper */ "./src/common/helpers/utility.helper.ts");
let ResourceAccessInterceptor = class ResourceAccessInterceptor {
    intercept(context, next) {
        return next.handle().pipe((0, operators_1.map)(data => {
            const request = context.switchToHttp().getRequest();
            const resourceScope = request.resourceScope;
            // Check access on the returned resource
            if (data && resourceScope) {
                const hasAccess = utility_helper_1.UtilityHelper.checkScopeAccess(data, resourceScope);
                if (!hasAccess) {
                    throw new common_1.ForbiddenException(`You do not have access to this resource`);
                }
            }
            return data;
        }));
    }
};
exports.ResourceAccessInterceptor = ResourceAccessInterceptor;
exports.ResourceAccessInterceptor = ResourceAccessInterceptor = __decorate([
    (0, common_1.Injectable)()
], ResourceAccessInterceptor);


/***/ }),

/***/ "./src/common/interceptors/transform.interceptor.ts":
/*!**********************************************************!*\
  !*** ./src/common/interceptors/transform.interceptor.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransformInterceptor = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const operators_1 = __webpack_require__(/*! rxjs/operators */ "rxjs/operators");
/**
 * A NestJS interceptor that transforms the response data.
 *
 * This interceptor converts class instances in the response to plain JavaScript objects
 * using the `instanceToPlain` function from class-transformer.
 * It's particularly useful when working with class-transformer decorated entities
 * to ensure proper serialization of response data.
 *
 * @implements {NestInterceptor}
 *
 * @example
 * ```typescript
 * @UseInterceptors(TransformInterceptor)
 * @Get()
 * findAll() {
 *   return this.service.findAll();
 * }
 * ```
 */
let TransformInterceptor = class TransformInterceptor {
    intercept(context, next) {
        return next.handle().pipe((0, operators_1.map)((data) => (0, class_transformer_1.instanceToPlain)(data)));
    }
};
exports.TransformInterceptor = TransformInterceptor;
exports.TransformInterceptor = TransformInterceptor = __decorate([
    (0, common_1.Injectable)()
], TransformInterceptor);


/***/ }),

/***/ "./src/common/interfaces/jwt-payload.interface.ts":
/*!********************************************************!*\
  !*** ./src/common/interfaces/jwt-payload.interface.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/common/listeners/employee-group-assignement.listener.ts":
/*!*********************************************************************!*\
  !*** ./src/common/listeners/employee-group-assignement.listener.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var EmployeeGroupAssignmentListener_1;
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeeGroupAssignmentListener = void 0;
const cutoffs_service_1 = __webpack_require__(/*! @/modules/payroll-management/cutoffs/cutoffs.service */ "./src/modules/payroll-management/cutoffs/cutoffs.service.ts");
const schedules_service_1 = __webpack_require__(/*! @/modules/shift-management/schedules/schedules.service */ "./src/modules/shift-management/schedules/schedules.service.ts");
const schedule_generation_service_1 = __webpack_require__(/*! @/modules/shift-management/schedules/services/schedule-generation.service */ "./src/modules/shift-management/schedules/services/schedule-generation.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const employee_assigned_event_1 = __webpack_require__(/*! ../events/employee-assigned.event */ "./src/common/events/employee-assigned.event.ts");
let EmployeeGroupAssignmentListener = EmployeeGroupAssignmentListener_1 = class EmployeeGroupAssignmentListener {
    constructor(cutoffsService, scheduleGenerationService, scheduleService) {
        this.cutoffsService = cutoffsService;
        this.scheduleGenerationService = scheduleGenerationService;
        this.scheduleService = scheduleService;
        this.logger = new common_1.Logger(EmployeeGroupAssignmentListener_1.name);
    }
    async handleEmployeeAssignedToGroup(event) {
        this.logger.log(`Handling employee assignment event for ${event.employees.length} employees to group ${event.group.id}`);
        // Find all future active cutoffs instead of just one
        const cutoffs = await this.cutoffsService.getActiveCutoffs();
        if (!cutoffs || cutoffs.length === 0) {
            this.logger.warn('No pending/active cutoff found, skipping schedule generation');
            return;
        }
        if (!event.group.shift) {
            this.logger.warn(`Group ${event.group.id} has no shift assigned, skipping schedule generation`);
            return;
        }
        // Get employee IDs
        const employeeIds = event.employees.map((employee) => employee.id);
        for (const cutoff of cutoffs) {
            // Check if the cutoff is in the future
            if (cutoff.startDate && cutoff.endDate) {
                const cutoffStartDate = new Date(cutoff.startDate);
                const cutoffEndDate = new Date(cutoff.endDate);
                const today = new Date();
                if (cutoffStartDate < today && cutoffEndDate > today) {
                    this.logger.warn(`Cutoff ${cutoff.id} is not in the future, skipping schedule generation`);
                    continue;
                }
            }
            this.logger.log(`Schedule generation job queued for cutoff ${cutoff.id} (${new Date(cutoff.startDate).toLocaleDateString()})`);
            // Queue schedule generation jobs for each cutoff
            await this.scheduleGenerationService.addGenerationJob({
                employeeIds,
                groupId: event.group.id,
                cutoffId: cutoff.id,
                requestedBy: event.assignedBy,
            });
        }
    }
    async handleEmployeeRemovedFromGroup(event) {
        // Find all future active cutoffs instead of just one
        const cutoffs = await this.cutoffsService.getActiveCutoffs();
        if (!cutoffs || cutoffs.length === 0) {
            this.logger.warn('No pending/active cutoff found, skipping schedule generation');
            return;
        }
        // Get employee IDs
        const employeeIds = event.employees.map((employee) => employee.id);
        for (const cutoff of cutoffs) {
            // Check if the cutoff is in the future
            if (cutoff.startDate && cutoff.endDate) {
                const cutoffStartDate = new Date(cutoff.startDate);
                const cutoffEndDate = new Date(cutoff.endDate);
                const today = new Date();
                if (cutoffStartDate < today && cutoffEndDate > today) {
                    this.logger.warn(`Cutoff ${cutoff.id} is not in the future, skipping schedule deletion`);
                    continue;
                }
            }
            // Delete schedules for each cutoff and removed employee
            await this.scheduleService.deleteSchedules({
                employeeIds,
                groupId: event.group.id,
                cutoffId: cutoff.id,
            });
            this.logger.log(`Schedules deleted for cutoff ${cutoff.id} (${new Date(cutoff.startDate).toLocaleDateString()}) for ${employeeIds.length} employees`);
        }
    }
};
exports.EmployeeGroupAssignmentListener = EmployeeGroupAssignmentListener;
__decorate([
    (0, event_emitter_1.OnEvent)(employee_assigned_event_1.GROUP_EVENTS.EMPLOYEE_ASSIGNED),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof employee_assigned_event_1.EmployeeAssignedEvent !== "undefined" && employee_assigned_event_1.EmployeeAssignedEvent) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], EmployeeGroupAssignmentListener.prototype, "handleEmployeeAssignedToGroup", null);
__decorate([
    (0, event_emitter_1.OnEvent)(employee_assigned_event_1.GROUP_EVENTS.EMPLOYEE_REMOVED),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_f = typeof employee_assigned_event_1.EmployeeAssignedEvent !== "undefined" && employee_assigned_event_1.EmployeeAssignedEvent) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], EmployeeGroupAssignmentListener.prototype, "handleEmployeeRemovedFromGroup", null);
exports.EmployeeGroupAssignmentListener = EmployeeGroupAssignmentListener = EmployeeGroupAssignmentListener_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof cutoffs_service_1.CutoffsService !== "undefined" && cutoffs_service_1.CutoffsService) === "function" ? _a : Object, typeof (_b = typeof schedule_generation_service_1.ScheduleGenerationService !== "undefined" && schedule_generation_service_1.ScheduleGenerationService) === "function" ? _b : Object, typeof (_c = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _c : Object])
], EmployeeGroupAssignmentListener);


/***/ }),

/***/ "./src/common/services/base.service.ts":
/*!*********************************************!*\
  !*** ./src/common/services/base.service.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseService = void 0;
const data_source_1 = __importDefault(__webpack_require__(/*! @/database/data-source */ "./src/database/data-source.ts"));
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const generalresponse_dto_1 = __webpack_require__(/*! ../dtos/generalresponse.dto */ "./src/common/dtos/generalresponse.dto.ts");
const pagination_dto_1 = __webpack_require__(/*! ../dtos/pagination.dto */ "./src/common/dtos/pagination.dto.ts");
const utility_helper_1 = __webpack_require__(/*! ../helpers/utility.helper */ "./src/common/helpers/utility.helper.ts");
const transaction_service_1 = __webpack_require__(/*! ./transaction.service */ "./src/common/services/transaction.service.ts");
let BaseService = class BaseService {
    constructor(repository, usersService) {
        this.repository = repository;
        this.usersService = usersService;
        this.logger = new common_1.Logger(this.constructor.name);
        this.transactionService = new transaction_service_1.TransactionService(data_source_1.default);
        this.entityName = this.repository.target instanceof Function ? this.repository.target.name : 'Entity';
        this.entityType = this.repository.target instanceof Function ? this.repository.target : Object;
        // State for query building
        this.queryState = {
            includes: new Map(),
            whereConditions: [],
            parameters: {},
            orderByClauses: [],
            skipValue: 0,
            takeValue: 0,
            isTracking: true,
            queryBuilder: null,
            parentPath: '',
            paramCounter: 0
        };
    }
    getRepository() {
        return this.repository;
    }
    async findAllComplex(scope, paginationDto) {
        try {
            const findOptions = paginationDto.toFindManyOptions(scope);
            const alias = this.entityName.toLowerCase();
            // Debug the incoming filter
            // console.log('Raw filter from client:', JSON.stringify(paginationDto.filter));
            // console.log('Converted findOptions where:', JSON.stringify(findOptions.where));
            // this.logger.debug(`Processing query with filters: ${JSON.stringify(findOptions.where)}`);
            // For complex filtering that requires JOIN operations or nested relations
            if (Object.keys(findOptions.where || {}).length > 0 ||
                (findOptions.relations && Object.keys(findOptions.relations).length > 0)) {
                // Use QueryBuilder for more complex queries
                const queryBuilder = this.repository.createQueryBuilder(alias);
                // Add soft delete condition - using proper parameter binding
                queryBuilder.where(`${alias}.deletedAt IS NULL`);
                // Track joined relations to avoid duplicates
                const joinedRelations = new Set();
                // Apply where conditions from findOptions
                if (findOptions.where) {
                    // Initialize arrays/objects for OR conditions
                    const orClauses = [];
                    const orParams = {};
                    // Check if OR condition exists first to avoid TypeScript errors
                    if (findOptions.where['OR'] && Array.isArray(findOptions.where['OR'])) {
                        try {
                            // Process each condition in the OR array
                            findOptions.where['OR'].forEach((condition, index) => {
                                // Create condition clauses for this OR branch
                                const conditionClauses = [];
                                const conditionParams = {};
                                // Process each field in this condition
                                Object.entries(condition).forEach(([key, value]) => {
                                    // Handle nested properties (relations.field)
                                    if (key.includes('.')) {
                                        const parts = key.split('.');
                                        const field = parts.pop();
                                        // Join each relation path to the main query builder
                                        let currentAlias = alias;
                                        let fullPath = '';
                                        // Process each part of the path for joins
                                        for (let i = 0; i < parts.length; i++) {
                                            const relationName = parts[i];
                                            const prevPath = fullPath;
                                            // Build the cumulative path
                                            fullPath = prevPath ? `${prevPath}.${relationName}` : relationName;
                                            const joinAlias = `${fullPath.replace(/\./g, '_')}_or_${index}_filter_${this.queryState.paramCounter++}`;
                                            const joinPath = `${currentAlias}.${relationName}`;
                                            // Only join if not already joined
                                            if (!joinedRelations.has(joinAlias)) {
                                                queryBuilder.leftJoin(joinPath, joinAlias);
                                                joinedRelations.add(joinAlias);
                                                this.logger.debug(`Joined relation for OR filter: ${joinPath} as ${joinAlias}`);
                                            }
                                            // Update the current alias for next iteration
                                            currentAlias = joinAlias;
                                        }
                                        // Apply the condition to the innermost relation
                                        if (typeof value === 'object' && value !== null && !(value instanceof Date)) {
                                            // Handle operators like ilike, gt, lt, etc.
                                            const paramBaseName = `${currentAlias}_${field}_or_${index}`;
                                            if ('ilike' in value) {
                                                const paramName = `${paramBaseName}_ilike_${this.queryState.paramCounter++}`;
                                                conditionClauses.push(`LOWER(${currentAlias}.${field}) LIKE LOWER(:${paramName})`);
                                                conditionParams[paramName] = `%${value.ilike}%`;
                                            }
                                            else if ('like' in value) {
                                                const paramName = `${paramBaseName}_like_${this.queryState.paramCounter++}`;
                                                conditionClauses.push(`${currentAlias}.${field} LIKE :${paramName}`);
                                                conditionParams[paramName] = `%${value.like}%`;
                                            }
                                            else {
                                                // Fall back to custom operator handling
                                                Object.entries(value).forEach(([op, opValue]) => {
                                                    const paramName = `${paramBaseName}_${op}_${this.queryState.paramCounter++}`;
                                                    switch (op) {
                                                        case 'eq':
                                                            conditionClauses.push(`${currentAlias}.${field} = :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'ne':
                                                            conditionClauses.push(`${currentAlias}.${field} != :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'gt':
                                                            conditionClauses.push(`${currentAlias}.${field} > :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'gte':
                                                            conditionClauses.push(`${currentAlias}.${field} >= :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'lt':
                                                            conditionClauses.push(`${currentAlias}.${field} < :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'lte':
                                                            conditionClauses.push(`${currentAlias}.${field} <= :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'in':
                                                            if (Array.isArray(opValue)) {
                                                                conditionClauses.push(`${currentAlias}.${field} IN (:...${paramName})`);
                                                                conditionParams[paramName] = opValue;
                                                            }
                                                            break;
                                                        case 'between':
                                                            if (Array.isArray(opValue) && opValue.length === 2) {
                                                                const minParam = `${paramName}_min`;
                                                                const maxParam = `${paramName}_max`;
                                                                conditionClauses.push(`${currentAlias}.${field} BETWEEN :${minParam} AND :${maxParam}`);
                                                                conditionParams[minParam] = opValue[0];
                                                                conditionParams[maxParam] = opValue[1];
                                                            }
                                                            break;
                                                        case 'isNull':
                                                            if (opValue === true) {
                                                                conditionClauses.push(`${currentAlias}.${field} IS NULL`);
                                                            }
                                                            else {
                                                                conditionClauses.push(`${currentAlias}.${field} IS NOT NULL`);
                                                            }
                                                            break;
                                                    }
                                                });
                                            }
                                        }
                                        else {
                                            // Simple equality for non-object values
                                            const paramName = `${currentAlias}_${field}_or_${index}_${this.queryState.paramCounter++}`;
                                            conditionClauses.push(`${currentAlias}.${field} = :${paramName}`);
                                            conditionParams[paramName] = value;
                                        }
                                    }
                                    else {
                                        // Handle direct properties (non-relational)
                                        if (typeof value === 'object' && value !== null && !(value instanceof Date)) {
                                            // Handle operators like ilike, gt, lt, etc.
                                            const paramBaseName = `${alias}_${key}_or_${index}`;
                                            if ('ilike' in value) {
                                                const paramName = `${paramBaseName}_ilike_${this.queryState.paramCounter++}`;
                                                conditionClauses.push(`LOWER(${alias}.${key}) LIKE LOWER(:${paramName})`);
                                                conditionParams[paramName] = `%${value.ilike}%`;
                                            }
                                            else if ('like' in value) {
                                                const paramName = `${paramBaseName}_like_${this.queryState.paramCounter++}`;
                                                conditionClauses.push(`${alias}.${key} LIKE :${paramName}`);
                                                conditionParams[paramName] = `%${value.like}%`;
                                            }
                                            else {
                                                // Fall back to other operators
                                                Object.entries(value).forEach(([op, opValue]) => {
                                                    const paramName = `${paramBaseName}_${op}_${this.queryState.paramCounter++}`;
                                                    switch (op) {
                                                        case 'eq':
                                                            conditionClauses.push(`${alias}.${key} = :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'ne':
                                                            conditionClauses.push(`${alias}.${key} != :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'gt':
                                                            conditionClauses.push(`${alias}.${key} > :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'gte':
                                                            conditionClauses.push(`${alias}.${key} >= :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'lt':
                                                            conditionClauses.push(`${alias}.${key} < :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'lte':
                                                            conditionClauses.push(`${alias}.${key} <= :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'in':
                                                            if (Array.isArray(opValue)) {
                                                                conditionClauses.push(`${alias}.${key} IN (:...${paramName})`);
                                                                conditionParams[paramName] = opValue;
                                                            }
                                                            break;
                                                        case 'between':
                                                            if (Array.isArray(opValue) && opValue.length === 2) {
                                                                const minParam = `${paramName}_min`;
                                                                const maxParam = `${paramName}_max`;
                                                                conditionClauses.push(`${alias}.${key} BETWEEN :${minParam} AND :${maxParam}`);
                                                                conditionParams[minParam] = opValue[0];
                                                                conditionParams[maxParam] = opValue[1];
                                                            }
                                                            break;
                                                        case 'isNull':
                                                            if (opValue === true) {
                                                                conditionClauses.push(`${alias}.${key} IS NULL`);
                                                            }
                                                            else {
                                                                conditionClauses.push(`${alias}.${key} IS NOT NULL`);
                                                            }
                                                            break;
                                                    }
                                                });
                                            }
                                        }
                                        else {
                                            // Simple equality for non-object values
                                            const paramName = `${alias}_${key}_or_${index}_${this.queryState.paramCounter++}`;
                                            conditionClauses.push(`${alias}.${key} = :${paramName}`);
                                            conditionParams[paramName] = value;
                                        }
                                    }
                                });
                                // Add this branch to the OR clauses if any conditions were added
                                if (conditionClauses.length > 0) {
                                    orClauses.push(`(${conditionClauses.join(' AND ')})`);
                                    Object.assign(orParams, conditionParams);
                                }
                            });
                            // Apply all OR conditions to the main query
                            if (orClauses.length > 0) {
                                queryBuilder.andWhere(`(${orClauses.join(' OR ')})`, orParams);
                                // this.logger.debug(`Applied OR conditions: ${orClauses.join(' OR ')}`);
                            }
                            // Remove OR from where to prevent double processing
                            delete findOptions.where['OR'];
                        }
                        catch (error) {
                            if (error instanceof Error) {
                                this.logger.error(`Error processing OR conditions: ${error.message}`, error.stack);
                            }
                            else {
                                this.logger.error(`Error processing OR conditions: ${String(error)}`);
                            }
                        }
                    }
                    Object.entries(findOptions.where).forEach(([key, value]) => {
                        // Skip isDeleted as we'll handle it separately
                        if (key === 'isDeleted')
                            return;
                        // Handle nested properties (relations.field)
                        if (key.includes('.')) {
                            const pathParts = key.split('.');
                            // Check if path is valid before proceeding
                            if (pathParts.length === 0) {
                                this.logger.warn(`Invalid path format: ${key}`);
                                return; // Skip this iteration of the forEach
                            }
                            const fieldName = pathParts.pop(); // Use non-null assertion since we checked length
                            let currentAlias = alias;
                            let fullPath = '';
                            // Process each part of the path for joins
                            for (let i = 0; i < pathParts.length; i++) {
                                const relationName = pathParts[i];
                                const prevPath = fullPath;
                                // Build the cumulative path
                                fullPath = prevPath ? `${prevPath}.${relationName}` : relationName;
                                const joinAlias = `${fullPath.replace(/\./g, '_')}_filter_${this.queryState.paramCounter++}`;
                                const joinPath = `${currentAlias}.${relationName}`;
                                // Only join if not already joined
                                if (!joinedRelations.has(joinAlias)) {
                                    // FIX: Actually perform the join operation!
                                    queryBuilder.innerJoin(joinPath, joinAlias);
                                    joinedRelations.add(joinAlias);
                                    this.logger.debug(`Joined relation for filter: ${joinPath} as ${joinAlias}`);
                                }
                                // Update the current alias for next iteration
                                currentAlias = joinAlias;
                            }
                            // Apply condition to final field
                            if (typeof value === 'object' && value !== null && !(value instanceof Date)) {
                                this.applyOperatorToQueryBuilder(queryBuilder, currentAlias, fieldName, value);
                                this.logger.debug(`Applied operator filter to ${currentAlias}.${fieldName}: ${JSON.stringify(value)}`);
                            }
                            else {
                                // Generate a truly unique parameter name
                                const paramName = `${currentAlias}_${fieldName}_${this.queryState.paramCounter++}`;
                                queryBuilder.andWhere(`${currentAlias}.${fieldName} = :${paramName}`, {
                                    [paramName]: value
                                });
                                this.logger.debug(`Applied equality filter to ${currentAlias}.${fieldName} = ${value}`);
                            }
                        }
                        else {
                            // Handle regular fields on main entity
                            if (typeof value === 'object' && value !== null && !(value instanceof Date)) {
                                this.applyOperatorToQueryBuilder(queryBuilder, alias, key, value);
                                this.logger.debug(`Applied operator filter to ${alias}.${key}: ${JSON.stringify(value)}`);
                            }
                            else {
                                // Generate a truly unique parameter name
                                const paramName = `${alias}_${key}_${this.queryState.paramCounter++}`;
                                queryBuilder.andWhere(`${alias}.${key} = :${paramName}`, {
                                    [paramName]: value
                                });
                                this.logger.debug(`Applied equality filter to ${alias}.${key} = ${value}`);
                            }
                        }
                    });
                }
                // Apply ordering
                if (findOptions.order) {
                    Object.entries(findOptions.order).forEach(([key, direction]) => {
                        // Handle nested ordering
                        if (key.includes('.')) {
                            const pathParts = key.split('.');
                            if (pathParts.length !== 2) {
                                this.logger.warn(`Complex nested ordering with more than one level is not supported: ${key}`);
                                return;
                            }
                            const [relation, field] = pathParts;
                            const relationAlias = `${relation}_order`;
                            // Join the relation if not already joined
                            if (!joinedRelations.has(relationAlias)) {
                                queryBuilder.leftJoin(`${alias}.${relation}`, relationAlias);
                                joinedRelations.add(relationAlias);
                                this.logger.debug(`Joined relation for ordering: ${relation} as ${relationAlias}`);
                            }
                            queryBuilder.addOrderBy(`${relationAlias}.${field}`, direction);
                            this.logger.debug(`Added order by ${relationAlias}.${field} ${direction}`);
                        }
                        else {
                            queryBuilder.addOrderBy(`${alias}.${key}`, direction);
                            this.logger.debug(`Added order by ${alias}.${key} ${direction}`);
                        }
                    });
                }
                // Handle field selection with relations
                if (findOptions.select && Array.isArray(findOptions.select) && findOptions.select.length > 0) {
                    // Clear any previous automatic selections
                    queryBuilder.select([]);
                    // Always include primary key for relational integrity
                    queryBuilder.addSelect(`${alias}.id`);
                    // Add requested fields for the main entity
                    findOptions.select.forEach(field => {
                        if (typeof field === 'string' && !field.includes('.')) {
                            queryBuilder.addSelect(`${alias}.${field}`);
                        }
                    });
                    this.logger.debug(`Applied field selection: ${JSON.stringify(findOptions.select)}`);
                }
                // Handle relations and field selection
                if (findOptions.relations) {
                    // Apply relations with any nested field selection
                    this.applyRelationsWithFieldSelection(queryBuilder, alias, findOptions.relations, findOptions.select, joinedRelations);
                    // this.logger.debug(`Applied relations: ${JSON.stringify(findOptions.relations)}`);
                    // ADDED: Apply field selection to the main entity when relations are present
                    if (findOptions.select) {
                        // Clear any previous selection to avoid selecting all fields
                        queryBuilder.select([]);
                        // Make sure we always select the ID field for relational integrity
                        queryBuilder.addSelect(`${alias}.id`);
                        // Handle array format
                        if (Array.isArray(findOptions.select)) {
                            findOptions.select.forEach(fieldName => {
                                if (typeof fieldName === 'string' && !fieldName.includes('.')) {
                                    queryBuilder.addSelect(`${alias}.${fieldName}`);
                                }
                            });
                        }
                        // Handle object format
                        else {
                            Object.entries(findOptions.select).forEach(([field, included]) => {
                                if (included && !field.includes('.')) {
                                    queryBuilder.addSelect(`${alias}.${field}`);
                                }
                            });
                        }
                        this.logger.debug(`Applied field selection to main entity: ${JSON.stringify(findOptions.select)}`);
                    }
                }
                // If no relations but we have select fields
                else if (findOptions.select) {
                    // Add ID to selection if not already included
                    if (!Object.keys(findOptions.select).includes('id')) {
                        queryBuilder.addSelect(`${alias}.id`);
                    }
                    // Add selected fields
                    Object.entries(findOptions.select).forEach(([field, included]) => {
                        if (included) {
                            queryBuilder.addSelect(`${alias}.${field}`);
                        }
                    });
                    this.logger.debug(`Applied field selection: ${JSON.stringify(findOptions.select)}`);
                }
                // Apply pagination
                queryBuilder.skip(findOptions.skip).take(findOptions.take);
                try {
                    // Execute the query with count
                    const [data, totalCount] = await queryBuilder.getManyAndCount();
                    // // Log the SQL for debugging purposes in development
                    // if (process.env.NODE_ENV !== 'production') {
                    //   console.log('Generated SQL:', queryBuilder.getSql());
                    //   console.log('Query parameters:', queryBuilder.getParameters());
                    // }
                    // this.logger.debug(`Found ${totalCount} items using QueryBuilder with relations and field selection`);
                    // Create a new pagination DTO to maintain all methods
                    const updatedPaginationDto = new pagination_dto_1.PaginationDto();
                    Object.assign(updatedPaginationDto, paginationDto, {
                        skip: findOptions.skip,
                        take: findOptions.take
                    });
                    return {
                        data,
                        totalCount,
                        meta: updatedPaginationDto,
                    };
                }
                catch (queryError) {
                    // Log and rethrow specific query errors with more context
                    if (queryError instanceof Error) {
                        this.logger.error(`Query execution error: ${queryError.message}`, queryError.stack);
                        this.logger.error(`Failed SQL: ${queryBuilder.getSql()}`);
                        this.logger.error(`Query parameters: ${JSON.stringify(queryBuilder.getParameters())}`);
                        throw new common_1.InternalServerErrorException(`Database query failed: ${queryError.message}`);
                    }
                    else {
                        this.logger.error(`Query execution error: ${String(queryError)}`);
                        this.logger.error(`Failed SQL: ${queryBuilder.getSql()}`);
                        this.logger.error(`Query parameters: ${JSON.stringify(queryBuilder.getParameters())}`);
                        throw new common_1.InternalServerErrorException(`Database query failed: ${String(queryError)}`);
                    }
                }
            }
            else {
                // For simple queries, use repository's findAndCount
                this.logger.debug('Using simple findAndCount for basic query');
                const [data, totalCount] = await this.repository.findAndCount(findOptions);
                // Create a new pagination DTO to maintain all methods
                const updatedPaginationDto = new pagination_dto_1.PaginationDto();
                Object.assign(updatedPaginationDto, paginationDto, {
                    skip: findOptions.skip,
                    take: findOptions.take,
                });
                return {
                    data,
                    totalCount,
                    meta: updatedPaginationDto,
                };
            }
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error in findAllComplex method: ${error.message}`, error.stack);
                throw new common_1.InternalServerErrorException(`Failed to retrieve ${this.entityName} records: ${error.message}`);
            }
            else {
                this.logger.error(`Error in findAllComplex method: ${String(error)}`);
                throw new common_1.InternalServerErrorException(`Failed to retrieve ${this.entityName} records: ${String(error)}`);
            }
        }
    }
    // Helper method to apply operators to QueryBuilder
    applyOperatorToQueryBuilder(queryBuilder, alias, field, valueObj) {
        // Create unique parameter name base
        const paramBaseName = `${alias}_${field}_${this.queryState.paramCounter++}`;
        // Debug the incoming value object
        // console.log(`Applying operator to ${alias}.${field}:`, JSON.stringify(valueObj, null, 2));
        // Handle TypeORM's internal operator objects (ILike, etc.)
        if (valueObj && valueObj._type && valueObj._value !== undefined) {
            const paramName = `${paramBaseName}_typeorm`;
            switch (valueObj._type) {
                case 'ilike':
                    // For ilike, TypeORM may have already added wildcards, so check the value
                    const ilikeValue = valueObj._value.includes('%') ? valueObj._value : `%${valueObj._value}%`;
                    queryBuilder.andWhere(`LOWER(${alias}.${field}) LIKE LOWER(:${paramName})`, {
                        [paramName]: ilikeValue
                    });
                    console.log(`Applied TypeORM ILIKE: ${alias}.${field} LIKE '${ilikeValue}'`);
                    break;
                case 'like':
                    const likeValue = valueObj._value.includes('%') ? valueObj._value : `%${valueObj._value}%`;
                    queryBuilder.andWhere(`${alias}.${field} LIKE :${paramName}`, {
                        [paramName]: likeValue
                    });
                    console.log(`Applied TypeORM LIKE: ${alias}.${field} LIKE '${likeValue}'`);
                    break;
                case 'equal':
                case 'eq':
                    queryBuilder.andWhere(`${alias}.${field} = :${paramName}`, {
                        [paramName]: valueObj._value
                    });
                    console.log(`Applied TypeORM equals: ${alias}.${field} = '${valueObj._value}'`);
                    break;
                case 'not':
                    if (valueObj._value === null) {
                        queryBuilder.andWhere(`${alias}.${field} IS NOT NULL`);
                        console.log(`Applied TypeORM not equals for NULL: ${alias}.${field} IS NOT NULL`);
                    }
                    else if (valueObj._value._type === 'in') {
                        queryBuilder.andWhere(`${alias}.${field} NOT IN (:...${paramName})`, {
                            [paramName]: valueObj._value._value
                        });
                        console.log(`Applied TypeORM not equals IN: ${alias}.${field} NOT IN (${valueObj._value._value.join(', ')})`);
                    }
                    else {
                        queryBuilder.andWhere(`${alias}.${field} != :${paramName} OR ${alias}.${field} IS NULL`, {
                            [paramName]: valueObj._value
                        });
                        console.log(`Applied TypeORM not equals with NULL check: ${alias}.${field} != '${valueObj._value}' OR ${alias}.${field} IS NULL`);
                    }
                    break;
                case 'gt':
                    queryBuilder.andWhere(`${alias}.${field} > :${paramName}`, {
                        [paramName]: valueObj._value
                    });
                    console.log(`Applied TypeORM greater than: ${alias}.${field} > ${valueObj._value}`);
                    break;
                case 'gte':
                    queryBuilder.andWhere(`${alias}.${field} >= :${paramName}`, {
                        [paramName]: valueObj._value
                    });
                    console.log(`Applied TypeORM greater than or equal: ${alias}.${field} >= ${valueObj._value}`);
                    break;
                case 'lt':
                    queryBuilder.andWhere(`${alias}.${field} < :${paramName}`, {
                        [paramName]: valueObj._value
                    });
                    console.log(`Applied TypeORM less than: ${alias}.${field} < ${valueObj._value}`);
                    break;
                case 'lte':
                    queryBuilder.andWhere(`${alias}.${field} <= :${paramName}`, {
                        [paramName]: valueObj._value
                    });
                    console.log(`Applied TypeORM less than or equal: ${alias}.${field} <= ${valueObj._value}`);
                    break;
                case 'in':
                    if (Array.isArray(valueObj._value)) {
                        queryBuilder.andWhere(`${alias}.${field} IN (:...${paramName})`, {
                            [paramName]: valueObj._value
                        });
                        console.log(`Applied TypeORM IN: ${alias}.${field} IN (${valueObj._value.join(', ')})`);
                    }
                    break;
                case 'nin':
                    if (Array.isArray(valueObj._value)) {
                        queryBuilder.andWhere(`${alias}.${field} NOT IN (:...${paramName})`, {
                            [paramName]: valueObj._value
                        });
                        console.log(`Applied TypeORM NOT IN: ${alias}.${field} NOT IN (${valueObj._value.join(', ')})`);
                    }
                    break;
                case 'any':
                    if (Array.isArray(valueObj._value)) {
                        queryBuilder.andWhere(`${alias}.${field} = ANY(:${paramName})`, {
                            [paramName]: valueObj._value
                        });
                        console.log(`Applied TypeORM ANY: ${alias}.${field} = ANY(${valueObj._value.join(', ')})`);
                    }
                    break;
                case 'between':
                    if (Array.isArray(valueObj._value) && valueObj._value.length === 2) {
                        queryBuilder.andWhere(`${alias}.${field} BETWEEN :${paramName}Min AND :${paramName}Max`, {
                            [`${paramName}Min`]: valueObj._value[0],
                            [`${paramName}Max`]: valueObj._value[1]
                        });
                        console.log(`Applied TypeORM BETWEEN: ${alias}.${field} BETWEEN ${valueObj._value[0]} AND ${valueObj._value[1]}`);
                    }
                    break;
                case 'isNull':
                    queryBuilder.andWhere(`${alias}.${field} IS NULL`);
                    console.log(`Applied TypeORM IS NULL: ${alias}.${field} IS NULL`);
                    break;
                case 'isNotNull':
                    queryBuilder.andWhere(`${alias}.${field} IS NOT NULL`);
                    console.log(`Applied TypeORM IS NOT NULL: ${alias}.${field} IS NOT NULL`);
                    break;
                default:
                // this.logger.warn(`Unsupported TypeORM operator type: ${valueObj._type}`);
            }
            return;
        }
        // Handle custom operator format
        try {
            if ('eq' in valueObj) {
                const paramName = `${paramBaseName}_eq`;
                queryBuilder.andWhere(`${alias}.${field} = :${paramName}`, { [paramName]: valueObj.eq });
                console.log(`Applied custom equals: ${alias}.${field} = '${valueObj.eq}'`);
            }
            else if ('ne' in valueObj) {
                const paramName = `${paramBaseName}_ne`;
                queryBuilder.andWhere(`${alias}.${field} != :${paramName}`, { [paramName]: valueObj.ne });
                console.log(`Applied custom not equals: ${alias}.${field} != '${valueObj.ne}'`);
            }
            else if ('gt' in valueObj) {
                const paramName = `${paramBaseName}_gt`;
                queryBuilder.andWhere(`${alias}.${field} > :${paramName}`, { [paramName]: valueObj.gt });
                console.log(`Applied custom greater than: ${alias}.${field} > ${valueObj.gt}`);
            }
            else if ('gte' in valueObj) {
                const paramName = `${paramBaseName}_gte`;
                queryBuilder.andWhere(`${alias}.${field} >= :${paramName}`, { [paramName]: valueObj.gte });
                console.log(`Applied custom greater than or equal: ${alias}.${field} >= ${valueObj.gte}`);
            }
            else if ('lt' in valueObj) {
                const paramName = `${paramBaseName}_lt`;
                queryBuilder.andWhere(`${alias}.${field} < :${paramName}`, { [paramName]: valueObj.lt });
                console.log(`Applied custom less than: ${alias}.${field} < ${valueObj.lt}`);
            }
            else if ('lte' in valueObj) {
                const paramName = `${paramBaseName}_lte`;
                queryBuilder.andWhere(`${alias}.${field} <= :${paramName}`, { [paramName]: valueObj.lte });
                console.log(`Applied custom less than or equal: ${alias}.${field} <= ${valueObj.lte}`);
            }
            else if ('like' in valueObj) {
                const paramName = `${paramBaseName}_like`;
                queryBuilder.andWhere(`${alias}.${field} LIKE :${paramName}`, {
                    [paramName]: `%${valueObj.like}%`
                });
                console.log(`Applied custom LIKE: ${alias}.${field} LIKE '%${valueObj.like}%'`);
            }
            else if ('ilike' in valueObj) {
                const paramName = `${paramBaseName}_ilike`;
                queryBuilder.andWhere(`LOWER(${alias}.${field}) LIKE LOWER(:${paramName})`, {
                    [paramName]: `%${valueObj.ilike}%`
                });
                console.log(`Applied custom ILIKE: ${alias}.${field} ILIKE '%${valueObj.ilike}%'`);
            }
            else if ('in' in valueObj && Array.isArray(valueObj.in)) {
                const paramName = `${paramBaseName}_in`;
                queryBuilder.andWhere(`${alias}.${field} IN (:...${paramName})`, { [paramName]: valueObj.in });
                console.log(`Applied custom IN: ${alias}.${field} IN (${valueObj.in.join(', ')})`);
            }
            else if ('nin' in valueObj && Array.isArray(valueObj.notIn)) {
                const paramName = `${paramBaseName}_notIn`;
                queryBuilder.andWhere(`${alias}.${field} NOT IN (:...${paramName})`, { [paramName]: valueObj.notIn });
                console.log(`Applied custom NOT IN: ${alias}.${field} NOT IN (${valueObj.notIn.join(', ')})`);
            }
            else if ('between' in valueObj && Array.isArray(valueObj.between) && valueObj.between.length === 2) {
                const paramMinName = `${paramBaseName}_between_min`;
                const paramMaxName = `${paramBaseName}_between_max`;
                queryBuilder.andWhere(`${alias}.${field} BETWEEN :${paramMinName} AND :${paramMaxName}`, {
                    [paramMinName]: valueObj.between[0],
                    [paramMaxName]: valueObj.between[1]
                });
                console.log(`Applied custom BETWEEN: ${alias}.${field} BETWEEN ${valueObj.between[0]} AND ${valueObj.between[1]}`);
            }
            else if ('isNull' in valueObj) {
                if (valueObj.isNull) {
                    queryBuilder.andWhere(`${alias}.${field} IS NULL`);
                    console.log(`Applied custom IS NULL: ${alias}.${field} IS NULL`);
                }
                else {
                    queryBuilder.andWhere(`${alias}.${field} IS NOT NULL`);
                    console.log(`Applied custom IS NOT NULL: ${alias}.${field} IS NOT NULL`);
                }
            }
            else {
                console.warn(`Unknown operator in filter object: ${JSON.stringify(valueObj)}`);
                this.logger.warn(`Unknown operator in filter object: ${JSON.stringify(valueObj)}`);
            }
        }
        catch (error) {
            console.error(`Error applying operator for ${alias}.${field}:`, error);
            if (error instanceof Error) {
                this.logger.error(`Error applying operator for ${alias}.${field}: ${error.message}`, error.stack);
            }
            else {
                this.logger.error(`Error applying operator for ${alias}.${field}: ${String(error)}`);
            }
        }
        // After applying any operator, log query parameters for debugging
        console.log('Current query parameters:', queryBuilder.getParameters());
    }
    // Helper method to recursively apply relations with field selection
    applyRelationsWithFieldSelection(queryBuilder, parentAlias, relations, select, joinedRelations = new Set()) {
        // Handle string array format for relations
        if (Array.isArray(relations)) {
            // Sort relations to ensure parent relations are joined before their children
            const sortedRelations = [...relations].sort((a, b) => {
                // Put non-nested relations first, then sort by nesting depth
                const aNestCount = (a.match(/\./g) || []).length;
                const bNestCount = (b.match(/\./g) || []).length;
                return aNestCount - bNestCount;
            });
            // Process each relation path
            sortedRelations.forEach(relationPath => {
                // Handle nested paths (e.g., "user.profile")
                if (relationPath.includes('.')) {
                    const relationParts = relationPath.split('.');
                    let currentAlias = parentAlias;
                    let currentPath = '';
                    // Process each part of the path
                    relationParts.forEach((part, index) => {
                        const isLastPart = index === relationParts.length - 1;
                        const prevPath = currentPath;
                        // Build the cumulative path
                        currentPath = prevPath ? `${prevPath}.${part}` : part;
                        const fullRelationPath = `${currentAlias}.${part}`;
                        const newAlias = `${currentPath.replace(/\./g, '_')}_rel`;
                        // Skip if this relation segment is already joined
                        if (joinedRelations.has(newAlias)) {
                            currentAlias = newAlias;
                            return;
                        }
                        joinedRelations.add(newAlias);
                        // Join with or without selecting all fields
                        if (isLastPart) {
                            queryBuilder.leftJoinAndSelect(fullRelationPath, newAlias);
                        }
                        else {
                            // For intermediate relations, just join without selecting fields
                            queryBuilder.leftJoin(fullRelationPath, newAlias);
                        }
                        // Update current alias for the next iteration
                        currentAlias = newAlias;
                    });
                }
                else {
                    // Handle simple non-nested relations
                    const relationAlias = `${relationPath}_rel`;
                    // Skip if already joined
                    if (joinedRelations.has(relationAlias)) {
                        return;
                    }
                    joinedRelations.add(relationAlias);
                    queryBuilder.leftJoinAndSelect(`${parentAlias}.${relationPath}`, relationAlias);
                }
            });
            return;
        }
        // Rest of the method for object-format relations stays the same
        Object.entries(relations).forEach(([relationName, relationValue]) => {
            if (!relationValue)
                return;
            const relationAlias = `${relationName}_rel`;
            // Skip if already joined
            if (joinedRelations.has(relationAlias)) {
                return;
            }
            joinedRelations.add(relationAlias);
            // Handle nested relations
            if (typeof relationValue === 'object') {
                // Join the parent relation
                queryBuilder.leftJoinAndSelect(`${parentAlias}.${relationName}`, relationAlias);
                // Apply nested relations recursively
                this.applyRelationsWithFieldSelection(queryBuilder, relationAlias, relationValue, select, joinedRelations);
            }
            else {
                // Apply field selection for this relation if specified
                const relationSelect = this.extractNestedSelect(relationName, select);
                if (relationSelect && Object.keys(relationSelect).length > 0) {
                    // Join without selecting all fields
                    queryBuilder.leftJoin(`${parentAlias}.${relationName}`, relationAlias);
                    // Add ID field to ensure proper relation loading
                    queryBuilder.addSelect(`${relationAlias}.id`);
                    // Add each selected field
                    Object.entries(relationSelect).forEach(([field, included]) => {
                        if (included) {
                            queryBuilder.addSelect(`${relationAlias}.${field}`);
                        }
                    });
                }
                else {
                    // No specific field selection, select all fields
                    queryBuilder.leftJoinAndSelect(`${parentAlias}.${relationName}`, relationAlias);
                }
            }
        });
    }
    // Extract nested select fields for a specific relation
    extractNestedSelect(relationName, select) {
        if (!select)
            return undefined;
        const nestedSelect = {};
        let hasNestedFields = false;
        // Handle array format for select
        if (Array.isArray(select)) {
            // For array format, check if any items start with the relation name
            select.forEach(fieldPath => {
                if (typeof fieldPath === 'string' && fieldPath.startsWith(`${relationName}.`)) {
                    const nestedField = fieldPath.substring(relationName.length + 1);
                    nestedSelect[nestedField] = true;
                    hasNestedFields = true;
                }
            });
        }
        else {
            // Handle object format
            Object.entries(select).forEach(([field, included]) => {
                if (field.startsWith(`${relationName}.`)) {
                    const nestedField = field.substring(relationName.length + 1);
                    nestedSelect[nestedField] = included;
                    hasNestedFields = true;
                }
            });
        }
        return hasNestedFields ? nestedSelect : undefined;
    }
    /**
     * Finds a single entity matching the specified criteria.
     *
     * @param criteria - Fields to search by (partial entity)
     * @param options - Additional query options
     * @param options.relations - Relations to eager load with the entity
     * @param options.select - Fields to select from the entity
     * @param options.order - Sort order for the query results
     * @param options.withDeleted - Whether to include soft-deleted entities (default: false)
     * @param options.cache - Enable result caching (boolean, TTL in ms, or cache options object)
     * @param options.loadEagerRelations - Whether to load eager relations (default: true)
     * @param options.transaction - Whether the query should use an existing transaction
     *
     * @returns A Promise resolving to the matched entity or null if not found
     *
     * @example
     * // Find a user by email
     * const user = await userService.findOneBy({ email: 'example@domain.com' });
     *
     * // Find a user with related posts
     * const userWithPosts = await userService.findOneBy(
     *   { id: 123 },
     *   { relations: { posts: true } }
     * );
     */
    async findOneBy(criteria, options) {
        const findOptions = Object.assign({ where: Object.assign(Object.assign({}, ((options === null || options === void 0 ? void 0 : options.withDeleted) || 'isDeleted' in criteria ? {} : { isDeleted: false })), criteria) }, options);
        return await this.repository.findOne(findOptions);
    }
    async findOneByOrFail(criteria, options) {
        const entity = await this.findOneBy(criteria, options);
        if (!entity) {
            throw new common_1.NotFoundException(`${this.entityName} with ${utility_helper_1.UtilityHelper.formatCriteria(criteria)} not found`);
        }
        return entity;
    }
    async validateBefore(dto) {
        // Default implementation does nothing
        // Child classes can override this to implement specific validations
    }
    // Enhanced reference validation with additional validation capabilities
    async validateReferences(dto, referenceFields) {
        // Create a copy to avoid mutating the input
        const result = Object.assign({}, dto);
        for (const config of referenceFields) {
            // Extract values from config with defaults
            const { field, service, required = false, unique, customValidator, transform = (e) => e } = config;
            // Get the reference from the DTO (handles nested paths like 'request.id')
            const fieldParts = field.split('.');
            let reference = dto;
            for (const part of fieldParts) {
                reference = reference === null || reference === void 0 ? void 0 : reference[part];
                if (reference === undefined)
                    break;
            }
            // Check if reference is required but missing
            if (required && (!reference || !reference.id)) {
                throw new common_1.BadRequestException(`${field} reference is required`);
            }
            // Skip validation if no reference or no ID
            if (!reference || !reference.id)
                continue;
            // Find the referenced entity
            const referenceId = reference.id;
            const entity = await service.findOneByOrFail({ id: referenceId });
            reference = entity;
            // Check uniqueness constraints if specified
            if (unique) {
                const { field: uniqueField, message } = unique;
                // Get value to check uniqueness against
                const checkValue = entity[uniqueField];
                if (checkValue !== undefined) {
                    // Query for existing entities with this reference
                    const existing = await this.repository.findOne({
                        where: { [uniqueField]: checkValue }
                    });
                    if (existing) {
                        throw new common_1.ConflictException(message || `A record with this ${uniqueField} ${checkValue} already exists`);
                    }
                }
            }
            // Run custom validator if provided
            if (customValidator) {
                await Promise.resolve(customValidator(entity, dto));
            }
            // Set the field value in the result object (with optional transformation)
            // This handles nested paths too
            if (fieldParts.length === 1) {
                // Simple field assignment
                result[field] = transform(entity);
            }
            else {
                // Nested field assignment
                let current = result;
                for (let i = 0; i < fieldParts.length - 1; i++) {
                    const part = fieldParts[i];
                    if (!current[part])
                        current[part] = {};
                    current = current[part];
                }
                // Set the innermost field
                const lastPart = fieldParts[fieldParts.length - 1];
                current[lastPart] = transform(entity);
            }
        }
        return result;
    }
    // DONE
    async create(createDto, createdBy) {
        await this.validateBefore(createDto);
        const entity = this.repository.create(Object.assign(Object.assign({}, createDto), { createdBy }));
        try {
            return await this.repository.save(entity);
        }
        catch (error) {
            // console.log('Full error object:', JSON.stringify(error, null, 2));
            throw new common_1.ConflictException(error.message);
        }
    }
    // DONE
    async update(id, updateDto, updatedBy) {
        await this.validateBefore(updateDto);
        const entity = await this.findOneByOrFail({ id });
        const updatedEntity = await this.repository.save(Object.assign(Object.assign(Object.assign({}, entity), updateDto), { updatedBy }));
        return updatedEntity;
    }
    // DONE
    async softDelete(id, deletedBy) {
        if (deletedBy) {
            await this.repository.update(id, { deletedBy });
        }
        await this.repository.softDelete(id);
        const response = new generalresponse_dto_1.GeneralResponseDto();
        response.statusCode = common_1.HttpStatus.NO_CONTENT;
        response.timestamp = new Date().toISOString();
        response.detail = 'Deletion Successful';
        response.message = `${this.entityName} with id ${id} was deleted successfully`;
        return response;
    }
    async save(entity) {
        if (Array.isArray(entity)) {
            return await this.repository.save(entity);
        }
        else {
            return await this.repository.save(entity);
        }
    }
    // DONE
    async delete(id) {
        const result = await this.repository.delete(id);
        if (result.affected === 0) {
            throw new common_1.NotFoundException(`${this.entityName} with id ${id} not found`);
        }
        const response = new generalresponse_dto_1.GeneralResponseDto();
        response.statusCode = common_1.HttpStatus.NO_CONTENT;
        response.timestamp = new Date().toISOString();
        response.detail = 'Deletion Successful';
        response.message = `${this.entityName} with id ${id} was deleted successfully`;
        return response;
    }
    // DONE
    async deleteMany(ids, hardDelete = false) {
        if (ids.length === 0) {
            throw new common_1.BadRequestException('No ids provided for deletion.');
        }
        const existingEntities = await this.repository.findBy({
            id: (0, typeorm_1.In)(ids),
        });
        if (existingEntities.length !== ids.length) {
            const foundIds = existingEntities.map(entity => entity.id);
            const missingIds = ids.filter(id => !foundIds.includes(id));
            throw new common_1.NotFoundException(`${this.entityName}s with ids ${missingIds.join(', ')} not found.`);
        }
        await this.transactionService.executeInTransaction(async (queryRunner) => {
            try {
                if (!hardDelete) {
                    // Perform soft delete by updating isDeleted flag
                    await queryRunner.manager.update(this.entityType, { id: (0, typeorm_1.In)(ids) }, { isDeleted: true, deletedAt: new Date() });
                }
                else {
                    // Perform hard delete (physically remove records)
                    await queryRunner.manager.delete(this.entityType, ids);
                }
            }
            catch (error) {
                throw new common_1.InternalServerErrorException(`Failed to delete ${this.entityName}s.`);
            }
        });
    }
    createQueryBuilder(options) {
        const { alias = 'entity', filters = {}, relations = {}, orderBy = {}, select = [] } = options;
        const queryBuilder = this.repository.createQueryBuilder(alias);
        // Apply WHERE conditions
        Object.entries(filters).forEach(([key, value]) => {
            if (key.includes('.')) {
                // Handle nested filters (relations)
                const [relationPath, field] = key.split('.');
                queryBuilder.andWhere(`${relationPath}.${field} = :${key.replace('.', '_')}`, {
                    [key.replace('.', '_')]: value
                });
            }
            else if (Array.isArray(value)) {
                // Handle array values like roles
                if (key.endsWith('s') && typeof value[0] === 'object') {
                    // Many-to-many or one-to-many relation array (like "roles")
                    const relationName = key;
                    const relationAlias = `${relationName}_filtered`;
                    queryBuilder.innerJoinAndSelect(`${alias}.${relationName}`, relationAlias);
                    queryBuilder.andWhere(`${relationAlias}.id IN (:...${key}Ids)`, {
                        [`${key}Ids`]: value.map(item => item.id || item)
                    });
                }
                else {
                    // Simple array values
                    queryBuilder.andWhere(`${alias}.${key} IN (:...${key})`, { [key]: value });
                }
            }
            else if (typeof value === 'object' && value !== null && !(value instanceof Date)) {
                // Handle TypeORM operators
                Object.entries(value).forEach(([operator, operatorValue]) => {
                    switch (operator) {
                        case 'like':
                            queryBuilder.andWhere(`${alias}.${key} LIKE :${key}_like`, {
                                [`${key}_like`]: `%${operatorValue}%`
                            });
                            break;
                        case 'gt':
                            queryBuilder.andWhere(`${alias}.${key} > :${key}_gt`, { [`${key}_gt`]: operatorValue });
                            break;
                        case 'gte':
                            queryBuilder.andWhere(`${alias}.${key} >= :${key}_gte`, { [`${key}_gte`]: operatorValue });
                            break;
                        case 'lt':
                            queryBuilder.andWhere(`${alias}.${key} < :${key}_lt`, { [`${key}_lt`]: operatorValue });
                            break;
                        case 'lte':
                            queryBuilder.andWhere(`${alias}.${key} <= :${key}_lte`, { [`${key}_lte`]: operatorValue });
                            break;
                        default:
                            queryBuilder.andWhere(`${alias}.${key} = :${key}`, { [key]: value });
                    }
                });
            }
            else {
                // Simple equality
                queryBuilder.andWhere(`${alias}.${key} = :${key}`, { [key]: value });
            }
        });
        // Apply relations
        Object.entries(relations).forEach(([relationName, relationOptions]) => {
            if (relationOptions === true) {
                queryBuilder.leftJoinAndSelect(`${alias}.${relationName}`, relationName);
            }
            else if (typeof relationOptions === 'object') {
                const relationAlias = relationName;
                queryBuilder.leftJoinAndSelect(`${alias}.${relationName}`, relationAlias);
                // Apply filters to the relation if needed
                if (relationOptions.where) {
                    Object.entries(relationOptions.where).forEach(([field, value]) => {
                        queryBuilder.andWhere(`${relationAlias}.${field} = :${relationAlias}_${field}`, {
                            [`${relationAlias}_${field}`]: value
                        });
                    });
                }
            }
        });
        // Apply ordering
        Object.entries(orderBy).forEach(([key, direction]) => {
            queryBuilder.addOrderBy(`${alias}.${key}`, direction);
        });
        // Apply select fields if specified
        if (select.length > 0) {
            queryBuilder.select(select.map(field => `${alias}.${field}`));
        }
        return queryBuilder;
    }
    /**
     * Include a related entity (similar to EF Include)
     */
    include(navigationPropertyPath) {
        const propertyName = this.getPropertyName(navigationPropertyPath);
        const joinAlias = propertyName;
        const joinPath = `${this.repository.metadata.name.toLowerCase()}.${propertyName}`;
        this.queryState.includes.set(propertyName, joinPath);
        this.queryState.parentPath = propertyName;
        return this;
    }
    /**
     * Include a nested related entity (similar to EF ThenInclude)
     */
    thenInclude(navigationPropertyPath) {
        const propertyName = this.getPropertyName(navigationPropertyPath);
        const parentPath = this.queryState.parentPath;
        const joinPath = `${parentPath}.${propertyName}`;
        this.queryState.includes.set(joinPath, joinPath);
        this.queryState.parentPath = joinPath;
        return this;
    }
    /**
     * Filter entities based on a predicate
     */
    where(predicate) {
        const condition = this.parseExpression(predicate);
        this.queryState.whereConditions.push(condition.query);
        Object.assign(this.queryState.parameters, condition.parameters);
        return this;
    }
    /**
     * Order entities by a property ascending
     */
    orderBy(keySelector) {
        const propertyName = this.getPropertyName(keySelector);
        const alias = this.repository.metadata.name.toLowerCase();
        this.queryState.orderByClauses.push(`${alias}.${propertyName} ASC`);
        return this;
    }
    /**
     * Order entities by a property descending
     */
    orderByDescending(keySelector) {
        const propertyName = this.getPropertyName(keySelector);
        const alias = this.repository.metadata.name.toLowerCase();
        this.queryState.orderByClauses.push(`${alias}.${propertyName} DESC`);
        return this;
    }
    /**
     * Add a secondary ordering by a property ascending
     */
    thenBy(keySelector) {
        const propertyName = this.getPropertyName(keySelector);
        const alias = this.repository.metadata.name.toLowerCase();
        this.queryState.orderByClauses.push(`${alias}.${propertyName} ASC`);
        return this;
    }
    /**
     * Add a secondary ordering by a property descending
     */
    thenByDescending(keySelector) {
        const propertyName = this.getPropertyName(keySelector);
        const alias = this.repository.metadata.name.toLowerCase();
        this.queryState.orderByClauses.push(`${alias}.${propertyName} DESC`);
        return this;
    }
    /**
     * Skip a number of entities (for pagination)
     */
    skip(count) {
        this.queryState.skipValue = count;
        return this;
    }
    /**
     * Take a number of entities (for pagination)
     */
    take(count) {
        this.queryState.takeValue = count;
        return this;
    }
    /**
     * Execute the query with no tracking (better performance)
     */
    asNoTracking() {
        this.queryState.isTracking = false;
        return this;
    }
    /**
     * Execute the query and return all entities as a list
     */
    async toList() {
        try {
            const query = this.buildQuery();
            if (this.queryState.skipValue > 0) {
                query.skip(this.queryState.skipValue);
            }
            if (this.queryState.takeValue > 0) {
                query.take(this.queryState.takeValue);
            }
            const result = await query.getMany();
            this.resetQueryState();
            return result;
        }
        catch (error) {
            this.resetQueryState();
            throw error;
        }
    }
    /**
     * Execute the query and return a paginated response
     */
    async toPagedList(skip = 0, take = 10) {
        try {
            const query = this.buildQuery();
            // Use provided values or those set by skip()/take() methods
            const skipValue = this.queryState.skipValue > 0 ? this.queryState.skipValue : skip;
            const takeValue = this.queryState.takeValue > 0 ? this.queryState.takeValue : take;
            query.skip(skipValue).take(takeValue);
            const [data, totalCount] = await Promise.all([
                query.getMany(),
                query.getCount()
            ]);
            const paginationDto = new pagination_dto_1.PaginationDto();
            Object.assign(paginationDto, {
                skip: skipValue,
                take: takeValue
            });
            this.resetQueryState();
            return {
                data,
                totalCount,
                meta: paginationDto
            };
        }
        catch (error) {
            this.resetQueryState();
            throw error;
        }
    }
    /**
     * Execute the query and return the first entity or null
     */
    async firstOrDefault() {
        try {
            const query = this.buildQuery();
            query.take(1);
            const result = await query.getOne();
            this.resetQueryState();
            return result;
        }
        catch (error) {
            this.resetQueryState();
            throw error;
        }
    }
    /**
     * Execute the query and return the first entity or throw if not found
     */
    async first() {
        const result = await this.firstOrDefault();
        if (!result) {
            throw new common_1.NotFoundException(`${this.entityName} not found`);
        }
        return result;
    }
    /**
     * Execute the query and return a single entity or null
     * Throws if more than one entity is found
     */
    async singleOrDefault() {
        try {
            const query = this.buildQuery();
            const entities = await query.getMany();
            if (entities.length > 1) {
                throw new common_1.BadRequestException(`Expected a single ${this.entityName}, but found multiple`);
            }
            this.resetQueryState();
            return entities.length === 1 ? entities[0] : null;
        }
        catch (error) {
            this.resetQueryState();
            throw error;
        }
    }
    /**
     * Execute the query and return a single entity
     * Throws if no entity is found or more than one entity is found
     */
    async single() {
        const result = await this.singleOrDefault();
        if (!result) {
            throw new common_1.NotFoundException(`${this.entityName} not found`);
        }
        return result;
    }
    /**
     * Count the number of entities that match the query
     */
    async count() {
        try {
            const query = this.buildQuery();
            const count = await query.getCount();
            this.resetQueryState();
            return count;
        }
        catch (error) {
            this.resetQueryState();
            throw error;
        }
    }
    /**
     * Check if any entities match the query
     */
    async any() {
        const count = await this.count();
        return count > 0;
    }
    // Private helper methods
    /**
     * Build the TypeORM query from the state
     */
    buildQuery() {
        const alias = this.repository.metadata.name.toLowerCase();
        const query = this.repository.createQueryBuilder(alias);
        // Add includes (relations)
        this.queryState.includes.forEach((joinPath, key) => {
            const relationAlias = key.replace(/\./g, '_');
            query.leftJoinAndSelect(joinPath, relationAlias);
        });
        // Add where conditions
        this.queryState.whereConditions.forEach(condition => {
            query.andWhere(condition);
        });
        // Add parameters
        if (Object.keys(this.queryState.parameters).length > 0) {
            query.setParameters(this.queryState.parameters);
        }
        // Add order by
        this.queryState.orderByClauses.forEach(orderBy => {
            const [path, direction] = orderBy.split(' ');
            query.addOrderBy(path, direction);
        });
        // Filter out soft-deleted entities by default
        query.andWhere(`${alias}.isDeleted = :isDeleted`, { isDeleted: false });
        return query;
    }
    /**
     * Extract property name from an expression
     */
    getPropertyName(expression) {
        const funcStr = expression.toString();
        // Extract property name after the arrow function parameter
        const regex = /=>.*?\.([a-zA-Z0-9_]+)(?:\s|$|\)|\.|\[)/;
        const match = funcStr.match(regex);
        if (!match) {
            throw new Error(`Could not extract property name from expression: ${funcStr}`);
        }
        return match[1];
    }
    /**
     * Parse an expression into a SQL condition
     */
    parseExpression(expression) {
        const funcStr = expression.toString();
        const parameters = {};
        const alias = this.repository.metadata.name.toLowerCase();
        // Check for logical operators (AND, OR)
        if (funcStr.includes('&&') || funcStr.includes('||')) {
            return this.parseLogicalExpression(funcStr, alias);
        }
        // Handle basic comparison operations
        const comparisonRegex = /=>.*?\.([a-zA-Z0-9_]+)\s*(===|==|!==|!=|>=|<=|>|<)\s*([^;)]+)/;
        const comparisonMatch = funcStr.match(comparisonRegex);
        if (comparisonMatch) {
            const [_, property, operator, value] = comparisonMatch;
            const paramName = `param${++this.queryState.paramCounter}`;
            // Parse the value
            let parsedValue;
            if (value.trim() === 'true')
                parsedValue = true;
            else if (value.trim() === 'false')
                parsedValue = false;
            else if (value.trim() === 'null')
                parsedValue = null;
            else if (/^['"].*['"]$/.test(value.trim()))
                parsedValue = value.trim().slice(1, -1);
            else if (!isNaN(Number(value.trim())))
                parsedValue = Number(value.trim());
            else
                parsedValue = value.trim();
            parameters[paramName] = parsedValue;
            // Map JS operator to SQL operator
            const sqlOperator = this.mapOperator(operator);
            return {
                query: `${alias}.${property} ${sqlOperator} :${paramName}`,
                parameters
            };
        }
        // Handle method calls (includes, startsWith, endsWith)
        const methodRegex = /=>.*?\.([a-zA-Z0-9_]+)\.([a-zA-Z0-9_]+)\(([^)]*)\)/;
        const methodMatch = funcStr.match(methodRegex);
        if (methodMatch) {
            const [_, property, method, args] = methodMatch;
            const paramName = `param${++this.queryState.paramCounter}`;
            // Parse the arguments
            const parsedArgs = args.trim().split(',').map(arg => {
                const trimmedArg = arg.trim();
                if (trimmedArg.startsWith("'") || trimmedArg.startsWith('"')) {
                    return trimmedArg.slice(1, -1);
                }
                return trimmedArg;
            });
            // Handle common string methods
            switch (method) {
                case 'includes':
                    return {
                        query: `${alias}.${property} LIKE :${paramName}`,
                        parameters: { [paramName]: `%${parsedArgs[0]}%` }
                    };
                case 'startsWith':
                    return {
                        query: `${alias}.${property} LIKE :${paramName}`,
                        parameters: { [paramName]: `${parsedArgs[0]}%` }
                    };
                case 'endsWith':
                    return {
                        query: `${alias}.${property} LIKE :${paramName}`,
                        parameters: { [paramName]: `%${parsedArgs[0]}` }
                    };
                case 'indexOf':
                    return {
                        query: `${alias}.${property} LIKE :${paramName}`,
                        parameters: { [paramName]: `%${parsedArgs[0]}%` }
                    };
                case 'toLowerCase':
                    return {
                        query: `LOWER(${alias}.${property}) = LOWER(:${paramName})`,
                        parameters: { [paramName]: parsedArgs[0] || '' }
                    };
                case 'toUpperCase':
                    return {
                        query: `UPPER(${alias}.${property}) = UPPER(:${paramName})`,
                        parameters: { [paramName]: parsedArgs[0] || '' }
                    };
                case 'trim':
                    return {
                        query: `TRIM(${alias}.${property}) = :${paramName}`,
                        parameters: { [paramName]: parsedArgs[0] || '' }
                    };
                default:
                    throw new Error(`Unsupported method: ${method}`);
            }
        }
        // Handle null/undefined checks
        const nullCheckRegex = /=>.*?\.([a-zA-Z0-9_]+)\s*===?\s*(null|undefined)/;
        const nullCheckMatch = funcStr.match(nullCheckRegex);
        if (nullCheckMatch) {
            const [_, property] = nullCheckMatch;
            return {
                query: `${alias}.${property} IS NULL`,
                parameters: {}
            };
        }
        const notNullCheckRegex = /=>.*?\.([a-zA-Z0-9_]+)\s*!==?\s*(null|undefined)/;
        const notNullCheckMatch = funcStr.match(notNullCheckRegex);
        if (notNullCheckMatch) {
            const [_, property] = notNullCheckMatch;
            return {
                query: `${alias}.${property} IS NOT NULL`,
                parameters: {}
            };
        }
        // Fallback for unrecognized expressions
        this.logger.warn(`Could not parse expression: ${funcStr}. Using default true condition.`);
        return {
            query: '1=1', // Always true
            parameters: {}
        };
    }
    /**
     * Parse logical expressions with AND (&&) or OR (||)
     */
    parseLogicalExpression(funcStr, alias) {
        let parameters = {};
        // Function to create a dummy Expression
        const createDummyExpression = (expressionStr) => {
            return new Function(`return ${expressionStr}`)();
        };
        // Split by OR first (lower precedence)
        if (funcStr.includes('||')) {
            const orParts = funcStr.split('||').map(part => {
                // Extract just the lambda function part for each condition
                const lambdaMatch = part.match(/(?:^\s*|[|&]{2}\s*)(\([^=]*=>\s*[^|&]*)/);
                if (lambdaMatch && lambdaMatch[1]) {
                    const fixedExpression = `${lambdaMatch[1]})`;
                    const result = this.parseExpression(createDummyExpression(fixedExpression));
                    parameters = Object.assign(Object.assign({}, parameters), result.parameters);
                    return `(${result.query})`;
                }
                return '1=1'; // Default to true for parts we can't parse
            });
            return {
                query: orParts.join(' OR '),
                parameters
            };
        }
        // Split by AND
        if (funcStr.includes('&&')) {
            const andParts = funcStr.split('&&').map(part => {
                // Extract just the lambda function part for each condition
                const lambdaMatch = part.match(/(?:^\s*|[|&]{2}\s*)(\([^=]*=>\s*[^|&]*)/);
                if (lambdaMatch && lambdaMatch[1]) {
                    const fixedExpression = `${lambdaMatch[1]})`;
                    const result = this.parseExpression(createDummyExpression(fixedExpression));
                    parameters = Object.assign(Object.assign({}, parameters), result.parameters);
                    return `(${result.query})`;
                }
                return '1=1'; // Default to true for parts we can't parse
            });
            return {
                query: andParts.join(' AND '),
                parameters
            };
        }
        // Should not reach here
        return {
            query: '1=1',
            parameters: {}
        };
    }
    /**
     * Map JavaScript operators to SQL operators
     */
    mapOperator(operator) {
        switch (operator) {
            case '===':
            case '==': return '=';
            case '!==':
            case '!=': return '!=';
            case '>': return '>';
            case '>=': return '>=';
            case '<': return '<';
            case '<=': return '<=';
            default: return '=';
        }
    }
    /**
     * Reset the query state after execution
     */
    resetQueryState() {
        this.queryState = {
            includes: new Map(),
            whereConditions: [],
            parameters: {},
            orderByClauses: [],
            skipValue: 0,
            takeValue: 0,
            isTracking: true,
            queryBuilder: null,
            parentPath: '',
            paramCounter: 0
        };
    }
};
exports.BaseService = BaseService;
exports.BaseService = BaseService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_1.Repository !== "undefined" && typeorm_1.Repository) === "function" ? _a : Object, Object])
], BaseService);


/***/ }),

/***/ "./src/common/services/common.service.ts":
/*!***********************************************!*\
  !*** ./src/common/services/common.service.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
let CommonService = class CommonService {
    constructor(configService) {
        this.configService = configService;
    }
    isProduction() {
        return this.configService.getOrThrow('NODE_ENV') === 'production';
    }
    isDevelopment() {
        return this.configService.getOrThrow('NODE_ENV') === 'development';
    }
};
exports.CommonService = CommonService;
exports.CommonService = CommonService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], CommonService);


/***/ }),

/***/ "./src/common/services/transaction.service.ts":
/*!****************************************************!*\
  !*** ./src/common/services/transaction.service.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
let TransactionService = class TransactionService {
    constructor(dataSource) {
        this.dataSource = dataSource;
    }
    async executeInTransaction(operation) {
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            const result = await operation(queryRunner);
            await queryRunner.commitTransaction();
            return result;
        }
        catch (error) {
            await queryRunner.rollbackTransaction();
            throw error;
        }
        finally {
            await queryRunner.release();
        }
    }
};
exports.TransactionService = TransactionService;
exports.TransactionService = TransactionService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_1.DataSource !== "undefined" && typeorm_1.DataSource) === "function" ? _a : Object])
], TransactionService);


/***/ }),

/***/ "./src/common/utils/day.util.ts":
/*!**************************************!*\
  !*** ./src/common/utils/day.util.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLogLevels = exports.DayUtils = void 0;
const day_enum_1 = __webpack_require__(/*! ../enums/day.enum */ "./src/common/enums/day.enum.ts");
exports.DayUtils = {
    isWeekend: (day) => {
        return day === day_enum_1.Day.SATURDAY || day === day_enum_1.Day.SUNDAY;
    },
    fromDate: (date) => {
        const dayName = new Intl.DateTimeFormat('en-US', { weekday: 'long' }).format(date);
        return dayName.toUpperCase();
    }
};
const getLogLevels = (isDevelopment) => {
    if (isDevelopment) {
        return ['log', 'error', 'warn', 'debug', 'verbose'];
    }
    return ['log', 'error', 'warn'];
};
exports.getLogLevels = getLogLevels;


/***/ }),

/***/ "./src/config.schema.ts":
/*!******************************!*\
  !*** ./src/config.schema.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configValidationSchema = void 0;
const Joi = __importStar(__webpack_require__(/*! joi */ "joi"));
exports.configValidationSchema = Joi.object({
    PORT: Joi.number().default(3000),
    NODE_ENV: Joi.string().default('development'),
    DB_HOST: Joi.string().required(),
    DB_PORT: Joi.number().default(3306).required(),
    DB_USERNAME: Joi.string().required(),
    DB_PASSWORD: Joi.string().required(),
    DB_DATABASE: Joi.string().required(),
    CACHE_TTL: Joi.number().default(60),
    RATE_LIMIT_WINDOW_MS: Joi.number().default(900000),
    RATE_LIMIT_MAX: Joi.number().default(100),
    APP_URL: Joi.string().default('http://localhost:3000'),
    GOOGLE_CLIENT_ID: Joi.string().required(),
    GOOGLE_CLIENT_SECRET: Joi.string().required(),
    GOOGLE_CALLBACK_URL: Joi.string().required(),
    EMAIL_HOST: Joi.string().required(),
    EMAIL_PORT: Joi.number().default(587),
    EMAIL_SECURE: Joi.boolean().default(false),
    EMAIL_USERNAME: Joi.string().required(),
    EMAIL_PASSWORD: Joi.string().required(),
    //ACCESS_TOKEN_SECRET: Joi.string().required(),
    ACCESS_TOKEN_EXPIRATION_MINUTES: Joi.number().default(15),
    // REFRESH_TOKEN_SECRET: Joi.string().required(),
    REFRESH_TOKEN_EXPIRATION_MINUTES: Joi.number().default(10080),
    ACCESS_TOKEN_MAX_AGE: Joi.number().default(900),
    REFRESH_TOKEN_MAX_AGE: Joi.number().default(10080),
    ACCESS_TOKEN_SECRET: Joi.string().required(),
});


/***/ }),

/***/ "./src/config/config.module.ts":
/*!*************************************!*\
  !*** ./src/config/config.module.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigModule = void 0;
const bull_module_1 = __webpack_require__(/*! @/bull/bull.module */ "./src/bull/bull.module.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const schedule_1 = __webpack_require__(/*! @nestjs/schedule */ "@nestjs/schedule");
const config_schema_1 = __webpack_require__(/*! ../config.schema */ "./src/config.schema.ts");
let ConfigModule = class ConfigModule {
};
exports.ConfigModule = ConfigModule;
exports.ConfigModule = ConfigModule = __decorate([
    (0, common_1.Module)({
        imports: [
            config_1.ConfigModule.forRoot({
                isGlobal: true,
                envFilePath: [`.env.stage.${process.env.STAGE}`],
                validationSchema: config_schema_1.configValidationSchema,
            }),
            event_emitter_1.EventEmitterModule.forRoot(),
            bull_module_1.BullModule.forRoot(),
            schedule_1.ScheduleModule.forRoot(),
        ],
        exports: [config_1.ConfigModule, event_emitter_1.EventEmitterModule, bull_module_1.BullModule, schedule_1.ScheduleModule],
    })
], ConfigModule);


/***/ }),

/***/ "./src/config/queues.config.ts":
/*!*************************************!*\
  !*** ./src/config/queues.config.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.queues = void 0;
exports.queues = [
    {
        name: 'notifications',
        options: {
            limiter: {
                max: 100,
                duration: 5000,
            },
            defaultJobOptions: {
                attempts: 3,
                backoff: {
                    type: 'exponential',
                    delay: 2000,
                },
                removeOnComplete: true,
                removeOnFail: false,
            },
        },
    },
    {
        name: 'payroll-processing',
        options: {
            limiter: {
                max: 100,
                duration: 60000, // 1 minute
            },
        }
    },
    {
        name: 'schedule-generation',
        options: {
            defaultJobOptions: {
                attempts: 3,
                backoff: {
                    type: 'exponential',
                    delay: 5000,
                },
                removeOnComplete: true,
            },
        },
    },
    {
        name: 'work-hour-calculation',
        options: {
            defaultJobOptions: {
                attempts: 3,
                backoff: {
                    type: 'exponential',
                    delay: 5000,
                },
                removeOnComplete: true,
            },
        },
    },
    // Add other queues as needed
];


/***/ }),

/***/ "./src/config/swagger.config.ts":
/*!**************************************!*\
  !*** ./src/config/swagger.config.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.swaggerCustomOptions = exports.swaggerConfig = exports.getLocalIpAddress = void 0;
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const os_1 = __webpack_require__(/*! os */ "os");
// Initialize ConfigService
const configService = new config_1.ConfigService();
// Get local IP address
const getLocalIpAddress = () => {
    var _a;
    const nets = (0, os_1.networkInterfaces)();
    for (const name of Object.keys(nets)) {
        for (const net of (_a = nets[name]) !== null && _a !== void 0 ? _a : []) {
            // Skip over non-IPv4 and internal (loopback) addresses
            if (net.family === 'IPv4' && !net.internal) {
                return net.address;
            }
        }
    }
    return 'localhost'; // Fallback
};
exports.getLocalIpAddress = getLocalIpAddress;
const localIp = (0, exports.getLocalIpAddress)();
const port = configService.get('PORT') || '3000';
exports.swaggerConfig = new swagger_1.DocumentBuilder()
    .setTitle('Dowinn HR Management System API')
    .setDescription('API Documentation')
    .setVersion('1.0')
    .addBearerAuth({
    type: 'http',
    scheme: 'bearer',
    bearerFormat: 'JWT',
    name: 'Authorization',
    description: 'Enter JWT token',
    in: 'header',
}, 'access-token')
    .addOAuth2({
    type: 'oauth2',
    flows: {
        password: {
            tokenUrl: '/auth/login',
            scopes: {},
        },
        authorizationCode: {
            authorizationUrl: '/auth/authorize',
            tokenUrl: '/auth/token',
            scopes: {},
        },
    },
})
    .addOAuth2({
    type: 'oauth2',
    name: 'google-oauth2',
    description: 'Google OAuth2 Authentication',
    flows: {
        authorizationCode: {
            authorizationUrl: 'https://accounts.google.com/o/oauth2/auth',
            tokenUrl: '/auth/google/callback', // Your backend endpoint that handles Google token exchange
            scopes: {
                'email': 'Access to email',
                'profile': 'Access to profile information',
                'openid': 'OpenID Connect'
            },
        },
    },
})
    // .addTag('Cutoffs', 'User management operations')
    // .addTag('auth', 'Authentication related endpoints')
    .addExtension('x-company-name', 'Dowinn HR')
    .addExtension('x-environment', process.env.NODE_ENV)
    .addServer(configService.getOrThrow('APP_URL'), "Local Development Server")
    .addServer(`http://${localIp}:${port}`, "LAN Development Server") // Use ConfigService to get server URL
    // .addGlobalParameters({
    //   name: 'version',
    //   in: 'header',
    //   required: false,
    //   description: 'API version to use',
    //   schema: {
    //     type: 'string',
    //     enum: ['v1', 'v2', 'v3'],
    //     default: 'v1'
    //   }
    // })
    .addSecurityRequirements('access-token')
    .addSecurityRequirements('google-oauth2')
    .build();
exports.swaggerCustomOptions = {
    explorer: true,
    customSiteTitle: 'HR Management System',
    customCssUrl: '/swagger/theme-flattop.css',
    customCss: '',
    customJs: '',
    customfavIcon: '',
    swaggerOptions: {
        persistAuthorization: true,
        docExpansion: 'none',
        filter: true,
        displayRequestDuration: true,
        supportedSubmitMethods: ['get', 'put', 'post', 'delete', 'options', 'head', 'patch', 'trace'],
        // Disable CSP
        defaultModelsExpandDepth: -1,
        defaultModelExpandDepth: 1,
        csp: false, // This disables Content Security Policy
        tagGroups: [
            {
                name: 'Account Management',
                tags: ['Auth', 'Users', 'Profile', 'Sessions'],
            },
            {
                name: 'Employee Management',
                tags: ['Employees', 'Roles', 'Permissions'],
            }
        ]
    }
};


/***/ }),

/***/ "./src/database/data-source.ts":
/*!*************************************!*\
  !*** ./src/database/data-source.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dataSourceOptions = void 0;
const profile_entity_1 = __webpack_require__(/*! @/modules/account-management/profiles/entities/profile.entity */ "./src/modules/account-management/profiles/entities/profile.entity.ts");
const address_entity_1 = __webpack_require__(/*! @/modules/addresses/entities/address.entity */ "./src/modules/addresses/entities/address.entity.ts");
const document_type_entity_1 = __webpack_require__(/*! @/modules/documents/document-types/entities/document-type.entity */ "./src/modules/documents/document-types/entities/document-type.entity.ts");
const alternative_schedule_entity_1 = __webpack_require__(/*! @/modules/shift-management/schedules/schedule-change-requests/entities/alternative-schedule.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/entities/alternative-schedule.entity.ts");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const dotenv_1 = __webpack_require__(/*! dotenv */ "dotenv");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
(0, dotenv_1.config)();
const configService = new config_1.ConfigService();
const isProduction = configService.get('NODE_ENV') === 'production';
exports.dataSourceOptions = {
    type: 'mysql',
    host: configService.get('DB_HOST'),
    port: parseInt(configService.get('DB_PORT') || '3306', 10),
    username: configService.get('DB_USERNAME'),
    password: configService.get('DB_PASSWORD'),
    database: configService.get('DB_DATABASE'),
    entities: ['dist/**/*.entity{.ts,.js}', address_entity_1.Address, profile_entity_1.Profile, document_type_entity_1.DocumentType, alternative_schedule_entity_1.AlternativeSchedule],
    migrations: ['dist/database/migrations/*{.ts,.js}'],
    synchronize: !isProduction,
    logging: false,
    ssl: isProduction,
    extra: {
        ssl: isProduction ? { rejectUnauthorized: false } : null,
    },
};
exports["default"] = new typeorm_1.DataSource(exports.dataSourceOptions);


/***/ }),

/***/ "./src/database/database.module.ts":
/*!*****************************************!*\
  !*** ./src/database/database.module.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DatabaseModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const data_source_1 = __webpack_require__(/*! ./data-source */ "./src/database/data-source.ts");
let DatabaseModule = class DatabaseModule {
};
exports.DatabaseModule = DatabaseModule;
exports.DatabaseModule = DatabaseModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forRootAsync({
                imports: [config_1.ConfigModule],
                inject: [config_1.ConfigService],
                useFactory: (configService) => (Object.assign(Object.assign({}, data_source_1.dataSourceOptions), { autoLoadEntities: true })),
            }),
        ],
    })
], DatabaseModule);


/***/ }),

/***/ "./src/database/entities/base.entity.ts":
/*!**********************************************!*\
  !*** ./src/database/entities/base.entity.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseEntity = void 0;
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
class BaseEntity extends typeorm_1.BaseEntity {
    constructor(item) {
        super();
        Object.assign(this, item);
    }
}
exports.BaseEntity = BaseEntity;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)('uuid'),
    __metadata("design:type", String)
], BaseEntity.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ type: 'timestamp' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], BaseEntity.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], BaseEntity.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BaseEntity.prototype, "createdBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BaseEntity.prototype, "updatedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], BaseEntity.prototype, "isDeleted", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BaseEntity.prototype, "deletedBy", void 0);
__decorate([
    (0, typeorm_1.DeleteDateColumn)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], BaseEntity.prototype, "deletedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    (0, typeorm_1.Index)("idx_organization"),
    __metadata("design:type", String)
], BaseEntity.prototype, "organizationId", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    (0, typeorm_1.Index)("idx_branch"),
    __metadata("design:type", String)
], BaseEntity.prototype, "branchId", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    (0, typeorm_1.Index)("idx_department"),
    __metadata("design:type", String)
], BaseEntity.prototype, "departmentId", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    (0, typeorm_1.Index)("idx_user"),
    __metadata("design:type", String)
], BaseEntity.prototype, "userId", void 0);


/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const api_1 = __webpack_require__(/*! @bull-board/api */ "@bull-board/api");
const bullAdapter_1 = __webpack_require__(/*! @bull-board/api/bullAdapter */ "@bull-board/api/bullAdapter"); // Correct import
const express_1 = __webpack_require__(/*! @bull-board/express */ "@bull-board/express"); // Correct import
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const nestjs_api_reference_1 = __webpack_require__(/*! @scalar/nestjs-api-reference */ "@scalar/nestjs-api-reference");
const compression_1 = __importDefault(__webpack_require__(/*! compression */ "compression"));
const express_rate_limit_1 = __importDefault(__webpack_require__(/*! express-rate-limit */ "express-rate-limit"));
const helmet_1 = __importDefault(__webpack_require__(/*! helmet */ "helmet"));
const app_module_1 = __webpack_require__(/*! ./app.module */ "./src/app.module.ts");
const http_exception_filter_1 = __webpack_require__(/*! ./common/filters/http-exception.filter */ "./src/common/filters/http-exception.filter.ts");
const transform_interceptor_1 = __webpack_require__(/*! ./common/interceptors/transform.interceptor */ "./src/common/interceptors/transform.interceptor.ts");
const day_util_1 = __webpack_require__(/*! ./common/utils/day.util */ "./src/common/utils/day.util.ts");
const swagger_config_1 = __webpack_require__(/*! ./config/swagger.config */ "./src/config/swagger.config.ts");
const system_logger_service_1 = __webpack_require__(/*! ./modules/logs/system-logs/services/system-logger.service */ "./src/modules/logs/system-logs/services/system-logger.service.ts");
// process.env.TZ = 'UTC';
async function bootstrap() {
    const isDevelopment = process.env.NODE_ENV !== 'production';
    // Create the app with our custom logger
    const app = await core_1.NestFactory.create(app_module_1.AppModule, {
        logger: (0, day_util_1.getLogLevels)(isDevelopment),
        bufferLogs: true, // Buffer logs until logger is set up
    });
    // Get the SystemLogger from our module
    const logger = await app.resolve(system_logger_service_1.SystemLogger);
    app.useLogger(logger);
    const configService = app.get(config_1.ConfigService);
    // Dynamically get all queues from the queues.config.ts
    const { queues } = await Promise.resolve().then(() => __importStar(__webpack_require__(/*! ./config/queues.config */ "./src/config/queues.config.ts")));
    // Set up Bull Board
    const serverAdapter = new express_1.ExpressAdapter();
    const bullAdapters = queues.map(queue => new bullAdapter_1.BullAdapter(app.get((0, bull_1.getQueueToken)(queue.name))));
    (0, api_1.createBullBoard)({
        queues: bullAdapters,
        serverAdapter,
    });
    // Define the base path for Bull Board UI
    serverAdapter.setBasePath('/api/admin/queues');
    const port = configService.getOrThrow('PORT');
    const appUrl = configService.getOrThrow('APP_URL');
    const corsOrigins = configService.getOrThrow('CORS_ORIGINS');
    // Rate Limit Settings
    const rateLimitWindowMs = configService.getOrThrow('RATE_LIMIT_WINDOW_MS');
    const rateLimitMax = configService.getOrThrow('RATE_LIMIT_MAX');
    // Set global prefix for all routes in the application
    app.setGlobalPrefix('/api');
    // Add Bull Board UI routes - place this AFTER helmet and BEFORE other routes
    app.use('/api/admin/queues', serverAdapter.getRouter());
    // Global validation pipe
    app.useGlobalPipes(new common_1.ValidationPipe({
        whitelist: true, // Strip properties that do not have any decorators
        forbidNonWhitelisted: true, // Throw an error if non-whitelisted properties are present
        transform: true, // Automatically transform payloads to be objects typed according to their DTO classes
        transformOptions: {
            enableImplicitConversion: true, // Allow implicit type conversion
        },
    }));
    // Global exception filter
    app.useGlobalFilters(new http_exception_filter_1.HttpExceptionFilter());
    // Global logging interceptor (using our new logging interceptor)
    // app.useGlobalInterceptors(new LoggingInterceptor());
    // Global transform interceptor
    app.useGlobalInterceptors(new transform_interceptor_1.TransformInterceptor());
    // Enable CORS with more secure settings
    app.enableCors({
        origin: true, // specify allowed origins
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE', // specify allowed HTTP methods
        credentials: true, // allow sending cookies from the frontend to the backend (for session cookies)
    });
    // Use Helmet for security with best practices
    app.use((0, helmet_1.default)()); // Sets appropriate HTTP headers for security
    app.use(helmet_1.default.referrerPolicy({ policy: 'no-referrer' })); // when following a link, do not send the Referer header to other sites (privacy)
    // Rate limiting
    app.use((0, express_rate_limit_1.default)({
        windowMs: rateLimitWindowMs, // 15 * 60 * 1000, // 15 minutes
        max: rateLimitMax, // limit each IP to 100 requests per windowMs
        message: 'Too many requests from this IP, please try again later.',
        headers: true,
    }));
    app.use((req, res, next) => {
        res.removeHeader('Cross-Origin-Opener-Policy');
        res.removeHeader('Origin-Agent-Cluster');
        res.removeHeader('Content-Security-Policy');
        next();
    });
    // Compression middleware
    app.use((0, compression_1.default)()); // Compress all responses to reduce the size of the response body and increase the speed of a web application
    // HTTP request logger
    // app.use(morgan('combined')); // Log HTTP requests with the Apache combined format (combined is the most common format) to the console
    // Swagger Setup
    const document = swagger_1.SwaggerModule.createDocument(app, swagger_config_1.swaggerConfig); // Create a Swagger document
    swagger_1.SwaggerModule.setup('api', app, document, swagger_config_1.swaggerCustomOptions); // Set up the Swagger module
    // Scalar Setup
    app.use('/reference', (0, nestjs_api_reference_1.apiReference)({
        content: document,
    }));
    await app.listen(port, '0.0.0.0'); // Listen on all network interfaces (LAN)
    logger.log(`Application is running on: ${appUrl}/api`, 'Main');
    logger.log(`API Reference available at: ${appUrl}/reference`, 'Main');
    logger.log(`Queue monitoring available at: ${appUrl}/api/admin/queues`, 'Main');
}
bootstrap();


/***/ }),

/***/ "./src/modules/account-management/account-management.module.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/account-management/account-management.module.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccountManagementModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const employee_management_module_1 = __webpack_require__(/*! ../employee-management/employee-management.module */ "./src/modules/employee-management/employee-management.module.ts");
const roles_module_1 = __webpack_require__(/*! ../employee-management/roles/roles.module */ "./src/modules/employee-management/roles/roles.module.ts");
const auth_module_1 = __webpack_require__(/*! ./auth/auth.module */ "./src/modules/account-management/auth/auth.module.ts");
const profiles_module_1 = __webpack_require__(/*! ./profiles/profiles.module */ "./src/modules/account-management/profiles/profiles.module.ts");
const user_seeder_service_1 = __webpack_require__(/*! ./services/user-seeder.service */ "./src/modules/account-management/services/user-seeder.service.ts");
const sessions_module_1 = __webpack_require__(/*! ./sessions/sessions.module */ "./src/modules/account-management/sessions/sessions.module.ts");
const users_module_1 = __webpack_require__(/*! ./users/users.module */ "./src/modules/account-management/users/users.module.ts");
let AccountManagementModule = class AccountManagementModule {
};
exports.AccountManagementModule = AccountManagementModule;
exports.AccountManagementModule = AccountManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            roles_module_1.RolesModule,
            auth_module_1.AuthModule,
            sessions_module_1.SessionsModule,
            profiles_module_1.ProfilesModule,
            employee_management_module_1.EmployeeManagementModule,
            core_1.RouterModule.register([
                {
                    path: 'account',
                    module: AccountManagementModule,
                    children: [
                        { path: 'auth', module: auth_module_1.AuthModule },
                        { path: 'users', module: users_module_1.UsersModule },
                        {
                            path: 'profiles',
                            module: profiles_module_1.ProfilesModule
                        },
                        { path: 'sessions', module: sessions_module_1.SessionsModule },
                    ],
                },
            ]),
        ],
        providers: [user_seeder_service_1.UserSeederService],
        exports: [
            auth_module_1.AuthModule,
            sessions_module_1.SessionsModule,
            profiles_module_1.ProfilesModule
        ]
    })
], AccountManagementModule);


/***/ }),

/***/ "./src/modules/account-management/auth/auth.controller.ts":
/*!****************************************************************!*\
  !*** ./src/modules/account-management/auth/auth.controller.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var AuthController_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthController = void 0;
const authorize_decorator_1 = __webpack_require__(/*! @/common/decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const current_user_decorator_1 = __webpack_require__(/*! @/common/decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const generic_api_responses_decorator_1 = __webpack_require__(/*! @/common/decorators/generic-api-responses.decorator */ "./src/common/decorators/generic-api-responses.decorator.ts");
const generalresponse_dto_1 = __webpack_require__(/*! @/common/dtos/generalresponse.dto */ "./src/common/dtos/generalresponse.dto.ts");
const jwt_payload_interface_1 = __webpack_require__(/*! @/common/interfaces/jwt-payload.interface */ "./src/common/interfaces/jwt-payload.interface.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const express_1 = __webpack_require__(/*! express */ "express");
const google_auth_guard_1 = __webpack_require__(/*! ../../../common/guards/google-auth.guard */ "./src/common/guards/google-auth.guard.ts");
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/modules/account-management/users/users.service.ts");
const auth_service_1 = __webpack_require__(/*! ./auth.service */ "./src/modules/account-management/auth/auth.service.ts");
const login_response_dto_1 = __webpack_require__(/*! ./dto/login-response.dto */ "./src/modules/account-management/auth/dto/login-response.dto.ts");
const login_user_dto_1 = __webpack_require__(/*! ./dto/login-user.dto */ "./src/modules/account-management/auth/dto/login-user.dto.ts");
const register_user_dto_1 = __webpack_require__(/*! ./dto/register-user.dto */ "./src/modules/account-management/auth/dto/register-user.dto.ts");
const token_dto_1 = __webpack_require__(/*! ./dto/token.dto */ "./src/modules/account-management/auth/dto/token.dto.ts");
let AuthController = AuthController_1 = class AuthController {
    constructor(authService, configService, usersService) {
        this.authService = authService;
        this.configService = configService;
        this.usersService = usersService;
        this.logger = new common_1.Logger(AuthController_1.name);
    }
    async googleOAuth() { }
    async login(loginDto, request, response) {
        const login = await this.authService.loginUser(loginDto, request);
        await this.authService.setAuthCookies(response, login);
        return login;
    }
    async verifyEmail(body) {
        const result = await this.authService.verifyEmail(body.token);
        return {
            statusCode: result ? 200 : 400,
            message: result
                ? 'Email verified successfully'
                : 'Invalid or expired verification token',
        };
    }
    async resendVerification(body) {
        const user = await this.usersService.findOneByOrFail({ email: body.email });
        if (user.emailVerified) {
            return {
                message: 'Email is already verified',
            };
        }
        const result = await this.authService.sendVerificationEmail(user);
        return {
            message: result
                ? 'Verification email sent successfully'
                : 'Failed to send verification email',
        };
    }
    async googleCallback(request, response) {
        try {
            const socialUser = request.user;
            if (!socialUser) {
                throw new common_1.UnauthorizedException('Authentication failed');
            }
            const tokens = await this.authService.googleOAuth(socialUser);
            await this.authService.setAuthCookies(response, tokens);
            // Redirect to frontend with success
            const redirectUrl = new URL(`${this.configService.get('APP_URL')}/login`);
            redirectUrl.searchParams.set('auth', 'success');
            return response.redirect(redirectUrl.toString());
        }
        catch (error) {
            this.logger.error(`Google OAuth callback failed: ${error.message}`);
            // Redirect to frontend with error
            const redirectUrl = new URL(`${this.configService.get('APP_URL')}/login`);
            redirectUrl.searchParams.set('auth', 'failed');
            redirectUrl.searchParams.set('error', 'Authentication failed');
            return response.redirect(redirectUrl.toString());
        }
    }
    async refreshToken(bodyRefreshToken, request, response) {
        var _a;
        // Get refresh token from cookies or request body
        const refreshToken = ((_a = request.cookies) === null || _a === void 0 ? void 0 : _a.refreshToken) ||
            bodyRefreshToken;
        if (!refreshToken) {
            throw new common_1.UnauthorizedException('Refresh token not found');
        }
        const tokens = await this.authService.refreshTokens(refreshToken, request);
        await this.authService.setAuthCookies(response, tokens);
        return tokens;
    }
    async logout(bodyRefreshToken, request, response) {
        var _a;
        // Get refresh token from cookies or request body
        const refreshToken = ((_a = request.cookies) === null || _a === void 0 ? void 0 : _a.refreshToken) ||
            bodyRefreshToken;
        if (!refreshToken) {
            throw new common_1.UnauthorizedException('Refresh token not found');
        }
        await this.authService.logoutUser(refreshToken, response);
        return { message: 'Logged out successfully' };
    }
    async register(registerDto) {
        await this.authService.registerUser(registerDto);
        return {
            statusCode: 201,
            message: 'Account created successfully. Please check your email to verify your account.',
        };
    }
    // @Get('google')
    // @UseGuards(GoogleAuthGuard)
    // @ApiOperation({ summary: 'Login with Google' })
    // @ApiResponse({ status: 200, description: 'Redirect to Google login.' })
    // async googleAuth(@Request() req) {}
    // @Get('google/redirect')
    // @UseGuards(GoogleAuthGuard)
    // @ApiOperation({ summary: 'Google login redirect' })
    // @ApiResponse({ status: 200, description: 'User logged in with Google successfully.' })
    // googleAuthRedirect(@Request() req) {
    //   return this.authService.googleLogin(req);
    // }
    getCurrentUser(user) {
        return user;
    }
};
exports.AuthController = AuthController;
__decorate([
    (0, common_1.Get)('google'),
    (0, common_1.UseGuards)(google_auth_guard_1.GoogleAuthGuard),
    (0, swagger_1.ApiOperation)({ summary: 'Login with Google' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Redirect to Google login.' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "googleOAuth", null);
__decorate([
    (0, common_1.Post)('login'),
    (0, swagger_1.ApiOperation)({ summary: 'Login with email and password' }),
    (0, swagger_1.ApiBody)({
        description: 'User login credentials',
        type: login_user_dto_1.LoginUserDto,
        required: true,
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized - Invalid credentials', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'Forbidden - User is not active', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad Request - Invalid input', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Not Found - User not found', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal Server Error', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User logged in successfully.', type: login_response_dto_1.LoginResponseDto }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, common_1.Res)({ passthrough: true })),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof login_user_dto_1.LoginUserDto !== "undefined" && login_user_dto_1.LoginUserDto) === "function" ? _d : Object, typeof (_e = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _e : Object, typeof (_f = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "login", null);
__decorate([
    (0, common_1.Post)('verify-email'),
    (0, swagger_1.ApiOperation)({
        summary: 'Verify user email address',
        description: 'Validates the verification token and marks the user\'s email as verified if valid'
    }),
    (0, swagger_1.ApiBody)({
        description: 'Verification token received in the email',
        type: token_dto_1.TokenDto,
        required: true,
        examples: {
            example1: {
                value: { token: 'your-verification-token' },
                description: 'Example of a verification token',
            },
        },
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Email verified successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Invalid or expired verification token',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'User not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 500,
        description: 'Internal Server Error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 403,
        description: 'Forbidden - User is not active',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 401,
        description: 'Unauthorized - Invalid credentials',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_g = typeof token_dto_1.TokenDto !== "undefined" && token_dto_1.TokenDto) === "function" ? _g : Object]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], AuthController.prototype, "verifyEmail", null);
__decorate([
    (0, common_1.Post)('resend-verification'),
    (0, swagger_1.ApiOperation)({ summary: 'Resend email verification link' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Verification email sent successfully.' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Email is already verified' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User not found' }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal Server Error' }),
    (0, swagger_1.ApiBody)({
        description: 'Email address to resend verification link',
        type: token_dto_1.TokenDto,
        required: true,
        examples: {
            example1: {
                value: { email: 'jyrrahcc@gmail.com' },
                description: 'Example of an email address',
            },
        },
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], AuthController.prototype, "resendVerification", null);
__decorate([
    (0, common_1.Get)('google/redirect'),
    (0, common_1.UseGuards)(google_auth_guard_1.GoogleAuthGuard),
    (0, swagger_1.ApiOperation)({ summary: 'Google OAuth callback' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User logged in with Google successfully.' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized - Authentication failed' }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal Server Error' }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'Forbidden - User is not active' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User not found' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad Request - Invalid input' }),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_k = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _k : Object, typeof (_l = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _l : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "googleCallback", null);
__decorate([
    (0, common_1.Post)('refresh'),
    (0, swagger_1.ApiOperation)({ summary: 'Refresh access token using refresh token' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                refreshToken: {
                    type: 'string',
                    description: 'Refresh token (optional if provided in cookies)',
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Access token refreshed successfully.' }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'Forbidden - User is not active' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User not found' }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal Server Error' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized - Refresh token not found or invalid' }),
    __param(0, (0, common_1.Body)('refreshToken', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, common_1.Res)({ passthrough: true })),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_m = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _m : Object, typeof (_o = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _o : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "refreshToken", null);
__decorate([
    (0, common_1.Post)('logout'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Logout user' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                refreshToken: {
                    type: 'string',
                    description: 'Refresh token (optional if provided in cookies)',
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User logged out successfully.' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized - Refresh token not found or invalid' }),
    __param(0, (0, common_1.Body)('refreshToken')),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, common_1.Res)({ passthrough: true })),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_p = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _p : Object, typeof (_q = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _q : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "logout", null);
__decorate([
    (0, common_1.Post)('register'),
    (0, swagger_1.ApiOperation)({ summary: 'Register a new user' }),
    (0, swagger_1.ApiBody)({
        description: 'User registration details',
        type: register_user_dto_1.RegisterUserDto,
        required: true,
    }),
    (0, generic_api_responses_decorator_1.ApiCreateResponses)('User', generalresponse_dto_1.GeneralResponseDto),
    (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_r = typeof register_user_dto_1.RegisterUserDto !== "undefined" && register_user_dto_1.RegisterUserDto) === "function" ? _r : Object]),
    __metadata("design:returntype", typeof (_s = typeof Promise !== "undefined" && Promise) === "function" ? _s : Object)
], AuthController.prototype, "register", null);
__decorate([
    (0, common_1.Get)('me'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get current authenticated user' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Return authenticated user details',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 401,
        description: 'Unauthorized - Invalid token',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 403,
        description: 'Forbidden',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_t = typeof jwt_payload_interface_1.IJwtPayload !== "undefined" && jwt_payload_interface_1.IJwtPayload) === "function" ? _t : Object]),
    __metadata("design:returntype", void 0)
], AuthController.prototype, "getCurrentUser", null);
exports.AuthController = AuthController = AuthController_1 = __decorate([
    (0, swagger_1.ApiTags)('Auth'),
    (0, common_1.Controller)(),
    __metadata("design:paramtypes", [typeof (_a = typeof auth_service_1.AuthService !== "undefined" && auth_service_1.AuthService) === "function" ? _a : Object, typeof (_b = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _b : Object, typeof (_c = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _c : Object])
], AuthController);


/***/ }),

/***/ "./src/modules/account-management/auth/auth.module.ts":
/*!************************************************************!*\
  !*** ./src/modules/account-management/auth/auth.module.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthModule = void 0;
const google_auth_guard_1 = __webpack_require__(/*! @/common/guards/google-auth.guard */ "./src/common/guards/google-auth.guard.ts");
const emails_module_1 = __webpack_require__(/*! @/modules/emails/emails.module */ "./src/modules/emails/emails.module.ts");
const permissions_module_1 = __webpack_require__(/*! @/modules/employee-management/roles/permissions/permissions.module */ "./src/modules/employee-management/roles/permissions/permissions.module.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const jwt_1 = __webpack_require__(/*! @nestjs/jwt */ "@nestjs/jwt");
const passport_1 = __webpack_require__(/*! @nestjs/passport */ "@nestjs/passport");
const jwt_auth_guard_1 = __webpack_require__(/*! ../../../common/guards/jwt-auth.guard */ "./src/common/guards/jwt-auth.guard.ts");
const permissions_guard_1 = __webpack_require__(/*! ../../../common/guards/permissions.guard */ "./src/common/guards/permissions.guard.ts");
const roles_guard_1 = __webpack_require__(/*! ../../../common/guards/roles.guard */ "./src/common/guards/roles.guard.ts");
const sessions_module_1 = __webpack_require__(/*! ../sessions/sessions.module */ "./src/modules/account-management/sessions/sessions.module.ts");
const auth_controller_1 = __webpack_require__(/*! ./auth.controller */ "./src/modules/account-management/auth/auth.controller.ts");
const auth_service_1 = __webpack_require__(/*! ./auth.service */ "./src/modules/account-management/auth/auth.service.ts");
const jwt_service_1 = __webpack_require__(/*! ./services/jwt.service */ "./src/modules/account-management/auth/services/jwt.service.ts");
const access_token_strategy_1 = __webpack_require__(/*! ./strategies/access-token.strategy */ "./src/modules/account-management/auth/strategies/access-token.strategy.ts");
const google_strategy_1 = __webpack_require__(/*! ./strategies/google.strategy */ "./src/modules/account-management/auth/strategies/google.strategy.ts");
let AuthModule = class AuthModule {
};
exports.AuthModule = AuthModule;
exports.AuthModule = AuthModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            passport_1.PassportModule.register({ defaultStrategy: 'jwt' }),
            sessions_module_1.SessionsModule,
            permissions_module_1.PermissionsModule,
            jwt_1.JwtModule.registerAsync({
                imports: [config_1.ConfigModule],
                inject: [config_1.ConfigService],
                useFactory: async (configService) => ({
                    secret: configService.get('ACCESS_TOKEN_SECRET'),
                    signOptions: { expiresIn: `${configService.get('ACCESS_TOKEN_EXPIRATION_MINUTES')}m` },
                }),
            }),
            emails_module_1.EmailsModule,
        ],
        providers: [auth_service_1.AuthService, jwt_service_1.JwtService, access_token_strategy_1.AccessTokenStrategy, google_strategy_1.GoogleStrategy, jwt_auth_guard_1.JwtAuthGuard, google_auth_guard_1.GoogleAuthGuard, permissions_guard_1.PermissionsGuard, roles_guard_1.RolesGuard],
        controllers: [auth_controller_1.AuthController],
        exports: [auth_service_1.AuthService, jwt_service_1.JwtService],
    })
], AuthModule);


/***/ }),

/***/ "./src/modules/account-management/auth/auth.service.ts":
/*!*************************************************************!*\
  !*** ./src/modules/account-management/auth/auth.service.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AuthService_1;
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthService = void 0;
const utility_helper_1 = __webpack_require__(/*! @/common/helpers/utility.helper */ "./src/common/helpers/utility.helper.ts");
const common_service_1 = __webpack_require__(/*! @/common/services/common.service */ "./src/common/services/common.service.ts");
const emails_service_1 = __webpack_require__(/*! @/modules/emails/emails.service */ "./src/modules/emails/emails.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const bcrypt = __importStar(__webpack_require__(/*! bcrypt */ "bcrypt"));
const uuid_1 = __webpack_require__(/*! uuid */ "uuid");
const sessions_service_1 = __webpack_require__(/*! ../sessions/sessions.service */ "./src/modules/account-management/sessions/sessions.service.ts");
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/modules/account-management/users/users.service.ts");
const jwt_service_1 = __webpack_require__(/*! ./services/jwt.service */ "./src/modules/account-management/auth/services/jwt.service.ts");
let AuthService = AuthService_1 = class AuthService {
    constructor(usersService, jwtService, configService, commonService, sessionsService, emailsService) {
        this.usersService = usersService;
        this.jwtService = jwtService;
        this.configService = configService;
        this.commonService = commonService;
        this.sessionsService = sessionsService;
        this.emailsService = emailsService;
        this.logger = new common_1.Logger(AuthService_1.name);
        this.VERIFICATION_TOKEN_EXPIRATION_HOURS = 24; // 24 hours
        this.commonCookieOptions = {
            httpOnly: true,
            secure: this.commonService.isProduction(),
            // sameSite: 'lax',
            maxAge: this.configService.getOrThrow('ACCESS_TOKEN_EXPIRATION_MINUTES') * 60 * 1000,
        };
    }
    async googleOAuth(socialUser) {
        var _a, _b, _c;
        const { email, providerId, firstName, lastName, picture } = socialUser;
        this.logger.log(`Processing OAuth login for ${email}`);
        // Find user by email or create if not exists
        let user = await this.usersService.findOneBy({ email });
        if (!user) {
            // Create a new user with data from Google
            const newUser = await this.usersService.create({
                email,
                profile: {
                    firstName: firstName || '',
                    lastName: lastName || '',
                    profilePicture: picture || '',
                },
                emailVerified: true, // Social logins are considered verified
                password: await bcrypt.hash((0, uuid_1.v4)(), 10), // Generate random password
            });
            user = await this.usersService.save(newUser);
            this.logger.log(`Created new user from Google OAuth: ${user.id}`);
        }
        else {
            // Update user information if needed
            let needsUpdate = false;
            if (!((_a = user.profile) === null || _a === void 0 ? void 0 : _a.firstName) && firstName) {
                user.profile.firstName = firstName;
                needsUpdate = true;
            }
            if (!((_b = user.profile) === null || _b === void 0 ? void 0 : _b.lastName) && lastName) {
                user.profile.lastName = lastName;
                needsUpdate = true;
            }
            if (!((_c = user.profile) === null || _c === void 0 ? void 0 : _c.profilePicture) && picture) {
                user.profile.profilePicture = picture;
                needsUpdate = true;
            }
            if (needsUpdate) {
                await this.usersService.save(user);
            }
        }
        // Create refresh token and access token
        const refreshToken = await this.jwtService.createRefreshToken();
        const payload = this.jwtService.createPayload(user, refreshToken);
        const accessToken = await this.jwtService.createToken(payload);
        // Save session information
        await this.sessionsService.create({
            refreshToken,
            user: { id: user.id },
            expiresAt: new Date(Date.now() + this.configService.getOrThrow('REFRESH_TOKEN_EXPIRATION_MINUTES') * 60 * 1000),
            userAgent: 'Google OAuth',
            ipAddress: 'OAuth Flow'
        });
        return {
            accessToken,
        };
    }
    // Add this method for sending verification emails
    async sendVerificationEmail(user) {
        var _a, _b;
        // Generate verification token (you may want to store this in the user record)
        const verificationToken = (0, uuid_1.v4)();
        // Store the token in the user record with an expiration
        user.verificationToken = verificationToken;
        user.verificationTokenExpires = new Date(Date.now() + this.VERIFICATION_TOKEN_EXPIRATION_HOURS * 60 * 60 * 1000); // 24 hours
        await this.usersService.update(user.id, user);
        // Build verification URL
        const baseUrl = this.configService.getOrThrow('FRONTEND_URL');
        const verificationUrl = `${baseUrl}/verify-email?token=${verificationToken}`;
        // Send the email
        return this.emailsService.sendTemplatedEmail(user.email, 'email-verification', {
            firstName: ((_a = user.profile) === null || _a === void 0 ? void 0 : _a.firstName) || 'User',
            lastName: (_b = user.profile) === null || _b === void 0 ? void 0 : _b.lastName,
            verificationUrl,
            expiry: this.VERIFICATION_TOKEN_EXPIRATION_HOURS,
        });
    }
    async validateUser(model) {
        // check if emailOrUserName property is an email
        var user = null;
        if (utility_helper_1.UtilityHelper.isEmail(model.emailOrUserName)) {
            // check if email exists
            user = await this.usersService.findOneBy({ email: model.emailOrUserName.toLowerCase().trim() }, { relations: { employee: { roles: { organization: true, branch: true, department: true } } } });
            if (!user) {
                return null;
            }
        }
        else {
            // check if username exists
            user = await this.usersService.findOneBy({ userName: model.emailOrUserName.toLowerCase().trim() }, { relations: { employee: { roles: { organization: true, branch: true, department: true } } } });
            if (!user) {
                return null;
            }
        }
        if (!user || !(await bcrypt.compare(model.password, user.password))) {
            return null;
        }
        return user;
    }
    //   /**
    //  * Validates a user from social authentication providers (Google, Facebook, etc.)
    //  * Handles user creation, updates, and generates authentication tokens.
    //  * 
    //  * @param socialUser User data received from the OAuth provider
    //  * @returns User entity with tokens
    //  */
    // async validateSocialUser(socialUser: ISocialUser): Promise<any> {
    //   const { email, provider, providerId, firstName, lastName, picture } = socialUser;
    //   this.logger.log(`Validating social user: ${email} from ${provider}`);
    //   // Start a transaction to ensure data consistency
    //   return await this.transactionService.executeInTransaction(async (manager) => {
    //     const userRepository = manager. y(User);
    //     // Try to find existing user by email
    //     let user = await userRepository.findOne({ 
    //       where: { email },
    //       relations: ['socialLogins'],
    //     });
    //     // Try to find by social provider ID if not found by email
    //     if (!user) {
    //       const socialLoginRepository = manager.getRepository(SocialLogin);
    //       const socialLogin = await socialLoginRepository.findOne({
    //         where: { provider, providerId },
    //         relations: ['user'],
    //       });
    //       if (socialLogin) {
    //         user = socialLogin.user;
    //       }
    //     }
    //     // If we found a user, update their information
    //     if (user) {
    //       this.logger.log(`Found existing user with email ${email}`);
    //       // Check if user is active
    //       if (user.isActive === false) {
    //         this.logger.warn(`User ${email} account is deactivated`);
    //         throw new UnauthorizedException('Your account has been deactivated');
    //       }
    //       // Ensure this social login is linked to the user's account
    //       const socialLoginRepository = manager.getRepository(SocialLogin);
    //       let socialLogin = await socialLoginRepository.findOne({
    //         where: { 
    //           user: { id: user.id },
    //           provider,
    //           providerId,
    //         },
    //       });
    //       // Link this social provider if not already linked
    //       if (!socialLogin) {
    //         socialLogin = socialLoginRepository.create({
    //           user,
    //           provider,
    //           providerId,
    //           lastLogin: new Date(),
    //         });
    //         await socialLoginRepository.save(socialLogin);
    //         this.logger.log(`Linked ${provider} account to existing user ${email}`);
    //       } else {
    //         // Update last login time
    //         socialLogin.lastLogin = new Date();
    //         await socialLoginRepository.save(socialLogin);
    //       }
    //     } 
    //     // Create new user if not found
    //     else {
    //       this.logger.log(`Creating new user for ${email} from ${provider}`);
    //       // Create user with data from social profile
    //       user = userRepository.create({
    //         email,
    //         firstName: firstName || '',
    //         lastName: lastName || '',
    //         profileImage: picture,
    //         isEmailVerified: true, // Social logins are considered verified
    //         lastLoginAt: new Date(),
    //       });
    //       // Try to auto-assign default role (e.g., "user")
    //       try {
    //         const roleRepository = manager.getRepository(Role);
    //         const userRole = await roleRepository.findOne({ 
    //           where: { name: 'user' } 
    //         });
    //         if (userRole) {
    //           user.roles = [userRole];
    //         }
    //       } catch (error) {
    //         this.logger.warn(`Could not assign default role to new user: ${error.message}`);
    //       }
    //       // Save the new user
    //       user = await userRepository.save(user);
    //       // Create social login record
    //       const socialLoginRepository = manager.getRepository(SocialLogin);
    //       const socialLogin = socialLoginRepository.create({
    //         user,
    //         provider,
    //         providerId,
    //         lastLogin: new Date(),
    //       });
    //       await socialLoginRepository.save(socialLogin);
    //     }
    //     // Update profile information if missing or incomplete
    //     let needsUpdate = false;
    //     if (!user.firstName && firstName) {
    //       user.firstName = firstName;
    //       needsUpdate = true;
    //     }
    //     if (!user.lastName && lastName) {
    //       user.lastName = lastName;
    //       needsUpdate = true;
    //     }
    //     if (!user.profileImage && picture) {
    //       user.profileImage = picture;
    //       needsUpdate = true;
    //     }
    //     if (needsUpdate) {
    //       await userRepository.save(user);
    //     }
    //     // Generate tokens for the user
    //     const tokens = await this.jwtService.generateTokens(user);
    //     // Return user with tokens
    //     return {
    //       user: this.usersService.sanitizeUser(user),
    //       ...tokens
    //     };
    //   });
    // }
    async registerUser(model) {
        // check if user already exists
        const existingEmail = await this.usersService.findOneBy({ email: model.email.toLowerCase().trim() });
        const existingUserName = await this.usersService.findOneBy({ userName: model.userName.toLowerCase().trim() });
        if (existingEmail) {
            // throw error if user already exists
            throw new common_1.ConflictException('Email is already used by another user.');
        }
        if (existingUserName) {
            // throw error if user already exists
            throw new common_1.ConflictException('Username is already used by another user.');
        }
        // create new user
        const user = await this.usersService.signUpUser(model);
        // can be decoupled to an event or queue
        await this.sendVerificationEmail(user).catch((error) => {
            this.logger.error('Failed to send verification email', error);
        });
        return user;
    }
    // Add a method to verify email
    async verifyEmail(token) {
        var _a, _b;
        const user = await this.usersService.findOneBy({ verificationToken: token });
        if (!user || !user.verificationTokenExpires) {
            return false;
        }
        // Check if token is expired
        if (user.verificationTokenExpires < new Date()) {
            return false;
        }
        // Mark email as verified
        user.emailVerified = true;
        user.verificationToken = undefined;
        user.verificationTokenExpires = undefined;
        await this.usersService.update(user.id, user);
        // Optionally send welcome email
        // can be decoupled
        this.emailsService.sendTemplatedEmail(user.email, 'welcome', {
            firstName: ((_a = user.profile) === null || _a === void 0 ? void 0 : _a.firstName) || 'User',
            lastName: (_b = user.profile) === null || _b === void 0 ? void 0 : _b.lastName,
            appName: this.configService.getOrThrow('APP_NAME'),
        }).catch(error => {
            this.logger.error(`Failed to send welcome email: ${error.message}`);
        });
        return true;
    }
    clearAuthCookies(response) {
        response.clearCookie('accessToken', this.commonCookieOptions);
        response.clearCookie('refreshToken', this.commonCookieOptions);
        return response;
    }
    setAuthCookies(response, tokens) {
        const accessTokenExpirationMinutes = this.configService.getOrThrow('ACCESS_TOKEN_EXPIRATION_MINUTES');
        const refreshTokenExpirationMinutes = this.configService.getOrThrow('REFRESH_TOKEN_EXPIRATION_MINUTES');
        // Set access token cookie
        response.cookie('accessToken', tokens.accessToken, Object.assign(Object.assign({}, this.commonCookieOptions), { maxAge: accessTokenExpirationMinutes * 60 * 1000 }));
        // response.cookie('refreshToken', tokens.refreshToken, {
        //   ...this.commonCookieOptions,
        //   maxAge: refreshTokenExpirationMinutes * 60 * 1000,
        // });
    }
    async logoutUser(refreshToken, response) {
        // Find the session with this refresh token
        const session = await this.sessionsService.findOneBy({ refreshToken });
        if (session) {
            // Update last active instead of deleting
            await this.sessionsService.update(session.id, {
                lastActiveAt: new Date(),
            });
        }
        // Clear auth cookies
        this.clearAuthCookies(response);
    }
    async refreshTokens(refreshToken, request) {
        const session = await this.sessionsService.findOneBy({ refreshToken }, {
            relations: {
                user: { employee: { roles: true } } // Include nested employee relation
            },
            order: { createdAt: 'DESC' }, // Get the newest session first
        });
        if (!session) {
            throw new common_1.UnauthorizedException('Session not found');
        }
        if (session.expiresAt && session.expiresAt < new Date()) {
            throw new common_1.UnauthorizedException('Refresh token expired');
        }
        // Check if user exists
        const user = session.user;
        if (!user) {
            throw new common_1.UnauthorizedException('User not found');
        }
        // Create new tokens
        const newRefreshToken = await this.jwtService.createRefreshToken();
        const newPayload = this.jwtService.createPayload(user, newRefreshToken);
        const accessToken = await this.jwtService.createToken(newPayload);
        // Calculate expiration time for refresh token
        const refreshTokenExpirationMinutes = this.configService.getOrThrow('REFRESH_TOKEN_EXPIRATION_MINUTES');
        const expiresAt = new Date();
        expiresAt.setMinutes(expiresAt.getMinutes() + refreshTokenExpirationMinutes * 2);
        // save refresh token to database
        await this.sessionsService.create({
            refreshToken,
            user: { id: user.id },
            expiresAt,
            userAgent: request === null || request === void 0 ? void 0 : request.headers['user-agent'],
            ipAddress: request === null || request === void 0 ? void 0 : request.ip,
            deviceId: Array.isArray(request === null || request === void 0 ? void 0 : request.headers['device-id'])
                ? request === null || request === void 0 ? void 0 : request.headers['device-id'][0]
                : request === null || request === void 0 ? void 0 : request.headers['device-id'],
        }, user.id);
        return {
            accessToken,
        };
    }
    // login user
    async loginUser(model, req) {
        var user = await this.validateUser(model);
        if (!user) {
            throw new common_1.UnauthorizedException('Invalid email or password');
        }
        if (user.emailVerified === false) {
            throw new common_1.UnauthorizedException('Email not verified');
        }
        const refreshToken = await this.jwtService.createRefreshToken();
        const payload = this.jwtService.createPayload(user, refreshToken);
        const accessToken = await this.jwtService.createToken(payload);
        // Calculate expiration time for refresh token
        const refreshTokenExpirationMinutes = this.configService.getOrThrow('REFRESH_TOKEN_EXPIRATION_MINUTES');
        const expiresAt = new Date();
        expiresAt.setMinutes(expiresAt.getMinutes() + refreshTokenExpirationMinutes * 2);
        // save refresh token to database
        await this.sessionsService.create({
            refreshToken,
            user: { id: user.id },
            expiresAt,
            userAgent: req === null || req === void 0 ? void 0 : req.headers['user-agent'],
            ipAddress: req === null || req === void 0 ? void 0 : req.ip,
            deviceId: Array.isArray(req === null || req === void 0 ? void 0 : req.headers['device-id'])
                ? req === null || req === void 0 ? void 0 : req.headers['device-id'][0]
                : req === null || req === void 0 ? void 0 : req.headers['device-id'],
        }, user.id);
        const response = {
            accessToken,
        };
        return response;
    }
};
exports.AuthService = AuthService;
exports.AuthService = AuthService = AuthService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _a : Object, typeof (_b = typeof jwt_service_1.JwtService !== "undefined" && jwt_service_1.JwtService) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object, typeof (_d = typeof common_service_1.CommonService !== "undefined" && common_service_1.CommonService) === "function" ? _d : Object, typeof (_e = typeof sessions_service_1.SessionsService !== "undefined" && sessions_service_1.SessionsService) === "function" ? _e : Object, typeof (_f = typeof emails_service_1.EmailsService !== "undefined" && emails_service_1.EmailsService) === "function" ? _f : Object])
], AuthService);


/***/ }),

/***/ "./src/modules/account-management/auth/dto/login-response.dto.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/account-management/auth/dto/login-response.dto.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoginResponseDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class LoginResponseDto {
}
exports.LoginResponseDto = LoginResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwiaWF0IjoxNjA5MjQ2MjUyLCJleHAiOjE2MDkyNTk0NTJ9.1eHJ4zZ1zr1v3r7w1eHJ4zZ1zr1v3r7w1eHJ4zZ1zr1v3r7w', description: 'The JWT token' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], LoginResponseDto.prototype, "accessToken", void 0);


/***/ }),

/***/ "./src/modules/account-management/auth/dto/login-user.dto.ts":
/*!*******************************************************************!*\
  !*** ./src/modules/account-management/auth/dto/login-user.dto.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoginUserDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class LoginUserDto {
}
exports.LoginUserDto = LoginUserDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'user@example.com', description: 'The email or username of the user' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_transformer_1.Expose)(),
    __metadata("design:type", String)
], LoginUserDto.prototype, "emailOrUserName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'password', description: 'The password of the user' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], LoginUserDto.prototype, "password", void 0);


/***/ }),

/***/ "./src/modules/account-management/auth/dto/register-user.dto.ts":
/*!**********************************************************************!*\
  !*** ./src/modules/account-management/auth/dto/register-user.dto.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RegisterUserDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const profile_dto_1 = __webpack_require__(/*! ../../profiles/dtos/profile.dto */ "./src/modules/account-management/profiles/dtos/profile.dto.ts");
class RegisterUserDto {
}
exports.RegisterUserDto = RegisterUserDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'user@example.com', description: 'The email of the user' }),
    (0, class_validator_1.IsEmail)({}, { message: 'Invalid email address' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_transformer_1.Expose)(),
    __metadata("design:type", String)
], RegisterUserDto.prototype, "email", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'user', description: 'The username of the user' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.Matches)(/^[a-z0-9.]+$/, { message: 'Username must contain only lowercase letters, numbers, and dots' }),
    (0, class_validator_1.MinLength)(5, { message: 'Username must be at least 5 characters long' }),
    (0, class_transformer_1.Expose)(),
    __metadata("design:type", String)
], RegisterUserDto.prototype, "userName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'password', description: 'The password of the user' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MinLength)(8, { message: 'Password must be at least 8 characters long' }),
    (0, class_validator_1.Matches)(/(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W)/, { message: 'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character' }),
    __metadata("design:type", String)
], RegisterUserDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'password', description: 'The password confirmation' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MinLength)(8, { message: 'Confirm Password must be at least 8 characters long' }),
    (0, class_validator_1.Matches)(/(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W)/, { message: 'Confirm Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character' }),
    (0, class_validator_1.ValidateIf)((o) => o.password === o.confirmPassword, { message: 'Passwords do not match' }),
    __metadata("design:type", String)
], RegisterUserDto.prototype, "confirmPassword", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Profile information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Type)(() => profile_dto_1.ProfileDto),
    __metadata("design:type", typeof (_a = typeof profile_dto_1.ProfileDto !== "undefined" && profile_dto_1.ProfileDto) === "function" ? _a : Object)
], RegisterUserDto.prototype, "profile", void 0);


/***/ }),

/***/ "./src/modules/account-management/auth/dto/token.dto.ts":
/*!**************************************************************!*\
  !*** ./src/modules/account-management/auth/dto/token.dto.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class TokenDto {
}
exports.TokenDto = TokenDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier token',
        example: '123e4567-e89b-12d3-a456-426614174000',
        required: true
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsUUID)('4'),
    __metadata("design:type", String)
], TokenDto.prototype, "token", void 0);


/***/ }),

/***/ "./src/modules/account-management/auth/services/jwt.service.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/account-management/auth/services/jwt.service.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var JwtService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JwtService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const jwt_1 = __webpack_require__(/*! @nestjs/jwt */ "@nestjs/jwt");
const uuid_1 = __webpack_require__(/*! uuid */ "uuid");
/**
 * Service responsible for JWT (JSON Web Token) operations.
 * Provides methods for creating, verifying, and decoding JWT tokens,
 * as well as managing JWT payloads.
 */
/**
 * @class JwtService
 * @injectable
 */
/**
 * @constructor
 * @param {NestJwtService} jwtService - The NestJS JWT service instance
 */
/**
 * Creates a JWT token from the provided payload
 * @method createToken
 * @param {IJwtPayload} payload - The payload to be encoded in the JWT
 * @returns {Promise<string>} A Promise that resolves to the JWT string
 */
/**
 * Verifies and decodes a JWT token
 * @method verifyToken
 * @param {string} token - The JWT token to verify
 * @returns {Promise<IJwtPayload>} A Promise that resolves to the decoded payload
 * @throws {Error} If the token is invalid or expired
 */
/**
 * Decodes a JWT token without verifying its signature
 * @method decodeToken
 * @param {string} token - The JWT token to decode
 * @returns {Promise<IJwtPayload>} A Promise that resolves to the decoded payload
 */
/**
 * Creates a standard JWT payload with common claims
 * @method createPayload
 * @param {string} userId - The user's unique identifier
 * @param {string} [email] - Optional email address
 * @param {string[]} [roles] - Optional array of user roles
 * @returns {IJwtPayload} The formatted JWT payload
 */
/**
 * Validates the structure of a JWT payload
 * @method validatePayload
 * @param {any} payload - The payload to validate
 * @returns {boolean} True if the payload matches the IJwtPayload structure
 */
/**
 * Service responsible for handling JSON Web Token (JWT) operations.
 * Provides functionality for creating, verifying, and decoding JWT tokens.
 *
 * @class
 */
/**
 * @constructor
 * @param {NestJwtService} jwtService - The NestJS JWT service instance
 * @param {ConfigService} configService - The configuration service for accessing environment variables
 */
/**
 * Creates a JWT token from the provided payload
 * @param {IJwtPayload} payload - The payload to be encoded in the token
 * @returns {Promise<string>} A Promise that resolves to the signed JWT token
 */
/**
 * Creates a refresh token from the provided payload with configurable expiration
 * @param {IJwtPayload} payload - The payload to be encoded in the refresh token
 * @returns {Promise<string>} A Promise that resolves to the signed refresh token
 */
/**
 * Verifies and decodes a JWT token
 * @param {string} token - The JWT token to verify
 * @returns {Promise<IJwtPayload>} A Promise that resolves to the decoded and verified payload
 * @throws {Error} If the token is invalid or expired
 */
/**
 * Decodes a JWT token without verification
 * @param {string} token - The JWT token to decode
 * @returns {Promise<IJwtPayload>} A Promise that resolves to the decoded payload
 */
/**
 * Creates a standard JWT payload with user information and expiration
 * @param {string} userId - The unique identifier of the user
 * @param {string} [email] - Optional email of the user
 * @param {string[]} [roles] - Optional array of user roles
 * @returns {IJwtPayload} The created JWT payload object
 */
/**
 * Validates the structure of a JWT payload
 * @param {any} payload - The payload to validate
 * @returns {boolean} True if the payload matches the expected structure, false otherwise
 */
let JwtService = JwtService_1 = class JwtService {
    constructor(jwtService, configService) {
        this.jwtService = jwtService;
        this.configService = configService;
        this.logger = new common_1.Logger(JwtService_1.name);
    }
    /**
     * Create a JWT token from payload
     */
    async createToken(payload) {
        return this.jwtService.sign(payload);
    }
    /**
     * Create a refresh token from payload
     */
    async createRefreshToken() {
        // const refreshTokenExpirationMinutes: number = this.configService.getOrThrow<number>('REFRESH_TOKEN_EXPIRATION_MINUTES');
        // return this.jwtService.sign(payload, { expiresIn: `${refreshTokenExpirationMinutes}m` });
        return (0, uuid_1.v4)();
    }
    /**
     * Verify and decode a JWT token
     */
    async verifyToken(token) {
        return this.jwtService.verify(token);
    }
    /**
     * Decode a JWT token without verifying
     */
    async decodeToken(token) {
        return this.jwtService.decode(token);
    }
    /**
     * Create a standard JWT payload
     */
    createPayload(user, refreshToken) {
        var _a, _b, _c;
        const now = Math.floor(Date.now() / 1000);
        const mappedRoles = ((_a = user.employee) === null || _a === void 0 ? void 0 : _a.roles) ? (_b = user.employee) === null || _b === void 0 ? void 0 : _b.roles.map(role => {
            var _a, _b, _c;
            return ({
                name: role.name,
                scope: role.scope,
                departmentId: (_a = role.department) === null || _a === void 0 ? void 0 : _a.id,
                organizationId: (_b = role.organization) === null || _b === void 0 ? void 0 : _b.id,
                branchId: (_c = role.branch) === null || _c === void 0 ? void 0 : _c.id,
            });
        }) : [];
        return {
            sub: user.id,
            iat: now,
            refreshToken,
            email: user.email,
            roles: mappedRoles !== null && mappedRoles !== void 0 ? mappedRoles : [],
            employeeId: (_c = user.employee) === null || _c === void 0 ? void 0 : _c.id,
        };
    }
    /**
     * Validate payload structure
     */
    validatePayload(payload) {
        return (typeof payload === 'object' &&
            typeof payload.sub === 'string' &&
            (!payload.email || typeof payload.email === 'string') &&
            (!payload.roles || Array.isArray(payload.roles)));
    }
};
exports.JwtService = JwtService;
exports.JwtService = JwtService = JwtService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof jwt_1.JwtService !== "undefined" && jwt_1.JwtService) === "function" ? _a : Object, typeof (_b = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _b : Object])
], JwtService);


/***/ }),

/***/ "./src/modules/account-management/auth/strategies/access-token.strategy.ts":
/*!*********************************************************************************!*\
  !*** ./src/modules/account-management/auth/strategies/access-token.strategy.ts ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccessTokenStrategy = void 0;
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const passport_1 = __webpack_require__(/*! @nestjs/passport */ "@nestjs/passport");
const passport_jwt_1 = __webpack_require__(/*! passport-jwt */ "passport-jwt");
const jwt_service_1 = __webpack_require__(/*! ../services/jwt.service */ "./src/modules/account-management/auth/services/jwt.service.ts");
let AccessTokenStrategy = class AccessTokenStrategy extends (0, passport_1.PassportStrategy)(passport_jwt_1.Strategy, 'jwt') {
    constructor(configService, jwtService, userService) {
        super({
            // Combine extractors to check both the Authorization header and the query parameter
            jwtFromRequest: (req) => {
                // Try to extract JWT from the Authorization header
                const authHeaderToken = passport_jwt_1.ExtractJwt.fromAuthHeaderAsBearerToken()(req);
                if (authHeaderToken) {
                    return authHeaderToken;
                }
                // If not found, try to extract JWT from the query parameter named 'token'
                const queryToken = passport_jwt_1.ExtractJwt.fromUrlQueryParameter('token')(req);
                return queryToken;
            },
            secretOrKey: configService.getOrThrow('ACCESS_TOKEN_SECRET'),
            ignoreExpiration: false,
        });
        this.configService = configService;
        this.jwtService = jwtService;
        this.userService = userService;
    }
    async validate(payload) {
        if (!this.jwtService.validatePayload(payload)) {
            throw new common_1.UnauthorizedException('Invalid token payload');
        }
        const user = await this.userService.findOneBy({ id: payload.sub });
        if (!user)
            throw new common_1.UnauthorizedException('User not found');
        return payload;
    }
};
exports.AccessTokenStrategy = AccessTokenStrategy;
exports.AccessTokenStrategy = AccessTokenStrategy = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object, typeof (_b = typeof jwt_service_1.JwtService !== "undefined" && jwt_service_1.JwtService) === "function" ? _b : Object, typeof (_c = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _c : Object])
], AccessTokenStrategy);


/***/ }),

/***/ "./src/modules/account-management/auth/strategies/google.strategy.ts":
/*!***************************************************************************!*\
  !*** ./src/modules/account-management/auth/strategies/google.strategy.ts ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var GoogleStrategy_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoogleStrategy = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const passport_1 = __webpack_require__(/*! @nestjs/passport */ "@nestjs/passport");
const passport_google_oauth20_1 = __webpack_require__(/*! passport-google-oauth20 */ "passport-google-oauth20");
const auth_service_1 = __webpack_require__(/*! ../auth.service */ "./src/modules/account-management/auth/auth.service.ts");
let GoogleStrategy = GoogleStrategy_1 = class GoogleStrategy extends (0, passport_1.PassportStrategy)(passport_google_oauth20_1.Strategy, 'google-auth') {
    constructor(configService, authService) {
        super({
            clientID: configService.getOrThrow('GOOGLE_CLIENT_ID'),
            clientSecret: configService.getOrThrow('GOOGLE_CLIENT_SECRET'),
            callbackURL: configService.getOrThrow('GOOGLE_CALLBACK_URL'),
            scope: ['profile', 'email']
        });
        this.configService = configService;
        this.authService = authService;
        this.logger = new common_1.Logger(GoogleStrategy_1.name);
    }
    authorizationParams() {
        return {
            prompt: 'select_account',
            access_type: 'offline', // To get refresh token
        };
    }
    async validate(accessToken, refreshToken, profile, done) {
        var _a, _b, _c, _d;
        try {
            this.logger.debug(`Validating Google user: ${profile.id}`);
            // Validate required profile data
            if (!profile || !profile.emails || profile.emails.length === 0) {
                this.logger.error('Invalid profile data received from Google');
                throw new common_1.UnauthorizedException('Invalid profile data from Google');
            }
            const email = profile.emails[0].value;
            if (!email) {
                this.logger.error('Email not provided by Google OAuth');
                throw new common_1.UnauthorizedException('Email is required');
            }
            // Extract user data from Google profile
            const user = {
                provider: 'google',
                providerId: profile.id,
                email,
                firstName: ((_a = profile.name) === null || _a === void 0 ? void 0 : _a.givenName) || '',
                lastName: ((_b = profile.name) === null || _b === void 0 ? void 0 : _b.familyName) || '',
                picture: ((_d = (_c = profile.photos) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.value) || '',
                accessToken,
                refreshToken: refreshToken || '',
            };
            // Return the user data to passport
            // This will be available in req.user in your controllers
            this.logger.log(`Google user authenticated successfully: ${email}`);
            done(null, user);
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Google authentication failed: ${error.message}`, error.stack);
            }
            else {
                this.logger.error(`Google authentication failed: ${String(error)}`);
            }
            done(error, false);
        }
    }
};
exports.GoogleStrategy = GoogleStrategy;
exports.GoogleStrategy = GoogleStrategy = GoogleStrategy_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object, typeof (_b = typeof auth_service_1.AuthService !== "undefined" && auth_service_1.AuthService) === "function" ? _b : Object])
], GoogleStrategy);


/***/ }),

/***/ "./src/modules/account-management/profiles/dtos/profile.dto.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/account-management/profiles/dtos/profile.dto.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetProfileDto = exports.UpdateProfileDto = exports.ProfileDto = void 0;
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const address_dto_1 = __webpack_require__(/*! ../../../addresses/dtos/address.dto */ "./src/modules/addresses/dtos/address.dto.ts");
class ProfileDto {
}
exports.ProfileDto = ProfileDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User ID associated with the profile' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'First name of the profile', example: 'John' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Middle name of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "middleName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Last name of the profile' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Full name of the profile', example: 'John Doe' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "fullName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Suffix (Jr., Sr., etc.)', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "suffix", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Gender of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "gender", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Sex of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "sex", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Profile picture URL', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "profilePicture", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Birth date of the profile', required: false, type: Date, example: '1990-01-01' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], ProfileDto.prototype, "birthDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Civil status of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "civilStatus", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Citizenship of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "citizenship", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Nationality of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "nationality", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Religion of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "religion", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Address information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => address_dto_1.AddressDto),
    __metadata("design:type", typeof (_b = typeof address_dto_1.AddressDto !== "undefined" && address_dto_1.AddressDto) === "function" ? _b : Object)
], ProfileDto.prototype, "address", void 0);
class UpdateProfileDto extends (0, swagger_1.PartialType)(ProfileDto) {
}
exports.UpdateProfileDto = UpdateProfileDto;
class GetProfileDto extends (0, create_get_dto_factory_1.createGetDto)(ProfileDto) {
}
exports.GetProfileDto = GetProfileDto;


/***/ }),

/***/ "./src/modules/account-management/profiles/entities/profile.entity.ts":
/*!****************************************************************************!*\
  !*** ./src/modules/account-management/profiles/entities/profile.entity.ts ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Profile = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const address_entity_1 = __webpack_require__(/*! ../../../addresses/entities/address.entity */ "./src/modules/addresses/entities/address.entity.ts");
const user_entity_1 = __webpack_require__(/*! ../../users/entities/user.entity */ "./src/modules/account-management/users/entities/user.entity.ts");
let Profile = class Profile extends base_entity_1.BaseEntity {
    generateFullName() {
        this.fullName = [
            this.firstName,
            this.middleName || '',
            this.lastName
        ].filter(Boolean).join(' ');
    }
};
exports.Profile = Profile;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Profile.prototype, "firstName", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "middleName", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Profile.prototype, "lastName", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Profile.prototype, "fullName", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "suffix", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "gender", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "sex", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "profilePicture", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Profile.prototype, "birthDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "civilStatus", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "citizenship", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "nationality", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "religion", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => user_entity_1.User, (user) => user.profile),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_b = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _b : Object)
], Profile.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Profile.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => address_entity_1.Address, (address) => address.profile, {
        cascade: true,
        eager: true
    }),
    __metadata("design:type", typeof (_c = typeof address_entity_1.Address !== "undefined" && address_entity_1.Address) === "function" ? _c : Object)
], Profile.prototype, "address", void 0);
__decorate([
    (0, typeorm_1.BeforeInsert)(),
    (0, typeorm_1.BeforeUpdate)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], Profile.prototype, "generateFullName", null);
exports.Profile = Profile = __decorate([
    (0, typeorm_1.Entity)('profiles')
], Profile);


/***/ }),

/***/ "./src/modules/account-management/profiles/profiles.controller.ts":
/*!************************************************************************!*\
  !*** ./src/modules/account-management/profiles/profiles.controller.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProfilesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const profile_dto_1 = __webpack_require__(/*! ./dtos/profile.dto */ "./src/modules/account-management/profiles/dtos/profile.dto.ts");
const profile_entity_1 = __webpack_require__(/*! ./entities/profile.entity */ "./src/modules/account-management/profiles/entities/profile.entity.ts");
const profiles_service_1 = __webpack_require__(/*! ./profiles.service */ "./src/modules/account-management/profiles/profiles.service.ts");
class ProfilesController extends (0, create_controller_factory_1.createController)(profile_entity_1.Profile, profiles_service_1.ProfilesService, profile_dto_1.GetProfileDto, profile_dto_1.ProfileDto, profile_dto_1.UpdateProfileDto) {
    findAllAdvanced(req, paginationDto) {
        return super.findAllAdvanced(req, paginationDto);
    }
    async findOne(id) {
        return await super.findOne(id);
    }
    async softDelete(id, deletedBy) {
        return super.softDelete(id, deletedBy);
    }
    async delete(id) {
        return super.delete(id);
    }
    deleteMany(ids, hardDelete) {
        return super.deleteMany(ids, hardDelete);
    }
}
exports.ProfilesController = ProfilesController;


/***/ }),

/***/ "./src/modules/account-management/profiles/profiles.module.ts":
/*!********************************************************************!*\
  !*** ./src/modules/account-management/profiles/profiles.module.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProfilesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const profile_entity_1 = __webpack_require__(/*! ./entities/profile.entity */ "./src/modules/account-management/profiles/entities/profile.entity.ts");
const profiles_controller_1 = __webpack_require__(/*! ./profiles.controller */ "./src/modules/account-management/profiles/profiles.controller.ts");
const profiles_service_1 = __webpack_require__(/*! ./profiles.service */ "./src/modules/account-management/profiles/profiles.service.ts");
let ProfilesModule = class ProfilesModule {
};
exports.ProfilesModule = ProfilesModule;
exports.ProfilesModule = ProfilesModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([profile_entity_1.Profile])],
        controllers: [profiles_controller_1.ProfilesController],
        providers: [profiles_service_1.ProfilesService],
        exports: [profiles_service_1.ProfilesService],
    })
], ProfilesModule);


/***/ }),

/***/ "./src/modules/account-management/profiles/profiles.service.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/account-management/profiles/profiles.service.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProfilesService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/modules/account-management/users/users.service.ts");
const profile_entity_1 = __webpack_require__(/*! ./entities/profile.entity */ "./src/modules/account-management/profiles/entities/profile.entity.ts");
let ProfilesService = class ProfilesService extends base_service_1.BaseService {
    constructor(ProfilesRepository, usersService) {
        super(ProfilesRepository, usersService);
        this.ProfilesRepository = ProfilesRepository;
        this.usersService = usersService;
    }
};
exports.ProfilesService = ProfilesService;
exports.ProfilesService = ProfilesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(profile_entity_1.Profile)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], ProfilesService);


/***/ }),

/***/ "./src/modules/account-management/services/user-seeder.service.ts":
/*!************************************************************************!*\
  !*** ./src/modules/account-management/services/user-seeder.service.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UserSeederService_1;
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserSeederService = void 0;
const employment_condition_enum_1 = __webpack_require__(/*! @/common/enums/employment/employment-condition.enum */ "./src/common/enums/employment/employment-condition.enum.ts");
const employment_status_enum_1 = __webpack_require__(/*! @/common/enums/employment/employment-status.enum */ "./src/common/enums/employment/employment-status.enum.ts");
const employment_type_enum_1 = __webpack_require__(/*! @/common/enums/employment/employment-type.enum */ "./src/common/enums/employment/employment-type.enum.ts");
const role_scope_type_enum_1 = __webpack_require__(/*! @/common/enums/role-scope-type.enum */ "./src/common/enums/role-scope-type.enum.ts");
const role_enum_1 = __webpack_require__(/*! @/common/enums/role.enum */ "./src/common/enums/role.enum.ts");
const auth_service_1 = __webpack_require__(/*! @/modules/account-management/auth/auth.service */ "./src/modules/account-management/auth/auth.service.ts");
const employees_service_1 = __webpack_require__(/*! @/modules/employee-management/employees.service */ "./src/modules/employee-management/employees.service.ts");
const roles_service_1 = __webpack_require__(/*! @/modules/employee-management/roles/roles.service */ "./src/modules/employee-management/roles/roles.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const bcrypt = __importStar(__webpack_require__(/*! bcrypt */ "bcrypt"));
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/modules/account-management/users/users.service.ts");
let UserSeederService = UserSeederService_1 = class UserSeederService {
    constructor(usersService, authService, rolesService, employeesService, configService) {
        this.usersService = usersService;
        this.authService = authService;
        this.rolesService = rolesService;
        this.employeesService = employeesService;
        this.configService = configService;
        this.logger = new common_1.Logger(UserSeederService_1.name);
    }
    async onModuleInit() {
        await this.seedSuperAdmin();
    }
    async seedSuperAdmin() {
        var _a, _b, _c, _d;
        const superAdminEmail = this.configService.getOrThrow('SUPER_ADMIN_EMAIL');
        const superAdminPassword = this.configService.getOrThrow('SUPER_ADMIN_PASSWORD');
        // this.logger.log('Checking if super admin role exists...');
        const superAdminRole = await this.seedSuperAdminRole();
        const employeeRole = await this.seedEmployeeRole();
        let superAdmin = await this.usersService.findOneBy({ email: superAdminEmail });
        // this.logger.log('Checking if super admin employee exists...');
        if (!superAdmin) {
            this.logger.warn('Super admin user does not exist');
            // create
            superAdmin = await this.usersService.create({
                email: superAdminEmail,
                emailVerified: true,
                password: await bcrypt.hash(superAdminPassword, 10),
                userName: superAdminEmail,
            });
        }
        let superAdminEmployee = await this.seedSuperAdminEmployee(superAdmin);
        // check if super admin employee has the super admin and employee role
        const hasSuperAdminAndEmployeeRole = ((_a = superAdminEmployee.roles) === null || _a === void 0 ? void 0 : _a.some(role => role.name === role_enum_1.Role.SUPERADMIN)) &&
            ((_b = superAdminEmployee.roles) === null || _b === void 0 ? void 0 : _b.some(role => role.name === role_enum_1.Role.EMPLOYEE));
        if (!hasSuperAdminAndEmployeeRole) {
            this.logger.warn('Super admin employee does not have the super admin and employee role');
            superAdminEmployee.roles = [superAdminRole, employeeRole];
            await this.employeesService.update(superAdminEmployee.id, superAdminEmployee);
            // this.logger.log('Super admin employee associated with the super admin and employee role successfully');
        }
        else {
            // this.logger.log('Super admin employee already has the super admin and employee role');
        }
        // Check if super admin user exists
        let superAdminUser = await this.usersService.findOneBy({ employee: { id: superAdminEmployee.id } }, { relations: { employee: true } });
        if (!superAdminUser) {
            // Check if super admin user exists with the super admin email
            superAdminUser = await this.usersService.findOneBy({ email: superAdminEmail });
            if (superAdminUser) {
                this.logger.warn('Super admin user exists but is not associated with the super admin employee');
                superAdminEmployee.user = superAdminUser;
            }
            else {
                // this.logger.log('Creating super admin user...');
                // create super admin user
                superAdminUser = await this.usersService.create({
                    email: superAdminEmail,
                    password: await bcrypt.hash(superAdminPassword, 10),
                    userName: superAdminEmail,
                    emailVerified: true,
                    employee: superAdminEmployee
                });
                // this.logger.log('Super admin user created successfully');
            }
        }
        else {
            // Check if super admin email is the same as the one in the config
            if (superAdminUser.email !== superAdminEmail) {
                // log super admin email
                this.logger.warn('Super admin email is different from the one in the config');
                // Update super admin email to the one in the config
                superAdminUser.email = superAdminEmail;
                superAdminUser.userName = superAdminEmail;
                await this.usersService.update(superAdminUser.id, superAdminUser);
                // this.logger.log('Super admin email updated successfully');
            }
            // Check if either password is missing
            if (!superAdminUser.password) {
                this.logger.warn('Missing password - updating to config password');
                superAdminUser.password = await bcrypt.hash(superAdminPassword, 10);
                await this.usersService.update(superAdminUser.id, superAdminUser);
            }
            else {
                // Only validate if both passwords exist
                var loginCredentials = {
                    emailOrUserName: (_c = superAdminUser.email) !== null && _c !== void 0 ? _c : "",
                    password: superAdminPassword
                };
                if (await this.authService.validateUser(loginCredentials)) {
                    // this.logger.log('Super admin password is the same as the one in the config');
                }
                else {
                    this.logger.warn('Super admin password is different from the one in the config');
                    superAdminUser.password = await bcrypt.hash(superAdminPassword, 10);
                    await this.usersService.update(superAdminUser.id, superAdminUser);
                }
            }
        }
        // check if superAdminUser is associated with the super admin employee
        if (((_d = superAdminUser.employee) === null || _d === void 0 ? void 0 : _d.id) !== superAdminEmployee.id) {
            this.logger.warn('Super admin user is not associated with the super admin employee');
            superAdminUser.employee = superAdminEmployee;
            await this.usersService.update(superAdminUser.id, superAdminUser);
            // this.logger.log('Super admin user associated with the super admin employee successfully');
        }
    }
    async seedSuperAdminRole() {
        // Check if super admin role exists
        let superAdminRole = await this.rolesService.findOneBy({ name: role_enum_1.Role.SUPERADMIN });
        // Create super admin role if it doesn't exist
        if (!superAdminRole) {
            // this.logger.log('Creating SuperAdmin role...');
            superAdminRole = await this.rolesService.create({
                name: role_enum_1.Role.SUPERADMIN,
                description: 'Super Admin Role',
                scope: role_scope_type_enum_1.RoleScopeType.GLOBAL,
            });
            // this.logger.log('SuperAdmin role created successfully');
        }
        else {
            // this.logger.log('SuperAdmin role already exists');
        }
        return superAdminRole;
    }
    async seedEmployeeRole() {
        // Check if employee role exists
        let employeeRole = await this.rolesService.findOneBy({ name: role_enum_1.Role.EMPLOYEE });
        // Create employee role if it doesn't exist
        if (!employeeRole) {
            // this.logger.log('Creating Employee role...');
            employeeRole = await this.rolesService.create({
                name: role_enum_1.Role.EMPLOYEE,
                description: 'Employee Role',
                scope: role_scope_type_enum_1.RoleScopeType.OWNED,
            });
            // this.logger.log('Employee role created successfully');
        }
        else {
            // this.logger.log('Employee role already exists');
        }
        return employeeRole;
    }
    async seedSuperAdminEmployee(user) {
        // Check if super admin employee exists
        let superAdminEmployee = await this.employeesService.findOneBy({ employeeNumber: 1 }, { relations: { roles: true } });
        // Create super admin employee if it doesn't exist
        if (!superAdminEmployee) {
            this.logger.log('Creating SuperAdmin employee...');
            superAdminEmployee = await this.employeesService.create({
                employmentStatus: employment_status_enum_1.EmploymentStatus.ACTIVE,
                employmentCondition: employment_condition_enum_1.EmploymentCondition.REGULAR,
                employmentType: employment_type_enum_1.EmploymentType.FULL_TIME,
                commencementDate: new Date(),
                user,
                userId: user.id,
                employeeNumber: 1,
            });
            // this.logger.log('SuperAdmin employee created successfully');
        }
        else {
            // this.logger.log('SuperAdmin employee already exists');
        }
        return superAdminEmployee;
    }
};
exports.UserSeederService = UserSeederService;
exports.UserSeederService = UserSeederService = UserSeederService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _a : Object, typeof (_b = typeof auth_service_1.AuthService !== "undefined" && auth_service_1.AuthService) === "function" ? _b : Object, typeof (_c = typeof roles_service_1.RolesService !== "undefined" && roles_service_1.RolesService) === "function" ? _c : Object, typeof (_d = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _d : Object, typeof (_e = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _e : Object])
], UserSeederService);


/***/ }),

/***/ "./src/modules/account-management/sessions/dtos/session.dto.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/account-management/sessions/dtos/session.dto.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetSessionDto = exports.UpdateSessionDto = exports.SessionDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SessionDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.SessionDto = SessionDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'userId123', description: 'The ID of the user' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], SessionDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'refreshToken123', description: 'The refresh token for the session' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], SessionDto.prototype, "refreshToken", void 0);
class UpdateSessionDto extends (0, swagger_1.PartialType)(SessionDto) {
}
exports.UpdateSessionDto = UpdateSessionDto;
class GetSessionDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateSessionDto, 'session') {
}
exports.GetSessionDto = GetSessionDto;


/***/ }),

/***/ "./src/modules/account-management/sessions/entities/session.entity.ts":
/*!****************************************************************************!*\
  !*** ./src/modules/account-management/sessions/entities/session.entity.ts ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Session = void 0;
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const base_entity_1 = __webpack_require__(/*! ../../../../database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const user_entity_1 = __webpack_require__(/*! ../../users/entities/user.entity */ "./src/modules/account-management/users/entities/user.entity.ts");
let Session = class Session extends base_entity_1.BaseEntity {
};
exports.Session = Session;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Session.prototype, "refreshToken", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Session.prototype, "expiresAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Session.prototype, "lastActiveAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, (user) => user.sessions, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_c = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _c : Object)
], Session.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Session.prototype, "userAgent", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Session.prototype, "ipAddress", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Session.prototype, "deviceId", void 0);
exports.Session = Session = __decorate([
    (0, typeorm_1.Entity)('sessions')
], Session);


/***/ }),

/***/ "./src/modules/account-management/sessions/sessions.controller.ts":
/*!************************************************************************!*\
  !*** ./src/modules/account-management/sessions/sessions.controller.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const session_dto_1 = __webpack_require__(/*! ./dtos/session.dto */ "./src/modules/account-management/sessions/dtos/session.dto.ts");
const session_entity_1 = __webpack_require__(/*! ./entities/session.entity */ "./src/modules/account-management/sessions/entities/session.entity.ts");
const sessions_service_1 = __webpack_require__(/*! ./sessions.service */ "./src/modules/account-management/sessions/sessions.service.ts");
class SessionsController extends (0, create_controller_factory_1.createController)(session_entity_1.Session, sessions_service_1.SessionsService, session_dto_1.GetSessionDto, undefined, session_dto_1.UpdateSessionDto) {
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async delete(id) {
        return await super.delete(id);
    }
}
exports.SessionsController = SessionsController;


/***/ }),

/***/ "./src/modules/account-management/sessions/sessions.module.ts":
/*!********************************************************************!*\
  !*** ./src/modules/account-management/sessions/sessions.module.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const session_entity_1 = __webpack_require__(/*! ./entities/session.entity */ "./src/modules/account-management/sessions/entities/session.entity.ts");
const sessions_controller_1 = __webpack_require__(/*! ./sessions.controller */ "./src/modules/account-management/sessions/sessions.controller.ts");
const sessions_service_1 = __webpack_require__(/*! ./sessions.service */ "./src/modules/account-management/sessions/sessions.service.ts");
let SessionsModule = class SessionsModule {
};
exports.SessionsModule = SessionsModule;
exports.SessionsModule = SessionsModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([session_entity_1.Session])],
        providers: [sessions_service_1.SessionsService],
        exports: [sessions_service_1.SessionsService],
        controllers: [sessions_controller_1.SessionsController],
    })
], SessionsModule);


/***/ }),

/***/ "./src/modules/account-management/sessions/sessions.service.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/account-management/sessions/sessions.service.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/modules/account-management/users/users.service.ts");
const session_entity_1 = __webpack_require__(/*! ./entities/session.entity */ "./src/modules/account-management/sessions/entities/session.entity.ts");
let SessionsService = class SessionsService extends base_service_1.BaseService {
    constructor(sessionsRepository, usersService) {
        super(sessionsRepository, usersService);
        this.sessionsRepository = sessionsRepository;
        this.usersService = usersService;
    }
};
exports.SessionsService = SessionsService;
exports.SessionsService = SessionsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(session_entity_1.Session)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], SessionsService);


/***/ }),

/***/ "./src/modules/account-management/users/dtos/user.dto.ts":
/*!***************************************************************!*\
  !*** ./src/modules/account-management/users/dtos/user.dto.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetUserDto = exports.UpdateUserDto = exports.UserDto = void 0;
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const profile_dto_1 = __webpack_require__(/*! ../../profiles/dtos/profile.dto */ "./src/modules/account-management/profiles/dtos/profile.dto.ts");
class UserDto {
}
exports.UserDto = UserDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The email address of the user',
        example: 'user@example.com'
    }),
    (0, class_validator_1.IsEmail)({}, { message: 'Please provide a valid email address' }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], UserDto.prototype, "email", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User password',
        example: 'StrongP@ssw0rd',
        minLength: 8
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MinLength)(8, { message: 'Password must be at least 8 characters long' }),
    __metadata("design:type", String)
], UserDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique username',
        example: 'john_doe'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MinLength)(3, { message: 'Username must be at least 3 characters long' }),
    __metadata("design:type", String)
], UserDto.prototype, "userName", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'User\'s phone number',
        example: '+1234567890'
    }),
    (0, class_validator_1.IsPhoneNumber)(undefined, { message: 'Please provide a valid phone number' }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], UserDto.prototype, "phoneNumber", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether the email has been verified',
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], UserDto.prototype, "emailVerified", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether the phone number has been verified',
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], UserDto.prototype, "phoneNumberVerified", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Number of failed access attempts',
        default: 0
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], UserDto.prototype, "accessFailedCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether lockout is enabled for this user',
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], UserDto.prototype, "lockoutEnabled", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether the user is currently locked out',
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], UserDto.prototype, "lockedOut", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'The timestamp when lockout started',
        example: '2023-01-01T00:00:00Z'
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value ? new Date(value) : undefined),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], UserDto.prototype, "lockOutStart", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'The timestamp when lockout ends',
        example: '2023-01-02T00:00:00Z'
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value ? new Date(value) : undefined),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], UserDto.prototype, "lockOutEnd", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Profile information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => profile_dto_1.ProfileDto),
    __metadata("design:type", typeof (_c = typeof profile_dto_1.ProfileDto !== "undefined" && profile_dto_1.ProfileDto) === "function" ? _c : Object)
], UserDto.prototype, "profile", void 0);
class UpdateUserDto extends (0, swagger_1.PartialType)(UserDto) {
}
exports.UpdateUserDto = UpdateUserDto;
class GetUserDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateUserDto, 'user') {
}
exports.GetUserDto = GetUserDto;


/***/ }),

/***/ "./src/modules/account-management/users/entities/user.entity.ts":
/*!**********************************************************************!*\
  !*** ./src/modules/account-management/users/entities/user.entity.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.User = void 0;
const document_entity_1 = __webpack_require__(/*! @/modules/documents/entities/document.entity */ "./src/modules/documents/entities/document.entity.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const activity_log_entity_1 = __webpack_require__(/*! @/modules/logs/activity-logs/entities/activity-log.entity */ "./src/modules/logs/activity-logs/entities/activity-log.entity.ts");
const notification_entity_1 = __webpack_require__(/*! @/modules/notifications/entities/notification.entity */ "./src/modules/notifications/entities/notification.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const base_entity_1 = __webpack_require__(/*! ../../../../database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const profile_entity_1 = __webpack_require__(/*! ../../profiles/entities/profile.entity */ "./src/modules/account-management/profiles/entities/profile.entity.ts");
const session_entity_1 = __webpack_require__(/*! ../../sessions/entities/session.entity */ "./src/modules/account-management/sessions/entities/session.entity.ts");
let User = class User extends base_entity_1.BaseEntity {
    constructor() {
        super(...arguments);
        this.lockedOut = false;
    }
    updateIsEmployeeStatus() {
        // Set isEmployee to true if the employee relation exists
        if (this.employee !== null && this.employee !== undefined) {
            this.isEmployee = true;
        }
    }
};
exports.User = User;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], User.prototype, "email", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], User.prototype, "password", void 0);
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], User.prototype, "userName", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => profile_entity_1.Profile, (profile) => profile.user, { cascade: true, eager: true, nullable: true }),
    __metadata("design:type", typeof (_a = typeof profile_entity_1.Profile !== "undefined" && profile_entity_1.Profile) === "function" ? _a : Object)
], User.prototype, "profile", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], User.prototype, "lastLogin", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], User.prototype, "phoneNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], User.prototype, "emailVerified", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], User.prototype, "phoneNumberVerified", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 0 }),
    __metadata("design:type", Number)
], User.prototype, "accessFailedCount", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], User.prototype, "lockoutEnabled", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Boolean)
], User.prototype, "lockedOut", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], User.prototype, "lockOutStart", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], User.prototype, "lockOutEnd", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], User.prototype, "verificationToken", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], User.prototype, "verificationTokenExpires", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => session_entity_1.Session, (session) => session.user, { nullable: true }),
    __metadata("design:type", Array)
], User.prototype, "sessions", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => activity_log_entity_1.ActivityLog, (activityLog) => activityLog.user, { nullable: true }),
    __metadata("design:type", Array)
], User.prototype, "activityLogs", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => document_entity_1.Document, (document) => document.user, { nullable: true }),
    __metadata("design:type", Array)
], User.prototype, "documents", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => notification_entity_1.Notification, (notification) => notification.user, { nullable: true }),
    __metadata("design:type", Array)
], User.prototype, "notifications", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => employee_entity_1.Employee, (employee) => employee.user, { nullable: true }),
    __metadata("design:type", typeof (_f = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _f : Object)
], User.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'bool', default: false }),
    __metadata("design:type", Boolean)
], User.prototype, "isEmployee", void 0);
__decorate([
    (0, typeorm_1.AfterLoad)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], User.prototype, "updateIsEmployeeStatus", null);
exports.User = User = __decorate([
    (0, typeorm_1.Entity)('users')
], User);


/***/ }),

/***/ "./src/modules/account-management/users/gateways/users.gateway.ts":
/*!************************************************************************!*\
  !*** ./src/modules/account-management/users/gateways/users.gateway.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersGateway = void 0;
const create_gateway_factory_1 = __webpack_require__(/*! @/common/factories/create-gateway.factory */ "./src/common/factories/create-gateway.factory.ts");
class UsersGateway extends (0, create_gateway_factory_1.createGateway)('users') {
}
exports.UsersGateway = UsersGateway;


/***/ }),

/***/ "./src/modules/account-management/users/users.controller.ts":
/*!******************************************************************!*\
  !*** ./src/modules/account-management/users/users.controller.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const user_dto_1 = __webpack_require__(/*! ./dtos/user.dto */ "./src/modules/account-management/users/dtos/user.dto.ts");
const user_entity_1 = __webpack_require__(/*! ./entities/user.entity */ "./src/modules/account-management/users/entities/user.entity.ts");
const users_service_1 = __webpack_require__(/*! ./users.service */ "./src/modules/account-management/users/users.service.ts");
class UsersController extends (0, create_controller_factory_1.createController)(user_entity_1.User, users_service_1.UsersService, user_dto_1.GetUserDto, undefined, user_dto_1.UpdateUserDto) {
    create(entityDto, createdById) {
        return super.create(entityDto, createdById);
    }
    async delete(id) {
        return await super.delete(id);
    }
}
exports.UsersController = UsersController;


/***/ }),

/***/ "./src/modules/account-management/users/users.module.ts":
/*!**************************************************************!*\
  !*** ./src/modules/account-management/users/users.module.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const user_entity_1 = __webpack_require__(/*! ./entities/user.entity */ "./src/modules/account-management/users/entities/user.entity.ts");
const users_gateway_1 = __webpack_require__(/*! ./gateways/users.gateway */ "./src/modules/account-management/users/gateways/users.gateway.ts");
const users_controller_1 = __webpack_require__(/*! ./users.controller */ "./src/modules/account-management/users/users.controller.ts");
const users_service_1 = __webpack_require__(/*! ./users.service */ "./src/modules/account-management/users/users.service.ts");
let UsersModule = class UsersModule {
};
exports.UsersModule = UsersModule;
exports.UsersModule = UsersModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([user_entity_1.User])],
        controllers: [users_controller_1.UsersController],
        providers: [users_service_1.UsersService, users_gateway_1.UsersGateway],
        exports: [users_service_1.UsersService],
    })
], UsersModule);


/***/ }),

/***/ "./src/modules/account-management/users/users.service.ts":
/*!***************************************************************!*\
  !*** ./src/modules/account-management/users/users.service.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const bcrypt = __importStar(__webpack_require__(/*! bcryptjs */ "bcryptjs"));
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const user_entity_1 = __webpack_require__(/*! ./entities/user.entity */ "./src/modules/account-management/users/entities/user.entity.ts");
let UsersService = class UsersService extends base_service_1.BaseService {
    constructor(userRepository) {
        super(userRepository, null);
        this.userRepository = userRepository;
    }
    async signUpUser(model) {
        const hashedPassword = await bcrypt.hash(model.password, 10);
        const user = this.create(Object.assign(Object.assign({}, model), { password: hashedPassword, emailVerified: false, userName: model.userName.toLowerCase().trim(), email: model.email.toLowerCase().trim() }));
        return user;
    }
};
exports.UsersService = UsersService;
exports.UsersService = UsersService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(user_entity_1.User)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], UsersService);


/***/ }),

/***/ "./src/modules/addresses/addresses.module.ts":
/*!***************************************************!*\
  !*** ./src/modules/addresses/addresses.module.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddressesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const addresses_service_1 = __webpack_require__(/*! ./addresses.service */ "./src/modules/addresses/addresses.service.ts");
const address_entity_1 = __webpack_require__(/*! ./entities/address.entity */ "./src/modules/addresses/entities/address.entity.ts");
let AddressesModule = class AddressesModule {
};
exports.AddressesModule = AddressesModule;
exports.AddressesModule = AddressesModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([address_entity_1.Address])],
        providers: [addresses_service_1.AddressesService],
        exports: [addresses_service_1.AddressesService],
    })
], AddressesModule);


/***/ }),

/***/ "./src/modules/addresses/addresses.service.ts":
/*!****************************************************!*\
  !*** ./src/modules/addresses/addresses.service.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddressesService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const users_service_1 = __webpack_require__(/*! ../account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const address_entity_1 = __webpack_require__(/*! ./entities/address.entity */ "./src/modules/addresses/entities/address.entity.ts");
let AddressesService = class AddressesService extends base_service_1.BaseService {
    constructor(AddressesService, usersService) {
        super(AddressesService, usersService);
        this.AddressesService = AddressesService;
        this.usersService = usersService;
    }
};
exports.AddressesService = AddressesService;
exports.AddressesService = AddressesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(address_entity_1.Address)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], AddressesService);


/***/ }),

/***/ "./src/modules/addresses/dtos/address.dto.ts":
/*!***************************************************!*\
  !*** ./src/modules/addresses/dtos/address.dto.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAddressDto = exports.UpdateAddressDto = exports.AddressDto = void 0;
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class AddressDto {
}
exports.AddressDto = AddressDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Street name, building and house number',
        example: '123 Main St, Building A'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(255),
    __metadata("design:type", String)
], AddressDto.prototype, "streetNameBuildingHouseNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Barangay name',
        example: 'Barangay 123'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], AddressDto.prototype, "barangay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'City or municipality name',
        example: 'Manila'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], AddressDto.prototype, "cityOrMunicipality", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Province name',
        example: 'Metro Manila'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], AddressDto.prototype, "province", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Region name',
        example: 'NCR'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], AddressDto.prototype, "region", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Postal code',
        example: 1000,
        type: Number
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], AddressDto.prototype, "postalCode", void 0);
class UpdateAddressDto extends (0, swagger_1.PartialType)(AddressDto) {
}
exports.UpdateAddressDto = UpdateAddressDto;
class GetAddressDto extends (0, create_get_dto_factory_1.createGetDto)(AddressDto) {
}
exports.GetAddressDto = GetAddressDto;


/***/ }),

/***/ "./src/modules/addresses/entities/address.entity.ts":
/*!**********************************************************!*\
  !*** ./src/modules/addresses/entities/address.entity.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Address = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const department_entity_1 = __webpack_require__(/*! @/modules/organization-management/branches/departments/entities/department.entity */ "./src/modules/organization-management/branches/departments/entities/department.entity.ts");
const branch_entity_1 = __webpack_require__(/*! @/modules/organization-management/branches/entities/branch.entity */ "./src/modules/organization-management/branches/entities/branch.entity.ts");
const organization_entity_1 = __webpack_require__(/*! @/modules/organization-management/entities/organization.entity */ "./src/modules/organization-management/entities/organization.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const profile_entity_1 = __webpack_require__(/*! ../../account-management/profiles/entities/profile.entity */ "./src/modules/account-management/profiles/entities/profile.entity.ts");
let Address = class Address extends base_entity_1.BaseEntity {
};
exports.Address = Address;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Address.prototype, "streetNameBuildingHouseNumber", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Address.prototype, "barangay", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Address.prototype, "cityOrMunicipality", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Address.prototype, "province", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Address.prototype, "region", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Number)
], Address.prototype, "postalCode", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => profile_entity_1.Profile, (profile) => profile.address, {
        onDelete: 'CASCADE', nullable: true
    }),
    (0, typeorm_1.JoinColumn)(),
    __metadata("design:type", typeof (_a = typeof profile_entity_1.Profile !== "undefined" && profile_entity_1.Profile) === "function" ? _a : Object)
], Address.prototype, "profile", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => organization_entity_1.Organization, (organization) => organization.address, {
        nullable: true
    }),
    (0, typeorm_1.JoinColumn)(),
    __metadata("design:type", typeof (_b = typeof organization_entity_1.Organization !== "undefined" && organization_entity_1.Organization) === "function" ? _b : Object)
], Address.prototype, "organization", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => branch_entity_1.Branch, (branch) => branch.address, {
        onDelete: 'CASCADE', nullable: true
    }),
    (0, typeorm_1.JoinColumn)(),
    __metadata("design:type", typeof (_c = typeof branch_entity_1.Branch !== "undefined" && branch_entity_1.Branch) === "function" ? _c : Object)
], Address.prototype, "branch", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => department_entity_1.Department, (department) => department.address, {
        onDelete: 'CASCADE', nullable: true
    }),
    (0, typeorm_1.JoinColumn)(),
    __metadata("design:type", typeof (_d = typeof department_entity_1.Department !== "undefined" && department_entity_1.Department) === "function" ? _d : Object)
], Address.prototype, "department", void 0);
exports.Address = Address = __decorate([
    (0, typeorm_1.Entity)('addresses')
], Address);


/***/ }),

/***/ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.controller.ts":
/*!*************************************************************************************************************!*\
  !*** ./src/modules/attendance-management/attendance-configurations/attendance-configurations.controller.ts ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendanceConfigurationsController = void 0;
const authorize_decorator_1 = __webpack_require__(/*! @/common/decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const current_user_decorator_1 = __webpack_require__(/*! @/common/decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const organization_entity_1 = __webpack_require__(/*! @/modules/organization-management/entities/organization.entity */ "./src/modules/organization-management/entities/organization.entity.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const attendance_configurations_service_1 = __webpack_require__(/*! ./attendance-configurations.service */ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.service.ts");
const attendance_configuration_dto_1 = __webpack_require__(/*! ./dtos/attendance-configuration.dto */ "./src/modules/attendance-management/attendance-configurations/dtos/attendance-configuration.dto.ts");
const attendance_configuration_entity_1 = __webpack_require__(/*! ./entities/attendance-configuration.entity */ "./src/modules/attendance-management/attendance-configurations/entities/attendance-configuration.entity.ts");
class AttendanceConfigurationsController extends (0, create_controller_factory_1.createController)(attendance_configuration_entity_1.AttendanceConfiguration, // Entity name for Swagger documentation
attendance_configurations_service_1.AttendanceConfigurationsService, // The service handling AttendanceConfiguration-related operations
attendance_configuration_dto_1.GetAttendanceConfigurationDto, // DTO for retrieving AttendanceConfigurations
attendance_configuration_dto_1.AttendanceConfigurationDto, // DTO for creating AttendanceConfigurations
attendance_configuration_dto_1.UpdateAttendanceConfigurationDto) {
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async update(id, entityDto, updatedById) {
        return await super.update(id, entityDto, updatedById);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    async delete(id) {
        return await super.delete(id);
    }
    async findOne(fieldsString, relations, select) {
        return await super.findOne(fieldsString, relations, select);
    }
    async findById(id, relations, select) {
        return await super.findById(id, relations, select);
    }
    async getOrganizationConfiguration(organizationId) {
        const config = await this.baseService.getOrganizationAttendanceConfiguration(organizationId);
        return (0, class_transformer_1.plainToInstance)(this.getDtoClass, config);
    }
    async getGlobalConfiguration() {
        const config = await this.baseService.getGlobalAttendanceConfiguration();
        return (0, class_transformer_1.plainToInstance)(this.getDtoClass, config);
    }
    async createOrUpdateOrganizationConfiguration(organizationId, configDto, userId) {
        // Check if organization already has a configuration
        const existingConfig = await this.baseService.findOneBy({ organization: new organization_entity_1.Organization({ id: organizationId }) }, { relations: { organization: true } });
        let savedConfig;
        if (existingConfig) {
            // Update existing configuration
            savedConfig = await this.baseService.update(existingConfig.id, Object.assign(Object.assign({}, configDto), { organization: new organization_entity_1.Organization({ id: organizationId }) }), userId);
        }
        else {
            // Create new configuration for organization
            savedConfig = await this.baseService.create(Object.assign(Object.assign({}, configDto), { organization: new organization_entity_1.Organization({ id: organizationId }) }), userId);
        }
        return (0, class_transformer_1.plainToInstance)(this.getDtoClass, savedConfig);
    }
    async updateGlobalConfiguration(configDto, userId) {
        const updatedConfig = await this.baseService.updateGlobalAttendanceConfiguration(configDto);
        return (0, class_transformer_1.plainToInstance)(this.getDtoClass, updatedConfig);
    }
}
exports.AttendanceConfigurationsController = AttendanceConfigurationsController;
__decorate([
    (0, common_1.Get)('organization/:organizationId'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({
        summary: 'Get attendance configuration for organization',
        description: 'Returns organization-specific configuration or global default if none exists'
    }),
    (0, swagger_1.ApiParam)({ name: 'organizationId', description: 'Organization ID' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Attendance configuration retrieved successfully',
        type: attendance_configuration_dto_1.GetAttendanceConfigurationDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Error retrieving attendance configuration',
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized access',
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden access to this resource',
    }),
    __param(0, (0, common_1.Param)('organizationId', common_1.ParseUUIDPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], AttendanceConfigurationsController.prototype, "getOrganizationConfiguration", null);
__decorate([
    (0, common_1.Get)('global'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({
        summary: 'Get global attendance configuration',
        description: 'Returns the global default attendance configuration'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Global attendance configuration retrieved successfully',
        type: attendance_configuration_dto_1.GetAttendanceConfigurationDto
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], AttendanceConfigurationsController.prototype, "getGlobalConfiguration", null);
__decorate([
    (0, common_1.Post)('organization/:organizationId'),
    (0, common_1.Put)('organization/:organizationId'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.MANAGE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Create or update organization attendance configuration',
        description: 'Creates new configuration or updates existing one for the organization'
    }),
    (0, swagger_1.ApiParam)({ name: 'organizationId', description: 'Organization ID' }),
    (0, swagger_1.ApiBody)({
        type: attendance_configuration_dto_1.AttendanceConfigurationDto,
        description: 'Attendance configuration data for the organization'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Organization attendance configuration saved successfully',
        type: attendance_configuration_dto_1.GetAttendanceConfigurationDto
    }),
    __param(0, (0, common_1.Param)('organizationId', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_c = typeof attendance_configuration_dto_1.AttendanceConfigurationDto !== "undefined" && attendance_configuration_dto_1.AttendanceConfigurationDto) === "function" ? _c : Object, String]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], AttendanceConfigurationsController.prototype, "createOrUpdateOrganizationConfiguration", null);
__decorate([
    (0, common_1.Put)('global'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Update global attendance configuration',
        description: 'Updates the global default attendance configuration'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Global attendance configuration updated successfully',
        type: attendance_configuration_dto_1.GetAttendanceConfigurationDto
    }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_e = typeof attendance_configuration_dto_1.UpdateAttendanceConfigurationDto !== "undefined" && attendance_configuration_dto_1.UpdateAttendanceConfigurationDto) === "function" ? _e : Object, String]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], AttendanceConfigurationsController.prototype, "updateGlobalConfiguration", null);


/***/ }),

/***/ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.module.ts":
/*!*********************************************************************************************************!*\
  !*** ./src/modules/attendance-management/attendance-configurations/attendance-configurations.module.ts ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendanceConfigurationsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const attendance_configurations_controller_1 = __webpack_require__(/*! ./attendance-configurations.controller */ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.controller.ts");
const attendance_configurations_service_1 = __webpack_require__(/*! ./attendance-configurations.service */ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.service.ts");
const attendance_configuration_entity_1 = __webpack_require__(/*! ./entities/attendance-configuration.entity */ "./src/modules/attendance-management/attendance-configurations/entities/attendance-configuration.entity.ts");
const attendance_configuration_seeder_service_1 = __webpack_require__(/*! ./services/attendance-configuration-seeder.service */ "./src/modules/attendance-management/attendance-configurations/services/attendance-configuration-seeder.service.ts");
let AttendanceConfigurationsModule = class AttendanceConfigurationsModule {
};
exports.AttendanceConfigurationsModule = AttendanceConfigurationsModule;
exports.AttendanceConfigurationsModule = AttendanceConfigurationsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([attendance_configuration_entity_1.AttendanceConfiguration]),
        ],
        providers: [attendance_configurations_service_1.AttendanceConfigurationsService, attendance_configuration_seeder_service_1.AttendanceConfigurationSeederService],
        exports: [attendance_configurations_service_1.AttendanceConfigurationsService],
        controllers: [attendance_configurations_controller_1.AttendanceConfigurationsController],
    })
], AttendanceConfigurationsModule);


/***/ }),

/***/ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.service.ts":
/*!**********************************************************************************************************!*\
  !*** ./src/modules/attendance-management/attendance-configurations/attendance-configurations.service.ts ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendanceConfigurationsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const organization_entity_1 = __webpack_require__(/*! @/modules/organization-management/entities/organization.entity */ "./src/modules/organization-management/entities/organization.entity.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const attendance_configuration_entity_1 = __webpack_require__(/*! ./entities/attendance-configuration.entity */ "./src/modules/attendance-management/attendance-configurations/entities/attendance-configuration.entity.ts");
let AttendanceConfigurationsService = class AttendanceConfigurationsService extends base_service_1.BaseService {
    constructor(attendanceConfigurationsRepository, usersService) {
        super(attendanceConfigurationsRepository, usersService);
        this.attendanceConfigurationsRepository = attendanceConfigurationsRepository;
        this.usersService = usersService;
    }
    async getGlobalAttendanceConfiguration() {
        const globalConfig = await this.findOneBy({ organization: undefined }, { relations: { organization: true } });
        if (!globalConfig) {
            return this.create({});
        }
        return globalConfig;
    }
    async getOrganizationAttendanceConfiguration(organizationId) {
        const organizationConfig = await this.findOneBy({ organization: new organization_entity_1.Organization({ id: organizationId }) }, { relations: { organization: true } });
        if (!organizationConfig) {
            return await this.getGlobalAttendanceConfiguration();
        }
        return organizationConfig;
    }
    async updateGlobalAttendanceConfiguration(data) {
        const globalConfig = await this.getGlobalAttendanceConfiguration();
        return this.update(globalConfig.id, data);
    }
};
exports.AttendanceConfigurationsService = AttendanceConfigurationsService;
exports.AttendanceConfigurationsService = AttendanceConfigurationsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(attendance_configuration_entity_1.AttendanceConfiguration)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], AttendanceConfigurationsService);


/***/ }),

/***/ "./src/modules/attendance-management/attendance-configurations/dtos/attendance-configuration.dto.ts":
/*!**********************************************************************************************************!*\
  !*** ./src/modules/attendance-management/attendance-configurations/dtos/attendance-configuration.dto.ts ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAttendanceConfigurationDto = exports.UpdateAttendanceConfigurationDto = exports.AttendanceConfigurationDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class AttendanceConfigurationDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.AttendanceConfigurationDto = AttendanceConfigurationDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'ID of the organization this configuration belongs to',
        example: '123e4567-e89b-12d3-a456-426614174000',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)('4'),
    __metadata("design:type", String)
], AttendanceConfigurationDto.prototype, "organizationId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Allow early check-ins',
        example: true,
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], AttendanceConfigurationDto.prototype, "allowEarlyTime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Allow late check-ins',
        example: false,
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], AttendanceConfigurationDto.prototype, "allowLate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Allow early check-outs',
        example: false,
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], AttendanceConfigurationDto.prototype, "allowUnderTime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Allow overtime check-outs',
        example: true,
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], AttendanceConfigurationDto.prototype, "allowOvertime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minutes before which check-in is considered early',
        example: 15,
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AttendanceConfigurationDto.prototype, "earlyTimeThresholdMinutes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minutes after which an attendance is considered late',
        example: 5,
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AttendanceConfigurationDto.prototype, "gracePeriodMinutes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minutes before which check-out is considered under time',
        example: 0,
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AttendanceConfigurationDto.prototype, "underTimeThresholdMinutes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minutes after which check-out is considered overtime',
        example: 30,
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AttendanceConfigurationDto.prototype, "overtimeThresholdMinutes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Round down early time to nearest specified minutes',
        example: false,
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], AttendanceConfigurationDto.prototype, "roundDownEarlyTime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minutes to round down early time to',
        example: 30,
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AttendanceConfigurationDto.prototype, "roundDownEarlyTimeMinutes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Round up late time to nearest specified minutes',
        example: false,
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], AttendanceConfigurationDto.prototype, "roundUpLate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minutes to round up late time to',
        example: 30,
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AttendanceConfigurationDto.prototype, "roundUpLateMinutes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Round down under time to nearest specified minutes',
        example: false,
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], AttendanceConfigurationDto.prototype, "roundDownUnderTime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minutes to round down under time to',
        example: 30,
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AttendanceConfigurationDto.prototype, "roundDownUnderTimeMinutes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Round up overtime to nearest specified minutes',
        example: false,
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], AttendanceConfigurationDto.prototype, "roundUpOvertime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minutes to round up overtime to',
        example: 30,
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AttendanceConfigurationDto.prototype, "roundUpOvertimeMinutes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Apply deduction for missing time in',
        example: true,
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], AttendanceConfigurationDto.prototype, "noTimeInDeduction", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Apply deduction for missing time out',
        example: true,
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], AttendanceConfigurationDto.prototype, "noTimeOutDeduction", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minutes to deduct for missing time in',
        example: 60,
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AttendanceConfigurationDto.prototype, "noTimeInDeductionMinutes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minutes to deduct for missing time out',
        example: 60,
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AttendanceConfigurationDto.prototype, "noTimeOutDeductionMinutes", void 0);
class UpdateAttendanceConfigurationDto extends (0, swagger_1.PartialType)(AttendanceConfigurationDto) {
}
exports.UpdateAttendanceConfigurationDto = UpdateAttendanceConfigurationDto;
class GetAttendanceConfigurationDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateAttendanceConfigurationDto, 'attendance configuration') {
}
exports.GetAttendanceConfigurationDto = GetAttendanceConfigurationDto;


/***/ }),

/***/ "./src/modules/attendance-management/attendance-configurations/entities/attendance-configuration.entity.ts":
/*!*****************************************************************************************************************!*\
  !*** ./src/modules/attendance-management/attendance-configurations/entities/attendance-configuration.entity.ts ***!
  \*****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendanceConfiguration = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const organization_entity_1 = __webpack_require__(/*! @/modules/organization-management/entities/organization.entity */ "./src/modules/organization-management/entities/organization.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
let AttendanceConfiguration = class AttendanceConfiguration extends base_entity_1.BaseEntity {
};
exports.AttendanceConfiguration = AttendanceConfiguration;
__decorate([
    (0, typeorm_1.OneToOne)(() => organization_entity_1.Organization, (organization) => organization.attendanceConfiguration, { eager: true, nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'organizationId' }),
    __metadata("design:type", typeof (_a = typeof organization_entity_1.Organization !== "undefined" && organization_entity_1.Organization) === "function" ? _a : Object)
], AttendanceConfiguration.prototype, "organization", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false, comment: 'Allow early check-ins' }),
    __metadata("design:type", Boolean)
], AttendanceConfiguration.prototype, "allowEarlyTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false, comment: 'Allow late check-ins' }),
    __metadata("design:type", Boolean)
], AttendanceConfiguration.prototype, "allowLate", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false, comment: 'Allow early check-outs' }),
    __metadata("design:type", Boolean)
], AttendanceConfiguration.prototype, "allowUnderTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true, comment: 'Allow overtime check-outs' }),
    __metadata("design:type", Boolean)
], AttendanceConfiguration.prototype, "allowOvertime", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 15, comment: 'Minutes before which check-in is considered early' }),
    __metadata("design:type", Number)
], AttendanceConfiguration.prototype, "earlyTimeThresholdMinutes", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 5, comment: 'Minutes after which an attendance is considered late' }),
    __metadata("design:type", Number)
], AttendanceConfiguration.prototype, "gracePeriodMinutes", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 0, comment: 'Minutes before which check-out is considered under time' }),
    __metadata("design:type", Number)
], AttendanceConfiguration.prototype, "underTimeThresholdMinutes", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 30, comment: 'Minutes after which check-out is considered overtime' }),
    __metadata("design:type", Number)
], AttendanceConfiguration.prototype, "overtimeThresholdMinutes", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false, comment: 'Round down early time to nearest specified minutes' }),
    __metadata("design:type", Boolean)
], AttendanceConfiguration.prototype, "roundDownEarlyTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 30, comment: 'Minutes to round down early time to' }),
    __metadata("design:type", Number)
], AttendanceConfiguration.prototype, "roundDownEarlyTimeMinutes", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false, comment: 'Round up late time to nearest specified minutes' }),
    __metadata("design:type", Boolean)
], AttendanceConfiguration.prototype, "roundUpLate", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 30, comment: 'Minutes to round up late time to' }),
    __metadata("design:type", Number)
], AttendanceConfiguration.prototype, "roundUpLateMinutes", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false, comment: 'Round down under time to nearest specified minutes' }),
    __metadata("design:type", Boolean)
], AttendanceConfiguration.prototype, "roundDownUnderTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 30, comment: 'Minutes to round down under time to' }),
    __metadata("design:type", Number)
], AttendanceConfiguration.prototype, "roundDownUnderTimeMinutes", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false, comment: 'Round up overtime to nearest specified minutes' }),
    __metadata("design:type", Boolean)
], AttendanceConfiguration.prototype, "roundUpOvertime", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 30, comment: 'Minutes to round up overtime to' }),
    __metadata("design:type", Number)
], AttendanceConfiguration.prototype, "roundUpOvertimeMinutes", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true, comment: 'Apply deduction for missing time in' }),
    __metadata("design:type", Boolean)
], AttendanceConfiguration.prototype, "noTimeInDeduction", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true, comment: 'Apply deduction for missing time out' }),
    __metadata("design:type", Boolean)
], AttendanceConfiguration.prototype, "noTimeOutDeduction", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 60, comment: 'Minutes to deduct for missing time in' }),
    __metadata("design:type", Number)
], AttendanceConfiguration.prototype, "noTimeInDeductionMinutes", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 60, comment: 'Minutes to deduct for missing time out' }),
    __metadata("design:type", Number)
], AttendanceConfiguration.prototype, "noTimeOutDeductionMinutes", void 0);
exports.AttendanceConfiguration = AttendanceConfiguration = __decorate([
    (0, typeorm_1.Entity)('attendance-configurations')
], AttendanceConfiguration);
//  if (!isViolationAllowed) {
//       // Calculate minutes difference
//       const minutesDiff = type === AttendanceStatus.LATE 
//         ? differenceInMinutes(actualTime, expectedTime)
//         : differenceInMinutes(expectedTime, actualTime);
//       // Check if minutes difference exceeds threshold
//       const thresholdMinutes = type === AttendanceStatus.LATE 
//         ? config.gracePeriodMinutes 
//         : config.underTimeThresholdMinutes;
//       if (minutesDiff > thresholdMinutes) {
//         // Mark attendance with violation status
//         if (!attendanceStatuses.includes(type)) {
//           attendanceStatuses.push(type);
//         }
//         this.logger.log(`Employee ${employee.user.email} ${type === AttendanceStatus.LATE ? 'is late' : 'is leaving early'} by ${minutesDiff} minutes`);
//         let roundedMinutes = minutesDiff;
//         const roundingConfig = type === AttendanceStatus.LATE
//           ? { round: config.roundUpLate, roundMinutes: config.roundUpLateMinutes }
//           : { round: config.roundDownUnderTime, roundMinutes: config.roundDownUnderTimeMinutes };
//         // Handle rounding based on configuration
//         if (roundingConfig.round) {
//           // Round up or down based on configuration
//           this.logger.log(`Rounding ${type === AttendanceStatus.LATE ? 'late time' : 'undertime'} based on configuration`);
//           roundedMinutes = type === AttendanceStatus.LATE 
//             ? Math.ceil(minutesDiff / roundingConfig.roundMinutes) * roundingConfig.roundMinutes
//             : Math.floor(minutesDiff / roundingConfig.roundMinutes) * roundingConfig.roundMinutes;
//           // Log rounded minutes
//           this.logger.log(`Rounded ${type === AttendanceStatus.LATE ? 'late time' : 'undertime'} to ${roundedMinutes} minutes`);
//         }
//         // Create work time request
//         await this.createWorkTimeRequest(dayType, employee.id, type, existingAttendance, roundedMinutes);
//         // Notify employee
//         const notificationTitle = type === AttendanceStatus.LATE ? 'Late Check-in' : 'Under Time Alert';
//         const notificationMessage = type === AttendanceStatus.LATE 
//           ? `You are late by ${minutesDiff} minutes on ${punchDate} at ${punchTimeStr}.${config.roundUpLate ? ` This was rounded up to ${roundedMinutes} minutes.` : ''}`
//           : `You are leaving early by ${minutesDiff} minutes on ${punchDate} at ${punchTimeStr}.${config.roundDownUnderTime ? ` This was rounded down to ${roundedMinutes} minutes.` : ''}`;
//         await this.notificationsService.create({
//           title: notificationTitle,
//           message: notificationMessage,
//           type: NotificationType.WARNING,
//           category: 'ATTENDANCE',
//           user: { id: employee.user.id },
//         });
//       } else {
//         this.logger.log(`Minutes ${type === AttendanceStatus.LATE ? 'late' : 'early'} is not considered as ${type.toLowerCase()}`);
//       }
//     } else {
//       this.logger.log(`Organization allows ${type.toLowerCase()}`);
//     }


/***/ }),

/***/ "./src/modules/attendance-management/attendance-configurations/services/attendance-configuration-seeder.service.ts":
/*!*************************************************************************************************************************!*\
  !*** ./src/modules/attendance-management/attendance-configurations/services/attendance-configuration-seeder.service.ts ***!
  \*************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AttendanceConfigurationSeederService_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendanceConfigurationSeederService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const attendance_configurations_service_1 = __webpack_require__(/*! ../attendance-configurations.service */ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.service.ts");
let AttendanceConfigurationSeederService = AttendanceConfigurationSeederService_1 = class AttendanceConfigurationSeederService {
    constructor(attendanceConfigurationsService) {
        this.attendanceConfigurationsService = attendanceConfigurationsService;
        this.logger = new common_1.Logger(AttendanceConfigurationSeederService_1.name);
    }
    async onModuleInit() {
        await this.seedGlobalAttendanceConfiguration();
    }
    async seedGlobalAttendanceConfiguration() {
        try {
            // Check if the global attendance configuration already exists
            const existingConfig = await this.attendanceConfigurationsService.findOneBy({
                organization: undefined
            }, { relations: { organization: true } });
            if (!existingConfig) {
                // Create a new global attendance configuration
                await this.attendanceConfigurationsService.create({});
                this.logger.log(`Global attendance configuration seeded`);
            }
        }
        catch (error) {
            this.logger.error(`Failed to seed attendance data: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
};
exports.AttendanceConfigurationSeederService = AttendanceConfigurationSeederService;
exports.AttendanceConfigurationSeederService = AttendanceConfigurationSeederService = AttendanceConfigurationSeederService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof attendance_configurations_service_1.AttendanceConfigurationsService !== "undefined" && attendance_configurations_service_1.AttendanceConfigurationsService) === "function" ? _a : Object])
], AttendanceConfigurationSeederService);


/***/ }),

/***/ "./src/modules/attendance-management/attendance-management.module.ts":
/*!***************************************************************************!*\
  !*** ./src/modules/attendance-management/attendance-management.module.ts ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendanceManagementModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const biometrics_module_1 = __webpack_require__(/*! ../biometrics/biometrics.module */ "./src/modules/biometrics/biometrics.module.ts");
const employee_management_module_1 = __webpack_require__(/*! ../employee-management/employee-management.module */ "./src/modules/employee-management/employee-management.module.ts");
const schedules_module_1 = __webpack_require__(/*! ../shift-management/schedules/schedules.module */ "./src/modules/shift-management/schedules/schedules.module.ts");
const attendance_configurations_module_1 = __webpack_require__(/*! ./attendance-configurations/attendance-configurations.module */ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.module.ts");
const attendance_punches_module_1 = __webpack_require__(/*! ./attendance-punches/attendance-punches.module */ "./src/modules/attendance-management/attendance-punches/attendance-punches.module.ts");
const attendances_controller_1 = __webpack_require__(/*! ./attendances.controller */ "./src/modules/attendance-management/attendances.controller.ts");
const attendances_service_1 = __webpack_require__(/*! ./attendances.service */ "./src/modules/attendance-management/attendances.service.ts");
const attendance_entity_1 = __webpack_require__(/*! ./entities/attendance.entity */ "./src/modules/attendance-management/entities/attendance.entity.ts");
const final_work_hours_module_1 = __webpack_require__(/*! ./final-work-hours/final-work-hours.module */ "./src/modules/attendance-management/final-work-hours/final-work-hours.module.ts");
const attendances_gateway_1 = __webpack_require__(/*! ./gateways/attendances.gateway */ "./src/modules/attendance-management/gateways/attendances.gateway.ts");
const attendance_listener_1 = __webpack_require__(/*! ./listeners/attendance.listener */ "./src/modules/attendance-management/listeners/attendance.listener.ts");
const attendance_data_seeder_service_1 = __webpack_require__(/*! ./services/attendance-data-seeder.service */ "./src/modules/attendance-management/services/attendance-data-seeder.service.ts");
const work_time_requests_module_1 = __webpack_require__(/*! ./work-time-requests/work-time-requests.module */ "./src/modules/attendance-management/work-time-requests/work-time-requests.module.ts");
const work_time_responses_module_1 = __webpack_require__(/*! ./work-time-requests/work-time-responses/work-time-responses.module */ "./src/modules/attendance-management/work-time-requests/work-time-responses/work-time-responses.module.ts");
let AttendanceManagementModule = class AttendanceManagementModule {
};
exports.AttendanceManagementModule = AttendanceManagementModule;
exports.AttendanceManagementModule = AttendanceManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([attendance_entity_1.Attendance]),
            core_1.RouterModule.register([
                {
                    path: 'attendances',
                    module: AttendanceManagementModule,
                    children: [
                        {
                            path: 'punches',
                            module: attendance_punches_module_1.AttendancePunchesModule,
                        },
                        {
                            path: 'work-time-requests',
                            module: work_time_requests_module_1.WorkTimeRequestsModule,
                            children: [
                                {
                                    path: 'responses',
                                    module: work_time_responses_module_1.WorkTimeResponsesModule,
                                }
                            ]
                        },
                        {
                            path: 'final-work-hours',
                            module: final_work_hours_module_1.FinalWorkHoursModule,
                        },
                        {
                            path: 'configurations',
                            module: attendance_configurations_module_1.AttendanceConfigurationsModule
                        }
                    ],
                }
            ]),
            attendance_punches_module_1.AttendancePunchesModule,
            work_time_requests_module_1.WorkTimeRequestsModule,
            final_work_hours_module_1.FinalWorkHoursModule,
            attendance_configurations_module_1.AttendanceConfigurationsModule,
            employee_management_module_1.EmployeeManagementModule,
            schedules_module_1.SchedulesModule,
            biometrics_module_1.BiometricsModule
        ],
        providers: [attendances_service_1.AttendancesService, attendance_listener_1.AttendanceListener, attendance_data_seeder_service_1.AttendanceDataSeederService, attendances_gateway_1.AttendancesGateway],
        exports: [
            attendances_service_1.AttendancesService,
            attendance_punches_module_1.AttendancePunchesModule,
            work_time_requests_module_1.WorkTimeRequestsModule,
            final_work_hours_module_1.FinalWorkHoursModule,
            attendance_configurations_module_1.AttendanceConfigurationsModule
        ],
        controllers: [attendances_controller_1.AttendancesController],
    })
], AttendanceManagementModule);


/***/ }),

/***/ "./src/modules/attendance-management/attendance-punches/attendance-punches.controller.ts":
/*!***********************************************************************************************!*\
  !*** ./src/modules/attendance-management/attendance-punches/attendance-punches.controller.ts ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancePunchesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const attendance_punches_service_1 = __webpack_require__(/*! ./attendance-punches.service */ "./src/modules/attendance-management/attendance-punches/attendance-punches.service.ts");
const attendance_punch_dto_1 = __webpack_require__(/*! ./dtos/attendance-punch.dto */ "./src/modules/attendance-management/attendance-punches/dtos/attendance-punch.dto.ts");
const attendance_punch_entity_1 = __webpack_require__(/*! ./entities/attendance-punch.entity */ "./src/modules/attendance-management/attendance-punches/entities/attendance-punch.entity.ts");
class AttendancePunchesController extends (0, create_controller_factory_1.createController)(attendance_punch_entity_1.AttendancePunch, attendance_punches_service_1.AttendancePunchesService, attendance_punch_dto_1.GetAttendancePunchDto) {
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async update(id, entityDto, updatedById) {
        return await super.update(id, entityDto, updatedById);
    }
    async delete(id) {
        return await super.delete(id);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    async findById(id, relations, select) {
        return await super.findById(id, relations, select);
    }
    async findOne(fieldsString, relations, select) {
        return await super.findOne(fieldsString, relations, select);
    }
}
exports.AttendancePunchesController = AttendancePunchesController;


/***/ }),

/***/ "./src/modules/attendance-management/attendance-punches/attendance-punches.module.ts":
/*!*******************************************************************************************!*\
  !*** ./src/modules/attendance-management/attendance-punches/attendance-punches.module.ts ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancePunchesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const attendance_punches_controller_1 = __webpack_require__(/*! ./attendance-punches.controller */ "./src/modules/attendance-management/attendance-punches/attendance-punches.controller.ts");
const attendance_punches_service_1 = __webpack_require__(/*! ./attendance-punches.service */ "./src/modules/attendance-management/attendance-punches/attendance-punches.service.ts");
const attendance_punch_entity_1 = __webpack_require__(/*! ./entities/attendance-punch.entity */ "./src/modules/attendance-management/attendance-punches/entities/attendance-punch.entity.ts");
let AttendancePunchesModule = class AttendancePunchesModule {
};
exports.AttendancePunchesModule = AttendancePunchesModule;
exports.AttendancePunchesModule = AttendancePunchesModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([attendance_punch_entity_1.AttendancePunch])],
        providers: [attendance_punches_service_1.AttendancePunchesService],
        exports: [attendance_punches_service_1.AttendancePunchesService],
        controllers: [attendance_punches_controller_1.AttendancePunchesController],
    })
], AttendancePunchesModule);


/***/ }),

/***/ "./src/modules/attendance-management/attendance-punches/attendance-punches.service.ts":
/*!********************************************************************************************!*\
  !*** ./src/modules/attendance-management/attendance-punches/attendance-punches.service.ts ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancePunchesService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const attendance_punch_entity_1 = __webpack_require__(/*! ./entities/attendance-punch.entity */ "./src/modules/attendance-management/attendance-punches/entities/attendance-punch.entity.ts");
let AttendancePunchesService = class AttendancePunchesService extends base_service_1.BaseService {
    constructor(attendancePunchesRepository, usersService) {
        super(attendancePunchesRepository, usersService);
        this.attendancePunchesRepository = attendancePunchesRepository;
        this.usersService = usersService;
    }
};
exports.AttendancePunchesService = AttendancePunchesService;
exports.AttendancePunchesService = AttendancePunchesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(attendance_punch_entity_1.AttendancePunch)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], AttendancePunchesService);


/***/ }),

/***/ "./src/modules/attendance-management/attendance-punches/dtos/attendance-punch.dto.ts":
/*!*******************************************************************************************!*\
  !*** ./src/modules/attendance-management/attendance-punches/dtos/attendance-punch.dto.ts ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAttendancePunchDto = exports.UpdateAttendancePunchDto = exports.AttendancePunchDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const punch_method_enum_1 = __webpack_require__(/*! @/common/enums/punch-method.enum */ "./src/common/enums/punch-method.enum.ts");
const punch_type_enum_1 = __webpack_require__(/*! @/common/enums/punch-type.enum */ "./src/common/enums/punch-type.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class AttendancePunchDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.AttendancePunchDto = AttendancePunchDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Attendance record this punch is associated with',
        example: '123e4567-e89b-12d3-a456-426614174000',
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(4),
    __metadata("design:type", String)
], AttendancePunchDto.prototype, "attendanceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Biometric device used for this punch',
        example: '123e4567-e89b-12d3-a456-426614174000',
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(4),
    __metadata("design:type", String)
], AttendancePunchDto.prototype, "biometricDeviceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of attendance punch (IN/OUT)',
        enum: punch_type_enum_1.PunchType,
        enumName: 'PunchType'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(punch_type_enum_1.PunchType),
    __metadata("design:type", typeof (_a = typeof punch_type_enum_1.PunchType !== "undefined" && punch_type_enum_1.PunchType) === "function" ? _a : Object)
], AttendancePunchDto.prototype, "punchType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Method used for punch (FINGERPRINT/MANUAL/etc)',
        enum: punch_method_enum_1.PunchMethod,
        enumName: 'PunchMethod'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(punch_method_enum_1.PunchMethod),
    __metadata("design:type", typeof (_b = typeof punch_method_enum_1.PunchMethod !== "undefined" && punch_method_enum_1.PunchMethod) === "function" ? _b : Object)
], AttendancePunchDto.prototype, "punchMethod", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Timestamp of the punch',
        example: '2023-07-21T08:30:00Z',
        type: Date
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDateString)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], AttendancePunchDto.prototype, "time", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employee identification number',
        example: 12345,
        type: Number
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], AttendancePunchDto.prototype, "employeeNumber", void 0);
class UpdateAttendancePunchDto extends (0, swagger_1.PartialType)(AttendancePunchDto) {
}
exports.UpdateAttendancePunchDto = UpdateAttendancePunchDto;
class GetAttendancePunchDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateAttendancePunchDto, 'attendance punch') {
}
exports.GetAttendancePunchDto = GetAttendancePunchDto;


/***/ }),

/***/ "./src/modules/attendance-management/attendance-punches/entities/attendance-punch.entity.ts":
/*!**************************************************************************************************!*\
  !*** ./src/modules/attendance-management/attendance-punches/entities/attendance-punch.entity.ts ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancePunch = void 0;
const punch_method_enum_1 = __webpack_require__(/*! @/common/enums/punch-method.enum */ "./src/common/enums/punch-method.enum.ts");
const punch_type_enum_1 = __webpack_require__(/*! @/common/enums/punch-type.enum */ "./src/common/enums/punch-type.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const biometric_device_entity_1 = __webpack_require__(/*! @/modules/biometrics/entities/biometric-device.entity */ "./src/modules/biometrics/entities/biometric-device.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const attendance_entity_1 = __webpack_require__(/*! ../../entities/attendance.entity */ "./src/modules/attendance-management/entities/attendance.entity.ts");
let AttendancePunch = class AttendancePunch extends base_entity_1.BaseEntity {
};
exports.AttendancePunch = AttendancePunch;
__decorate([
    (0, typeorm_1.ManyToOne)(() => attendance_entity_1.Attendance, (attendance) => attendance.attendancePunches),
    (0, typeorm_1.JoinColumn)({ name: 'attendanceId' }),
    __metadata("design:type", typeof (_a = typeof attendance_entity_1.Attendance !== "undefined" && attendance_entity_1.Attendance) === "function" ? _a : Object)
], AttendancePunch.prototype, "attendance", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], AttendancePunch.prototype, "time", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: punch_method_enum_1.PunchMethod }),
    __metadata("design:type", typeof (_c = typeof punch_method_enum_1.PunchMethod !== "undefined" && punch_method_enum_1.PunchMethod) === "function" ? _c : Object)
], AttendancePunch.prototype, "punchMethod", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: punch_type_enum_1.PunchType }),
    __metadata("design:type", typeof (_d = typeof punch_type_enum_1.PunchType !== "undefined" && punch_type_enum_1.PunchType) === "function" ? _d : Object)
], AttendancePunch.prototype, "punchType", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Number)
], AttendancePunch.prototype, "employeeNumber", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => biometric_device_entity_1.BiometricDevice, (biometricDevice) => biometricDevice.attendancePunches),
    (0, typeorm_1.JoinColumn)({ name: 'biometricDeviceId' }),
    __metadata("design:type", typeof (_e = typeof biometric_device_entity_1.BiometricDevice !== "undefined" && biometric_device_entity_1.BiometricDevice) === "function" ? _e : Object)
], AttendancePunch.prototype, "biometricDevice", void 0);
exports.AttendancePunch = AttendancePunch = __decorate([
    (0, typeorm_1.Entity)('attendance-punches')
], AttendancePunch);


/***/ }),

/***/ "./src/modules/attendance-management/attendances.controller.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/attendance-management/attendances.controller.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancesController = void 0;
const authorize_decorator_1 = __webpack_require__(/*! @/common/decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const current_user_decorator_1 = __webpack_require__(/*! @/common/decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const generalresponse_dto_1 = __webpack_require__(/*! @/common/dtos/generalresponse.dto */ "./src/common/dtos/generalresponse.dto.ts");
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const attendances_service_1 = __webpack_require__(/*! ./attendances.service */ "./src/modules/attendance-management/attendances.service.ts");
const attendance_dto_1 = __webpack_require__(/*! ./dtos/attendance.dto */ "./src/modules/attendance-management/dtos/attendance.dto.ts");
const attendance_entity_1 = __webpack_require__(/*! ./entities/attendance.entity */ "./src/modules/attendance-management/entities/attendance.entity.ts");
class AttendancesController extends (0, create_controller_factory_1.createController)(attendance_entity_1.Attendance, attendances_service_1.AttendancesService, attendance_dto_1.GetAttendanceDto, undefined, undefined) {
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async delete(id) {
        return await super.delete(id);
    }
    async update(id, entityDto, updatedById) {
        return await super.update(id, entityDto, updatedById);
    }
    async deleteMany(ids, hardDelete) {
        await super.deleteMany(ids, hardDelete);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    async processAttendanceRecords(userId) {
        try {
            if (!(await this.baseService.processAttendanceRecords(userId)))
                throw new common_1.NotFoundException('No attendance records found to process');
            return {
                message: 'Processing of attendance records has been initiated. Please wait for the system to finish processing.',
                statusCode: common_1.HttpStatus.OK
            };
        }
        catch (error) {
            return {
                message: 'An error occurred while processing attendance records: ' + error.message,
                statusCode: error.status || common_1.HttpStatus.INTERNAL_SERVER_ERROR
            };
        }
    }
}
exports.AttendancesController = AttendancesController;
__decorate([
    (0, common_1.Post)('process'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.MANAGE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Manually process attendance records',
        description: 'Triggers processing of attendance records for undertime, overtime, missing checkins/checkouts, and absences. This also calculates final work hours per day.'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Attendance records processed successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'User is not authorized to process attendance records',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'An error occurred while processing attendance records',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], AttendancesController.prototype, "processAttendanceRecords", null);


/***/ }),

/***/ "./src/modules/attendance-management/attendances.service.ts":
/*!******************************************************************!*\
  !*** ./src/modules/attendance-management/attendances.service.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancesService = void 0;
const attendance_status_enum_1 = __webpack_require__(/*! @/common/enums/attendance-status.enum */ "./src/common/enums/attendance-status.enum.ts");
const holiday_type_enum_1 = __webpack_require__(/*! @/common/enums/holiday-type.enum */ "./src/common/enums/holiday-type.enum.ts");
const notification_type_enum_1 = __webpack_require__(/*! @/common/enums/notification-type.enum */ "./src/common/enums/notification-type.enum.ts");
const request_status_enum_1 = __webpack_require__(/*! @/common/enums/request-status.enum */ "./src/common/enums/request-status.enum.ts");
const attendance_event_1 = __webpack_require__(/*! @/common/events/attendance.event */ "./src/common/events/attendance.event.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const schedule_1 = __webpack_require__(/*! @nestjs/schedule */ "@nestjs/schedule");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const date_fns_1 = __webpack_require__(/*! date-fns */ "date-fns");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const employees_service_1 = __webpack_require__(/*! ../employee-management/employees.service */ "./src/modules/employee-management/employees.service.ts");
const notifications_service_1 = __webpack_require__(/*! ../notifications/notifications.service */ "./src/modules/notifications/notifications.service.ts");
const schedules_service_1 = __webpack_require__(/*! ../shift-management/schedules/schedules.service */ "./src/modules/shift-management/schedules/schedules.service.ts");
const attendance_configurations_service_1 = __webpack_require__(/*! ./attendance-configurations/attendance-configurations.service */ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.service.ts");
const attendance_entity_1 = __webpack_require__(/*! ./entities/attendance.entity */ "./src/modules/attendance-management/entities/attendance.entity.ts");
const final_work_hour_entity_1 = __webpack_require__(/*! ./final-work-hours/entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
const attendances_gateway_1 = __webpack_require__(/*! ./gateways/attendances.gateway */ "./src/modules/attendance-management/gateways/attendances.gateway.ts");
const work_time_request_entity_1 = __webpack_require__(/*! ./work-time-requests/entities/work-time-request.entity */ "./src/modules/attendance-management/work-time-requests/entities/work-time-request.entity.ts");
const work_time_requests_service_1 = __webpack_require__(/*! ./work-time-requests/work-time-requests.service */ "./src/modules/attendance-management/work-time-requests/work-time-requests.service.ts");
let AttendancesService = class AttendancesService extends base_service_1.BaseService {
    constructor(attendancesRepository, usersService, workTimeRequestsService, notificationsService, employeesService, schedulesService, eventEmitter, attendancesGateway, attendanceConfigurationsService) {
        super(attendancesRepository, usersService);
        this.attendancesRepository = attendancesRepository;
        this.usersService = usersService;
        this.workTimeRequestsService = workTimeRequestsService;
        this.notificationsService = notificationsService;
        this.employeesService = employeesService;
        this.schedulesService = schedulesService;
        this.eventEmitter = eventEmitter;
        this.attendancesGateway = attendancesGateway;
        this.attendanceConfigurationsService = attendanceConfigurationsService;
    }
    async create(createDto, createdBy) {
        await this.attendancesGateway.pingAll();
        return await super.create(createDto, createdBy);
    }
    async update(id, updateDto, updatedBy) {
        await this.attendancesGateway.pingAll();
        return await super.update(id, updateDto, updatedBy);
    }
    async save(entity) {
        await this.attendancesGateway.pingAll();
        return await super.save(entity);
    }
    getEmployeeAttendanceToday(employeeId, punchTime) {
        return this.attendancesRepository.findOne({
            where: {
                employee: { id: employeeId },
                timeIn: (0, typeorm_2.Between)((0, date_fns_1.startOfDay)(punchTime), (0, date_fns_1.endOfDay)(punchTime))
            },
            relations: { employee: true }
        });
    }
    // Run at midnight
    async processAttendanceRecords(processedBy) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        // Get all attendance records for the day that has no final work hours yet
        const attendances = await this.attendancesRepository.find({
            where: {
                schedule: {
                    date: (0, typeorm_2.LessThan)(today),
                }
            },
            relations: { cutoff: true, employee: { user: true }, schedule: true },
        });
        if (attendances.length === 0) {
            this.logger.log(`No attendance records to process`);
            return false;
        }
        this.logger.log(`Processing ${attendances.length} attendance records`);
        // can also process late and no check in
        await this.handleLateEmployees(attendances);
        // Process employees that checked in early
        await this.handleEarlyEmployees(attendances);
        // Process employees with missing check-in
        await this.handleMissingCheckIns(attendances);
        // Process employees with under time
        await this.handleUnderTimeEmployees(attendances);
        // Process employees with over time
        await this.handleOverTimeEmployees(attendances);
        // Process employees with check-in but no check-out
        await this.handleMissingCheckOuts(attendances);
        // Process employees worked on rest day
        await this.handleRestDayEmployees(attendances);
        // Process employees that has no attendance record or absent
        await this.handleAbsentEmployees();
        // mark attendance records as processed
        for (const attendance of attendances) {
            attendance.isProcessed = true;
            attendance.processedBy = processedBy;
            attendance.processedAt = new Date();
        }
        await this.save(attendances);
        // notification
        await this.notificationsService.create({
            title: 'Attendance Processed',
            message: `Attendance records for ${attendances.length} employees have been processed successfully.`,
            type: notification_type_enum_1.NotificationType.INFO,
            category: 'ATTENDANCE',
            user: { id: processedBy },
        });
        // log attendance processing
        this.logger.log(`Attendance records processed successfully`);
        // Emit event for attendance processing
        this.eventEmitter.emit(attendance_event_1.ATTENDANCE_EVENTS.ATTENDANCE_PROCESSED, new attendance_event_1.AttendanceProcessedEvent(attendances, processedBy));
        return true;
    }
    async handleEarlyEmployees(attendances) {
        // filter attendances for early
        const earlyAttendances = attendances.filter(attendance => {
            var _a;
            return ((_a = attendance.statuses) === null || _a === void 0 ? void 0 : _a.includes(attendance_status_enum_1.AttendanceStatus.EARLY)) === true;
        });
        if (earlyAttendances.length === 0) {
            this.logger.log(`No early attendances to process`);
            return;
        }
        this.logger.log(`Found ${earlyAttendances.length} early attendances to process`);
        for (const attendance of earlyAttendances) {
            try {
                this.logger.log(`Processing early for employee ${attendance.employee.user.email}`);
                // get organization config
                const config = await this.attendanceConfigurationsService.getOrganizationAttendanceConfiguration(attendance.employee.organizationId);
                const formattedAttendanceDate = (0, date_fns_1.format)(attendance.schedule.date, 'yyyy-MM-dd');
                // Calculate early minutes
                const scheduleStartTime = new Date(`${formattedAttendanceDate}T${attendance.schedule.startTime}`);
                const timeIn = attendance.timeIn ? new Date(attendance.timeIn) : new Date(attendance.schedule.startTime);
                // Calculate early (when employee checks in before scheduled start time)
                let earlyMinutes = (scheduleStartTime.getTime() - timeIn.getTime()) / (1000 * 60);
                // Check if organization rounds down early
                if (config.roundDownEarlyTime) {
                    earlyMinutes = Math.ceil(earlyMinutes / config.roundDownEarlyTimeMinutes) * config.roundDownEarlyTimeMinutes;
                }
                // Check if there is already worktime request for early
                const existingRequest = await this.workTimeRequestsService.findOneBy({
                    attendance: new attendance_entity_1.Attendance({ id: attendance.id }),
                    type: attendance_status_enum_1.AttendanceStatus.EARLY,
                }, { relations: { attendance: true } });
                if (!existingRequest) {
                    this.logger.log(`No existing work time request for early found for employee ${attendance.employee.user.email}`);
                    // Create work time request
                    const workTimeRequest = new work_time_request_entity_1.WorkTimeRequest({
                        attendance: attendance,
                        type: attendance_status_enum_1.AttendanceStatus.EARLY,
                        duration: earlyMinutes,
                        status: request_status_enum_1.RequestStatus.PENDING,
                        cutoff: attendance.cutoff,
                        date: attendance.schedule.date,
                        dayType: attendance.dayType,
                        createdBy: attendance.employee.id,
                        employee: attendance.employee,
                        organizationId: attendance.employee.organizationId,
                        branchId: attendance.employee.branchId,
                        departmentId: attendance.employee.departmentId,
                        userId: attendance.employee.userId
                    });
                    await this.workTimeRequestsService.save(workTimeRequest);
                    await this.notificationsService.create({
                        title: 'Early Check-in Alert',
                        message: `You checked in early by ${earlyMinutes} minutes on ${formattedAttendanceDate}.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                }
                else {
                    // update existing request with early minutes
                    this.logger.log(`Updating existing work time request for early for employee ${attendance.employee.user.email}`);
                    existingRequest.duration = earlyMinutes;
                    await this.workTimeRequestsService.save(existingRequest);
                    await this.notificationsService.create({
                        title: 'Early Updated',
                        message: `Your early request for ${formattedAttendanceDate} has been updated to ${earlyMinutes} minutes.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                }
            }
            catch (error) {
                this.logger.error(`Error processing early for attendance ${attendance.id}: ${error.message}`, error.stack);
            }
        }
    }
    async handleLateEmployees(attendances) {
        // filter attendances for late
        const lateAttendances = attendances.filter(attendance => {
            var _a;
            return ((_a = attendance.statuses) === null || _a === void 0 ? void 0 : _a.includes(attendance_status_enum_1.AttendanceStatus.LATE)) === true;
        });
        if (lateAttendances.length === 0) {
            this.logger.log(`No late attendances to process`);
            return;
        }
        this.logger.log(`Found ${lateAttendances.length} late attendances to process`);
        for (const attendance of lateAttendances) {
            try {
                this.logger.log(`Processing late for employee ${attendance.employee.user.email}`);
                // get organization config
                const config = await this.attendanceConfigurationsService.getOrganizationAttendanceConfiguration(attendance.employee.organizationId);
                const formattedAttendanceDate = (0, date_fns_1.format)(attendance.schedule.date, 'yyyy-MM-dd');
                // Calculate late minutes
                const scheduleStartTime = new Date(`${formattedAttendanceDate}T${attendance.schedule.startTime}`);
                const timeIn = attendance.timeIn ? new Date(attendance.timeIn) : new Date(attendance.schedule.startTime);
                // Calculate late (when employee checks in after scheduled start time)
                let lateMinutes = (timeIn.getTime() - scheduleStartTime.getTime()) / (1000 * 60);
                // Check if organization rounds up late
                if (config.roundUpLate) {
                    lateMinutes = Math.ceil(lateMinutes / config.roundUpLateMinutes) * config.roundUpLateMinutes;
                }
                // Check if there is already worktime request for late
                const existingRequest = await this.workTimeRequestsService.findOneBy({
                    attendance: new attendance_entity_1.Attendance({ id: attendance.id }),
                    type: attendance_status_enum_1.AttendanceStatus.LATE,
                }, { relations: { attendance: true } });
                if (!existingRequest) {
                    this.logger.log(`No existing work time request for late found for employee ${attendance.employee.user.email}`);
                    // Create work time request
                    const workTimeRequest = new work_time_request_entity_1.WorkTimeRequest({
                        attendance: attendance,
                        type: attendance_status_enum_1.AttendanceStatus.LATE,
                        duration: lateMinutes,
                        status: request_status_enum_1.RequestStatus.PENDING,
                        cutoff: attendance.cutoff,
                        date: attendance.schedule.date,
                        dayType: attendance.dayType,
                        createdBy: attendance.employee.id,
                        employee: attendance.employee,
                        organizationId: attendance.employee.organizationId,
                        branchId: attendance.employee.branchId,
                        departmentId: attendance.employee.departmentId,
                        userId: attendance.employee.userId
                    });
                    await this.workTimeRequestsService.save(workTimeRequest);
                    await this.notificationsService.create({
                        title: 'Late Check-in Alert',
                        message: `You were late by ${lateMinutes} minutes on ${formattedAttendanceDate}.`,
                        type: notification_type_enum_1.NotificationType.WARNING,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                }
                else {
                    // update existing request with late minutes
                    this.logger.log(`Updating existing work time request for late for employee ${attendance.employee.user.email}`);
                    existingRequest.duration = lateMinutes;
                    await this.workTimeRequestsService.save(existingRequest);
                    await this.notificationsService.create({
                        title: 'Late Updated',
                        message: `Your late request for ${formattedAttendanceDate} has been updated to ${lateMinutes} minutes.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                }
            }
            catch (error) {
                this.logger.error(`Error processing late for attendance ${attendance.id}: ${error.message}`, error.stack);
            }
        }
    }
    async handleUnderTimeEmployees(attendances) {
        // filter attendances for under time
        const underTimeAttendances = attendances.filter(attendance => {
            var _a;
            return ((_a = attendance.statuses) === null || _a === void 0 ? void 0 : _a.includes(attendance_status_enum_1.AttendanceStatus.UNDER_TIME)) === true;
        });
        if (underTimeAttendances.length === 0) {
            this.logger.log(`No under time attendances to process`);
            return;
        }
        this.logger.log(`Found ${underTimeAttendances.length} under time attendances to process`);
        for (const attendance of underTimeAttendances) {
            try {
                this.logger.log(`Processing under time for employee ${attendance.employee.user.email}`);
                // get organization config
                const config = await this.attendanceConfigurationsService.getOrganizationAttendanceConfiguration(attendance.employee.organizationId);
                const formattedAttendanceDate = (0, date_fns_1.format)(attendance.schedule.date, 'yyyy-MM-dd');
                // Calculate total undertime minutes
                const scheduleEndTime = new Date(`${formattedAttendanceDate}T${attendance.schedule.endTime}`);
                const timeOut = attendance.timeOut ? new Date(attendance.timeOut) : new Date(attendance.schedule.endTime);
                // Calculate under time (when employee leaves before scheduled end time)
                let underTimeMinutes = (scheduleEndTime.getTime() - timeOut.getTime()) / (1000 * 60);
                // Check if organization rounds down under time
                if (config.roundDownUnderTime) {
                    underTimeMinutes = Math.ceil(underTimeMinutes / config.roundDownUnderTimeMinutes) * config.roundDownUnderTimeMinutes;
                }
                // Check if there is already worktime request for undertime
                const existingRequest = await this.workTimeRequestsService.findOneBy({
                    attendance: new attendance_entity_1.Attendance({ id: attendance.id }),
                    type: attendance_status_enum_1.AttendanceStatus.UNDER_TIME,
                }, { relations: { attendance: true } });
                if (!existingRequest) {
                    this.logger.log(`No existing work time request for under time for employee ${attendance.employee.user.email}`);
                    // Create work time request
                    const workTimeRequest = new work_time_request_entity_1.WorkTimeRequest({
                        attendance: attendance,
                        type: attendance_status_enum_1.AttendanceStatus.UNDER_TIME,
                        duration: underTimeMinutes,
                        status: request_status_enum_1.RequestStatus.PENDING,
                        cutoff: attendance.cutoff,
                        date: attendance.schedule.date,
                        dayType: attendance.dayType,
                        createdBy: attendance.employee.id,
                        employee: attendance.employee,
                        organizationId: attendance.employee.organizationId,
                        branchId: attendance.employee.branchId,
                        departmentId: attendance.employee.departmentId,
                        userId: attendance.employee.userId
                    });
                    await this.workTimeRequestsService.save(workTimeRequest);
                    await this.notificationsService.create({
                        title: 'Early Check-out',
                        message: `You left ${underTimeMinutes} minutes early on ${formattedAttendanceDate}.`,
                        type: notification_type_enum_1.NotificationType.WARNING,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                }
                else {
                    // update existing request with under time minutes
                    this.logger.log(`Updating existing work time request for under time for employee ${attendance.employee.user.email}`);
                    existingRequest.duration = underTimeMinutes;
                    await this.workTimeRequestsService.save(existingRequest);
                    await this.notificationsService.create({
                        title: 'Under Time Updated',
                        message: `Your under time request for ${formattedAttendanceDate} has been updated to ${underTimeMinutes} minutes.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                }
            }
            catch (error) {
                this.logger.error(`Error processing under time for attendance ${attendance.id}: ${error.message}`, error.stack);
            }
        }
    }
    async handleOverTimeEmployees(attendances) {
        // filter attendances for over time
        const overTimeAttendances = attendances.filter(attendance => {
            var _a;
            return ((_a = attendance.statuses) === null || _a === void 0 ? void 0 : _a.includes(attendance_status_enum_1.AttendanceStatus.OVERTIME)) === true;
        });
        if (overTimeAttendances.length === 0) {
            this.logger.log(`No over time attendances to process`);
            return;
        }
        this.logger.log(`Found ${overTimeAttendances.length} over time attendances to process`);
        for (const attendance of overTimeAttendances) {
            try {
                this.logger.log(`Processing over time for employee ${attendance.employee.user.email}`);
                const formattedAttendanceDate = (0, date_fns_1.format)(attendance.schedule.date, 'yyyy-MM-dd');
                const config = await this.attendanceConfigurationsService.getOrganizationAttendanceConfiguration(attendance.employee.organizationId);
                // Calculate total overtime minutes
                const scheduleEndTime = new Date(`${formattedAttendanceDate}T${attendance.schedule.endTime}`);
                const timeOut = attendance.timeOut ? new Date(attendance.timeOut) : new Date(attendance.schedule.endTime);
                // Calculate overtime (when employee leaves after scheduled end time)
                let overtimeMinutes = (timeOut.getTime() - scheduleEndTime.getTime()) / (1000 * 60);
                // Check if organization rounds up overtime
                if (config.roundUpOvertime) {
                    overtimeMinutes = Math.ceil(overtimeMinutes / config.roundUpOvertimeMinutes) * config.roundUpOvertimeMinutes;
                }
                // Check if there is already worktime request for overtime
                const existingRequest = await this.workTimeRequestsService.findOneBy({
                    attendance: new attendance_entity_1.Attendance({ id: attendance.id }),
                    type: attendance_status_enum_1.AttendanceStatus.OVERTIME,
                }, { relations: { attendance: true } });
                if (!existingRequest) {
                    this.logger.log(`No existing work time request for overtime found for employee ${attendance.employee.user.email}`);
                    // Create work time request
                    const workTimeRequest = new work_time_request_entity_1.WorkTimeRequest({
                        attendance: attendance,
                        type: attendance_status_enum_1.AttendanceStatus.OVERTIME,
                        duration: overtimeMinutes,
                        date: attendance.schedule.date,
                        status: request_status_enum_1.RequestStatus.PENDING,
                        dayType: attendance.dayType,
                        cutoff: attendance.cutoff,
                        createdBy: attendance.employee.id,
                        employee: attendance.employee,
                        organizationId: attendance.employee.organizationId,
                        branchId: attendance.employee.branchId,
                        departmentId: attendance.employee.departmentId,
                        userId: attendance.employee.userId
                    });
                    await this.workTimeRequestsService.save(workTimeRequest);
                    await this.notificationsService.create({
                        title: 'Overtime Alert',
                        message: `You worked ${overtimeMinutes} minutes of overtime on ${formattedAttendanceDate}.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                }
                else {
                    // update existing request with overtime minutes
                    this.logger.log(`Updating existing work time request for overtime for employee ${attendance.employee.user.email}`);
                    existingRequest.duration = overtimeMinutes;
                    await this.workTimeRequestsService.save(existingRequest);
                    await this.notificationsService.create({
                        title: 'Overtime Updated',
                        message: `Your overtime request for ${formattedAttendanceDate} has been updated to ${overtimeMinutes} minutes.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                }
            }
            catch (error) {
                this.logger.error(`Error processing over time for attendance ${attendance.id}: ${error.message}`, error.stack);
            }
        }
    }
    async handleMissingCheckOuts(attendances) {
        var _a;
        // filter attendances for missing check-out
        const incompleteAttendances = attendances.filter(attendance => {
            return attendance.timeIn && !attendance.timeOut;
        });
        if (incompleteAttendances.length === 0) {
            this.logger.log(`No missing check out attendances to process`);
            return;
        }
        this.logger.log(`Found ${incompleteAttendances.length} missing checkout attendances to process`);
        for (const attendance of incompleteAttendances) {
            try {
                const formattedAttendanceDate = (0, date_fns_1.format)(attendance.schedule.date, 'yyyy-MM-dd');
                this.logger.log(`Employee ${attendance.employee.user.email} has no check-out for ${formattedAttendanceDate}`);
                // Update attendance with NO_CHECKED_OUT status
                if (!((_a = attendance.statuses) === null || _a === void 0 ? void 0 : _a.includes(attendance_status_enum_1.AttendanceStatus.NO_CHECKED_OUT))) {
                    attendance.statuses = [...attendance.statuses || [], attendance_status_enum_1.AttendanceStatus.NO_CHECKED_OUT];
                }
                await this.save(attendance);
                // Check if there is already worktime request for missing check-out
                const existingRequest = await this.workTimeRequestsService.findOneBy({
                    attendance: new attendance_entity_1.Attendance({ id: attendance.id }),
                    type: attendance_status_enum_1.AttendanceStatus.NO_CHECKED_OUT,
                }, { relations: { attendance: true } });
                if (!existingRequest) {
                    this.logger.log(`No existing work time request for missing check-out found for employee ${attendance.employee.user.email}`);
                    // create new work time request
                    await this.workTimeRequestsService.create({
                        attendance,
                        type: attendance_status_enum_1.AttendanceStatus.NO_CHECKED_OUT,
                        status: request_status_enum_1.RequestStatus.PENDING,
                        cutoff: attendance.cutoff,
                        dayType: attendance.dayType,
                        date: attendance.schedule.date,
                        createdBy: attendance.employee.id,
                        employee: { id: attendance.employee.id },
                        organizationId: attendance.employee.organizationId,
                        branchId: attendance.employee.branchId,
                        departmentId: attendance.employee.departmentId,
                        userId: attendance.employee.userId
                    });
                    await this.notificationsService.create({
                        title: 'Missing Check-Out Alert',
                        message: `You forgot to check-out in ${formattedAttendanceDate}. Please check your attendance record.`,
                        type: notification_type_enum_1.NotificationType.DANGER,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                }
            }
            catch (error) {
                this.logger.error(`Error processing missing check-out for attendance ${attendance.id}: ${error.message}`);
            }
        }
    }
    async handleMissingCheckIns(attendances) {
        var _a;
        // filter attendances for missing check-in
        const incompleteAttendances = attendances.filter(attendance => {
            return !attendance.timeIn && attendance.timeOut;
        });
        if (incompleteAttendances.length === 0) {
            this.logger.log(`No missing check in attendances to process`);
            return;
        }
        this.logger.log(`Found ${incompleteAttendances.length} missing check-in attendances to process`);
        for (const attendance of incompleteAttendances) {
            try {
                const formattedAttendanceDate = (0, date_fns_1.format)(attendance.schedule.date, 'yyyy-MM-dd');
                this.logger.log(`Employee ${attendance.employee.user.email} has no check-in for ${formattedAttendanceDate}`);
                // Update attendance with NO_CHECKED_IN status
                if (!((_a = attendance.statuses) === null || _a === void 0 ? void 0 : _a.includes(attendance_status_enum_1.AttendanceStatus.NO_CHECKED_IN))) {
                    attendance.statuses = [...attendance.statuses || [], attendance_status_enum_1.AttendanceStatus.NO_CHECKED_IN];
                }
                await this.save(attendance);
                // Check if there is already worktime request for missing check-in
                const existingRequest = await this.workTimeRequestsService.findOneBy({
                    attendance: new attendance_entity_1.Attendance({ id: attendance.id }),
                    type: attendance_status_enum_1.AttendanceStatus.NO_CHECKED_IN,
                }, { relations: { attendance: true } });
                if (!existingRequest) {
                    this.logger.log(`No existing work time request for missing check-in found for employee ${attendance.employee.user.email}`);
                    // create new work time request
                    await this.workTimeRequestsService.create({
                        attendance,
                        type: attendance_status_enum_1.AttendanceStatus.NO_CHECKED_IN,
                        status: request_status_enum_1.RequestStatus.PENDING,
                        cutoff: attendance.cutoff,
                        dayType: attendance.dayType,
                        date: attendance.schedule.date,
                        createdBy: attendance.employee.id,
                        employee: { id: attendance.employee.id },
                        organizationId: attendance.employee.organizationId,
                        branchId: attendance.employee.branchId,
                        departmentId: attendance.employee.departmentId,
                        userId: attendance.employee.userId
                    });
                    await this.notificationsService.create({
                        title: 'Missing Check-In Alert',
                        message: `You forgot to check-in on ${formattedAttendanceDate}. Please check your attendance record.`,
                        type: notification_type_enum_1.NotificationType.DANGER,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                }
            }
            catch (error) {
                this.logger.error(`Error processing missing check-in for attendance ${attendance.id}: ${error.message}`);
            }
        }
    }
    async handleRestDayEmployees(attendances) {
        var _a, _b;
        // filter attendances for rest day
        const restDayAttendances = attendances.filter(attendance => {
            return attendance.schedule.restDay === true && attendance.timeIn && attendance.timeOut;
        });
        if (restDayAttendances.length === 0) {
            this.logger.log(`No rest day attendances to process`);
            return;
        }
        this.logger.log(`Found ${restDayAttendances.length} rest day attendances to process`);
        for (const attendance of restDayAttendances) {
            try {
                const formattedDate = (0, date_fns_1.format)(attendance.schedule.date, 'yyyy-MM-dd');
                this.logger.log(`Processing rest day work for employee ${attendance.employee.user.email} on ${formattedDate}`);
                // Calculate total hours worked
                const timeIn = attendance.timeIn ? new Date(attendance.timeIn) : new Date();
                const timeOut = attendance.timeOut ? new Date(attendance.timeOut) : new Date();
                const breakTimeMinutes = attendance.schedule.breakTime || 0;
                // Calculate total minutes worked (excluding break)
                const totalWorkMinutes = (0, date_fns_1.differenceInMinutes)(timeOut, timeIn) - breakTimeMinutes;
                const totalWorkHours = totalWorkMinutes / 60;
                // Check if the employee worked a full shift (9+ hours including break)
                // This translates to 8+ hours of actual work time
                if (totalWorkHours >= 8) {
                    this.logger.log(`Employee ${attendance.employee.id} worked ${totalWorkHours.toFixed(2)} hours on rest day - eligible for offset`);
                    // Add OFFSET status
                    if (!((_a = attendance.statuses) === null || _a === void 0 ? void 0 : _a.includes(attendance_status_enum_1.AttendanceStatus.OFFSET))) {
                        attendance.statuses = [...attendance.statuses || [], attendance_status_enum_1.AttendanceStatus.OFFSET];
                    }
                    // Grant offset leave credit to the employee
                    attendance.employee.offsetLeaveCredits += 1;
                    await this.employeesService.save(attendance.employee);
                    // await this.workTimeRequestsService.create({
                    //     attendance,
                    //     type: AttendanceStatus.OFFSET,
                    //     status: RequestStatus.PENDING,
                    //     dayType: attendance.dayType,
                    //     createdBy: attendance.employee.id,
                    //     employee: { id: attendance.employee.id },
                    // });
                    // Notify the employee about offset earned
                    await this.notificationsService.create({
                        title: 'Rest Day Offset Requested',
                        message: `You received 1 offset leave credit for working on your rest day (${formattedDate}).`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                }
                else {
                    this.logger.log(`Employee ${attendance.employee.id} worked ${totalWorkHours.toFixed(2)} hours on rest day - eligible for overtime`);
                    // Add OVERTIME status
                    if (!((_b = attendance.statuses) === null || _b === void 0 ? void 0 : _b.includes(attendance_status_enum_1.AttendanceStatus.OVERTIME))) {
                        attendance.statuses = [...attendance.statuses || [], attendance_status_enum_1.AttendanceStatus.OVERTIME];
                    }
                    // Check if there is already worktime request for overtime
                    const existingRequest = await this.workTimeRequestsService.findOneBy({
                        attendance: new attendance_entity_1.Attendance({ id: attendance.id }),
                        type: attendance_status_enum_1.AttendanceStatus.OVERTIME,
                    }, { relations: { attendance: true } });
                    if (!existingRequest) {
                        // Notify the employee about overtime
                        await this.notificationsService.create({
                            title: 'Rest Day Overtime',
                            message: `Your ${totalWorkHours.toFixed(2)} hours worked on rest day (${formattedDate}) will be counted as overtime.`,
                            type: notification_type_enum_1.NotificationType.INFO,
                            category: 'ATTENDANCE',
                            user: { id: attendance.employee.user.id },
                        });
                        // Create a work time request for overtime
                        await this.workTimeRequestsService.create({
                            attendance: { id: attendance.id },
                            type: attendance_status_enum_1.AttendanceStatus.OVERTIME,
                            dayType: attendance.dayType,
                            duration: totalWorkMinutes,
                            date: attendance.schedule.date,
                            status: request_status_enum_1.RequestStatus.PENDING,
                            employee: { id: attendance.employee.id },
                            organizationId: attendance.employee.organizationId,
                            branchId: attendance.employee.branchId,
                            departmentId: attendance.employee.departmentId,
                            userId: attendance.employee.userId
                        });
                    }
                    else {
                        // Update existing request with overtime minutes
                        this.logger.log(`Updating existing work time request for overtime for employee ${attendance.employee.user.email}`);
                        existingRequest.duration = totalWorkMinutes;
                        await this.workTimeRequestsService.save(existingRequest);
                        await this.notificationsService.create({
                            title: 'Rest Day Overtime Updated',
                            message: `Your overtime request for ${formattedDate} has been updated to ${totalWorkMinutes} minutes.`,
                            type: notification_type_enum_1.NotificationType.INFO,
                            category: 'ATTENDANCE',
                            user: { id: attendance.employee.user.id },
                        });
                    }
                }
                // Save the updated attendance record
                await this.save(attendance);
            }
            catch (error) {
                this.logger.error(`Error processing rest day for attendance ${attendance.id}: ${error.message}`, error.stack);
            }
        }
    }
    async handleAbsentEmployees() {
        var _a;
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        // Find all schedules for the given date that should have attendance
        let previousSchedules = await this.schedulesService.getRepository().find({
            where: {
                date: (0, typeorm_2.LessThan)(today),
            },
            relations: { cutoff: true, employee: { user: true }, attendance: true }
        });
        // First resolve all attendance checks with Promise.all
        const schedulesWithAbsenceInfo = await Promise.all(previousSchedules.map(async (schedule) => {
            const attendance = await this.attendancesRepository.findOne({
                where: { schedule: { id: schedule.id } },
                relations: { schedule: { employee: true } }
            });
            const isAbsent = attendance &&
                (attendance.statuses &&
                    attendance.statuses.includes(attendance_status_enum_1.AttendanceStatus.ABSENT));
            return { schedule, isAbsent };
        }));
        // Then filter based on the resolved absence status
        const absentSchedules = schedulesWithAbsenceInfo
            .filter(item => item.isAbsent)
            .map(item => item.schedule);
        if (absentSchedules.length === 0) {
            this.logger.log(`No schedules found for absence processing`);
            return;
        }
        this.logger.log(`Found ${absentSchedules.length} schedules to process for absence`);
        // Process each absent employee
        for (const schedule of absentSchedules) {
            try {
                let dayType;
                const isRestDay = schedule.restDay;
                const holidayType = (_a = schedule.holiday) === null || _a === void 0 ? void 0 : _a.type;
                if (isRestDay && holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
                    dayType = final_work_hour_entity_1.DayType.REGULAR_HOLIDAY_REST_DAY;
                }
                else if (isRestDay && (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING)) {
                    dayType = final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY_REST_DAY;
                }
                else if (isRestDay) {
                    dayType = final_work_hour_entity_1.DayType.REST_DAY;
                }
                else if (holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
                    dayType = final_work_hour_entity_1.DayType.REGULAR_HOLIDAY;
                }
                else if (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING || holidayType === holiday_type_enum_1.HolidayType.SPECIAL_WORKING) {
                    dayType = final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY;
                }
                else {
                    dayType = final_work_hour_entity_1.DayType.REGULAR_DAY;
                }
                // Create new attendance record with absent status
                let attendance = await this.attendancesRepository.findOne({ where: { schedule: { id: schedule.id } }, relations: { schedule: true } });
                if (!attendance) {
                    this.logger.log(`No attendance record found for employee ${schedule.employee.user.email} on ${(0, date_fns_1.format)(schedule.date, 'MMMM dd, yyyy')}`);
                    attendance = new attendance_entity_1.Attendance({});
                }
                attendance.employee = schedule.employee;
                attendance.schedule = schedule;
                attendance.dayType = dayType;
                attendance.isProcessed = true;
                attendance.date = schedule.date;
                attendance.cutoff = schedule.cutoff;
                attendance.statuses = [attendance_status_enum_1.AttendanceStatus.ABSENT];
                const savedAttendance = await this.attendancesRepository.save(attendance);
                // Check if there is already worktime request for absence
                const existingRequest = await this.workTimeRequestsService.findOneBy({
                    attendance: new attendance_entity_1.Attendance({ id: savedAttendance.id }),
                    type: attendance_status_enum_1.AttendanceStatus.ABSENT,
                }, { relations: { attendance: true } });
                if (!existingRequest) {
                    // Notify the employee about their recorded absence
                    await this.notificationsService.create({
                        user: { id: schedule.employee.user.id },
                        title: 'Absence Recorded',
                        category: 'ATTENDANCE',
                        message: `You were marked absent for ${(0, date_fns_1.format)(schedule.date, 'MMMM dd, yyyy')}`,
                        type: notification_type_enum_1.NotificationType.DANGER
                    });
                    this.logger.log(`New attendance record created for employee ${schedule.employee.user.email} on ${(0, date_fns_1.format)(schedule.date, 'MMMM dd, yyyy')}`);
                    // Create work time request for the absence
                    const workTimeRequest = new work_time_request_entity_1.WorkTimeRequest({});
                    workTimeRequest.employee = schedule.employee;
                    workTimeRequest.attendance = savedAttendance;
                    workTimeRequest.date = schedule.date;
                    workTimeRequest.type = attendance_status_enum_1.AttendanceStatus.ABSENT;
                    workTimeRequest.status = request_status_enum_1.RequestStatus.PENDING;
                    workTimeRequest.cutoff = schedule.cutoff;
                    workTimeRequest.dayType = dayType;
                    workTimeRequest.createdBy = schedule.employee.id;
                    workTimeRequest.organizationId = schedule.employee.organizationId;
                    workTimeRequest.branchId = schedule.employee.branchId;
                    workTimeRequest.departmentId = schedule.employee.departmentId;
                    workTimeRequest.userId = schedule.employee.userId;
                    await this.workTimeRequestsService.save(workTimeRequest);
                }
            }
            catch (error) {
                this.logger.error(`Error processing absence for employee ${schedule.employee.id}: ${error.message}`, error.stack);
            }
        }
    }
};
exports.AttendancesService = AttendancesService;
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_DAY_AT_MIDNIGHT),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], AttendancesService.prototype, "processAttendanceRecords", null);
exports.AttendancesService = AttendancesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(attendance_entity_1.Attendance)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof work_time_requests_service_1.WorkTimeRequestsService !== "undefined" && work_time_requests_service_1.WorkTimeRequestsService) === "function" ? _c : Object, typeof (_d = typeof notifications_service_1.NotificationsService !== "undefined" && notifications_service_1.NotificationsService) === "function" ? _d : Object, typeof (_e = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _e : Object, typeof (_f = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _f : Object, typeof (_g = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _g : Object, typeof (_h = typeof attendances_gateway_1.AttendancesGateway !== "undefined" && attendances_gateway_1.AttendancesGateway) === "function" ? _h : Object, typeof (_j = typeof attendance_configurations_service_1.AttendanceConfigurationsService !== "undefined" && attendance_configurations_service_1.AttendanceConfigurationsService) === "function" ? _j : Object])
], AttendancesService);


/***/ }),

/***/ "./src/modules/attendance-management/dtos/attendance.dto.ts":
/*!******************************************************************!*\
  !*** ./src/modules/attendance-management/dtos/attendance.dto.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAttendanceDto = exports.UpdateAttendanceDto = exports.CreateAttendanceDto = exports.AttendanceDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const attendance_status_enum_1 = __webpack_require__(/*! @/common/enums/attendance-status.enum */ "./src/common/enums/attendance-status.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class AttendanceDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.AttendanceDto = AttendanceDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employee ID',
        example: '123e4567-e89b-12d3-a456-426614174000'
    }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], AttendanceDto.prototype, "employeeId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'List of attendance statuses',
        type: [String],
        enum: attendance_status_enum_1.AttendanceStatus,
        example: [attendance_status_enum_1.AttendanceStatus.CHECKED_IN, attendance_status_enum_1.AttendanceStatus.LATE]
    }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsEnum)(attendance_status_enum_1.AttendanceStatus, { each: true }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Array)
], AttendanceDto.prototype, "statuses", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date of the attendance',
        example: '2023-01-01',
        type: String,
        format: 'date'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], AttendanceDto.prototype, "date", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Time when employee clocked in',
        example: '2023-01-01T09:00:00Z',
        type: Date
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], AttendanceDto.prototype, "timeIn", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Time when employee clocked out',
        example: '2023-01-01T17:00:00Z',
        type: Date,
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], AttendanceDto.prototype, "timeOut", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Schedule ID',
        example: '123e4567-e89b-12d3-a456-426614174000'
    }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], AttendanceDto.prototype, "scheduleId", void 0);
class CreateAttendanceDto extends AttendanceDto {
}
exports.CreateAttendanceDto = CreateAttendanceDto;
class UpdateAttendanceDto extends (0, swagger_1.PartialType)(AttendanceDto) {
}
exports.UpdateAttendanceDto = UpdateAttendanceDto;
class GetAttendanceDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateAttendanceDto, 'attendance') {
}
exports.GetAttendanceDto = GetAttendanceDto;


/***/ }),

/***/ "./src/modules/attendance-management/entities/attendance.entity.ts":
/*!*************************************************************************!*\
  !*** ./src/modules/attendance-management/entities/attendance.entity.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Attendance = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const cutoff_entity_1 = __webpack_require__(/*! @/modules/payroll-management/cutoffs/entities/cutoff.entity */ "./src/modules/payroll-management/cutoffs/entities/cutoff.entity.ts");
const schedule_entity_1 = __webpack_require__(/*! @/modules/shift-management/schedules/entities/schedule.entity */ "./src/modules/shift-management/schedules/entities/schedule.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const attendance_punch_entity_1 = __webpack_require__(/*! ../attendance-punches/entities/attendance-punch.entity */ "./src/modules/attendance-management/attendance-punches/entities/attendance-punch.entity.ts");
const final_work_hour_entity_1 = __webpack_require__(/*! ../final-work-hours/entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
const work_time_request_entity_1 = __webpack_require__(/*! ../work-time-requests/entities/work-time-request.entity */ "./src/modules/attendance-management/work-time-requests/entities/work-time-request.entity.ts");
let Attendance = class Attendance extends base_entity_1.BaseEntity {
};
exports.Attendance = Attendance;
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.attendances, { eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_a = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _a : Object)
], Attendance.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'simple-array',
        nullable: true,
    }),
    __metadata("design:type", Array)
], Attendance.prototype, "statuses", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Attendance.prototype, "timeIn", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], Attendance.prototype, "timeOut", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], Attendance.prototype, "isProcessed", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Attendance.prototype, "processedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date', nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], Attendance.prototype, "date", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], Attendance.prototype, "processedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: final_work_hour_entity_1.DayType }),
    __metadata("design:type", typeof (_f = typeof final_work_hour_entity_1.DayType !== "undefined" && final_work_hour_entity_1.DayType) === "function" ? _f : Object)
], Attendance.prototype, "dayType", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => schedule_entity_1.Schedule, (schedule) => schedule.attendance, { eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'scheduleId' }),
    __metadata("design:type", typeof (_g = typeof schedule_entity_1.Schedule !== "undefined" && schedule_entity_1.Schedule) === "function" ? _g : Object)
], Attendance.prototype, "schedule", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => cutoff_entity_1.Cutoff, (cutoff) => cutoff.attendances),
    (0, typeorm_1.JoinColumn)({ name: 'cutoffId' }),
    __metadata("design:type", typeof (_h = typeof cutoff_entity_1.Cutoff !== "undefined" && cutoff_entity_1.Cutoff) === "function" ? _h : Object)
], Attendance.prototype, "cutoff", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => attendance_punch_entity_1.AttendancePunch, (attendancePunches) => attendancePunches.attendance, { cascade: true }),
    __metadata("design:type", Array)
], Attendance.prototype, "attendancePunches", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => work_time_request_entity_1.WorkTimeRequest, (workTimeRequest) => workTimeRequest.attendance, { cascade: true, nullable: true }),
    __metadata("design:type", Array)
], Attendance.prototype, "workTimeRequests", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => final_work_hour_entity_1.FinalWorkHour, (finalWorkHour) => finalWorkHour.attendance, { nullable: true }),
    __metadata("design:type", typeof (_j = typeof final_work_hour_entity_1.FinalWorkHour !== "undefined" && final_work_hour_entity_1.FinalWorkHour) === "function" ? _j : Object)
], Attendance.prototype, "finalWorkHour", void 0);
exports.Attendance = Attendance = __decorate([
    (0, typeorm_1.Entity)('attendances')
], Attendance);


/***/ }),

/***/ "./src/modules/attendance-management/final-work-hours/dtos/final-work-hour.dto.ts":
/*!****************************************************************************************!*\
  !*** ./src/modules/attendance-management/final-work-hours/dtos/final-work-hour.dto.ts ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g, _h;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFinalWorkHourDto = exports.UpdateFinalWorkHourDto = exports.FinalWorkHourDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const reference_dto_1 = __webpack_require__(/*! @/common/dtos/reference.dto */ "./src/common/dtos/reference.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const final_work_hour_entity_1 = __webpack_require__(/*! ../entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
class FinalWorkHourDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.FinalWorkHourDto = FinalWorkHourDto;
__decorate([
    (0, swagger_1.ApiProperty)({ type: () => reference_dto_1.ReferenceDto, description: 'Employee reference' }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_a = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _a : Object)
], FinalWorkHourDto.prototype, "employee", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: () => reference_dto_1.ReferenceDto, description: 'Attendance reference' }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_b = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _b : Object)
], FinalWorkHourDto.prototype, "attendance", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: () => reference_dto_1.ReferenceDto, description: 'Cutoff reference' }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_c = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _c : Object)
], FinalWorkHourDto.prototype, "cutoff", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Time in', type: Date }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], FinalWorkHourDto.prototype, "timeIn", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Time out', type: Date }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], FinalWorkHourDto.prototype, "timeOut", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Overtime out', type: Date }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_f = typeof Date !== "undefined" && Date) === "function" ? _f : Object)
], FinalWorkHourDto.prototype, "overTimeOut", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'No time in hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "noTimeInHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'No time out hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "noTimeOutHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Absent hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "absentHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Tardiness hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "tardinessHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Undertime hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "undertimeHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Regular day hours', example: 8.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "regularDayHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Rest day hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "restDayHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Special holiday hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "specialHolidayHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Regular holiday hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "regularHolidayHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Overtime regular day hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "overtimeRegularDayHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Overtime rest day hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "overtimeRestDayHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Overtime special holiday hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "overtimeSpecialHolidayHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Overtime regular holiday hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "overtimeRegularHolidayHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Night differential hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "nightDifferentialHours", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Overtime night differential hours', example: 0.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], FinalWorkHourDto.prototype, "nightDifferentialOvertimeHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Day type',
        enum: final_work_hour_entity_1.DayType,
        example: final_work_hour_entity_1.DayType.REGULAR_DAY
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(final_work_hour_entity_1.DayType),
    __metadata("design:type", typeof (_g = typeof final_work_hour_entity_1.DayType !== "undefined" && final_work_hour_entity_1.DayType) === "function" ? _g : Object)
], FinalWorkHourDto.prototype, "dayType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Work date', type: Date }),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_h = typeof Date !== "undefined" && Date) === "function" ? _h : Object)
], FinalWorkHourDto.prototype, "workDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Notes' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FinalWorkHourDto.prototype, "notes", void 0);
class UpdateFinalWorkHourDto extends (0, swagger_1.PartialType)(FinalWorkHourDto) {
}
exports.UpdateFinalWorkHourDto = UpdateFinalWorkHourDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Is approved', example: false }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], UpdateFinalWorkHourDto.prototype, "isApproved", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Is processed', example: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], UpdateFinalWorkHourDto.prototype, "isProcessed", void 0);
class GetFinalWorkHourDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateFinalWorkHourDto, 'final work hour') {
}
exports.GetFinalWorkHourDto = GetFinalWorkHourDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Batch ID' }),
    (0, class_validator_1.IsUUID)('4'),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], GetFinalWorkHourDto.prototype, "payrollBatchId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Batch ID' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)('4'),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GetFinalWorkHourDto.prototype, "batchId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total regular hours', example: 8.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], GetFinalWorkHourDto.prototype, "totalRegularHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total overtime hours', example: 1.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], GetFinalWorkHourDto.prototype, "totalOvertimeHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total hours', example: 9.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], GetFinalWorkHourDto.prototype, "totalHours", void 0);


/***/ }),

/***/ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts":
/*!***********************************************************************************************!*\
  !*** ./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FinalWorkHour = exports.DayType = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const cutoff_entity_1 = __webpack_require__(/*! @/modules/payroll-management/cutoffs/entities/cutoff.entity */ "./src/modules/payroll-management/cutoffs/entities/cutoff.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const attendance_entity_1 = __webpack_require__(/*! ../../entities/attendance.entity */ "./src/modules/attendance-management/entities/attendance.entity.ts");
// Define day type enum for better type safety
var DayType;
(function (DayType) {
    DayType["REGULAR_DAY"] = "REGULAR_DAY";
    DayType["REST_DAY"] = "REST_DAY";
    DayType["SPECIAL_HOLIDAY"] = "SPECIAL_HOLIDAY";
    DayType["REGULAR_HOLIDAY"] = "REGULAR_HOLIDAY";
    DayType["SPECIAL_HOLIDAY_REST_DAY"] = "SPECIAL_HOLIDAY_REST_DAY";
    DayType["REGULAR_HOLIDAY_REST_DAY"] = "REGULAR_HOLIDAY_REST_DAY";
})(DayType || (exports.DayType = DayType = {}));
let FinalWorkHour = class FinalWorkHour extends base_entity_1.BaseEntity {
    // Calculate derived values after loading from database
    calculateDerivedFields() {
        // Calculate totals if not already set
        if (this.totalRegularHours === 0) {
            this.totalRegularHours = +this.regularDayHours + +this.restDayHours +
                +this.specialHolidayHours + +this.regularHolidayHours;
        }
        if (this.totalOvertimeHours === 0) {
            this.totalOvertimeHours = +this.overtimeRegularDayHours + +this.overtimeRestDayHours +
                +this.overtimeSpecialHolidayHours + +this.overtimeRegularHolidayHours;
        }
        if (this.totalHours === 0) {
            this.totalHours = +this.totalRegularHours + +this.totalOvertimeHours;
        }
    }
};
exports.FinalWorkHour = FinalWorkHour;
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.finalWorkHours),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_a = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _a : Object)
], FinalWorkHour.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => attendance_entity_1.Attendance, (attendance) => attendance.finalWorkHour),
    (0, typeorm_1.JoinColumn)({ name: 'attendanceId' }),
    __metadata("design:type", typeof (_b = typeof attendance_entity_1.Attendance !== "undefined" && attendance_entity_1.Attendance) === "function" ? _b : Object)
], FinalWorkHour.prototype, "attendance", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => cutoff_entity_1.Cutoff, (cutoff) => cutoff.finalWorkHours),
    (0, typeorm_1.JoinColumn)({ name: 'cutoffId' }),
    __metadata("design:type", typeof (_c = typeof cutoff_entity_1.Cutoff !== "undefined" && cutoff_entity_1.Cutoff) === "function" ? _c : Object)
], FinalWorkHour.prototype, "cutoff", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], FinalWorkHour.prototype, "timeIn", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], FinalWorkHour.prototype, "timeOut", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_f = typeof Date !== "undefined" && Date) === "function" ? _f : Object)
], FinalWorkHour.prototype, "overTimeOut", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "noTimeInHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "noTimeOutHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "absentHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "tardinessHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "undertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "regularDayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "restDayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "specialHolidayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "regularHolidayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "overtimeRegularDayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "overtimeRestDayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "overtimeSpecialHolidayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "overtimeRegularHolidayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "nightDifferentialHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "overtimeNightDifferentialHours", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: DayType,
        default: DayType.REGULAR_DAY
    }),
    __metadata("design:type", String)
], FinalWorkHour.prototype, "dayType", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "totalRegularHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "totalOvertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "totalHours", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], FinalWorkHour.prototype, "isApproved", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], FinalWorkHour.prototype, "approvedBy", void 0);
__decorate([
    (0, typeorm_1.Column)('timestamp', { nullable: true }),
    __metadata("design:type", typeof (_g = typeof Date !== "undefined" && Date) === "function" ? _g : Object)
], FinalWorkHour.prototype, "approvedAt", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], FinalWorkHour.prototype, "batchId", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], FinalWorkHour.prototype, "payrollBatchId", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], FinalWorkHour.prototype, "isProcessed", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], FinalWorkHour.prototype, "processedBy", void 0);
__decorate([
    (0, typeorm_1.Column)('timestamp', { nullable: true }),
    __metadata("design:type", typeof (_h = typeof Date !== "undefined" && Date) === "function" ? _h : Object)
], FinalWorkHour.prototype, "processedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_j = typeof Date !== "undefined" && Date) === "function" ? _j : Object)
], FinalWorkHour.prototype, "workDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], FinalWorkHour.prototype, "notes", void 0);
__decorate([
    (0, typeorm_1.AfterLoad)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], FinalWorkHour.prototype, "calculateDerivedFields", null);
exports.FinalWorkHour = FinalWorkHour = __decorate([
    (0, typeorm_1.Entity)('final-work-hours')
], FinalWorkHour);


/***/ }),

/***/ "./src/modules/attendance-management/final-work-hours/final-work-hours.controller.ts":
/*!*******************************************************************************************!*\
  !*** ./src/modules/attendance-management/final-work-hours/final-work-hours.controller.ts ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FinalWorkHoursController = void 0;
const authorize_decorator_1 = __webpack_require__(/*! @/common/decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const current_user_decorator_1 = __webpack_require__(/*! @/common/decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const generalresponse_dto_1 = __webpack_require__(/*! @/common/dtos/generalresponse.dto */ "./src/common/dtos/generalresponse.dto.ts");
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const final_work_hour_dto_1 = __webpack_require__(/*! ./dtos/final-work-hour.dto */ "./src/modules/attendance-management/final-work-hours/dtos/final-work-hour.dto.ts");
const final_work_hour_entity_1 = __webpack_require__(/*! ./entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
const final_work_hours_service_1 = __webpack_require__(/*! ./final-work-hours.service */ "./src/modules/attendance-management/final-work-hours/final-work-hours.service.ts");
class FinalWorkHoursController extends (0, create_controller_factory_1.createController)(final_work_hour_entity_1.FinalWorkHour, final_work_hours_service_1.FinalWorkHoursService, final_work_hour_dto_1.GetFinalWorkHourDto, undefined, final_work_hour_dto_1.UpdateFinalWorkHourDto) {
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async delete(id) {
        return await super.delete(id);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    async recalculateByCutoffId(cutoffId, userId) {
        await this.baseService.recalculateByCutoffId(cutoffId, userId);
        return {
            statusCode: common_1.HttpStatus.OK,
            message: 'Final work hours recalculation has been successfully initiated',
        };
    }
}
exports.FinalWorkHoursController = FinalWorkHoursController;
__decorate([
    (0, common_1.Post)('recalculate/cutoff/:cutoffId'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.MANAGE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Recalculate Final Work Hours',
        description: 'Recalculates all final work hours for a specific cutoff period'
    }),
    (0, swagger_1.ApiParam)({
        name: 'cutoffId',
        description: 'The unique identifier of the cutoff period to recalculate',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Final work hours recalculation has been successfully initiated',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Invalid cutoff ID format', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: 'Cutoff period not found', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.INTERNAL_SERVER_ERROR, description: 'Internal server error', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.UNAUTHORIZED, description: 'Unauthorized', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.FORBIDDEN, description: 'Forbidden', type: generalresponse_dto_1.GeneralResponseDto }),
    __param(0, (0, common_1.Param)('cutoffId', common_1.ParseUUIDPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], FinalWorkHoursController.prototype, "recalculateByCutoffId", null);


/***/ }),

/***/ "./src/modules/attendance-management/final-work-hours/final-work-hours.module.ts":
/*!***************************************************************************************!*\
  !*** ./src/modules/attendance-management/final-work-hours/final-work-hours.module.ts ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FinalWorkHoursModule = void 0;
const cutoffs_module_1 = __webpack_require__(/*! @/modules/payroll-management/cutoffs/cutoffs.module */ "./src/modules/payroll-management/cutoffs/cutoffs.module.ts");
const payroll_management_module_1 = __webpack_require__(/*! @/modules/payroll-management/payroll-management.module */ "./src/modules/payroll-management/payroll-management.module.ts");
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const attendance_configurations_module_1 = __webpack_require__(/*! ../attendance-configurations/attendance-configurations.module */ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.module.ts");
const attendance_management_module_1 = __webpack_require__(/*! ../attendance-management.module */ "./src/modules/attendance-management/attendance-management.module.ts");
const final_work_hour_entity_1 = __webpack_require__(/*! ./entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
const final_work_hours_controller_1 = __webpack_require__(/*! ./final-work-hours.controller */ "./src/modules/attendance-management/final-work-hours/final-work-hours.controller.ts");
const final_work_hours_service_1 = __webpack_require__(/*! ./final-work-hours.service */ "./src/modules/attendance-management/final-work-hours/final-work-hours.service.ts");
const work_hour_calculation_service_1 = __webpack_require__(/*! ./services/work-hour-calculation.service */ "./src/modules/attendance-management/final-work-hours/services/work-hour-calculation.service.ts");
let FinalWorkHoursModule = class FinalWorkHoursModule {
};
exports.FinalWorkHoursModule = FinalWorkHoursModule;
exports.FinalWorkHoursModule = FinalWorkHoursModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([final_work_hour_entity_1.FinalWorkHour]),
            bull_1.BullModule.registerQueue({
                name: 'work-hour-calculation'
            }),
            cutoffs_module_1.CutoffsModule,
            (0, common_1.forwardRef)(() => attendance_management_module_1.AttendanceManagementModule),
            payroll_management_module_1.PayrollManagementModule,
            attendance_configurations_module_1.AttendanceConfigurationsModule,
        ],
        providers: [final_work_hours_service_1.FinalWorkHoursService, work_hour_calculation_service_1.WorkHourCalculationService, work_hour_calculation_service_1.WorkHourCalculationProcessor],
        exports: [final_work_hours_service_1.FinalWorkHoursService, work_hour_calculation_service_1.WorkHourCalculationService, work_hour_calculation_service_1.WorkHourCalculationProcessor],
        controllers: [final_work_hours_controller_1.FinalWorkHoursController],
    })
], FinalWorkHoursModule);


/***/ }),

/***/ "./src/modules/attendance-management/final-work-hours/final-work-hours.service.ts":
/*!****************************************************************************************!*\
  !*** ./src/modules/attendance-management/final-work-hours/final-work-hours.service.ts ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FinalWorkHoursService = void 0;
const attendance_status_enum_1 = __webpack_require__(/*! @/common/enums/attendance-status.enum */ "./src/common/enums/attendance-status.enum.ts");
const holiday_type_enum_1 = __webpack_require__(/*! @/common/enums/holiday-type.enum */ "./src/common/enums/holiday-type.enum.ts");
const attendance_event_1 = __webpack_require__(/*! @/common/events/attendance.event */ "./src/common/events/attendance.event.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const cutoffs_service_1 = __webpack_require__(/*! @/modules/payroll-management/cutoffs/cutoffs.service */ "./src/modules/payroll-management/cutoffs/cutoffs.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const date_fns_1 = __webpack_require__(/*! date-fns */ "date-fns");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const attendances_service_1 = __webpack_require__(/*! ../attendances.service */ "./src/modules/attendance-management/attendances.service.ts");
const final_work_hour_entity_1 = __webpack_require__(/*! ./entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
let FinalWorkHoursService = class FinalWorkHoursService extends base_service_1.BaseService {
    constructor(finalWorkHoursRepository, usersService, eventEmitter, cutoffsService, attendancesService) {
        super(finalWorkHoursRepository, usersService);
        this.finalWorkHoursRepository = finalWorkHoursRepository;
        this.usersService = usersService;
        this.eventEmitter = eventEmitter;
        this.cutoffsService = cutoffsService;
        this.attendancesService = attendancesService;
    }
    /**
     * Calculates and categorizes work hours based on day type
     * No pay calculations included - strictly time tracking
     */
    calculateWorkHoursBreakdown(finalWorkHour) {
        var _a;
        const result = {
            regularDayHours: 0,
            restDayHours: 0,
            specialHolidayHours: 0,
            regularHolidayHours: 0,
            absentHours: 0,
            tardinessHours: 0,
            undertimeHours: 0,
            overtimeRegularDayHours: 0,
            overtimeRestDayHours: 0,
            overtimeSpecialHolidayHours: 0,
            overtimeRegularHolidayHours: 0,
            nightDifferentialHours: 0,
            overtimeNightDifferentialHours: 0,
            dayType: final_work_hour_entity_1.DayType.REGULAR_DAY,
            totalRegularHours: 0,
            totalOvertimeHours: 0,
            totalHours: 0
        };
        // Extract schedule information
        const { schedule } = finalWorkHour.attendance;
        const isRestDay = schedule.restDay === true;
        const holidayType = (_a = schedule.holiday) === null || _a === void 0 ? void 0 : _a.type;
        const formattedAttendanceDate = (0, date_fns_1.format)(schedule.date, 'yyyy-MM-dd');
        // Calculate total undertime minutes
        const scheduleEndTime = new Date(`${formattedAttendanceDate}T${schedule.endTime}`);
        const scheduleStartTime = new Date(`${formattedAttendanceDate}T${schedule.startTime}`);
        // Convert hours to milliseconds (1 hour = 3600000 milliseconds)
        const noTimeInMilliseconds = finalWorkHour.noTimeInHours * 3600000;
        const noTimeOutMilliseconds = finalWorkHour.noTimeOutHours * 3600000;
        // Properly calculate timeIn and timeOut with Date objects
        const timeIn = finalWorkHour.timeIn ||
            new Date(scheduleStartTime.getTime() + noTimeInMilliseconds);
        const timeOut = finalWorkHour.timeOut ||
            new Date(scheduleEndTime.getTime() - noTimeOutMilliseconds);
        const { statuses } = finalWorkHour.attendance;
        const isUnderTime = statuses === null || statuses === void 0 ? void 0 : statuses.includes(attendance_status_enum_1.AttendanceStatus.UNDER_TIME);
        const isAbsent = statuses === null || statuses === void 0 ? void 0 : statuses.includes(attendance_status_enum_1.AttendanceStatus.ABSENT);
        if (isAbsent) {
            // If absent, set all hours to 0
            result.absentHours = this.calculateHours(timeIn, timeOut, schedule.breakTime);
            return result;
        }
        // Calculate regular and overtime hours
        const regularHours = this.calculateHours(timeIn, timeOut, schedule.breakTime);
        const overtimeHours = finalWorkHour.overTimeOut ?
            this.calculateHours(timeOut, finalWorkHour.overTimeOut) : 0;
        result.tardinessHours = this.calculateHours(scheduleStartTime, timeIn);
        result.undertimeHours = isUnderTime ? this.calculateHours(timeOut, scheduleEndTime) : 0;
        // Calculate night differential hours
        const nightDiffHours = this.calculateNightDifferentialHours(timeIn, timeOut, finalWorkHour.overTimeOut);
        // Categorize hours based on day type
        if (isRestDay && holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
            result.dayType = final_work_hour_entity_1.DayType.REGULAR_HOLIDAY_REST_DAY;
            result.regularHolidayHours = regularHours;
            result.overtimeRegularHolidayHours = overtimeHours;
        }
        else if (isRestDay && (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING)) {
            result.dayType = final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY_REST_DAY;
            result.specialHolidayHours = regularHours;
            result.overtimeSpecialHolidayHours = overtimeHours;
        }
        else if (isRestDay) {
            result.dayType = final_work_hour_entity_1.DayType.REST_DAY;
            result.restDayHours = regularHours;
            result.overtimeRestDayHours = overtimeHours;
        }
        else if (holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
            result.dayType = final_work_hour_entity_1.DayType.REGULAR_HOLIDAY;
            result.regularHolidayHours = regularHours;
            result.overtimeRegularHolidayHours = overtimeHours;
        }
        else if (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING || holidayType === holiday_type_enum_1.HolidayType.SPECIAL_WORKING) {
            result.dayType = final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY;
            result.specialHolidayHours = regularHours;
            result.overtimeSpecialHolidayHours = overtimeHours;
        }
        else {
            result.dayType = final_work_hour_entity_1.DayType.REGULAR_DAY;
            result.regularDayHours = regularHours;
            result.overtimeRegularDayHours = overtimeHours;
        }
        // Store night differential hours
        result.nightDifferentialHours = nightDiffHours.regular;
        result.overtimeNightDifferentialHours = nightDiffHours.overtime;
        // Calculate totals
        result.totalRegularHours = result.regularDayHours +
            result.restDayHours +
            result.specialHolidayHours +
            result.regularHolidayHours;
        result.totalOvertimeHours = result.overtimeRegularDayHours +
            result.overtimeRestDayHours +
            result.overtimeSpecialHolidayHours +
            result.overtimeRegularHolidayHours;
        result.totalHours = result.totalRegularHours + result.totalOvertimeHours;
        return result;
    }
    /**
     * Calculate night differential hours worked
     * @returns Object containing regular and overtime night differential hours
     */
    calculateNightDifferentialHours(timeIn, timeOut, overTimeOut) {
        const NIGHT_DIFF_START_HOUR = 22; // 10:00 PM
        const NIGHT_DIFF_END_HOUR = 6; // 6:00 AM
        let regularNightDiffHours = 0;
        let overtimeNightDiffHours = 0;
        const timeInLocal = new Date(timeIn);
        const timeOutLocal = new Date(timeOut);
        const overTimeOutLocal = overTimeOut ? new Date(overTimeOut) : null;
        // Calculate regular night differential hours (between timeIn and timeOut)
        let currentHour = new Date(timeInLocal);
        while (currentHour < timeOutLocal) {
            const nextHour = new Date(currentHour);
            nextHour.setHours(nextHour.getHours() + 1);
            const hourEnd = new Date(Math.min(nextHour.getTime(), timeOutLocal.getTime()));
            const hourDiff = this.calculateHours(currentHour, hourEnd, 6);
            const hour = currentHour.getHours();
            if (hour >= NIGHT_DIFF_START_HOUR || hour < NIGHT_DIFF_END_HOUR) {
                regularNightDiffHours += hourDiff;
            }
            currentHour = nextHour;
        }
        // Calculate overtime night differential hours (between timeOut and overTimeOut)
        if (overTimeOutLocal) {
            currentHour = new Date(timeOutLocal);
            while (currentHour < overTimeOutLocal) {
                const nextHour = new Date(currentHour);
                nextHour.setHours(nextHour.getHours() + 1);
                const hourEnd = new Date(Math.min(nextHour.getTime(), overTimeOutLocal.getTime()));
                const hourDiff = this.calculateHours(currentHour, hourEnd, 6);
                const hour = currentHour.getHours();
                if (hour >= NIGHT_DIFF_START_HOUR || hour < NIGHT_DIFF_END_HOUR) {
                    overtimeNightDiffHours += hourDiff;
                }
                currentHour = nextHour;
            }
        }
        // Round to 2 decimal places
        return {
            regular: Math.round(regularNightDiffHours * 100) / 100,
            overtime: Math.round(overtimeNightDiffHours * 100) / 100
        };
    }
    /**
     * Calculate hours between two time points, subtracting break time
     * @param start Start date and time
     * @param end End date and time
     * @param breakTimeDuration Break time in minutes
     * @returns Number of hours worked, rounded to 2 decimal places
     */
    calculateHours(start, end, breakTimeDuration = 0) {
        // Calculate the time difference in milliseconds
        const diffMs = end.getTime() - start.getTime();
        // Convert to hours
        const diffHours = diffMs / (1000 * 60 * 60);
        // Convert break time from minutes to hours and subtract
        const breakTimeHours = breakTimeDuration / 60;
        const totalHours = diffHours - breakTimeHours;
        // Round to 2 decimal places
        return Math.round(totalHours * 100) / 100;
    }
    async recalculateByCutoffId(cutoffId, updatedBy) {
        var _a;
        // Check if cutoff exists
        const cutoff = await this.cutoffsService.findOneByOrFail({ id: cutoffId }, { relations: { attendances: true } });
        // get all processed attendances
        const processedAttendances = (_a = cutoff.attendances) === null || _a === void 0 ? void 0 : _a.filter(attendance => {
            return attendance.isProcessed;
        });
        if (!processedAttendances || processedAttendances.length === 0) {
            throw new common_1.NotFoundException(`No processed attendances found for cutoff ID: ${cutoffId}`);
        }
        // emit event to recalculate final work hours
        this.eventEmitter.emit(attendance_event_1.ATTENDANCE_EVENTS.RECALCULATE_FINAL_WORK_HOURS, new attendance_event_1.RecalculateFinalWorkHoursEvent(updatedBy, cutoffId));
    }
    /*
    * Recalculate final work hours for a specific attendance
    * @param attendanceId ID of the attendance to recalculate
    * @param updatedBy User who triggered the update
    */
    async recalculateByAttendanceId(attendanceId, updatedBy) {
        // Check if attendance exists'
        await this.attendancesService.findOneByOrFail({ id: attendanceId });
        this.eventEmitter.emit(attendance_event_1.ATTENDANCE_EVENTS.RECALCULATE_FINAL_WORK_HOURS, new attendance_event_1.RecalculateFinalWorkHoursEvent(updatedBy, undefined, [attendanceId]));
    }
    /**
     * Updates a FinalWorkHour entity with calculated hours breakdown
     */
    async updateWorkHoursBreakdown(finalWorkHourId, createdBy) {
        const finalWorkHour = await this.findOneByOrFail({ id: finalWorkHourId }, { relations: { attendance: { schedule: { holiday: true } } } });
        const breakdown = this.calculateWorkHoursBreakdown(finalWorkHour);
        // log
        this.logger.log(`Updating final work hour ${finalWorkHourId}`);
        // Update the record with calculated hours
        return this.update(finalWorkHourId, {
            regularDayHours: breakdown.regularDayHours,
            restDayHours: breakdown.restDayHours,
            specialHolidayHours: breakdown.specialHolidayHours,
            regularHolidayHours: breakdown.regularHolidayHours,
            overtimeRegularDayHours: breakdown.overtimeRegularDayHours,
            overtimeRestDayHours: breakdown.overtimeRestDayHours,
            overtimeSpecialHolidayHours: breakdown.overtimeSpecialHolidayHours,
            overtimeRegularHolidayHours: breakdown.overtimeRegularHolidayHours,
            nightDifferentialHours: breakdown.nightDifferentialHours,
            dayType: breakdown.dayType,
            absentHours: breakdown.absentHours,
            tardinessHours: breakdown.tardinessHours,
            undertimeHours: breakdown.undertimeHours,
            totalRegularHours: breakdown.totalRegularHours,
            totalOvertimeHours: breakdown.totalOvertimeHours,
            totalHours: breakdown.totalHours,
        }, createdBy);
    }
};
exports.FinalWorkHoursService = FinalWorkHoursService;
exports.FinalWorkHoursService = FinalWorkHoursService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(final_work_hour_entity_1.FinalWorkHour)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _c : Object, typeof (_d = typeof cutoffs_service_1.CutoffsService !== "undefined" && cutoffs_service_1.CutoffsService) === "function" ? _d : Object, typeof (_e = typeof attendances_service_1.AttendancesService !== "undefined" && attendances_service_1.AttendancesService) === "function" ? _e : Object])
], FinalWorkHoursService);


/***/ }),

/***/ "./src/modules/attendance-management/final-work-hours/services/work-hour-calculation.service.ts":
/*!******************************************************************************************************!*\
  !*** ./src/modules/attendance-management/final-work-hours/services/work-hour-calculation.service.ts ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var WorkHourCalculationService_1, WorkHourCalculationProcessor_1;
var _a, _b, _c, _d, _e, _f, _g, _h;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkHourCalculationProcessor = exports.WorkHourCalculationService = void 0;
const attendance_status_enum_1 = __webpack_require__(/*! @/common/enums/attendance-status.enum */ "./src/common/enums/attendance-status.enum.ts");
const payroll_state_enum_1 = __webpack_require__(/*! @/common/enums/payroll/payroll-state.enum */ "./src/common/enums/payroll/payroll-state.enum.ts");
const payrolls_service_1 = __webpack_require__(/*! @/modules/payroll-management/payrolls.service */ "./src/modules/payroll-management/payrolls.service.ts");
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const bull_2 = __webpack_require__(/*! bull */ "bull");
const date_fns_1 = __webpack_require__(/*! date-fns */ "date-fns");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const uuid_1 = __webpack_require__(/*! uuid */ "uuid");
const attendance_configurations_service_1 = __webpack_require__(/*! ../../attendance-configurations/attendance-configurations.service */ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.service.ts");
const attendances_service_1 = __webpack_require__(/*! ../../attendances.service */ "./src/modules/attendance-management/attendances.service.ts");
const attendance_entity_1 = __webpack_require__(/*! ../../entities/attendance.entity */ "./src/modules/attendance-management/entities/attendance.entity.ts");
const work_time_requests_service_1 = __webpack_require__(/*! ../../work-time-requests/work-time-requests.service */ "./src/modules/attendance-management/work-time-requests/work-time-requests.service.ts");
const final_work_hour_entity_1 = __webpack_require__(/*! ../entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
const final_work_hours_service_1 = __webpack_require__(/*! ../final-work-hours.service */ "./src/modules/attendance-management/final-work-hours/final-work-hours.service.ts");
let WorkHourCalculationService = WorkHourCalculationService_1 = class WorkHourCalculationService {
    constructor(workHourQueue) {
        this.workHourQueue = workHourQueue;
        this.logger = new common_1.Logger(WorkHourCalculationService_1.name);
    }
    async queueFinalWorkHoursCalculation(attendanceIds, processedBy) {
        try {
            // Validate input
            if (!attendanceIds || attendanceIds.length === 0) {
                throw new Error('No attendance IDs provided for calculation');
            }
            // Generate a batch ID for tracking
            const batchId = (0, uuid_1.v4)();
            // Queue the job with high priority
            await this.workHourQueue.add('calculate-final-work-hours', {
                attendanceIds,
                batchId,
                processedBy
            }, {
                priority: 1,
                attempts: 3,
                backoff: {
                    type: 'exponential',
                    delay: 5000
                },
                removeOnComplete: true,
                jobId: `final-work-hours-${batchId}`
            });
            this.logger.log(`Queued final work hours calculation for batch ${batchId} with ${attendanceIds.length} attendances`);
            return batchId;
        }
        catch (error) {
            this.logger.error(`Failed to queue work hour calculation: ${error.message}`, error.stack);
            throw error;
        }
    }
};
exports.WorkHourCalculationService = WorkHourCalculationService;
exports.WorkHourCalculationService = WorkHourCalculationService = WorkHourCalculationService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, bull_1.InjectQueue)('work-hour-calculation')),
    __metadata("design:paramtypes", [typeof (_a = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _a : Object])
], WorkHourCalculationService);
let WorkHourCalculationProcessor = WorkHourCalculationProcessor_1 = class WorkHourCalculationProcessor {
    constructor(attendanceService, finalWorkHourService, workTimeRequestsService, payrollsService, attendanceConfigurationsService) {
        this.attendanceService = attendanceService;
        this.finalWorkHourService = finalWorkHourService;
        this.workTimeRequestsService = workTimeRequestsService;
        this.payrollsService = payrollsService;
        this.attendanceConfigurationsService = attendanceConfigurationsService;
        this.logger = new common_1.Logger(WorkHourCalculationProcessor_1.name);
        this.GRACE_PERIOD_MINUTES = 5; // Consider late after 5 minutes
    }
    async calculateFinalWorkHours(job) {
        const { attendanceIds, batchId, processedBy } = job.data;
        this.logger.log(`Processing final work hours calculation for batch ${batchId} with ${attendanceIds.length} attendances`);
        try {
            let processedCount = 0;
            let failedCount = 0;
            for (const attendanceId of attendanceIds) {
                try {
                    // log hello
                    await this.processAttendance(attendanceId, batchId, processedBy);
                    processedCount++;
                }
                catch (attendanceError) {
                    failedCount++;
                    this.logger.error(`Error processing attendance ${attendanceId} in batch ${batchId}: ${attendanceError.message}`);
                    // Continue processing other attendances despite this error
                }
            }
            if (failedCount > attendanceIds.length * 0.5) { // If more than 50% failed
                throw new Error(`Batch ${batchId} had too many failures: ${failedCount}/${attendanceIds.length}`);
            }
            if (processedCount === attendanceIds.length) {
                this.logger.log(`Successfully processed all ${processedCount} attendances in batch ${batchId}`);
            }
            else {
                this.logger.warn(`Processed ${processedCount} out of ${attendanceIds.length} attendances in batch ${batchId}`);
            }
        }
        catch (error) {
            this.logger.error(`Failed to process batch ${batchId}: ${error.message}`);
            throw error; // Re-throw to allow Bull to handle the job failure
        }
    }
    async processAttendance(attendanceId, batchId, processedBy) {
        var _a, _b;
        this.logger.log(`Processing attendance ${attendanceId}`);
        // Find attendance with all necessary relations
        let attendance = await this.attendanceService.findOneByOrFail({ id: attendanceId }, { relations: { employee: true, schedule: { shift: true, cutoff: true, holiday: true } } });
        // Create or update final work hour record
        let finalWorkHour = await this.finalWorkHourService.findOneBy({
            attendance: new attendance_entity_1.Attendance({ id: attendanceId })
        }, { relations: { attendance: true } });
        if (finalWorkHour) {
            this.logger.log(`Final work hour already exists for attendance ${attendanceId}, updating...`);
        }
        else {
            this.logger.log(`Creating new final work hour for attendance ${attendanceId}`);
            finalWorkHour = new final_work_hour_entity_1.FinalWorkHour({});
        }
        const config = await this.attendanceConfigurationsService.getOrganizationAttendanceConfiguration(attendance.organizationId);
        // Convert schedule times to Date objects when needed
        let timeIn = attendance.timeIn;
        let timeOut = attendance.timeOut;
        let overTimeOut = undefined;
        let noTimeInHours = 0;
        let noTimeOutHours = 0;
        // Safely parse schedule times
        let scheduleEndTime, scheduleStartTime;
        try {
            const [shours, sminutes] = attendance.schedule.endTime.split(':').map(Number);
            scheduleEndTime = new Date(attendance.schedule.date);
            scheduleEndTime.setHours(shours, sminutes, 0);
            const [ehours, eminutes] = attendance.schedule.startTime.split(':').map(Number);
            scheduleStartTime = new Date(attendance.schedule.date);
            scheduleStartTime.setHours(ehours, eminutes, 0);
        }
        catch (parseError) {
            throw new Error(`Invalid schedule times for attendance ${attendanceId}: ${parseError.message}`);
        }
        // Handle timeIn logic
        // Check if there is no time in
        if (!timeIn) {
            // Check if attendance status is not an absent
            if (((_a = attendance.statuses) === null || _a === void 0 ? void 0 : _a.includes(attendance_status_enum_1.AttendanceStatus.ABSENT)) === false) {
                noTimeInHours = config.noTimeInDeductionMinutes / 60;
            }
        }
        // Check if timeIn is before schedule start time
        else if (timeIn < scheduleStartTime) {
            // check if config does not allow early time
            if (!config.allowEarlyTime) {
                timeIn = new Date(scheduleStartTime);
            }
            else {
                const isManagementRequested = await this.workTimeRequestsService.checkForManagementRequest(attendance.employee.id, (0, date_fns_1.format)(attendance.schedule.date, 'yyyy-MM-dd'), attendance_status_enum_1.AttendanceStatus.EARLY);
                if (isManagementRequested) {
                    this.logger.debug(`Management requested early time for attendance ${attendanceId}`);
                    // Calculate new timeIn by subtracting the approved duration (in minutes) from the schedule start time
                    const durationInMinutes = isManagementRequested.duration || 0;
                    timeIn = new Date(scheduleStartTime);
                    timeIn.setMinutes(timeIn.getMinutes() - durationInMinutes);
                }
                else {
                    // If management did not request early time, set timeIn to schedule start time
                    timeIn = new Date(scheduleStartTime);
                    this.logger.debug(`Setting timeIn to schedule start time for attendance ${attendanceId}`);
                }
            }
        }
        else {
            const lateRequest = await this.workTimeRequestsService.getRepository().findOne({
                where: {
                    attendance: { id: attendanceId },
                    type: attendance_status_enum_1.AttendanceStatus.LATE
                },
                relations: { workTimeResponse: true, attendance: true }
            });
            if (lateRequest) {
                this.logger.debug(`Late request found for attendance ${attendanceId}, adjusting timeIn`);
                // Adjust timeIn based on late request
                timeIn = new Date(scheduleStartTime);
                timeIn.setMinutes(scheduleStartTime.getMinutes() + (lateRequest.duration || 0));
            }
        }
        // Handle timeOut logic
        if (!timeOut) {
            // Check if attendance status contains absent
            if (((_b = attendance.statuses) === null || _b === void 0 ? void 0 : _b.includes(attendance_status_enum_1.AttendanceStatus.ABSENT)) === false) {
                noTimeOutHours = config.noTimeOutDeductionMinutes / 60;
            }
        }
        else if (timeOut > scheduleEndTime) {
            try {
                // Find the work time request of this attendance
                const workTimeRequest = await this.workTimeRequestsService.getRepository().findOne({
                    where: {
                        attendance: { id: attendanceId },
                        workTimeResponse: { approved: true },
                        type: attendance_status_enum_1.AttendanceStatus.OVERTIME
                    },
                    relations: { workTimeResponse: true, attendance: true }
                });
                if (workTimeRequest) {
                    this.logger.debug(`Overtime approved for attendance ${attendanceId}`);
                    timeOut = new Date(scheduleEndTime);
                    overTimeOut = new Date(timeOut);
                    overTimeOut.setMinutes(overTimeOut.getMinutes() + (workTimeRequest.duration || 0));
                    this.logger.debug(`Setting timeOut to ${overTimeOut} for attendance ${attendanceId}`);
                }
                else {
                    // If no overtime request, set timeOut to schedule end time
                    this.logger.debug(`No overtime request found for attendance ${attendanceId}, setting timeOut to schedule end time`);
                    timeOut = new Date(scheduleEndTime);
                }
            }
            catch (queryError) {
                this.logger.warn(`Error checking work time request for attendance ${attendanceId}: ${queryError.message}`);
                timeOut = new Date(scheduleEndTime);
            }
        }
        else {
            // Check if there is an early time request
            const underRequest = await this.workTimeRequestsService.getRepository().findOne({
                where: {
                    attendance: { id: attendanceId },
                    type: attendance_status_enum_1.AttendanceStatus.UNDER_TIME
                },
                relations: { workTimeResponse: true, attendance: true }
            });
            if (underRequest) {
                this.logger.debug(`Early request found for attendance ${attendanceId}, adjusting timeOut`);
                // Adjust timeOut based on early request
                timeOut = new Date(scheduleEndTime);
                timeOut.setMinutes(scheduleEndTime.getMinutes() - (underRequest.duration || 0));
            }
            else {
                this.logger.debug(`No early request found for attendance ${attendanceId}, keeping original timeOut`);
            }
        }
        try {
            finalWorkHour = await this.finalWorkHourService.getRepository().save({
                id: finalWorkHour.id,
                attendance: { id: attendanceId },
                employee: { id: attendance.employee.id },
                cutoff: { id: attendance.schedule.cutoff.id },
                timeIn,
                batchId,
                timeOut,
                overTimeOut,
                noTimeInHours,
                noTimeOutHours,
                organizationId: attendance.employee.organizationId,
                branchId: attendance.employee.branchId,
                departmentId: attendance.employee.departmentId,
                userId: attendance.employee.userId,
                dayType: attendance.dayType,
                workDate: attendance.schedule.date,
                createdBy: finalWorkHour.id ? finalWorkHour.createdBy : processedBy,
                updatedBy: finalWorkHour.id ? processedBy : undefined,
            });
            // Update work hours breakdown
            await this.finalWorkHourService.updateWorkHoursBreakdown(finalWorkHour.id, processedBy);
            const payroll = await this.payrollsService.getRepository().findOne({
                where: {
                    cutoff: { id: attendance.schedule.cutoff.id },
                    employee: { id: attendance.employee.id },
                    state: (0, typeorm_1.Not)(payroll_state_enum_1.PayrollState.VOID)
                },
                relations: { cutoff: true, employee: true }
            });
            // update payrolls if needed
            if (payroll)
                await this.payrollsService.recalculatePayroll(payroll === null || payroll === void 0 ? void 0 : payroll.id, { preserveState: true }, processedBy);
        }
        catch (saveError) {
            throw new Error(`Database error while saving final work hour: ${saveError.message}`);
        }
    }
};
exports.WorkHourCalculationProcessor = WorkHourCalculationProcessor;
__decorate([
    (0, bull_1.Process)('calculate-final-work-hours'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_g = typeof bull_2.Job !== "undefined" && bull_2.Job) === "function" ? _g : Object]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], WorkHourCalculationProcessor.prototype, "calculateFinalWorkHours", null);
exports.WorkHourCalculationProcessor = WorkHourCalculationProcessor = WorkHourCalculationProcessor_1 = __decorate([
    (0, bull_1.Processor)('work-hour-calculation'),
    __metadata("design:paramtypes", [typeof (_b = typeof attendances_service_1.AttendancesService !== "undefined" && attendances_service_1.AttendancesService) === "function" ? _b : Object, typeof (_c = typeof final_work_hours_service_1.FinalWorkHoursService !== "undefined" && final_work_hours_service_1.FinalWorkHoursService) === "function" ? _c : Object, typeof (_d = typeof work_time_requests_service_1.WorkTimeRequestsService !== "undefined" && work_time_requests_service_1.WorkTimeRequestsService) === "function" ? _d : Object, typeof (_e = typeof payrolls_service_1.PayrollsService !== "undefined" && payrolls_service_1.PayrollsService) === "function" ? _e : Object, typeof (_f = typeof attendance_configurations_service_1.AttendanceConfigurationsService !== "undefined" && attendance_configurations_service_1.AttendanceConfigurationsService) === "function" ? _f : Object])
], WorkHourCalculationProcessor);


/***/ }),

/***/ "./src/modules/attendance-management/gateways/attendances.gateway.ts":
/*!***************************************************************************!*\
  !*** ./src/modules/attendance-management/gateways/attendances.gateway.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancesGateway = void 0;
const create_gateway_factory_1 = __webpack_require__(/*! @/common/factories/create-gateway.factory */ "./src/common/factories/create-gateway.factory.ts");
class AttendancesGateway extends (0, create_gateway_factory_1.createGateway)('attendances') {
}
exports.AttendancesGateway = AttendancesGateway;


/***/ }),

/***/ "./src/modules/attendance-management/listeners/attendance.listener.ts":
/*!****************************************************************************!*\
  !*** ./src/modules/attendance-management/listeners/attendance.listener.ts ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AttendanceListener_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendanceListener = void 0;
const attendance_status_enum_1 = __webpack_require__(/*! @/common/enums/attendance-status.enum */ "./src/common/enums/attendance-status.enum.ts");
const holiday_type_enum_1 = __webpack_require__(/*! @/common/enums/holiday-type.enum */ "./src/common/enums/holiday-type.enum.ts");
const notification_type_enum_1 = __webpack_require__(/*! @/common/enums/notification-type.enum */ "./src/common/enums/notification-type.enum.ts");
const request_status_enum_1 = __webpack_require__(/*! @/common/enums/request-status.enum */ "./src/common/enums/request-status.enum.ts");
const schedule_status_1 = __webpack_require__(/*! @/common/enums/schedule-status */ "./src/common/enums/schedule-status.ts");
const attendance_event_1 = __webpack_require__(/*! @/common/events/attendance.event */ "./src/common/events/attendance.event.ts");
const attendance_punches_service_1 = __webpack_require__(/*! @/modules/attendance-management/attendance-punches/attendance-punches.service */ "./src/modules/attendance-management/attendance-punches/attendance-punches.service.ts");
const attendances_service_1 = __webpack_require__(/*! @/modules/attendance-management/attendances.service */ "./src/modules/attendance-management/attendances.service.ts");
const biometric_devices_service_1 = __webpack_require__(/*! @/modules/biometrics/services/biometric-devices.service */ "./src/modules/biometrics/services/biometric-devices.service.ts");
const employees_service_1 = __webpack_require__(/*! @/modules/employee-management/employees.service */ "./src/modules/employee-management/employees.service.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const notifications_service_1 = __webpack_require__(/*! @/modules/notifications/notifications.service */ "./src/modules/notifications/notifications.service.ts");
const schedule_entity_1 = __webpack_require__(/*! @/modules/shift-management/schedules/entities/schedule.entity */ "./src/modules/shift-management/schedules/entities/schedule.entity.ts");
const schedules_service_1 = __webpack_require__(/*! @/modules/shift-management/schedules/schedules.service */ "./src/modules/shift-management/schedules/schedules.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const date_fns_1 = __webpack_require__(/*! date-fns */ "date-fns");
const attendance_configurations_service_1 = __webpack_require__(/*! ../attendance-configurations/attendance-configurations.service */ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.service.ts");
const final_work_hour_entity_1 = __webpack_require__(/*! ../final-work-hours/entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
const work_hour_calculation_service_1 = __webpack_require__(/*! ../final-work-hours/services/work-hour-calculation.service */ "./src/modules/attendance-management/final-work-hours/services/work-hour-calculation.service.ts");
const work_time_requests_service_1 = __webpack_require__(/*! ../work-time-requests/work-time-requests.service */ "./src/modules/attendance-management/work-time-requests/work-time-requests.service.ts");
let AttendanceListener = AttendanceListener_1 = class AttendanceListener {
    constructor(attendancesService, attendancePunchesService, employeesService, schedulesService, biometricDevicesService, notificationsService, workTimeRequestsService, workHourCalculationService, attendanceConfigurationsService) {
        this.attendancesService = attendancesService;
        this.attendancePunchesService = attendancePunchesService;
        this.employeesService = employeesService;
        this.schedulesService = schedulesService;
        this.biometricDevicesService = biometricDevicesService;
        this.notificationsService = notificationsService;
        this.workTimeRequestsService = workTimeRequestsService;
        this.workHourCalculationService = workHourCalculationService;
        this.attendanceConfigurationsService = attendanceConfigurationsService;
        this.logger = new common_1.Logger(AttendanceListener_1.name);
    }
    async handleAttendanceRecorded(event) {
        var _a, _b, _c, _d, _e, _f;
        // Get the biometric device entity
        const biometricDevice = await this.biometricDevicesService.findOneBy({ deviceId: event.deviceId });
        if (!biometricDevice) {
            this.logger.error(`Biometric device with ID ${event.deviceId} not found`);
            return;
        }
        // Process each attendance record
        for (const record of event.attendances) {
            try {
                // Validate userId is a proper number before parsing
                if (!record.userId || !/^\d+$/.test(record.userId)) {
                    this.logger.warn(`Invalid user ID format: "${record.userId}". Must be numeric.`);
                    continue;
                }
                const employeeNumber = parseInt(record.userId, 10);
                if (isNaN(employeeNumber)) {
                    this.logger.warn(`Failed to parse employee number from: "${record.userId}"`);
                    continue;
                }
                // Find employee by biometric ID
                const employee = await this.employeesService.findOneBy({
                    employeeNumber
                }, { relations: { user: true } });
                if (!employee) {
                    this.logger.warn(`No employee found with biometric ID ${record.userId}`);
                    continue;
                }
                const config = await this.attendanceConfigurationsService.getOrganizationAttendanceConfiguration(employee.organizationId);
                const punchTime = new Date(record.timestamp);
                punchTime.setSeconds(0, 0); // Set seconds and milliseconds to zero
                const punchDate = (0, date_fns_1.format)(punchTime, 'yyyy-MM-dd');
                const punchTimeStr = (0, date_fns_1.format)(punchTime, 'HH:mm');
                // Find today's schedule for the employee
                const todaySchedule = await this.schedulesService.getEmployeeScheduleToday(employee.id);
                let attendanceStatuses = [];
                if (!todaySchedule) {
                    this.logger.warn(`No schedule found for employee ${employee.id} on ${punchDate}`);
                    // Notify employee
                    await this.notificationsService.create({
                        title: 'No Schedule Found',
                        message: `You have no schedule for today (${punchDate}). Your attendance will not be recorded. Please communicate with your HR/Supervisor.`,
                        type: notification_type_enum_1.NotificationType.WARNING,
                        category: 'ATTENDANCE',
                        user: { id: employee.user.id },
                    });
                    continue;
                }
                let dayType;
                const isRestDay = todaySchedule.restDay;
                const holidayType = (_a = todaySchedule.holiday) === null || _a === void 0 ? void 0 : _a.type;
                if (isRestDay && holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
                    dayType = final_work_hour_entity_1.DayType.REGULAR_HOLIDAY_REST_DAY;
                }
                else if (isRestDay && (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING)) {
                    dayType = final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY_REST_DAY;
                }
                else if (isRestDay) {
                    dayType = final_work_hour_entity_1.DayType.REST_DAY;
                }
                else if (holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
                    dayType = final_work_hour_entity_1.DayType.REGULAR_HOLIDAY;
                }
                else if (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING || holidayType === holiday_type_enum_1.HolidayType.SPECIAL_WORKING) {
                    dayType = final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY;
                }
                else {
                    dayType = final_work_hour_entity_1.DayType.REGULAR_DAY;
                }
                if (todaySchedule.status === schedule_status_1.ScheduleStatus.LEAVE) {
                    this.logger.log(`Employee ${employee.id} is on leave today`);
                    // Notify employee
                    await this.notificationsService.create({
                        title: 'Leave Notification',
                        message: `You are on leave today (${punchDate}). Your attendance will be recorded.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: employee.user.id },
                    });
                }
                if (todaySchedule.holiday) {
                    this.logger.log(`Employee ${employee.id} checked in on a holiday (${todaySchedule.holiday.name})`);
                    // Notify employee
                    await this.notificationsService.create({
                        title: 'Holiday Check-in',
                        message: `You checked in on a holiday (${todaySchedule.holiday.name}) on ${punchDate} at ${punchTimeStr}.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: employee.user.id },
                    });
                }
                if (todaySchedule.restDay) {
                    this.logger.log(`Employee ${employee.id} is on rest day but checking in`);
                    // notify employee
                    await this.notificationsService.create({
                        title: 'Rest Day Check-in',
                        message: `You are on a rest day but checked in on ${punchDate} at ${punchTimeStr}.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: employee.user.id },
                    });
                }
                const { startTime, endTime } = todaySchedule;
                const effectiveStartTime = startTime;
                const effectiveEndTime = endTime;
                const shiftStartTime = (0, date_fns_1.parseISO)(`${punchDate}T${effectiveStartTime}`);
                const shiftEndTime = (0, date_fns_1.parseISO)(`${punchDate}T${effectiveEndTime}`);
                const middleTime = new Date(shiftStartTime.getTime() +
                    (shiftEndTime.getTime() - shiftStartTime.getTime()) / 2);
                middleTime.setSeconds(0, 0); // Set seconds and milliseconds to zero
                // Find attendance for today if it exists
                let existingAttendance = await this.attendancesService.findOneBy({
                    employee: new employee_entity_1.Employee({ id: employee.id }),
                    schedule: new schedule_entity_1.Schedule({ id: todaySchedule.id }),
                }, { relations: { cutoff: true } });
                // If no existing attendance create an attendance
                if (!existingAttendance) {
                    this.logger.log(`Creating new attendance for employee ${employee.user.email} on ${punchDate}`);
                    existingAttendance = await this.attendancesService.create({
                        employee: { id: employee.id },
                        schedule: { id: todaySchedule.id },
                        cutoff: { id: todaySchedule.cutoff.id },
                        date: todaySchedule.date,
                        dayType,
                        organizationId: employee.organizationId,
                        departmentId: employee.departmentId,
                        branchId: employee.branchId,
                        userId: employee.user.id,
                    }, employee.user.id);
                }
                // Determine check-in status based on middle time threshold
                if ((0, date_fns_1.isBefore)(punchTime, middleTime)) {
                    // log
                    this.logger.log(`Employee ${employee.user.email} checked in before middle time on ${punchDate} at ${punchTimeStr}`);
                    if (!existingAttendance.timeIn) {
                        // log
                        this.logger.log(`Employee ${employee.user.email} is checking in`);
                        // Check if late
                        if ((0, date_fns_1.isAfter)(punchTime, shiftStartTime)) {
                            // Check if orgnaization does not allow late time
                            if (!config.allowLate) {
                                const minutesLate = (0, date_fns_1.differenceInMinutes)(punchTime, shiftStartTime);
                                // Check if minutes late can be considered as late time
                                if (minutesLate > config.gracePeriodMinutes) {
                                    this.logger.log(`Employee ${employee.user.email} is late by ${minutesLate} minutes`);
                                    // Mark attendance as late time
                                    attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.LATE);
                                    let roundedMinutes = minutesLate;
                                    // Check if organization rounds up late time
                                    if (config.roundUpLate) {
                                        roundedMinutes = Math.ceil(minutesLate / config.roundUpLateMinutes) * config.roundUpLateMinutes;
                                        this.logger.log(`Rounded late time to ${roundedMinutes} minutes`);
                                    }
                                    // Create work time request for late arrival
                                    await this.createWorkTimeRequest(dayType, employee.id, attendance_status_enum_1.AttendanceStatus.LATE, existingAttendance, roundedMinutes);
                                    // Notify employee
                                    await this.notificationsService.create({
                                        title: 'Late Check-in',
                                        message: `You are late by ${minutesLate} minutes on ${punchDate} at ${punchTimeStr}.${config.roundUpLate ? ` This was rounded up to ${roundedMinutes} minutes.` : ''}`,
                                        type: notification_type_enum_1.NotificationType.WARNING,
                                        category: 'ATTENDANCE',
                                        user: { id: employee.user.id },
                                    });
                                }
                                else {
                                    this.logger.log('Minutes late is not considered as late time');
                                }
                            }
                            else {
                                this.logger.log('Organization allows late time');
                            }
                        }
                        else {
                            // Check organization allow early time
                            if (config.allowEarlyTime) {
                                let minutesEarly = (0, date_fns_1.differenceInMinutes)(shiftStartTime, punchTime);
                                // Check if minutes early can be considered as early time
                                if (minutesEarly > config.earlyTimeThresholdMinutes) {
                                    // Mark attendance as early time
                                    this.logger.log(`Employee ${employee.user.email} is early by ${minutesEarly} minutes`);
                                    attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.EARLY);
                                    attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.CHECKED_IN);
                                    // Check if early time is management-requested
                                    const isManagementRequested = await this.workTimeRequestsService.checkForManagementRequest(employee.id, punchDate, attendance_status_enum_1.AttendanceStatus.EARLY);
                                    if (isManagementRequested) {
                                        this.logger.log(`Early time is management-requested`);
                                        let roundedMinutes = minutesEarly;
                                        // Check if organization rounds down early time
                                        if (config.roundDownEarlyTime) {
                                            // Round down early time by the organization's round down minutes
                                            roundedMinutes = Math.floor(minutesEarly / config.roundDownEarlyTimeMinutes) * config.roundDownEarlyTimeMinutes;
                                            this.logger.log(`Rounded early time from ${minutesEarly} to ${roundedMinutes} minutes`);
                                        }
                                        // Update management-requested work time request
                                        isManagementRequested.duration = roundedMinutes;
                                        isManagementRequested.dayType = dayType;
                                        isManagementRequested.attendance = existingAttendance;
                                        await this.workTimeRequestsService.save(isManagementRequested);
                                        // Notify employee
                                        await this.notificationsService.create({
                                            title: 'Early Time Check-in',
                                            message: `You checked in early by ${minutesEarly} minutes on ${punchDate} at ${punchTimeStr}.${config.roundDownEarlyTime ? ` This was rounded down to ${roundedMinutes} minutes.` : ''}`,
                                            type: notification_type_enum_1.NotificationType.INFO,
                                            category: 'ATTENDANCE',
                                            user: { id: employee.user.id },
                                        });
                                    }
                                }
                                else {
                                    this.logger.log('Time in is not considered as early time');
                                }
                            }
                            else {
                                this.logger.log('Organization does not allow early time');
                            }
                        }
                        if (!((_b = existingAttendance.statuses) === null || _b === void 0 ? void 0 : _b.includes(attendance_status_enum_1.AttendanceStatus.CHECKED_IN))) {
                            attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.CHECKED_IN);
                        }
                        existingAttendance.timeIn = punchTime;
                        existingAttendance.statuses = attendanceStatuses;
                    }
                    else {
                        this.logger.log(`Employee ${employee.user.email} already checked in`);
                        // notify employee
                        await this.notificationsService.create({
                            title: 'Already Checked In',
                            message: `You tried to check in but you have already checked in on ${punchDate} at ${punchTimeStr}.`,
                            type: notification_type_enum_1.NotificationType.INFO,
                            category: 'ATTENDANCE',
                            user: { id: employee.user.id },
                        });
                    }
                }
                else {
                    attendanceStatuses = existingAttendance.statuses || [];
                    // log
                    if (!existingAttendance.timeIn && !((_c = existingAttendance.statuses) === null || _c === void 0 ? void 0 : _c.includes(attendance_status_enum_1.AttendanceStatus.NO_CHECKED_IN))) {
                        attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.NO_CHECKED_IN);
                        // Create work time request for no check in
                        await this.createWorkTimeRequest(dayType, employee.id, attendance_status_enum_1.AttendanceStatus.NO_CHECKED_IN, existingAttendance);
                        // Notify employee
                        await this.notificationsService.create({
                            title: 'No Check-in',
                            message: `You did not check in on ${punchDate} at ${punchTimeStr}.`,
                            type: notification_type_enum_1.NotificationType.WARNING,
                            category: 'ATTENDANCE',
                            user: { id: employee.user.id },
                        });
                    }
                    // Check if employee is undertime
                    if ((0, date_fns_1.isBefore)(punchTime, shiftEndTime)) {
                        // log
                        this.logger.log(`Employee ${employee.user.email} is leaving early on ${punchDate} at ${punchTimeStr}`);
                        const minutesEarly = (0, date_fns_1.differenceInMinutes)(shiftEndTime, punchTime);
                        if (!config.allowUnderTime && minutesEarly > config.underTimeThresholdMinutes) {
                            if (!((_d = existingAttendance.statuses) === null || _d === void 0 ? void 0 : _d.includes(attendance_status_enum_1.AttendanceStatus.UNDER_TIME))) {
                                attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.UNDER_TIME);
                            }
                            this.logger.log(`Employee ${employee.id} is leaving ${minutesEarly} minutes early`);
                            // move this to cron job
                            // // Create work time request for under time
                            // await this.createWorkTimeRequest(dayType, employee.id, AttendanceStatus.UNDER_TIME, existingAttendance.id, minutesEarly);
                            // // Notify management
                            // await this.notificationsService.create({
                            //   title: 'Early Check-out',
                            //   message: `You are leaving ${minutesEarly} minutes early on ${punchDate} at ${punchTimeStr}.`,
                            //   type: NotificationType.WARNING,
                            //   category: 'ATTENDANCE',
                            //   user: { id: employee.user.id },
                            // });
                            // if (config.roundDownUnderTime) {
                            //   const roundedMinutes = Math.floor(minutesEarly / config.roundDownUnderTimeMinutes) * config.roundDownUnderTimeMinutes;
                            //   punchTime.setMinutes(punchTime.getMinutes() - roundedMinutes);
                            //   this.logger.log(`Rounded early time to ${roundedMinutes} minutes`);
                            // }
                        }
                    }
                    else {
                        // Check if employee is overtime
                        attendanceStatuses = attendanceStatuses.filter(status => status !== attendance_status_enum_1.AttendanceStatus.UNDER_TIME);
                        const minutesOvertime = (0, date_fns_1.differenceInMinutes)(punchTime, shiftEndTime);
                        if (config.allowOvertime && minutesOvertime > config.overtimeThresholdMinutes) {
                            if (!((_e = existingAttendance.statuses) === null || _e === void 0 ? void 0 : _e.includes(attendance_status_enum_1.AttendanceStatus.OVERTIME))) {
                                attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.OVERTIME);
                            }
                            this.logger.log(`Employee ${employee.id} worked ${minutesOvertime} minutes overtime`);
                            // move this to cron job              
                            // Create work time request for overtime
                            // await this.createWorkTimeRequest(dayType, employee.id, AttendanceStatus.OVERTIME, existingAttendance.id, minutesOvertime);
                            // // Notify employee
                            // await this.notificationsService.create({
                            //   title: 'Overtime Alert',
                            //   message: `You worked ${minutesOvertime} minutes overtime on ${punchDate} at ${punchTimeStr}.`,
                            //   type: NotificationType.INFO,
                            //   category: 'ATTENDANCE',
                            //   user: { id: employee.user.id },
                            // });
                            // if (config.roundUpOvertime) {
                            //   const roundedMinutes = Math.ceil(minutesOvertime / config.roundUpOvertimeMinutes) * config.roundUpOvertimeMinutes;
                            //   punchTime.setMinutes(punchTime.getMinutes() + roundedMinutes);
                            //   this.logger.log(`Rounded overtime time to ${roundedMinutes} minutes`);
                            // }
                        }
                    }
                    if (!((_f = existingAttendance.statuses) === null || _f === void 0 ? void 0 : _f.includes(attendance_status_enum_1.AttendanceStatus.CHECKED_OUT)))
                        attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.CHECKED_OUT);
                    existingAttendance.statuses = [...attendanceStatuses];
                    existingAttendance.updatedBy = employee.user.id;
                    existingAttendance.timeOut = punchTime;
                }
                await this.attendancesService.save(existingAttendance);
                // Create attendance punch record
                await this.attendancePunchesService.create({
                    attendance: { id: existingAttendance.id },
                    time: punchTime,
                    punchType: record.punchType,
                    punchMethod: record.punchMethod,
                    employeeNumber,
                    userId: employee.user.id,
                    organizationId: employee.organizationId,
                    departmentId: employee.departmentId,
                    branchId: employee.branchId,
                    biometricDevice: { id: biometricDevice.id },
                }, employee.user.id);
                this.logger.log(`Successfully processed ${record.punchMethod} punch for employee ${employee.user.email} at ${punchTimeStr} with status ${existingAttendance.statuses}`);
            }
            catch (error) {
                if (error instanceof Error) {
                    this.logger.error(`Error processing attendance record: ${error.message}`, error.stack);
                }
                else {
                    this.logger.error(`Error processing attendance record: ${String(error)}`);
                }
            }
        }
    }
    async handleAttendanceProcessedEvent(event) {
        this.logger.log(`Handling attendance processed event for ${event.attendances.length} attendances`);
        if (event.attendances.length === 0) {
            return;
        }
        // Extract attendance IDs
        const attendanceIds = event.attendances.map(attendance => attendance.id);
        // Queue the attendances for final work hour calculation
        await this.workHourCalculationService.queueFinalWorkHoursCalculation(attendanceIds, event.processedBy // Since this is triggered by a system process
        );
    }
    async handleRecalculateFinalWorkHoursEvent(event) {
        this.logger.log(`Handling recalculation of final work hours for cutoff ID ${event.cutoffId}`);
        // Fetch all attendances for the given cutoff that is already processed
        const attendances = await this.attendancesService.getRepository().find({
            where: { isProcessed: true, cutoff: { id: event.cutoffId } },
        });
        const attendanceIds = event.cutoffId ? attendances.map(attendance => attendance.id) : event.specificAttendanceIds || [];
        // Queue the attendances for final work hour calculation
        await this.workHourCalculationService.queueFinalWorkHoursCalculation(attendanceIds, event.recalculatedBy // Since this is triggered by a system process
        );
    }
    // Helper methods for notifications and work time requests
    async createWorkTimeRequest(dayType, employeeId, type, attendance, duration) {
        try {
            await this.workTimeRequestsService.create({
                attendance,
                cutoff: attendance.cutoff,
                type,
                duration,
                dayType,
                date: attendance.date,
                status: request_status_enum_1.RequestStatus.PENDING,
                createdBy: employeeId,
                employee: { id: employeeId },
                organizationId: attendance.organizationId,
                departmentId: attendance.departmentId,
                branchId: attendance.branchId,
                userId: attendance.userId,
            });
            this.logger.log(`Created work time request for employee ${employeeId} for type ${type}`);
        }
        catch (error) {
            this.logger.error(`Failed to create work time request: ${error.message}`);
        }
    }
};
exports.AttendanceListener = AttendanceListener;
__decorate([
    (0, event_emitter_1.OnEvent)(attendance_event_1.ATTENDANCE_EVENTS.ATTENDANCE_RECORDED),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_k = typeof attendance_event_1.AttendanceRecordedEvent !== "undefined" && attendance_event_1.AttendanceRecordedEvent) === "function" ? _k : Object]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], AttendanceListener.prototype, "handleAttendanceRecorded", null);
__decorate([
    (0, event_emitter_1.OnEvent)(attendance_event_1.ATTENDANCE_EVENTS.ATTENDANCE_PROCESSED),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_m = typeof attendance_event_1.AttendanceProcessedEvent !== "undefined" && attendance_event_1.AttendanceProcessedEvent) === "function" ? _m : Object]),
    __metadata("design:returntype", Promise)
], AttendanceListener.prototype, "handleAttendanceProcessedEvent", null);
__decorate([
    (0, event_emitter_1.OnEvent)(attendance_event_1.ATTENDANCE_EVENTS.RECALCULATE_FINAL_WORK_HOURS),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_o = typeof attendance_event_1.RecalculateFinalWorkHoursEvent !== "undefined" && attendance_event_1.RecalculateFinalWorkHoursEvent) === "function" ? _o : Object]),
    __metadata("design:returntype", Promise)
], AttendanceListener.prototype, "handleRecalculateFinalWorkHoursEvent", null);
exports.AttendanceListener = AttendanceListener = AttendanceListener_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof attendances_service_1.AttendancesService !== "undefined" && attendances_service_1.AttendancesService) === "function" ? _a : Object, typeof (_b = typeof attendance_punches_service_1.AttendancePunchesService !== "undefined" && attendance_punches_service_1.AttendancePunchesService) === "function" ? _b : Object, typeof (_c = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _c : Object, typeof (_d = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _d : Object, typeof (_e = typeof biometric_devices_service_1.BiometricDevicesService !== "undefined" && biometric_devices_service_1.BiometricDevicesService) === "function" ? _e : Object, typeof (_f = typeof notifications_service_1.NotificationsService !== "undefined" && notifications_service_1.NotificationsService) === "function" ? _f : Object, typeof (_g = typeof work_time_requests_service_1.WorkTimeRequestsService !== "undefined" && work_time_requests_service_1.WorkTimeRequestsService) === "function" ? _g : Object, typeof (_h = typeof work_hour_calculation_service_1.WorkHourCalculationService !== "undefined" && work_hour_calculation_service_1.WorkHourCalculationService) === "function" ? _h : Object, typeof (_j = typeof attendance_configurations_service_1.AttendanceConfigurationsService !== "undefined" && attendance_configurations_service_1.AttendanceConfigurationsService) === "function" ? _j : Object])
], AttendanceListener);


/***/ }),

/***/ "./src/modules/attendance-management/services/attendance-data-seeder.service.ts":
/*!**************************************************************************************!*\
  !*** ./src/modules/attendance-management/services/attendance-data-seeder.service.ts ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AttendanceDataSeederService_1;
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendanceDataSeederService = void 0;
const attendance_status_enum_1 = __webpack_require__(/*! @/common/enums/attendance-status.enum */ "./src/common/enums/attendance-status.enum.ts");
const holiday_type_enum_1 = __webpack_require__(/*! @/common/enums/holiday-type.enum */ "./src/common/enums/holiday-type.enum.ts");
const punch_method_enum_1 = __webpack_require__(/*! @/common/enums/punch-method.enum */ "./src/common/enums/punch-method.enum.ts");
const punch_type_enum_1 = __webpack_require__(/*! @/common/enums/punch-type.enum */ "./src/common/enums/punch-type.enum.ts");
const biometric_devices_service_1 = __webpack_require__(/*! @/modules/biometrics/services/biometric-devices.service */ "./src/modules/biometrics/services/biometric-devices.service.ts");
const schedules_service_1 = __webpack_require__(/*! @/modules/shift-management/schedules/schedules.service */ "./src/modules/shift-management/schedules/schedules.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const date_fns_1 = __webpack_require__(/*! date-fns */ "date-fns");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const attendance_punches_service_1 = __webpack_require__(/*! ../attendance-punches/attendance-punches.service */ "./src/modules/attendance-management/attendance-punches/attendance-punches.service.ts");
const attendance_punch_entity_1 = __webpack_require__(/*! ../attendance-punches/entities/attendance-punch.entity */ "./src/modules/attendance-management/attendance-punches/entities/attendance-punch.entity.ts");
const attendances_service_1 = __webpack_require__(/*! ../attendances.service */ "./src/modules/attendance-management/attendances.service.ts");
const attendance_entity_1 = __webpack_require__(/*! ../entities/attendance.entity */ "./src/modules/attendance-management/entities/attendance.entity.ts");
const final_work_hour_entity_1 = __webpack_require__(/*! ../final-work-hours/entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
let AttendanceDataSeederService = AttendanceDataSeederService_1 = class AttendanceDataSeederService {
    constructor(configService, schedulesService, biometricDevicesService, attendancesService, attendancePunchesService) {
        this.configService = configService;
        this.schedulesService = schedulesService;
        this.biometricDevicesService = biometricDevicesService;
        this.attendancesService = attendancesService;
        this.attendancePunchesService = attendancePunchesService;
        this.logger = new common_1.Logger(AttendanceDataSeederService_1.name);
        this.EMPLOYEE_ID = 'fdddac4f-c6aa-485b-a8d5-9f44502f8dd9';
        this.EMPLOYEE_NUMBER = 1;
        this.DEFAULT_DEVICE_ID = 'DEVICE001';
    }
    async onModuleInit() {
        // Only run when explicitly enabled
        const seedManaged = this.configService.get('SEED_MANAGED_ATTENDANCE', true) === true;
        // get all attendances
        const attendanceCount = await this.attendancesService.getRepository().count();
        if (!seedManaged || attendanceCount > 0) {
            return;
        }
        // Clear existing attendance data for clean tests when explicitly seeding managed data
        this.logger.log('Clearing existing attendance data before seeding managed scenarios...');
        try {
            await this.attendancePunchesService.getRepository().delete({
                attendance: { employee: { id: this.EMPLOYEE_ID } }
            });
            await this.attendancesService.getRepository().delete({
                employee: { id: this.EMPLOYEE_ID }
            });
        }
        catch (error) {
            this.logger.error('Error clearing existing attendance data:', error);
        }
        // Seed focused test data with all important attendance patterns
        await this.seedManagedAttendanceScenarios();
    }
    /**
     * Seeds a manageable set of specific attendance scenarios for testing
     */
    /**
   * Seeds a manageable set of specific attendance scenarios for testing
   * Each scenario will be assigned to a different schedule
   */
    async seedManagedAttendanceScenarios(targetDate = new Date()) {
        this.logger.log(`Seeding targeted attendance scenarios for date: ${(0, date_fns_1.format)(targetDate, 'yyyy-MM-dd')}`);
        const biometricDevice = await this.ensureBiometricDeviceExists();
        // Fetch multiple schedules for the test employee (we need at least 16)
        // Get schedules from a date range to ensure we have enough
        const startDate = new Date(targetDate);
        startDate.setDate(startDate.getDate() - 15); // Get schedules from 15 days ago
        const endDate = new Date(targetDate);
        endDate.setDate(endDate.getDate() + 15); // To 15 days in the future
        this.logger.log(`Fetching schedules from ${(0, date_fns_1.format)(startDate, 'yyyy-MM-dd')} to ${(0, date_fns_1.format)(endDate, 'yyyy-MM-dd')}`);
        const schedules = await this.schedulesService.getRepository().find({
            where: {
                employee: { id: this.EMPLOYEE_ID },
                date: (0, typeorm_1.Between)(startDate, endDate)
            },
            relations: {
                employee: true,
                holiday: true,
                shift: true,
                cutoff: true
            },
            order: { date: 'ASC' }
        });
        // Check if we have enough schedules
        if (schedules.length < 16) {
            this.logger.warn(`Only found ${schedules.length} schedules, need at least 16 for all scenarios`);
            if (schedules.length === 0) {
                this.logger.error('No schedules found for employee, cannot seed attendance data');
                return;
            }
        }
        // Define timing constants
        const EARLY_MINUTES = 20;
        const LATE_MINUTES = 10;
        const UNDERTIME_MINUTES = 20;
        const OVERTIME_MINUTES = 45;
        // Create scenarios array - keeping only what's needed
        const scenarios = [
            // Basic scenarios
            {
                name: '1-Regular Attendance',
                description: 'Normal check-in and check-out',
                timeIn: null, // Will be set based on schedule
                timeOut: null // Will be set based on schedule
            },
            {
                name: '2-Late Attendance',
                description: 'Late check-in',
                timeIn: null,
                timeOut: null
            },
            {
                name: '3-Undertime Attendance',
                description: 'Early check-out',
                timeIn: null,
                timeOut: null
            },
            {
                name: '4-Overtime Attendance',
                description: 'Late check-out (overtime)',
                timeIn: null,
                timeOut: null
            },
            {
                name: '5-Early Time Attendance',
                description: 'Early check-in',
                timeIn: null,
                timeOut: null
            },
            {
                name: '6-No Time In',
                description: 'Missing check-in',
                timeIn: null,
                timeOut: null
            },
            {
                name: '7-No Time Out',
                description: 'Missing check-out',
                timeIn: null,
                timeOut: null
            },
            {
                name: '8-Absent',
                description: 'No check-in or check-out',
                timeIn: null,
                timeOut: null
            },
            // Combination scenarios
            {
                name: '9-Late Overtime',
                description: 'Late check-in with overtime',
                timeIn: null,
                timeOut: null
            },
            {
                name: '10-Late Undertime',
                description: 'Late check-in with early check-out',
                timeIn: null,
                timeOut: null
            },
            {
                name: '11-Late No Time Out',
                description: 'Late check-in with missing check-out',
                timeIn: null,
                timeOut: null
            },
            {
                name: '12-Early Undertime',
                description: 'Early check-in with early check-out',
                timeIn: null,
                timeOut: null
            },
            {
                name: '13-Early Overtime',
                description: 'Early check-in with overtime',
                timeIn: null,
                timeOut: null
            },
            {
                name: '14-Early No Time Out',
                description: 'Early check-in with missing check-out',
                timeIn: null,
                timeOut: null
            },
            {
                name: '15-No Time In Undertime',
                description: 'Missing check-in with early check-out',
                timeIn: null,
                timeOut: null
            },
            {
                name: '16-No Time In Overtime',
                description: 'Missing check-in with overtime',
                timeIn: null,
                timeOut: null
            }
        ];
        // Process each scenario with a different schedule
        const totalScenarios = Math.min(scenarios.length, schedules.length);
        for (let i = 0; i < totalScenarios; i++) {
            const scenario = scenarios[i];
            const schedule = schedules[i];
            // Format date from the schedule
            const scheduleDate = (0, date_fns_1.format)(schedule.date, 'yyyy-MM-dd');
            const scheduleStartTime = (0, date_fns_1.parseISO)(`${scheduleDate}T${schedule.startTime}`);
            const scheduleEndTime = (0, date_fns_1.parseISO)(`${scheduleDate}T${schedule.endTime}`);
            // Configure the scenario times based on schedule and scenario type
            switch (scenario.name.split('-')[0]) {
                case '1': // Regular
                    scenario.timeIn = scheduleStartTime;
                    scenario.timeOut = scheduleEndTime;
                    break;
                case '2': // Late
                    scenario.timeIn = (0, date_fns_1.addMinutes)(scheduleStartTime, LATE_MINUTES);
                    scenario.timeOut = scheduleEndTime;
                    break;
                case '3': // Undertime
                    scenario.timeIn = scheduleStartTime;
                    scenario.timeOut = (0, date_fns_1.addMinutes)(scheduleEndTime, -UNDERTIME_MINUTES);
                    break;
                case '4': // Overtime
                    scenario.timeIn = scheduleStartTime;
                    scenario.timeOut = (0, date_fns_1.addMinutes)(scheduleEndTime, OVERTIME_MINUTES);
                    break;
                case '5': // Early time
                    scenario.timeIn = (0, date_fns_1.addMinutes)(scheduleStartTime, -EARLY_MINUTES);
                    scenario.timeOut = scheduleEndTime;
                    break;
                case '6': // No time in
                    scenario.timeIn = null;
                    scenario.timeOut = scheduleEndTime;
                    break;
                case '7': // No time out
                    scenario.timeIn = scheduleStartTime;
                    scenario.timeOut = null;
                    break;
                case '8': // Absent
                    scenario.timeIn = null;
                    scenario.timeOut = null;
                    break;
                case '9': // Late overtime
                    scenario.timeIn = (0, date_fns_1.addMinutes)(scheduleStartTime, LATE_MINUTES);
                    scenario.timeOut = (0, date_fns_1.addMinutes)(scheduleEndTime, OVERTIME_MINUTES);
                    break;
                case '10': // Late undertime
                    scenario.timeIn = (0, date_fns_1.addMinutes)(scheduleStartTime, LATE_MINUTES);
                    scenario.timeOut = (0, date_fns_1.addMinutes)(scheduleEndTime, -UNDERTIME_MINUTES);
                    break;
                case '11': // Late no time out
                    scenario.timeIn = (0, date_fns_1.addMinutes)(scheduleStartTime, LATE_MINUTES);
                    scenario.timeOut = null;
                    break;
                case '12': // Early undertime
                    scenario.timeIn = (0, date_fns_1.addMinutes)(scheduleStartTime, -EARLY_MINUTES);
                    scenario.timeOut = (0, date_fns_1.addMinutes)(scheduleEndTime, -UNDERTIME_MINUTES);
                    break;
                case '13': // Early overtime
                    scenario.timeIn = (0, date_fns_1.addMinutes)(scheduleStartTime, -EARLY_MINUTES);
                    scenario.timeOut = (0, date_fns_1.addMinutes)(scheduleEndTime, OVERTIME_MINUTES);
                    break;
                case '14': // Early no time out
                    scenario.timeIn = (0, date_fns_1.addMinutes)(scheduleStartTime, -EARLY_MINUTES);
                    scenario.timeOut = null;
                    break;
                case '15': // No time in undertime
                    scenario.timeIn = null;
                    scenario.timeOut = (0, date_fns_1.addMinutes)(scheduleEndTime, -UNDERTIME_MINUTES);
                    break;
                case '16': // No time in overtime
                    scenario.timeIn = null;
                    scenario.timeOut = (0, date_fns_1.addMinutes)(scheduleEndTime, OVERTIME_MINUTES);
                    break;
            }
            // Create attendance for this schedule and scenario
            await this.createAttendanceForSchedule(schedule, scenario, biometricDevice);
            this.logger.log(`Created attendance for scenario: ${scenario.name} on ${(0, date_fns_1.format)(schedule.date, 'yyyy-MM-dd')}`);
        }
        this.logger.log(`Successfully seeded ${totalScenarios} attendance scenarios from ${(0, date_fns_1.format)(startDate, 'yyyy-MM-dd')} to ${(0, date_fns_1.format)(endDate, 'yyyy-MM-dd')}`);
    }
    async createAttendanceForSchedule(schedule, scenario, biometricDevice) {
        this.logger.log(`Creating ${scenario.name} scenario for schedule on ${(0, date_fns_1.format)(schedule.date, 'yyyy-MM-dd')}`);
        // Determine day type based on schedule
        const dayType = this.determineDayType(schedule);
        // Determine attendance statuses
        const statuses = this.determineAttendanceStatuses(schedule, scenario);
        // Create the attendance record
        const attendance = new attendance_entity_1.Attendance({});
        attendance.employee = schedule.employee;
        attendance.schedule = schedule;
        attendance.timeIn = scenario.timeIn || undefined;
        attendance.timeOut = scenario.timeOut || undefined;
        attendance.statuses = statuses;
        attendance.isProcessed = false;
        attendance.dayType = dayType;
        attendance.date = schedule.date;
        attendance.cutoff = schedule.cutoff;
        attendance.organizationId = schedule.employee.organizationId;
        attendance.departmentId = schedule.employee.departmentId;
        attendance.branchId = schedule.employee.branchId;
        attendance.userId = schedule.employee.userId;
        // Save the attendance record to get an ID
        const savedAttendance = (await this.attendancesService.save(attendance));
        // Create attendance punches if applicable
        const punches = [];
        if (scenario.timeIn) {
            const inPunch = new attendance_punch_entity_1.AttendancePunch({});
            inPunch.attendance = savedAttendance;
            inPunch.time = scenario.timeIn;
            inPunch.punchMethod = punch_method_enum_1.PunchMethod.FINGERPRINT;
            inPunch.punchType = punch_type_enum_1.PunchType.CHECK_IN;
            inPunch.employeeNumber = this.EMPLOYEE_NUMBER;
            inPunch.biometricDevice = biometricDevice;
            punches.push(inPunch);
        }
        if (scenario.timeOut) {
            const outPunch = new attendance_punch_entity_1.AttendancePunch({});
            outPunch.attendance = savedAttendance;
            outPunch.time = scenario.timeOut;
            outPunch.punchMethod = punch_method_enum_1.PunchMethod.FINGERPRINT;
            outPunch.punchType = punch_type_enum_1.PunchType.CHECK_OUT;
            outPunch.employeeNumber = this.EMPLOYEE_NUMBER;
            outPunch.biometricDevice = biometricDevice;
            punches.push(outPunch);
        }
        // Save all punches
        if (punches.length > 0) {
            await this.attendancePunchesService.getRepository().save(punches);
            this.logger.log(`Created ${punches.length} attendance punches for attendance ${savedAttendance.id}`);
        }
        this.logger.log(`Created attendance record ${savedAttendance.id} for ${scenario.name} scenario`);
    }
    determineDayType(schedule) {
        var _a;
        const isRestDay = schedule.restDay === true;
        const holidayType = (_a = schedule.holiday) === null || _a === void 0 ? void 0 : _a.type;
        if (isRestDay && holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
            return final_work_hour_entity_1.DayType.REGULAR_HOLIDAY_REST_DAY;
        }
        else if (isRestDay && (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING || holidayType === holiday_type_enum_1.HolidayType.SPECIAL_WORKING)) {
            return final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY_REST_DAY;
        }
        else if (isRestDay) {
            return final_work_hour_entity_1.DayType.REST_DAY;
        }
        else if (holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
            return final_work_hour_entity_1.DayType.REGULAR_HOLIDAY;
        }
        else if (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING || holidayType === holiday_type_enum_1.HolidayType.SPECIAL_WORKING) {
            return final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY;
        }
        else {
            return final_work_hour_entity_1.DayType.REGULAR_DAY;
        }
    }
    determineAttendanceStatuses(schedule, scenario) {
        const statuses = [];
        // Parse schedule times
        const scheduleDate = (0, date_fns_1.format)(schedule.date, 'yyyy-MM-dd');
        const scheduleStartTime = (0, date_fns_1.parseISO)(`${scheduleDate}T${schedule.startTime}`);
        const scheduleEndTime = (0, date_fns_1.parseISO)(`${scheduleDate}T${schedule.endTime}`);
        // Config values (match those from your attendance configuration)
        const EARLY_THRESHOLD_MINUTES = 15;
        const GRACE_PERIOD_MINUTES = 5;
        const UNDER_TIME_THRESHOLD_MINUTES = 15;
        const OVERTIME_THRESHOLD_MINUTES = 30;
        // Handle absence
        if (!scenario.timeIn && !scenario.timeOut) {
            statuses.push(attendance_status_enum_1.AttendanceStatus.ABSENT);
            return statuses;
        }
        // Handle no check-in
        if (!scenario.timeIn && scenario.timeOut) {
            statuses.push(attendance_status_enum_1.AttendanceStatus.NO_CHECKED_IN);
            statuses.push(attendance_status_enum_1.AttendanceStatus.CHECKED_OUT);
            return statuses;
        }
        // Handle no check-out
        if (scenario.timeIn && !scenario.timeOut) {
            statuses.push(attendance_status_enum_1.AttendanceStatus.CHECKED_IN);
            statuses.push(attendance_status_enum_1.AttendanceStatus.NO_CHECKED_OUT);
            return statuses;
        }
        // Now we know both timeIn and timeOut exist
        if (scenario.timeIn) {
            statuses.push(attendance_status_enum_1.AttendanceStatus.CHECKED_IN);
            // Check for early arrival
            if (scenario.timeIn < (0, date_fns_1.addMinutes)(scheduleStartTime, -EARLY_THRESHOLD_MINUTES)) {
                statuses.push(attendance_status_enum_1.AttendanceStatus.EARLY);
            }
            // Check for late arrival
            if (scenario.timeIn > (0, date_fns_1.addMinutes)(scheduleStartTime, GRACE_PERIOD_MINUTES)) {
                statuses.push(attendance_status_enum_1.AttendanceStatus.LATE);
            }
        }
        if (scenario.timeOut) {
            statuses.push(attendance_status_enum_1.AttendanceStatus.CHECKED_OUT);
            // Check for undertime
            if (scenario.timeOut < (0, date_fns_1.addMinutes)(scheduleEndTime, -UNDER_TIME_THRESHOLD_MINUTES)) {
                statuses.push(attendance_status_enum_1.AttendanceStatus.UNDER_TIME);
            }
            // Check for overtime
            if (scenario.timeOut > (0, date_fns_1.addMinutes)(scheduleEndTime, OVERTIME_THRESHOLD_MINUTES)) {
                statuses.push(attendance_status_enum_1.AttendanceStatus.OVERTIME);
            }
        }
        // Special day types
        if (schedule.restDay) {
            statuses.push(attendance_status_enum_1.AttendanceStatus.REST_DAY);
        }
        if (schedule.holiday) {
            statuses.push(attendance_status_enum_1.AttendanceStatus.HOLIDAY);
        }
        return statuses;
    }
    async ensureBiometricDeviceExists() {
        // Check if our test biometric device exists
        let biometricDevice = await this.biometricDevicesService.findOneBy({ deviceId: this.DEFAULT_DEVICE_ID });
        if (!biometricDevice) {
            // Create a test biometric device if it doesn't exist
            biometricDevice = await this.biometricDevicesService.create({
                deviceId: this.DEFAULT_DEVICE_ID,
                name: 'Test Biometric Device',
                ipAddress: '10.10.10.45',
                port: 5010,
                isOffline: false,
            });
            this.logger.log(`Created test biometric device with ID: ${this.DEFAULT_DEVICE_ID}`);
        }
        return biometricDevice;
    }
};
exports.AttendanceDataSeederService = AttendanceDataSeederService;
exports.AttendanceDataSeederService = AttendanceDataSeederService = AttendanceDataSeederService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object, typeof (_b = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _b : Object, typeof (_c = typeof biometric_devices_service_1.BiometricDevicesService !== "undefined" && biometric_devices_service_1.BiometricDevicesService) === "function" ? _c : Object, typeof (_d = typeof attendances_service_1.AttendancesService !== "undefined" && attendances_service_1.AttendancesService) === "function" ? _d : Object, typeof (_e = typeof attendance_punches_service_1.AttendancePunchesService !== "undefined" && attendance_punches_service_1.AttendancePunchesService) === "function" ? _e : Object])
], AttendanceDataSeederService);


/***/ }),

/***/ "./src/modules/attendance-management/work-time-requests/dtos/management-work-time-request.dto.ts":
/*!*******************************************************************************************************!*\
  !*** ./src/modules/attendance-management/work-time-requests/dtos/management-work-time-request.dto.ts ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ManagementWorkTimeRequestDto = void 0;
const attendance_status_enum_1 = __webpack_require__(/*! @/common/enums/attendance-status.enum */ "./src/common/enums/attendance-status.enum.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class ManagementWorkTimeRequestDto {
}
exports.ManagementWorkTimeRequestDto = ManagementWorkTimeRequestDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'ID of a single employee (use either this or groupId or employeeIds)',
        example: '123e4567-e89b-12d3-a456-426614174000',
    }),
    (0, class_validator_1.IsUUID)('4', { message: 'Employee ID must be a valid UUID' }),
    (0, class_validator_1.ValidateIf)(o => !o.groupId && !o.employeeIds),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ManagementWorkTimeRequestDto.prototype, "employeeId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'IDs of multiple employees (use either this or employeeId or groupId)',
        example: ['123e4567-e89b-12d3-a456-426614174000', '223e4567-e89b-12d3-a456-426614174000'],
        type: [String],
    }),
    (0, class_validator_1.IsUUID)('4', { each: true, message: 'Each employee ID must be a valid UUID' }),
    (0, class_validator_1.ValidateIf)(o => !o.groupId && !o.employeeId),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Array)
], ManagementWorkTimeRequestDto.prototype, "employeeIds", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'ID of a shift group (use either this or employeeId or employeeIds)',
        example: '123e4567-e89b-12d3-a456-426614174000',
    }),
    (0, class_validator_1.IsUUID)('4', { message: 'Group ID must be a valid UUID' }),
    (0, class_validator_1.ValidateIf)(o => !o.employeeId && !o.employeeIds),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ManagementWorkTimeRequestDto.prototype, "groupId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date of the work request (YYYY-MM-DD)',
        example: '2023-05-15',
        type: String,
    }),
    (0, class_validator_1.IsDateString)({}, { message: 'Date must be in YYYY-MM-DD format' }),
    __metadata("design:type", String)
], ManagementWorkTimeRequestDto.prototype, "date", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of work time request',
        enum: [attendance_status_enum_1.AttendanceStatus.EARLY, attendance_status_enum_1.AttendanceStatus.OVERTIME],
        example: attendance_status_enum_1.AttendanceStatus.EARLY,
    }),
    (0, class_validator_1.IsEnum)(attendance_status_enum_1.AttendanceStatus, { message: 'Type must be either EARLY or OVERTIME' }),
    (0, class_validator_1.IsIn)([attendance_status_enum_1.AttendanceStatus.EARLY, attendance_status_enum_1.AttendanceStatus.OVERTIME], {
        message: 'Only EARLY or OVERTIME request types are allowed'
    }),
    __metadata("design:type", typeof (_a = typeof attendance_status_enum_1.AttendanceStatus !== "undefined" && attendance_status_enum_1.AttendanceStatus) === "function" ? _a : Object)
], ManagementWorkTimeRequestDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Indicates if early time should be considered as overtime',
        example: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ManagementWorkTimeRequestDto.prototype, "earlyTimeAsOvertime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Reason for the work request',
        example: 'Special project preparation',
        minLength: 5,
        maxLength: 500,
    }),
    (0, class_validator_1.IsString)({ message: 'Reason must be a string' }),
    __metadata("design:type", String)
], ManagementWorkTimeRequestDto.prototype, "reason", void 0);


/***/ }),

/***/ "./src/modules/attendance-management/work-time-requests/dtos/work-time-request.dto.ts":
/*!********************************************************************************************!*\
  !*** ./src/modules/attendance-management/work-time-requests/dtos/work-time-request.dto.ts ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetWorkTimeRequestDto = exports.UpdateWorkTimeRequestDto = exports.WorkTimeRequestDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const reference_dto_1 = __webpack_require__(/*! @/common/dtos/reference.dto */ "./src/common/dtos/reference.dto.ts");
const attendance_status_enum_1 = __webpack_require__(/*! @/common/enums/attendance-status.enum */ "./src/common/enums/attendance-status.enum.ts");
const request_status_enum_1 = __webpack_require__(/*! @/common/enums/request-status.enum */ "./src/common/enums/request-status.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const final_work_hour_entity_1 = __webpack_require__(/*! ../../final-work-hours/entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
class WorkTimeRequestDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.WorkTimeRequestDto = WorkTimeRequestDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employee reference',
        type: reference_dto_1.ReferenceDto
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _a : Object)
], WorkTimeRequestDto.prototype, "employee", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of attendance',
        enum: attendance_status_enum_1.AttendanceStatus,
        example: attendance_status_enum_1.AttendanceStatus.OVERTIME
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(attendance_status_enum_1.AttendanceStatus),
    __metadata("design:type", typeof (_b = typeof attendance_status_enum_1.AttendanceStatus !== "undefined" && attendance_status_enum_1.AttendanceStatus) === "function" ? _b : Object)
], WorkTimeRequestDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Duration in minutes',
        example: 120,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({ maxDecimalPlaces: 2 }),
    __metadata("design:type", Number)
], WorkTimeRequestDto.prototype, "duration", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Day type',
        enum: final_work_hour_entity_1.DayType,
        default: final_work_hour_entity_1.DayType.REGULAR_DAY,
        example: final_work_hour_entity_1.DayType.REGULAR_DAY
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(final_work_hour_entity_1.DayType),
    __metadata("design:type", typeof (_c = typeof final_work_hour_entity_1.DayType !== "undefined" && final_work_hour_entity_1.DayType) === "function" ? _c : Object)
], WorkTimeRequestDto.prototype, "dayType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Attendance reference',
        type: reference_dto_1.ReferenceDto
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_d = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _d : Object)
], WorkTimeRequestDto.prototype, "attendance", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Documents associated with the work time request',
        type: [reference_dto_1.ReferenceDto],
        example: [
            { id: '123e4567-e89b-12d3-a456-426614174000' },
            { id: '123e4567-e89b-12d3-a456-426614174001' }
        ]
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], WorkTimeRequestDto.prototype, "documents", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Reason for the request',
        example: 'Urgent project completion required overtime',
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], WorkTimeRequestDto.prototype, "reason", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Indicates if early time should be considered as overtime',
        example: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], WorkTimeRequestDto.prototype, "earlyTimeAsOvertime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Indicates if this request was initiated by management',
        example: false,
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], WorkTimeRequestDto.prototype, "managementRequested", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'ID of the manager who requested this (if management requested)',
        example: '123e4567-e89b-12d3-a456-426614174000',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_e = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _e : Object)
], WorkTimeRequestDto.prototype, "requestedByManager", void 0);
class UpdateWorkTimeRequestDto extends (0, swagger_1.PartialType)(WorkTimeRequestDto) {
}
exports.UpdateWorkTimeRequestDto = UpdateWorkTimeRequestDto;
class GetWorkTimeRequestDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateWorkTimeRequestDto, 'work time request') {
}
exports.GetWorkTimeRequestDto = GetWorkTimeRequestDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Status of the work time request',
        enum: request_status_enum_1.RequestStatus,
        example: request_status_enum_1.RequestStatus.PENDING,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(request_status_enum_1.RequestStatus),
    __metadata("design:type", typeof (_f = typeof request_status_enum_1.RequestStatus !== "undefined" && request_status_enum_1.RequestStatus) === "function" ? _f : Object)
], GetWorkTimeRequestDto.prototype, "status", void 0);


/***/ }),

/***/ "./src/modules/attendance-management/work-time-requests/entities/work-time-request.entity.ts":
/*!***************************************************************************************************!*\
  !*** ./src/modules/attendance-management/work-time-requests/entities/work-time-request.entity.ts ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeRequest = void 0;
const attendance_status_enum_1 = __webpack_require__(/*! @/common/enums/attendance-status.enum */ "./src/common/enums/attendance-status.enum.ts");
const request_status_enum_1 = __webpack_require__(/*! @/common/enums/request-status.enum */ "./src/common/enums/request-status.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const document_entity_1 = __webpack_require__(/*! @/modules/documents/entities/document.entity */ "./src/modules/documents/entities/document.entity.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const cutoff_entity_1 = __webpack_require__(/*! @/modules/payroll-management/cutoffs/entities/cutoff.entity */ "./src/modules/payroll-management/cutoffs/entities/cutoff.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const attendance_entity_1 = __webpack_require__(/*! ../../entities/attendance.entity */ "./src/modules/attendance-management/entities/attendance.entity.ts");
const final_work_hour_entity_1 = __webpack_require__(/*! ../../final-work-hours/entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
const work_time_response_entity_1 = __webpack_require__(/*! ../work-time-responses/entities/work-time-response.entity */ "./src/modules/attendance-management/work-time-requests/work-time-responses/entities/work-time-response.entity.ts");
let WorkTimeRequest = class WorkTimeRequest extends base_entity_1.BaseEntity {
};
exports.WorkTimeRequest = WorkTimeRequest;
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.workTimeRequests),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_a = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _a : Object)
], WorkTimeRequest.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: request_status_enum_1.RequestStatus, default: request_status_enum_1.RequestStatus.PENDING }),
    __metadata("design:type", typeof (_b = typeof request_status_enum_1.RequestStatus !== "undefined" && request_status_enum_1.RequestStatus) === "function" ? _b : Object)
], WorkTimeRequest.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: attendance_status_enum_1.AttendanceStatus }),
    __metadata("design:type", typeof (_c = typeof attendance_status_enum_1.AttendanceStatus !== "undefined" && attendance_status_enum_1.AttendanceStatus) === "function" ? _c : Object)
], WorkTimeRequest.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], WorkTimeRequest.prototype, "duration", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], WorkTimeRequest.prototype, "date", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: final_work_hour_entity_1.DayType,
        default: final_work_hour_entity_1.DayType.REGULAR_DAY
    }),
    __metadata("design:type", typeof (_e = typeof final_work_hour_entity_1.DayType !== "undefined" && final_work_hour_entity_1.DayType) === "function" ? _e : Object)
], WorkTimeRequest.prototype, "dayType", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => attendance_entity_1.Attendance, (attendance) => attendance.workTimeRequests, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'attendanceId' }),
    __metadata("design:type", typeof (_f = typeof attendance_entity_1.Attendance !== "undefined" && attendance_entity_1.Attendance) === "function" ? _f : Object)
], WorkTimeRequest.prototype, "attendance", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => cutoff_entity_1.Cutoff, (cutoff) => cutoff.workTimeRequests),
    (0, typeorm_1.JoinColumn)({ name: 'cutoffId' }),
    __metadata("design:type", typeof (_g = typeof cutoff_entity_1.Cutoff !== "undefined" && cutoff_entity_1.Cutoff) === "function" ? _g : Object)
], WorkTimeRequest.prototype, "cutoff", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => document_entity_1.Document, (document) => document.workTimeRequest, { nullable: true, cascade: true }),
    __metadata("design:type", Array)
], WorkTimeRequest.prototype, "documents", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], WorkTimeRequest.prototype, "reason", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], WorkTimeRequest.prototype, "earlyTimeAsOvertime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], WorkTimeRequest.prototype, "managementRequested", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'requestedByManagerId' }),
    __metadata("design:type", typeof (_h = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _h : Object)
], WorkTimeRequest.prototype, "requestedByManager", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => work_time_response_entity_1.WorkTimeResponse, (workTimeResponse) => workTimeResponse.workTimeRequest, { eager: true, nullable: true }),
    __metadata("design:type", typeof (_j = typeof work_time_response_entity_1.WorkTimeResponse !== "undefined" && work_time_response_entity_1.WorkTimeResponse) === "function" ? _j : Object)
], WorkTimeRequest.prototype, "workTimeResponse", void 0);
exports.WorkTimeRequest = WorkTimeRequest = __decorate([
    (0, typeorm_1.Entity)('work-time-requests')
], WorkTimeRequest);


/***/ }),

/***/ "./src/modules/attendance-management/work-time-requests/listener/work-time.listener.ts":
/*!*********************************************************************************************!*\
  !*** ./src/modules/attendance-management/work-time-requests/listener/work-time.listener.ts ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var WorkTimeListener_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeListener = void 0;
const request_status_enum_1 = __webpack_require__(/*! @/common/enums/request-status.enum */ "./src/common/enums/request-status.enum.ts");
const work_time_event_1 = __webpack_require__(/*! @/common/events/work-time.event */ "./src/common/events/work-time.event.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const final_work_hours_service_1 = __webpack_require__(/*! ../../final-work-hours/final-work-hours.service */ "./src/modules/attendance-management/final-work-hours/final-work-hours.service.ts");
const work_time_requests_service_1 = __webpack_require__(/*! ../work-time-requests.service */ "./src/modules/attendance-management/work-time-requests/work-time-requests.service.ts");
let WorkTimeListener = WorkTimeListener_1 = class WorkTimeListener {
    constructor(workTimeRequestsService, finalWorkHoursService) {
        this.workTimeRequestsService = workTimeRequestsService;
        this.finalWorkHoursService = finalWorkHoursService;
        this.logger = new common_1.Logger(WorkTimeListener_1.name);
    }
    async handleWorkTimeResponded(event) {
        // log
        this.logger.log(`Work time request responded: ${event.workTimeRequestId}, approved: ${event.isApproved}`);
        if (!event.workTimeRequestId) {
            this.logger.warn('Work time request ID is missing');
            return;
        }
        let workTimeRequest = await this.workTimeRequestsService.update(event.workTimeRequestId, {
            status: event.isApproved === true ? request_status_enum_1.RequestStatus.APPROVED : (event.isApproved === false ? request_status_enum_1.RequestStatus.REJECTED : request_status_enum_1.RequestStatus.PENDING),
        }, event.respondedBy);
        workTimeRequest = await this.workTimeRequestsService.findOneByOrFail({ id: event.workTimeRequestId });
        if (!workTimeRequest.attendance) {
            this.logger.warn('Work time request attendance is missing');
            return;
        }
        // recalculate final work hours for the attendance only
        await this.finalWorkHoursService.recalculateByAttendanceId(workTimeRequest.attendance.id, event.respondedBy);
    }
};
exports.WorkTimeListener = WorkTimeListener;
__decorate([
    (0, event_emitter_1.OnEvent)(work_time_event_1.WORK_TIME_EVENTS.WORK_TIME_RESPONDED),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof work_time_event_1.WorkTimeRespondedEvent !== "undefined" && work_time_event_1.WorkTimeRespondedEvent) === "function" ? _c : Object]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], WorkTimeListener.prototype, "handleWorkTimeResponded", null);
exports.WorkTimeListener = WorkTimeListener = WorkTimeListener_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof work_time_requests_service_1.WorkTimeRequestsService !== "undefined" && work_time_requests_service_1.WorkTimeRequestsService) === "function" ? _a : Object, typeof (_b = typeof final_work_hours_service_1.FinalWorkHoursService !== "undefined" && final_work_hours_service_1.FinalWorkHoursService) === "function" ? _b : Object])
], WorkTimeListener);


/***/ }),

/***/ "./src/modules/attendance-management/work-time-requests/work-time-requests.controller.ts":
/*!***********************************************************************************************!*\
  !*** ./src/modules/attendance-management/work-time-requests/work-time-requests.controller.ts ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeRequestsController = void 0;
const authorize_decorator_1 = __webpack_require__(/*! @/common/decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const current_user_decorator_1 = __webpack_require__(/*! @/common/decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const generalresponse_dto_1 = __webpack_require__(/*! @/common/dtos/generalresponse.dto */ "./src/common/dtos/generalresponse.dto.ts");
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const management_work_time_request_dto_1 = __webpack_require__(/*! ./dtos/management-work-time-request.dto */ "./src/modules/attendance-management/work-time-requests/dtos/management-work-time-request.dto.ts");
const work_time_request_dto_1 = __webpack_require__(/*! ./dtos/work-time-request.dto */ "./src/modules/attendance-management/work-time-requests/dtos/work-time-request.dto.ts");
const work_time_request_entity_1 = __webpack_require__(/*! ./entities/work-time-request.entity */ "./src/modules/attendance-management/work-time-requests/entities/work-time-request.entity.ts");
const work_time_requests_service_1 = __webpack_require__(/*! ./work-time-requests.service */ "./src/modules/attendance-management/work-time-requests/work-time-requests.service.ts");
class WorkTimeRequestsController extends (0, create_controller_factory_1.createController)(work_time_request_entity_1.WorkTimeRequest, work_time_requests_service_1.WorkTimeRequestsService, work_time_request_dto_1.GetWorkTimeRequestDto, work_time_request_dto_1.WorkTimeRequestDto, work_time_request_dto_1.UpdateWorkTimeRequestDto) {
    async delete(id) {
        return await super.delete(id);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    async createManagementWorkRequest(dto, managerId) {
        const success = await this.baseService.createManagementWorkRequest(dto, managerId);
        return {
            message: 'Management work time request created successfully'
        };
    }
}
exports.WorkTimeRequestsController = WorkTimeRequestsController;
__decorate([
    (0, common_1.Post)('management'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.CREATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Create management-requested work time requests',
        description: 'Creates early arrival or overtime requests for one or more employees'
    }),
    (0, swagger_1.ApiBody)({ type: management_work_time_request_dto_1.ManagementWorkTimeRequestDto, description: 'Management work time request', required: true }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Management work time request created successfully', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Invalid request parameters' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.UNAUTHORIZED, description: 'Unauthorized' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.FORBIDDEN, description: 'Forbidden' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.INTERNAL_SERVER_ERROR, description: 'Internal server error' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: 'Manager, employee(s), or schedule(s) not found' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof management_work_time_request_dto_1.ManagementWorkTimeRequestDto !== "undefined" && management_work_time_request_dto_1.ManagementWorkTimeRequestDto) === "function" ? _a : Object, String]),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], WorkTimeRequestsController.prototype, "createManagementWorkRequest", null);


/***/ }),

/***/ "./src/modules/attendance-management/work-time-requests/work-time-requests.module.ts":
/*!*******************************************************************************************!*\
  !*** ./src/modules/attendance-management/work-time-requests/work-time-requests.module.ts ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeRequestsModule = void 0;
const documents_module_1 = __webpack_require__(/*! @/modules/documents/documents.module */ "./src/modules/documents/documents.module.ts");
const employee_management_module_1 = __webpack_require__(/*! @/modules/employee-management/employee-management.module */ "./src/modules/employee-management/employee-management.module.ts");
const shift_management_module_1 = __webpack_require__(/*! @/modules/shift-management/shift-management.module */ "./src/modules/shift-management/shift-management.module.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const attendance_configurations_module_1 = __webpack_require__(/*! ../attendance-configurations/attendance-configurations.module */ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.module.ts");
const final_work_hours_module_1 = __webpack_require__(/*! ../final-work-hours/final-work-hours.module */ "./src/modules/attendance-management/final-work-hours/final-work-hours.module.ts");
const work_time_request_entity_1 = __webpack_require__(/*! ./entities/work-time-request.entity */ "./src/modules/attendance-management/work-time-requests/entities/work-time-request.entity.ts");
const work_time_listener_1 = __webpack_require__(/*! ./listener/work-time.listener */ "./src/modules/attendance-management/work-time-requests/listener/work-time.listener.ts");
const work_time_requests_controller_1 = __webpack_require__(/*! ./work-time-requests.controller */ "./src/modules/attendance-management/work-time-requests/work-time-requests.controller.ts");
const work_time_requests_service_1 = __webpack_require__(/*! ./work-time-requests.service */ "./src/modules/attendance-management/work-time-requests/work-time-requests.service.ts");
const work_time_responses_module_1 = __webpack_require__(/*! ./work-time-responses/work-time-responses.module */ "./src/modules/attendance-management/work-time-requests/work-time-responses/work-time-responses.module.ts");
let WorkTimeRequestsModule = class WorkTimeRequestsModule {
};
exports.WorkTimeRequestsModule = WorkTimeRequestsModule;
exports.WorkTimeRequestsModule = WorkTimeRequestsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([work_time_request_entity_1.WorkTimeRequest]),
            (0, common_1.forwardRef)(() => final_work_hours_module_1.FinalWorkHoursModule),
            documents_module_1.DocumentsModule,
            employee_management_module_1.EmployeeManagementModule,
            shift_management_module_1.ShiftManagementModule,
            attendance_configurations_module_1.AttendanceConfigurationsModule,
            work_time_responses_module_1.WorkTimeResponsesModule,
        ],
        providers: [work_time_requests_service_1.WorkTimeRequestsService, work_time_listener_1.WorkTimeListener],
        exports: [
            work_time_requests_service_1.WorkTimeRequestsService,
            work_time_responses_module_1.WorkTimeResponsesModule,
        ],
        controllers: [work_time_requests_controller_1.WorkTimeRequestsController],
    })
], WorkTimeRequestsModule);


/***/ }),

/***/ "./src/modules/attendance-management/work-time-requests/work-time-requests.service.ts":
/*!********************************************************************************************!*\
  !*** ./src/modules/attendance-management/work-time-requests/work-time-requests.service.ts ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeRequestsService = void 0;
const attendance_status_enum_1 = __webpack_require__(/*! @/common/enums/attendance-status.enum */ "./src/common/enums/attendance-status.enum.ts");
const notification_type_enum_1 = __webpack_require__(/*! @/common/enums/notification-type.enum */ "./src/common/enums/notification-type.enum.ts");
const request_status_enum_1 = __webpack_require__(/*! @/common/enums/request-status.enum */ "./src/common/enums/request-status.enum.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const documents_service_1 = __webpack_require__(/*! @/modules/documents/documents.service */ "./src/modules/documents/documents.service.ts");
const employees_service_1 = __webpack_require__(/*! @/modules/employee-management/employees.service */ "./src/modules/employee-management/employees.service.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const notifications_service_1 = __webpack_require__(/*! @/modules/notifications/notifications.service */ "./src/modules/notifications/notifications.service.ts");
const groups_service_1 = __webpack_require__(/*! @/modules/shift-management/groups/groups.service */ "./src/modules/shift-management/groups/groups.service.ts");
const schedules_service_1 = __webpack_require__(/*! @/modules/shift-management/schedules/schedules.service */ "./src/modules/shift-management/schedules/schedules.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const attendance_configurations_service_1 = __webpack_require__(/*! ../attendance-configurations/attendance-configurations.service */ "./src/modules/attendance-management/attendance-configurations/attendance-configurations.service.ts");
const work_time_request_entity_1 = __webpack_require__(/*! ./entities/work-time-request.entity */ "./src/modules/attendance-management/work-time-requests/entities/work-time-request.entity.ts");
const work_time_responses_service_1 = __webpack_require__(/*! ./work-time-responses/work-time-responses.service */ "./src/modules/attendance-management/work-time-requests/work-time-responses/work-time-responses.service.ts");
let WorkTimeRequestsService = class WorkTimeRequestsService extends base_service_1.BaseService {
    constructor(workTimeRequestsRepository, usersService, documentsService, employeesService, schedulesService, groupsService, attendanceConfigurationsService, notificationsService, workTimeResponsesService) {
        super(workTimeRequestsRepository, usersService);
        this.workTimeRequestsRepository = workTimeRequestsRepository;
        this.usersService = usersService;
        this.documentsService = documentsService;
        this.employeesService = employeesService;
        this.schedulesService = schedulesService;
        this.groupsService = groupsService;
        this.attendanceConfigurationsService = attendanceConfigurationsService;
        this.notificationsService = notificationsService;
        this.workTimeResponsesService = workTimeResponsesService;
    }
    async validateBefore(dto) {
        // Validate that the worktime request exists and doesn't already have a response
        dto = await this.validateReferences(dto, [
            {
                field: 'documents',
                service: this.documentsService,
            },
            {
                field: 'employee',
                service: this.employeesService,
                required: true
            }
        ]);
    }
    async checkForManagementRequest(employeeId, date, type) {
        try {
            // Check for an approved work time request that was management-requested for this date
            const request = await this.findOneBy({
                employee: new employee_entity_1.Employee({ id: employeeId }),
                type,
                managementRequested: true,
                date: new Date(date),
                status: request_status_enum_1.RequestStatus.APPROVED,
            });
            if (request) {
                this.logger.log(`Found approved management-requested ${type} for employee ${employeeId} on ${date}`);
            }
            return request;
        }
        catch (error) {
            this.logger.error(`Error checking for management-requested ${type}: ${error.message}`);
            return null;
        }
    }
    async createManagementWorkRequest(dto, managerId) {
        var _a;
        // Get the manager's information to validate permissions
        const manager = await this.usersService.findOneByOrFail({ id: managerId }, { relations: { employee: true } });
        if (!manager.employee) {
            throw new common_1.BadRequestException('Only managers with employee records can create management requests');
        }
        const config = await this.attendanceConfigurationsService.getOrganizationAttendanceConfiguration(manager.employee.organizationId);
        // check if config allow over time and early time
        if (dto.type === attendance_status_enum_1.AttendanceStatus.EARLY && !config.allowEarlyTime) {
            throw new common_1.BadRequestException('The organization does not allow early time. Please check the attendance configuration.');
        }
        if (dto.type === attendance_status_enum_1.AttendanceStatus.OVERTIME && !config.allowOvertime) {
            throw new common_1.BadRequestException('The organization does not allow overtime. Please check the attendance configuration.');
        }
        // Validate that at least one employee selection method is provided
        if (!dto.employeeId && !((_a = dto.employeeIds) === null || _a === void 0 ? void 0 : _a.length) && !dto.groupId) {
            throw new common_1.BadRequestException('Must provide either employeeId, employeeIds, or groupId');
        }
        // Determine which employees to create requests for
        let employeeIds = [];
        if (dto.employeeId) {
            // Single employee
            employeeIds = [dto.employeeId];
        }
        else if (dto.employeeIds && dto.employeeIds.length > 0) {
            // Multiple specific employees
            employeeIds = dto.employeeIds;
        }
        else if (dto.groupId) {
            // All employees in a shift group
            const group = await this.groupsService.findOneByOrFail({ id: dto.groupId }, {
                relations: { employees: true }
            });
            if (!group || !group.employees || group.employees.length === 0) {
                throw new common_1.BadRequestException(`No employees found in group with ID ${dto.groupId}`);
            }
            employeeIds = group.employees.map(emp => emp.id);
        }
        if (employeeIds.length === 0) {
            throw new common_1.BadRequestException('No valid employees found for the request');
        }
        this.logger.log(`Creating ${dto.type} requests for ${employeeIds.length} employees`);
        // For large employee sets, process in batches to avoid memory issues
        const BATCH_SIZE = 50;
        const createdRequests = [];
        const failedEmployees = [];
        // Get all employees with their user info in a single query for notification efficiency
        const employees = await this.employeesService.getRepository().find({
            where: { id: (0, typeorm_2.In)(employeeIds) },
            relations: { user: true }
        });
        const employeeMap = new Map(employees.map(emp => [emp.id, emp]));
        // Process in batches
        for (let i = 0; i < employeeIds.length; i += BATCH_SIZE) {
            const batchIds = employeeIds.slice(i, i + BATCH_SIZE);
            this.logger.debug(`Processing batch ${Math.floor(i / BATCH_SIZE) + 1} with ${batchIds.length} employees`);
            // Use a transaction for consistency
            const batchResults = await this.transactionService.executeInTransaction(async (queryRunner) => {
                var _a;
                const batchRequests = [];
                const batchFailures = [];
                const notifications = [];
                // Process each employee in the batch
                for (const employeeId of batchIds) {
                    try {
                        const employee = employeeMap.get(employeeId);
                        if (!employee) {
                            batchFailures.push({ id: employeeId, reason: 'Employee not found' });
                            continue;
                        }
                        // Get the schedule for this employee on the specified date
                        let schedule;
                        try {
                            schedule = await this.schedulesService.findOneByOrFail({
                                employee: new employee_entity_1.Employee({ id: employeeId }),
                                date: new Date(dto.date)
                            }, { relations: { cutoff: true, holiday: true } });
                        }
                        catch (scheduleError) {
                            batchFailures.push({ id: employeeId, reason: scheduleError.message });
                            continue;
                        }
                        // Create the work time request with management request flags
                        const workTimeRequest = await this.create({
                            cutoff: { id: schedule.cutoff.id },
                            type: dto.type,
                            date: new Date(dto.date),
                            reason: `Management requested ${dto.type === attendance_status_enum_1.AttendanceStatus.EARLY ? 'early arrival' : 'overtime'}: ${dto.reason}`,
                            status: request_status_enum_1.RequestStatus.PENDING,
                            employee: { id: employeeId },
                            managementRequested: true,
                            requestedByManager: new employee_entity_1.Employee({ id: (_a = manager.employee) === null || _a === void 0 ? void 0 : _a.id }),
                        }, managerId);
                        // Auto-approve the request since it's from management
                        await this.workTimeResponsesService.create({
                            workTimeRequest: new work_time_request_entity_1.WorkTimeRequest({ id: workTimeRequest.id }),
                            approved: true,
                            message: 'Auto-approved management request',
                        }, managerId);
                        // Prepare notification data
                        notifications.push({
                            title: `Management ${dto.type === attendance_status_enum_1.AttendanceStatus.EARLY ? 'Early Work' : 'Overtime'} Request`,
                            message: `Your manager has requested that you ${dto.type === attendance_status_enum_1.AttendanceStatus.EARLY ? 'arrive' : 'work'} ${dto.type === attendance_status_enum_1.AttendanceStatus.EARLY ? 'early' : 'overtime'} on ${dto.date}. Reason: ${dto.reason}`,
                            type: notification_type_enum_1.NotificationType.INFO,
                            category: 'ATTENDANCE',
                            user: { id: employee.user.id },
                            createdBy: managerId,
                        });
                        batchRequests.push(workTimeRequest);
                    }
                    catch (error) {
                        batchFailures.push({ id: employeeId, reason: error.message });
                    }
                }
                // Bulk create notifications for efficiency
                if (notifications.length > 0) {
                    try {
                        await Promise.all(notifications.map(notification => this.notificationsService.create(notification, managerId)));
                    }
                    catch (notificationError) {
                        this.logger.error(`Failed to send notifications: ${notificationError.message}`);
                        // Don't fail the whole transaction for notification errors
                    }
                }
                return { batchRequests, batchFailures };
            });
            createdRequests.push(...batchResults.batchRequests);
            failedEmployees.push(...batchResults.batchFailures);
        }
        // Log failures but don't fail the request if some succeeded
        if (failedEmployees.length > 0) {
            this.logger.warn(`Failed to create requests for ${failedEmployees.length} employees`);
            for (const failure of failedEmployees) {
                this.logger.warn(`  Employee ${failure.id}: ${failure.reason}`);
            }
        }
        if (createdRequests.length === 0) {
            throw new common_1.BadRequestException('Failed to create any work time requests');
        }
        this.logger.log(`Successfully created ${createdRequests.length} work time requests`);
        return true;
    }
};
exports.WorkTimeRequestsService = WorkTimeRequestsService;
exports.WorkTimeRequestsService = WorkTimeRequestsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(work_time_request_entity_1.WorkTimeRequest)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof documents_service_1.DocumentsService !== "undefined" && documents_service_1.DocumentsService) === "function" ? _c : Object, typeof (_d = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _d : Object, typeof (_e = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _e : Object, typeof (_f = typeof groups_service_1.GroupsService !== "undefined" && groups_service_1.GroupsService) === "function" ? _f : Object, typeof (_g = typeof attendance_configurations_service_1.AttendanceConfigurationsService !== "undefined" && attendance_configurations_service_1.AttendanceConfigurationsService) === "function" ? _g : Object, typeof (_h = typeof notifications_service_1.NotificationsService !== "undefined" && notifications_service_1.NotificationsService) === "function" ? _h : Object, typeof (_j = typeof work_time_responses_service_1.WorkTimeResponsesService !== "undefined" && work_time_responses_service_1.WorkTimeResponsesService) === "function" ? _j : Object])
], WorkTimeRequestsService);


/***/ }),

/***/ "./src/modules/attendance-management/work-time-requests/work-time-responses/dtos/work-time-response.dto.ts":
/*!*****************************************************************************************************************!*\
  !*** ./src/modules/attendance-management/work-time-requests/work-time-responses/dtos/work-time-response.dto.ts ***!
  \*****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetWorkTimeResponseDto = exports.UpdateWorkTimeResponseDto = exports.WorkTimeResponseDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const reference_dto_1 = __webpack_require__(/*! @/common/dtos/reference.dto */ "./src/common/dtos/reference.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class WorkTimeResponseDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.WorkTimeResponseDto = WorkTimeResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Approval status of the work time request',
        example: true
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Boolean)
], WorkTimeResponseDto.prototype, "approved", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Response message for the work time request',
        example: 'Your work time request has been approved.'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], WorkTimeResponseDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Work time request associated with this response',
        type: reference_dto_1.ReferenceDto,
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_a = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _a : Object)
], WorkTimeResponseDto.prototype, "workTimeRequest", void 0);
class UpdateWorkTimeResponseDto extends (0, swagger_1.PartialType)(WorkTimeResponseDto) {
}
exports.UpdateWorkTimeResponseDto = UpdateWorkTimeResponseDto;
class GetWorkTimeResponseDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateWorkTimeResponseDto, 'work time response') {
}
exports.GetWorkTimeResponseDto = GetWorkTimeResponseDto;


/***/ }),

/***/ "./src/modules/attendance-management/work-time-requests/work-time-responses/entities/work-time-response.entity.ts":
/*!************************************************************************************************************************!*\
  !*** ./src/modules/attendance-management/work-time-requests/work-time-responses/entities/work-time-response.entity.ts ***!
  \************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeResponse = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const work_time_request_entity_1 = __webpack_require__(/*! ../../entities/work-time-request.entity */ "./src/modules/attendance-management/work-time-requests/entities/work-time-request.entity.ts");
let WorkTimeResponse = class WorkTimeResponse extends base_entity_1.BaseEntity {
};
exports.WorkTimeResponse = WorkTimeResponse;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Boolean)
], WorkTimeResponse.prototype, "approved", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], WorkTimeResponse.prototype, "message", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => work_time_request_entity_1.WorkTimeRequest, (workTimeRequest) => workTimeRequest.workTimeResponse, { cascade: true }),
    (0, typeorm_1.JoinColumn)({ name: 'workTimeRequestId' }),
    __metadata("design:type", typeof (_a = typeof work_time_request_entity_1.WorkTimeRequest !== "undefined" && work_time_request_entity_1.WorkTimeRequest) === "function" ? _a : Object)
], WorkTimeResponse.prototype, "workTimeRequest", void 0);
exports.WorkTimeResponse = WorkTimeResponse = __decorate([
    (0, typeorm_1.Entity)('work-time-responses')
], WorkTimeResponse);


/***/ }),

/***/ "./src/modules/attendance-management/work-time-requests/work-time-responses/work-time-responses.controller.ts":
/*!********************************************************************************************************************!*\
  !*** ./src/modules/attendance-management/work-time-requests/work-time-responses/work-time-responses.controller.ts ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeResponsesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const work_time_response_dto_1 = __webpack_require__(/*! ./dtos/work-time-response.dto */ "./src/modules/attendance-management/work-time-requests/work-time-responses/dtos/work-time-response.dto.ts");
const work_time_response_entity_1 = __webpack_require__(/*! ./entities/work-time-response.entity */ "./src/modules/attendance-management/work-time-requests/work-time-responses/entities/work-time-response.entity.ts");
const work_time_responses_service_1 = __webpack_require__(/*! ./work-time-responses.service */ "./src/modules/attendance-management/work-time-requests/work-time-responses/work-time-responses.service.ts");
class WorkTimeResponsesController extends (0, create_controller_factory_1.createController)(work_time_response_entity_1.WorkTimeResponse, work_time_responses_service_1.WorkTimeResponsesService, work_time_response_dto_1.GetWorkTimeResponseDto, work_time_response_dto_1.WorkTimeResponseDto, work_time_response_dto_1.UpdateWorkTimeResponseDto) {
    async delete(id) {
        return await super.delete(id);
    }
    async deleteMany(ids, hardDelete) {
        return await super.deleteMany(ids, hardDelete);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    async findOne(fieldsString, relations, select) {
        return await super.findOne(fieldsString, relations, select);
    }
}
exports.WorkTimeResponsesController = WorkTimeResponsesController;


/***/ }),

/***/ "./src/modules/attendance-management/work-time-requests/work-time-responses/work-time-responses.module.ts":
/*!****************************************************************************************************************!*\
  !*** ./src/modules/attendance-management/work-time-requests/work-time-responses/work-time-responses.module.ts ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeResponsesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const work_time_requests_module_1 = __webpack_require__(/*! ../work-time-requests.module */ "./src/modules/attendance-management/work-time-requests/work-time-requests.module.ts");
const work_time_response_entity_1 = __webpack_require__(/*! ./entities/work-time-response.entity */ "./src/modules/attendance-management/work-time-requests/work-time-responses/entities/work-time-response.entity.ts");
const work_time_responses_controller_1 = __webpack_require__(/*! ./work-time-responses.controller */ "./src/modules/attendance-management/work-time-requests/work-time-responses/work-time-responses.controller.ts");
const work_time_responses_service_1 = __webpack_require__(/*! ./work-time-responses.service */ "./src/modules/attendance-management/work-time-requests/work-time-responses/work-time-responses.service.ts");
let WorkTimeResponsesModule = class WorkTimeResponsesModule {
};
exports.WorkTimeResponsesModule = WorkTimeResponsesModule;
exports.WorkTimeResponsesModule = WorkTimeResponsesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([work_time_response_entity_1.WorkTimeResponse]),
            (0, common_1.forwardRef)(() => work_time_requests_module_1.WorkTimeRequestsModule)
        ],
        providers: [work_time_responses_service_1.WorkTimeResponsesService],
        exports: [work_time_responses_service_1.WorkTimeResponsesService],
        controllers: [work_time_responses_controller_1.WorkTimeResponsesController],
    })
], WorkTimeResponsesModule);


/***/ }),

/***/ "./src/modules/attendance-management/work-time-requests/work-time-responses/work-time-responses.service.ts":
/*!*****************************************************************************************************************!*\
  !*** ./src/modules/attendance-management/work-time-requests/work-time-responses/work-time-responses.service.ts ***!
  \*****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeResponsesService = void 0;
const work_time_event_1 = __webpack_require__(/*! @/common/events/work-time.event */ "./src/common/events/work-time.event.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const work_time_requests_service_1 = __webpack_require__(/*! ../work-time-requests.service */ "./src/modules/attendance-management/work-time-requests/work-time-requests.service.ts");
const work_time_response_entity_1 = __webpack_require__(/*! ./entities/work-time-response.entity */ "./src/modules/attendance-management/work-time-requests/work-time-responses/entities/work-time-response.entity.ts");
let WorkTimeResponsesService = class WorkTimeResponsesService extends base_service_1.BaseService {
    constructor(workTimeResponsesRepository, usersService, workTimeRequestsService, eventEmitter) {
        super(workTimeResponsesRepository, usersService);
        this.workTimeResponsesRepository = workTimeResponsesRepository;
        this.usersService = usersService;
        this.workTimeRequestsService = workTimeRequestsService;
        this.eventEmitter = eventEmitter;
    }
    async validateBefore(dto) {
        // Validate that the worktime request exists and doesn't already have a response
        dto = await this.validateReferences(dto, [
            {
                field: 'workTimeRequest',
                service: this.workTimeRequestsService,
                required: true
            }
        ]);
    }
    async create(createDto, createdBy) {
        var _a;
        const workTimeResponse = await super.create(createDto, createdBy);
        this.eventEmitter.emit(work_time_event_1.WORK_TIME_EVENTS.WORK_TIME_RESPONDED, new work_time_event_1.WorkTimeRespondedEvent((_a = createDto.workTimeRequest) === null || _a === void 0 ? void 0 : _a.id, createDto.approved, createdBy));
        return workTimeResponse;
    }
    async update(id, updateDto, updatedBy) {
        var _a;
        const workTimeResponse = await super.update(id, updateDto, updatedBy);
        this.eventEmitter.emit(work_time_event_1.WORK_TIME_EVENTS.WORK_TIME_RESPONDED, new work_time_event_1.WorkTimeRespondedEvent((_a = updateDto.workTimeRequest) === null || _a === void 0 ? void 0 : _a.id, updateDto.approved, updatedBy));
        return workTimeResponse;
    }
};
exports.WorkTimeResponsesService = WorkTimeResponsesService;
exports.WorkTimeResponsesService = WorkTimeResponsesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(work_time_response_entity_1.WorkTimeResponse)),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => work_time_requests_service_1.WorkTimeRequestsService))),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof work_time_requests_service_1.WorkTimeRequestsService !== "undefined" && work_time_requests_service_1.WorkTimeRequestsService) === "function" ? _c : Object, typeof (_d = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _d : Object])
], WorkTimeResponsesService);


/***/ }),

/***/ "./src/modules/biometrics/biometric-devices.controller.ts":
/*!****************************************************************!*\
  !*** ./src/modules/biometrics/biometric-devices.controller.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricDevicesController = void 0;
const authorize_decorator_1 = __webpack_require__(/*! @/common/decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const current_user_decorator_1 = __webpack_require__(/*! @/common/decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const generic_api_responses_decorator_1 = __webpack_require__(/*! @/common/decorators/generic-api-responses.decorator */ "./src/common/decorators/generic-api-responses.decorator.ts");
const generalresponse_dto_1 = __webpack_require__(/*! @/common/dtos/generalresponse.dto */ "./src/common/dtos/generalresponse.dto.ts");
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const utility_helper_1 = __webpack_require__(/*! @/common/helpers/utility.helper */ "./src/common/helpers/utility.helper.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const biometric_device_dto_1 = __webpack_require__(/*! ./dtos/biometric-device.dto */ "./src/modules/biometrics/dtos/biometric-device.dto.ts");
const connect_device_dto_1 = __webpack_require__(/*! ./dtos/connect-device.dto */ "./src/modules/biometrics/dtos/connect-device.dto.ts");
const biometric_device_entity_1 = __webpack_require__(/*! ./entities/biometric-device.entity */ "./src/modules/biometrics/entities/biometric-device.entity.ts");
const biometric_devices_service_1 = __webpack_require__(/*! ./services/biometric-devices.service */ "./src/modules/biometrics/services/biometric-devices.service.ts");
const biometrics_factory_service_1 = __webpack_require__(/*! ./services/biometrics-factory.service */ "./src/modules/biometrics/services/biometrics-factory.service.ts");
let BiometricDevicesController = class BiometricDevicesController extends (0, create_controller_factory_1.createController)(biometric_device_entity_1.BiometricDevice, biometric_devices_service_1.BiometricDevicesService, biometric_device_dto_1.GetBiometricDeviceDto, undefined, biometric_device_dto_1.UpdateBiometricDeviceDto) {
    constructor(biometricsFactory, biometricDevicesService) {
        super(biometricDevicesService);
        this.biometricsFactory = biometricsFactory;
        this.biometricDevicesService = biometricDevicesService;
    }
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async delete(id) {
        return await super.delete(id);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    async deleteMany(ids, hardDelete) {
        await super.deleteMany(ids, hardDelete);
    }
    async findOne(fieldsString, relations, select) {
        return await super.findOne(fieldsString, relations, select);
    }
    async connectDevice(req, connectDeviceDto, createdBy) {
        // Get the device information first to check access scope
        const device = await this.biometricDevicesService.findOneBy({ deviceId: connectDeviceDto.ipAddress + ":" + connectDeviceDto.port });
        if (device) {
            utility_helper_1.UtilityHelper.checkScopeAccess(device, req.resourceScope);
        }
        const service = this.biometricsFactory.getService(connectDeviceDto.deviceType);
        return await service.connect(connectDeviceDto, createdBy);
    }
    async disconnectDevice(req, deviceId) {
        // Get the device information first to check access scope
        const device = await this.biometricDevicesService.findOneByOrFail({ deviceId });
        utility_helper_1.UtilityHelper.checkScopeAccess(device, req.resourceScope);
        // Get the appropriate service based on the device ID
        const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
        return await service.disconnect(deviceId, true);
    }
    async getTime(req, deviceId) {
        // Check if user has access to this device based on scope
        utility_helper_1.UtilityHelper.checkScopeAccess(await this.biometricDevicesService.findOneByOrFail({ deviceId }), req.resourceScope);
        // Get the appropriate service based on the device ID
        const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
        const time = await service.getTime(deviceId);
        return { deviceId, time };
    }
    async setTime(req, deviceId, body) {
        utility_helper_1.UtilityHelper.checkScopeAccess(await this.biometricDevicesService.findOneByOrFail({ deviceId }), req.resourceScope);
        // Get the appropriate service based on the device ID
        const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
        // Parse the time or use current time
        const time = body.time ? new Date(body.time) : new Date();
        // Validate time format
        if (isNaN(time.getTime())) {
            throw new common_1.HttpException('Invalid time format', common_1.HttpStatus.BAD_REQUEST);
        }
        const result = await service.setTime(deviceId, time);
        return { message: "Biometric Device time set successfully" };
    }
};
exports.BiometricDevicesController = BiometricDevicesController;
__decorate([
    (0, common_1.Post)('devices/connect'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.CREATE }),
    (0, swagger_1.ApiOperation)({ summary: 'Connect to a biometric device' }),
    (0, swagger_1.ApiBody)({
        description: 'Device connection parameters',
        type: connect_device_dto_1.ConnectDeviceDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CONFLICT,
        description: 'Device already connected',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Device connected successfully',
        type: biometric_device_dto_1.GetBiometricDeviceDto
    }),
    (0, generic_api_responses_decorator_1.ApiCreateResponses)('Biometric Device', biometric_device_dto_1.GetBiometricDeviceDto),
    (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_c = typeof connect_device_dto_1.ConnectDeviceDto !== "undefined" && connect_device_dto_1.ConnectDeviceDto) === "function" ? _c : Object, String]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], BiometricDevicesController.prototype, "connectDevice", null);
__decorate([
    (0, common_1.Put)('devices/:deviceId/disconnect'),
    (0, swagger_1.ApiOperation)({ summary: 'Disconnect from a biometric device' }),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiParam)({
        name: 'deviceId', description: 'Device ID to disconnect from',
        type: String
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Biometric Device disconnected successfully',
        type: biometric_device_dto_1.GetBiometricDeviceDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Biometric Device not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, generic_api_responses_decorator_1.ApiUpdateResponses)('Biometric Device', biometric_device_dto_1.GetBiometricDeviceDto),
    (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], BiometricDevicesController.prototype, "disconnectDevice", null);
__decorate([
    (0, common_1.Get)('devices/:deviceId/time'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({ summary: 'Get device time' }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Biometric Device time retrieved successfully',
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], BiometricDevicesController.prototype, "getTime", null);
__decorate([
    (0, common_1.Put)('devices/:deviceId/time'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Set device time',
        description: 'Sets the time on the biometric device. If no time is provided, it uses the current server time.'
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, swagger_1.ApiBody)({
        description: 'Time to set on the device (optional)',
        type: Object,
        schema: {
            properties: {
                time: { type: 'string', format: 'date-time', example: '2023-10-01T12:00:00Z' }
            },
            required: []
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK, description: 'Biometric Device time set successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Biometric device not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Param)('deviceId')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], BiometricDevicesController.prototype, "setTime", null);
exports.BiometricDevicesController = BiometricDevicesController = __decorate([
    __param(0, (0, common_1.Inject)(biometrics_factory_service_1.BiometricsFactoryService)),
    __metadata("design:paramtypes", [typeof (_a = typeof biometrics_factory_service_1.BiometricsFactoryService !== "undefined" && biometrics_factory_service_1.BiometricsFactoryService) === "function" ? _a : Object, typeof (_b = typeof biometric_devices_service_1.BiometricDevicesService !== "undefined" && biometric_devices_service_1.BiometricDevicesService) === "function" ? _b : Object])
], BiometricDevicesController);


/***/ }),

/***/ "./src/modules/biometrics/biometrics.controller.ts":
/*!*********************************************************!*\
  !*** ./src/modules/biometrics/biometrics.controller.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricsController = void 0;
const authorize_decorator_1 = __webpack_require__(/*! @/common/decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const generic_api_responses_decorator_1 = __webpack_require__(/*! @/common/decorators/generic-api-responses.decorator */ "./src/common/decorators/generic-api-responses.decorator.ts");
const generalresponse_dto_1 = __webpack_require__(/*! @/common/dtos/generalresponse.dto */ "./src/common/dtos/generalresponse.dto.ts");
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const utility_helper_1 = __webpack_require__(/*! @/common/helpers/utility.helper */ "./src/common/helpers/utility.helper.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const biometric_user_dto_1 = __webpack_require__(/*! ./dtos/biometric-user.dto */ "./src/modules/biometrics/dtos/biometric-user.dto.ts");
const error_response_dto_1 = __webpack_require__(/*! ./dtos/error-response.dto */ "./src/modules/biometrics/dtos/error-response.dto.ts");
const timeout_interceptor_1 = __webpack_require__(/*! ./interceptors/timeout.interceptor */ "./src/modules/biometrics/interceptors/timeout.interceptor.ts");
const biometric_devices_service_1 = __webpack_require__(/*! ./services/biometric-devices.service */ "./src/modules/biometrics/services/biometric-devices.service.ts");
const biometrics_factory_service_1 = __webpack_require__(/*! ./services/biometrics-factory.service */ "./src/modules/biometrics/services/biometrics-factory.service.ts");
class GetFingerprintDto {
    constructor() {
        this.fingerId = 0;
    }
}
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Device ID to get fingerprint from',
        example: '192.168.1.100:4370'
    }),
    __metadata("design:type", String)
], GetFingerprintDto.prototype, "deviceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User ID',
        example: '1001'
    }),
    __metadata("design:type", String)
], GetFingerprintDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Finger ID (0-9)',
        example: 0,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], GetFingerprintDto.prototype, "fingerId", void 0);
// New DTOs for additional endpoints
class SetDeviceTimeDto {
}
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Time to set on the device (ISO format)',
        example: '2025-05-06T12:00:00.000Z',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SetDeviceTimeDto.prototype, "time", void 0);
class UnlockDoorDto {
}
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Delay in seconds to keep the door unlocked',
        example: 3,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], UnlockDoorDto.prototype, "delay", void 0);
class SyncUsersDto {
}
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Source device ID to copy users from',
        example: '192.168.1.100:4370'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SyncUsersDto.prototype, "sourceDeviceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Target device ID to copy users to',
        example: '192.168.1.101:4370'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SyncUsersDto.prototype, "targetDeviceId", void 0);
class ExecuteCommandDto {
}
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Command to execute on device',
        example: 'get_device_info1'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ExecuteCommandDto.prototype, "command", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Data for the command (optional)',
        example: '{"value": 1}',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ExecuteCommandDto.prototype, "data", void 0);
let BiometricsController = class BiometricsController {
    constructor(biometricsFactory, biometricDevicesService) {
        this.biometricsFactory = biometricsFactory;
        this.biometricDevicesService = biometricDevicesService;
    }
    getErrorMessage(error) {
        return error instanceof Error ? error.message : 'An unknown error occurred';
    }
    handleError(error, defaultMessage, notImplementedMessage) {
        if (error instanceof common_1.HttpException) {
            throw error;
        }
        const errorMessage = this.getErrorMessage(error);
        // Check if this is a "not implemented" error
        if (errorMessage.includes('not implemented') || errorMessage.includes('NOT_IMPLEMENTED')) {
            throw new common_1.HttpException(notImplementedMessage, common_1.HttpStatus.NOT_IMPLEMENTED);
        }
        // Check if this is a "not found" error
        if (errorMessage.includes('not found') || errorMessage.includes('not connected')) {
            throw new common_1.HttpException(`Device not found or not connected: ${errorMessage}`, common_1.HttpStatus.NOT_FOUND);
        }
        // Generic error response
        throw new common_1.HttpException(`${defaultMessage}: ${errorMessage}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
    }
    async getUserFingerprint(getFingerprintDto) {
        try {
            const { deviceId, userId, fingerId = 0 } = getFingerprintDto;
            // Get the appropriate service based on device type
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const template = await service.getUserFingerprint(deviceId, userId, fingerId);
            if (!template) {
                throw new common_1.HttpException(`No fingerprint template found for user ${userId} (finger ${fingerId})`, common_1.HttpStatus.NOT_FOUND);
            }
            return template;
        }
        catch (error) {
            return this.handleError(error, 'Failed to retrieve fingerprint template', 'Fingerprint template retrieval not supported by this device type');
        }
    }
    async registerUser(req, setUserDto) {
        // Get the device information first to check access scope
        const device = await this.biometricDevicesService.findOneBy({ deviceId: setUserDto.deviceId });
        if (!device) {
            throw new common_1.HttpException(`Biometric Device ${setUserDto.deviceId} not found`, common_1.HttpStatus.NOT_FOUND);
        }
        // Get resource scope from request
        const resourceScope = req.resourceScope;
        // Check if user has access to this device based on scope
        const hasAccess = utility_helper_1.UtilityHelper.checkScopeAccess(device, resourceScope);
        if (!hasAccess) {
            throw new common_1.HttpException(`You don't have permission to register users on Biometric Device ${setUserDto.deviceId}`, common_1.HttpStatus.FORBIDDEN);
        }
        // Get the appropriate service based on the device ID
        const service = await this.biometricsFactory.getServiceByDeviceId(setUserDto.deviceId);
        return await service.registerUser(setUserDto.deviceId, setUserDto);
    }
    async updateUser(req, setUserDto) {
        // Get the device information first to check access scope
        const device = await this.biometricDevicesService.findOneBy({ deviceId: setUserDto.deviceId });
        if (!device) {
            throw new common_1.HttpException(`Biometric Device ${setUserDto.deviceId} not found`, common_1.HttpStatus.NOT_FOUND);
        }
        // Get resource scope from request
        const resourceScope = req.resourceScope;
        // Check if user has access to this device based on scope
        const hasAccess = utility_helper_1.UtilityHelper.checkScopeAccess(device, resourceScope);
        if (!hasAccess) {
            throw new common_1.HttpException(`You don't have permission to update users on Biometric Device ${setUserDto.deviceId}`, common_1.HttpStatus.FORBIDDEN);
        }
        // Get the appropriate service based on the device ID
        const service = await this.biometricsFactory.getServiceByDeviceId(setUserDto.deviceId);
        return await service.updateUser(setUserDto.deviceId, setUserDto);
    }
    // TODO: Delete user endpoint
    // @Delete('devices/:deviceId/users/:userId')
    // @Authorize({ endpointType: Action.DELETE })
    // @ApiOperation({ summary: 'Delete a user from a biometric device' })
    // @ApiParam({
    //     name: 'deviceId',
    //     description: 'Target device ID',
    //     type: String,
    //     example: "10.10.10.100:5010"
    // })
    // @ApiParam({
    //     name: 'biometricUserId',
    //     description: 'User ID to delete',
    //     type: Number,
    //     example: 1001
    // })
    // @ApiResponse({
    //     status: HttpStatus.OK,
    //     description: 'User deleted successfully',
    //     type: GeneralResponseDto
    // })
    // @ApiResponse({
    //     status: HttpStatus.NOT_FOUND,
    //     description: 'Device or user not found',
    //     type: GeneralResponseDto
    // })
    // @ApiGenericResponses()
    // async deleteUser(
    //     @Req() req: any,
    //     @Param('deviceId') deviceId: string,
    //     @Param('biometricUserId') biometricUserId: number
    // ): Promise<Partial<GeneralResponseDto>> {
    //     // Get the device information first to check access scope
    //     const device = await this.biometricDevicesService.findOneBy({ deviceId: deviceId });
    //     if (!device) {
    //         throw new HttpException(
    //             `Biometric Device ${deviceId} not found`,
    //             HttpStatus.NOT_FOUND
    //         );
    //     }
    //     // Get resource scope from request
    //     const resourceScope = req.resourceScope;
    //     // Check if user has access to this device based on scope
    //     const hasAccess = UtilityHelper.checkScopeAccess(device, resourceScope);
    //     if (!hasAccess) {
    //         throw new HttpException(
    //             `You don't have permission to delete users on Biometric Device ${deviceId}`,
    //             HttpStatus.FORBIDDEN
    //         );
    //     }
    //     const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
    //     const result = await service.deleteUser(deviceId, biometricUserId);
    //     return {
    //         message: result 
    //             ? `User ${biometricUserId} deleted successfully from device ${deviceId}` 
    //             : `Failed to delete user ${biometricUserId} from device ${deviceId}`
    //     };
    // }
    async getUsers(req, deviceId) {
        // Get the device information first to check access scope
        const device = await this.biometricDevicesService.findOneBy({ deviceId: deviceId });
        if (!device) {
            throw new common_1.HttpException(`Biometric Device ${deviceId} not found`, common_1.HttpStatus.NOT_FOUND);
        }
        // Get resource scope from request
        const resourceScope = req.resourceScope;
        // Check if user has access to this device based on scope
        const hasAccess = utility_helper_1.UtilityHelper.checkScopeAccess(device, resourceScope);
        if (!hasAccess) {
            throw new common_1.HttpException(`You don't have permission to access users on Biometric Device ${deviceId}`, common_1.HttpStatus.FORBIDDEN);
        }
        const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
        return await service.getUsers(deviceId);
    }
    async getUserById(req, params) {
        // Get the device information first to check access scope
        const device = await this.biometricDevicesService.findOneBy({ deviceId: params.deviceId });
        if (!device) {
            throw new common_1.NotFoundException(`Biometric Device ${params.deviceId} not found`);
        }
        // Get resource scope from request
        const resourceScope = req.resourceScope;
        // Check if user has access to this device based on scope
        const hasAccess = utility_helper_1.UtilityHelper.checkScopeAccess(device, resourceScope);
        if (!hasAccess) {
            throw new common_1.ForbiddenException(`You don't have permission to access user ${params.biometricUserId} on Biometric Device ${params.deviceId}`);
        }
        const service = await this.biometricsFactory.getServiceByDeviceId(params.deviceId);
        return await service.getUserById(params);
    }
    async getAttendanceRecords(deviceId, startDateParam, endDateParam) {
        try {
            // Parse dates if provided
            const startDate = startDateParam ? new Date(startDateParam) : undefined;
            const endDate = endDateParam ? new Date(endDateParam) : undefined;
            // Validate date formats
            if ((startDate && isNaN(startDate.getTime())) ||
                (endDate && isNaN(endDate.getTime()))) {
                throw new common_1.HttpException('Invalid date format', common_1.HttpStatus.BAD_REQUEST);
            }
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const records = await service.getAttendanceRecords(deviceId, startDate, endDate);
            return {
                records,
                count: records.length,
                deviceId
            };
        }
        catch (error) {
            return this.handleError(error, 'Failed to get attendance records', 'Attendance record retrieval not supported by this device type');
        }
    }
    async getAttendanceSize(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const size = await service.getAttendanceSize(deviceId);
            return { size, deviceId };
        }
        catch (error) {
            return this.handleError(error, 'Failed to get attendance size', 'Attendance size retrieval not supported by this device type');
        }
    }
    async clearAttendanceRecords(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const result = await service.clearAttendanceRecords(deviceId);
            return {
                success: result,
                message: result
                    ? 'Attendance records cleared successfully'
                    : 'Failed to clear attendance records'
            };
        }
        catch (error) {
            return this.handleError(error, 'Failed to clear attendance records', 'Attendance record clearing not supported by this device type');
        }
    }
    async getSerialNumber(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const serialNumber = await service.getSerialNumber(deviceId);
            return { deviceId, serialNumber };
        }
        catch (error) {
            return this.handleError(error, 'Failed to get device serial number', 'Serial number retrieval not supported by this device type');
        }
    }
    async getFirmwareVersion(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const firmwareVersion = await service.getFirmwareVersion(deviceId);
            return { deviceId, firmwareVersion };
        }
        catch (error) {
            return this.handleError(error, 'Failed to get device firmware version', 'Firmware version retrieval not supported by this device type');
        }
    }
    async restartDevice(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const success = await service.restartDevice(deviceId);
            return { deviceId, success };
        }
        catch (error) {
            return this.handleError(error, 'Failed to restart device', 'Device restart not supported by this device type');
        }
    }
    async unlockDoor(deviceId, unlockDoorDto) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            // Unlock door with delay (if supported)
            const success = await service.unlockDoor(deviceId);
            return { deviceId, success };
        }
        catch (error) {
            return this.handleError(error, 'Failed to unlock door', 'Door unlocking not supported by this device type');
        }
    }
    async syncUsers(syncUsersDto) {
        try {
            const { sourceDeviceId, targetDeviceId } = syncUsersDto;
            // Get the appropriate service based on source device ID (could also check target device type)
            const service = await this.biometricsFactory.getServiceByDeviceId(sourceDeviceId);
            const count = await service.syncUsers(sourceDeviceId, targetDeviceId);
            return { sourceDeviceId, targetDeviceId, count };
        }
        catch (error) {
            return this.handleError(error, 'Failed to sync users between devices', 'User synchronization not supported by this device type');
        }
    }
    async getUserDetails(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            return await service.getUserDetails(deviceId);
        }
        catch (error) {
            return this.handleError(error, 'Failed to get user details', 'User details retrieval not supported by this device type');
        }
    }
};
exports.BiometricsController = BiometricsController;
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get fingerprint template for a user' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Fingerprint template retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                id: { type: 'string', example: '1001-0' },
                userId: { type: 'string', example: '1001' },
                fingerId: { type: 'number', example: 0 },
                template: { type: 'string', format: 'binary', description: 'Binary template data' },
                provider: { type: 'string', example: 'zkteco' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Template or device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid request',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, common_1.Get)('users/fingerprint'),
    __param(0, (0, common_1.Query)(new common_1.ValidationPipe({ transform: true }))),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [GetFingerprintDto]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], BiometricsController.prototype, "getUserFingerprint", null);
__decorate([
    (0, common_1.Post)('users/register'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.CREATE }),
    (0, swagger_1.ApiOperation)({ summary: 'Register a new user on a biometric device' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        description: 'User registered successfully',
        type: biometric_user_dto_1.BiometricUserDto
    }),
    (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_d = typeof biometric_user_dto_1.BiometricUserDto !== "undefined" && biometric_user_dto_1.BiometricUserDto) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], BiometricsController.prototype, "registerUser", null);
__decorate([
    (0, common_1.Put)('users/update'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({ summary: 'Update an existing user on a biometric device' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'User updated successfully',
        type: biometric_user_dto_1.BiometricUserDto
    }),
    (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_f = typeof biometric_user_dto_1.BiometricUserDto !== "undefined" && biometric_user_dto_1.BiometricUserDto) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], BiometricsController.prototype, "updateUser", null);
__decorate([
    (0, common_1.Get)('devices/:deviceId/users'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({ summary: 'Get users registered on a biometric device' }),
    (0, swagger_1.ApiParam)({
        name: 'deviceId',
        description: 'Target device ID',
        type: String,
        example: "10.10.10.100:5010"
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'List of users retrieved successfully',
        type: [biometric_user_dto_1.BiometricUserDto]
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Biometric Device not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], BiometricsController.prototype, "getUsers", null);
__decorate([
    (0, common_1.Get)('devices/:deviceId/users/:biometricUserId'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({ summary: 'Get a specific user by ID from a biometric device' }),
    (0, swagger_1.ApiParam)({
        name: 'deviceId',
        description: 'Target device ID',
        type: String
    }),
    (0, swagger_1.ApiParam)({
        name: 'biometricUserId',
        description: 'User ID in the biometric device',
        type: Number
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'User retrieved successfully',
        type: biometric_user_dto_1.BiometricUserDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'User or device not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Param)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_j = typeof biometric_user_dto_1.GetBiometricUserDto !== "undefined" && biometric_user_dto_1.GetBiometricUserDto) === "function" ? _j : Object]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], BiometricsController.prototype, "getUserById", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get attendance records from a device' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'List of attendance records',
        type: [Object]
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Filter by start date (ISO format)' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'Filter by end date (ISO format)' }),
    (0, common_1.Get)('devices/:deviceId/attendances'),
    __param(0, (0, common_1.Param)('deviceId')),
    __param(1, (0, common_1.Query)('startDate')),
    __param(2, (0, common_1.Query)('endDate')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], BiometricsController.prototype, "getAttendanceRecords", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get attendance records size' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Attendance record count',
        type: Number
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Get)('devices/:deviceId/attendance/size'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], BiometricsController.prototype, "getAttendanceSize", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Clear attendance records from a device' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Attendance records cleared successfully' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Delete)('devices/:deviceId/attendance'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], BiometricsController.prototype, "clearAttendanceRecords", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get device serial number' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Device serial number retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                deviceId: { type: 'string', example: '192.168.1.100:4370' },
                serialNumber: { type: 'string', example: 'ABC123456' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Get)('devices/:deviceId/serial'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_p = typeof Promise !== "undefined" && Promise) === "function" ? _p : Object)
], BiometricsController.prototype, "getSerialNumber", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get device firmware version' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Device firmware version retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                deviceId: { type: 'string', example: '192.168.1.100:4370' },
                firmwareVersion: { type: 'string', example: '1.2.3' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Get)('devices/:deviceId/firmware'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_q = typeof Promise !== "undefined" && Promise) === "function" ? _q : Object)
], BiometricsController.prototype, "getFirmwareVersion", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Restart device' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Device restarted successfully',
        schema: {
            type: 'object',
            properties: {
                deviceId: { type: 'string', example: '192.168.1.100:4370' },
                success: { type: 'boolean', example: true }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Post)('devices/:deviceId/restart'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_r = typeof Promise !== "undefined" && Promise) === "function" ? _r : Object)
], BiometricsController.prototype, "restartDevice", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Unlock device door' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Door unlocked successfully',
        schema: {
            type: 'object',
            properties: {
                deviceId: { type: 'string', example: '192.168.1.100:4370' },
                success: { type: 'boolean', example: true }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Post)('devices/:deviceId/unlock-door'),
    __param(0, (0, common_1.Param)('deviceId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, UnlockDoorDto]),
    __metadata("design:returntype", typeof (_s = typeof Promise !== "undefined" && Promise) === "function" ? _s : Object)
], BiometricsController.prototype, "unlockDoor", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Sync users between devices' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Users synced successfully',
        schema: {
            type: 'object',
            properties: {
                sourceDeviceId: { type: 'string', example: '192.168.1.100:4370' },
                targetDeviceId: { type: 'string', example: '192.168.1.101:4370' },
                count: { type: 'number', example: 10 }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, common_1.Post)('devices/sync-users'),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [SyncUsersDto]),
    __metadata("design:returntype", typeof (_t = typeof Promise !== "undefined" && Promise) === "function" ? _t : Object)
], BiometricsController.prototype, "syncUsers", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get user details including fingerprint info' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'User details retrieved successfully',
        type: [Object]
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Get)('devices/:deviceId/user-details'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_u = typeof Promise !== "undefined" && Promise) === "function" ? _u : Object)
], BiometricsController.prototype, "getUserDetails", null);
exports.BiometricsController = BiometricsController = __decorate([
    (0, swagger_1.ApiTags)('Biometrics'),
    (0, common_1.Controller)(),
    (0, common_1.UseInterceptors)(new timeout_interceptor_1.TimeoutInterceptor(30)),
    __metadata("design:paramtypes", [typeof (_a = typeof biometrics_factory_service_1.BiometricsFactoryService !== "undefined" && biometrics_factory_service_1.BiometricsFactoryService) === "function" ? _a : Object, typeof (_b = typeof biometric_devices_service_1.BiometricDevicesService !== "undefined" && biometric_devices_service_1.BiometricDevicesService) === "function" ? _b : Object])
], BiometricsController);


/***/ }),

/***/ "./src/modules/biometrics/biometrics.module.ts":
/*!*****************************************************!*\
  !*** ./src/modules/biometrics/biometrics.module.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricsModule = void 0;
const attendance_punch_entity_1 = __webpack_require__(/*! @/modules/attendance-management/attendance-punches/entities/attendance-punch.entity */ "./src/modules/attendance-management/attendance-punches/entities/attendance-punch.entity.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const biometric_devices_controller_1 = __webpack_require__(/*! ./biometric-devices.controller */ "./src/modules/biometrics/biometric-devices.controller.ts");
const biometrics_controller_1 = __webpack_require__(/*! ./biometrics.controller */ "./src/modules/biometrics/biometrics.controller.ts");
const biometric_device_entity_1 = __webpack_require__(/*! ./entities/biometric-device.entity */ "./src/modules/biometrics/entities/biometric-device.entity.ts");
const biometric_template_entity_1 = __webpack_require__(/*! ./entities/biometric-template.entity */ "./src/modules/biometrics/entities/biometric-template.entity.ts");
const biometrics_gateway_1 = __webpack_require__(/*! ./gateways/biometrics.gateway */ "./src/modules/biometrics/gateways/biometrics.gateway.ts");
const timeout_interceptor_1 = __webpack_require__(/*! ./interceptors/timeout.interceptor */ "./src/modules/biometrics/interceptors/timeout.interceptor.ts");
const anvis_biometrics_service_1 = __webpack_require__(/*! ./services/anvis-biometrics.service */ "./src/modules/biometrics/services/anvis-biometrics.service.ts");
const biometric_devices_service_1 = __webpack_require__(/*! ./services/biometric-devices.service */ "./src/modules/biometrics/services/biometric-devices.service.ts");
const biometrics_factory_service_1 = __webpack_require__(/*! ./services/biometrics-factory.service */ "./src/modules/biometrics/services/biometrics-factory.service.ts");
const biometrics_polling_service_1 = __webpack_require__(/*! ./services/biometrics-polling.service */ "./src/modules/biometrics/services/biometrics-polling.service.ts");
const zkteco_biometrics_service_1 = __webpack_require__(/*! ./services/zkteco-biometrics.service */ "./src/modules/biometrics/services/zkteco-biometrics.service.ts");
let BiometricsModule = class BiometricsModule {
};
exports.BiometricsModule = BiometricsModule;
exports.BiometricsModule = BiometricsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([biometric_device_entity_1.BiometricDevice, biometric_template_entity_1.BiometricTemplate, attendance_punch_entity_1.AttendancePunch]),
            core_1.RouterModule.register([{
                    path: 'biometrics',
                    module: BiometricsModule,
                }]),
        ],
        controllers: [biometrics_controller_1.BiometricsController, biometric_devices_controller_1.BiometricDevicesController],
        providers: [
            // Register ZKTeco service
            {
                provide: 'ZKTECO_SERVICE',
                useClass: zkteco_biometrics_service_1.ZKTecoBiometricsService,
            },
            // Register Anviz service
            {
                provide: 'ANVIZ_SERVICE',
                useClass: anvis_biometrics_service_1.AnvizBiometricsService,
            },
            // Register the legacy token for backward compatibility
            {
                provide: 'BIOMETRIC_SERVICE',
                useExisting: 'ZKTECO_SERVICE', // Default to ZKTeco for backward compatibility
            },
            {
                provide: timeout_interceptor_1.TimeoutInterceptor,
                useFactory: () => new timeout_interceptor_1.TimeoutInterceptor(30),
            },
            biometrics_polling_service_1.BiometricsPollingService,
            biometric_devices_service_1.BiometricDevicesService,
            biometrics_factory_service_1.BiometricsFactoryService,
            biometrics_gateway_1.BiometricsGateway,
        ],
        exports: [
            'ZKTECO_SERVICE',
            'ANVIZ_SERVICE',
            'BIOMETRIC_SERVICE',
            biometric_devices_service_1.BiometricDevicesService,
            biometrics_factory_service_1.BiometricsFactoryService,
        ],
    })
], BiometricsModule);


/***/ }),

/***/ "./src/modules/biometrics/dtos/biometric-device.dto.ts":
/*!*************************************************************!*\
  !*** ./src/modules/biometrics/dtos/biometric-device.dto.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBiometricDeviceDto = exports.UpdateBiometricDeviceDto = exports.BiometricDeviceDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const biometrics_device_type_enum_1 = __webpack_require__(/*! @/common/enums/biometrics-device-type.enum */ "./src/common/enums/biometrics-device-type.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class BiometricDeviceDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.BiometricDeviceDto = BiometricDeviceDto;
class UpdateBiometricDeviceDto extends (0, swagger_1.PartialType)(BiometricDeviceDto) {
}
exports.UpdateBiometricDeviceDto = UpdateBiometricDeviceDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the biometric device',
        example: 'Main Entrance Scanner',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(255),
    __metadata("design:type", String)
], UpdateBiometricDeviceDto.prototype, "name", void 0);
class GetBiometricDeviceDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateBiometricDeviceDto, 'biometric device') {
}
exports.GetBiometricDeviceDto = GetBiometricDeviceDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier for the device (assigned by manufacturer)',
        example: 'ZK-123456',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], GetBiometricDeviceDto.prototype, "deviceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'IP address of the biometric device',
        example: '192.168.1.100',
    }),
    (0, class_validator_1.IsIP)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], GetBiometricDeviceDto.prototype, "ipAddress", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Port number the device is accessible on',
        example: 4370,
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsPort)(),
    __metadata("design:type", Number)
], GetBiometricDeviceDto.prototype, "port", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Model of the biometric device',
        example: 'F18',
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], GetBiometricDeviceDto.prototype, "model", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Serial number of the device',
        example: 'SN12345678',
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], GetBiometricDeviceDto.prototype, "serialNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Provider/manufacturer of the biometric device',
        enum: biometrics_device_type_enum_1.BiometricDeviceType,
        default: biometrics_device_type_enum_1.BiometricDeviceType.ZKTECO,
        example: biometrics_device_type_enum_1.BiometricDeviceType.ZKTECO
    }),
    (0, class_validator_1.IsEnum)(biometrics_device_type_enum_1.BiometricDeviceType),
    __metadata("design:type", typeof (_a = typeof biometrics_device_type_enum_1.BiometricDeviceType !== "undefined" && biometrics_device_type_enum_1.BiometricDeviceType) === "function" ? _a : Object)
], GetBiometricDeviceDto.prototype, "provider", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Firmware version of the device',
        example: '1.2.5',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], GetBiometricDeviceDto.prototype, "firmware", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Platform information of the device',
        example: 'ZKTeco Biometric Platform',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], GetBiometricDeviceDto.prototype, "platform", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Version of the device',
        example: 'V1.0',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], GetBiometricDeviceDto.prototype, "deviceVersion", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Operating system of the device',
        example: 'Linux Embedded',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], GetBiometricDeviceDto.prototype, "os", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the device is currently connected',
        example: false,
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], GetBiometricDeviceDto.prototype, "isConnected", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the device is in offline mode',
        example: false,
        required: true
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], GetBiometricDeviceDto.prototype, "isOffline", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date and time of the last synchronization',
        example: '2023-09-15T10:30:00Z',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsDateString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], GetBiometricDeviceDto.prototype, "lastSync", void 0);


/***/ }),

/***/ "./src/modules/biometrics/dtos/biometric-user.dto.ts":
/*!***********************************************************!*\
  !*** ./src/modules/biometrics/dtos/biometric-user.dto.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricUserDto = exports.GetBiometricUserDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class GetBiometricUserDto {
}
exports.GetBiometricUserDto = GetBiometricUserDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Target device ID',
        type: String
    }),
    (0, class_validator_1.IsString)({ message: 'Device ID must be a string' }),
    (0, class_validator_1.IsNotEmpty)({ message: 'Device ID is required and cannot be empty' }),
    __metadata("design:type", String)
], GetBiometricUserDto.prototype, "deviceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User ID in the biometric device',
        type: Number
    }),
    (0, class_validator_1.IsNotEmpty)({ message: 'Biometric user ID is required and cannot be empty' }),
    (0, class_validator_1.IsPositive)({ message: 'Biometric user ID must be a positive number' }),
    (0, class_validator_1.IsNumber)({}, { message: 'Biometric user ID must be a valid number' }),
    __metadata("design:type", Number)
], GetBiometricUserDto.prototype, "biometricUserId", void 0);
class BiometricUserDto extends GetBiometricUserDto {
}
exports.BiometricUserDto = BiometricUserDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User name', example: 'John Doe' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.Length)(1, 24, { message: 'Name must be between 1 and 24 characters' }),
    __metadata("design:type", String)
], BiometricUserDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'User password (if applicable)',
        example: 123456
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({}, { message: 'Password must be a number' }),
    (0, class_validator_1.Min)(0, { message: 'Password must be a non-negative number' }),
    __metadata("design:type", Number)
], BiometricUserDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'User card number (if applicable)',
        example: 1234567890
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({}, { message: 'Card number must be a number' }),
    (0, class_validator_1.Min)(0, { message: 'Card number must be a non-negative number' }),
    __metadata("design:type", Number)
], BiometricUserDto.prototype, "cardNumber", void 0);


/***/ }),

/***/ "./src/modules/biometrics/dtos/connect-device.dto.ts":
/*!***********************************************************!*\
  !*** ./src/modules/biometrics/dtos/connect-device.dto.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectDeviceDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const biometrics_device_type_enum_1 = __webpack_require__(/*! @/common/enums/biometrics-device-type.enum */ "./src/common/enums/biometrics-device-type.enum.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class ConnectDeviceDto extends base_dto_1.BaseDto {
    constructor() {
        super(...arguments);
        this.port = 4370;
    }
}
exports.ConnectDeviceDto = ConnectDeviceDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Device IP address',
        example: '192.168.1.100'
    }),
    (0, class_validator_1.IsIP)(4),
    __metadata("design:type", String)
], ConnectDeviceDto.prototype, "ipAddress", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Device port number',
        example: 4370,
        default: 4370
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(65535),
    __metadata("design:type", Number)
], ConnectDeviceDto.prototype, "port", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Device type/manufacturer',
        enum: biometrics_device_type_enum_1.BiometricDeviceType,
        default: biometrics_device_type_enum_1.BiometricDeviceType.ZKTECO,
        example: 'zkteco'
    }),
    (0, class_validator_1.IsEnum)(biometrics_device_type_enum_1.BiometricDeviceType),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof biometrics_device_type_enum_1.BiometricDeviceType !== "undefined" && biometrics_device_type_enum_1.BiometricDeviceType) === "function" ? _a : Object)
], ConnectDeviceDto.prototype, "deviceType", void 0);


/***/ }),

/***/ "./src/modules/biometrics/dtos/error-response.dto.ts":
/*!***********************************************************!*\
  !*** ./src/modules/biometrics/dtos/error-response.dto.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ErrorResponseDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
/**
 * DTO for biometrics API error responses
 */
class ErrorResponseDto {
}
exports.ErrorResponseDto = ErrorResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'HTTP status code of the error response',
        example: 400,
        type: Number,
    }),
    __metadata("design:type", Number)
], ErrorResponseDto.prototype, "statusCode", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Error message or messages describing the issue',
        example: 'Failed to connect to device',
        oneOf: [
            { type: 'string' },
            { type: 'array', items: { type: 'string' } }
        ]
    }),
    __metadata("design:type", Object)
], ErrorResponseDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Error code for client identification',
        example: 'DEVICE_CONNECTION_ERROR',
        type: String,
    }),
    __metadata("design:type", String)
], ErrorResponseDto.prototype, "code", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Additional error details or context',
        example: 'Device might be offline or credentials are invalid',
        type: String,
        required: false
    }),
    __metadata("design:type", String)
], ErrorResponseDto.prototype, "detail", void 0);


/***/ }),

/***/ "./src/modules/biometrics/entities/biometric-device.entity.ts":
/*!********************************************************************!*\
  !*** ./src/modules/biometrics/entities/biometric-device.entity.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricDevice = void 0;
const biometrics_device_type_enum_1 = __webpack_require__(/*! @/common/enums/biometrics-device-type.enum */ "./src/common/enums/biometrics-device-type.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const attendance_punch_entity_1 = __webpack_require__(/*! @/modules/attendance-management/attendance-punches/entities/attendance-punch.entity */ "./src/modules/attendance-management/attendance-punches/entities/attendance-punch.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
let BiometricDevice = class BiometricDevice extends base_entity_1.BaseEntity {
};
exports.BiometricDevice = BiometricDevice;
__decorate([
    (0, typeorm_1.Column)({ unique: true, nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "deviceId", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], BiometricDevice.prototype, "ipAddress", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Number)
], BiometricDevice.prototype, "port", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "model", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "serialNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: biometrics_device_type_enum_1.BiometricDeviceType,
        default: biometrics_device_type_enum_1.BiometricDeviceType.ZKTECO
    }),
    __metadata("design:type", typeof (_a = typeof biometrics_device_type_enum_1.BiometricDeviceType !== "undefined" && biometrics_device_type_enum_1.BiometricDeviceType) === "function" ? _a : Object)
], BiometricDevice.prototype, "provider", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "firmware", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "platform", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "deviceVersion", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "os", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], BiometricDevice.prototype, "isConnected", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], BiometricDevice.prototype, "isOffline", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], BiometricDevice.prototype, "lastSync", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => attendance_punch_entity_1.AttendancePunch, (attendancePunch) => attendancePunch.biometricDevice, { nullable: true }),
    __metadata("design:type", Array)
], BiometricDevice.prototype, "attendancePunches", void 0);
exports.BiometricDevice = BiometricDevice = __decorate([
    (0, typeorm_1.Entity)('biometric_devices')
], BiometricDevice);


/***/ }),

/***/ "./src/modules/biometrics/entities/biometric-template.entity.ts":
/*!**********************************************************************!*\
  !*** ./src/modules/biometrics/entities/biometric-template.entity.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricTemplate = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
let BiometricTemplate = class BiometricTemplate extends base_entity_1.BaseEntity {
};
exports.BiometricTemplate = BiometricTemplate;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], BiometricTemplate.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Number)
], BiometricTemplate.prototype, "fingerId", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'longblob' }),
    __metadata("design:type", typeof (_a = typeof Buffer !== "undefined" && Buffer) === "function" ? _a : Object)
], BiometricTemplate.prototype, "template", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], BiometricTemplate.prototype, "provider", void 0);
exports.BiometricTemplate = BiometricTemplate = __decorate([
    (0, typeorm_1.Entity)('biometric_templates')
], BiometricTemplate);


/***/ }),

/***/ "./src/modules/biometrics/gateways/biometrics.gateway.ts":
/*!***************************************************************!*\
  !*** ./src/modules/biometrics/gateways/biometrics.gateway.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricsGateway = void 0;
const create_gateway_factory_1 = __webpack_require__(/*! @/common/factories/create-gateway.factory */ "./src/common/factories/create-gateway.factory.ts");
class BiometricsGateway extends (0, create_gateway_factory_1.createGateway)('biometrics') {
}
exports.BiometricsGateway = BiometricsGateway;


/***/ }),

/***/ "./src/modules/biometrics/interceptors/timeout.interceptor.ts":
/*!********************************************************************!*\
  !*** ./src/modules/biometrics/interceptors/timeout.interceptor.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutInterceptor = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const rxjs_1 = __webpack_require__(/*! rxjs */ "rxjs");
const operators_1 = __webpack_require__(/*! rxjs/operators */ "rxjs/operators");
let TimeoutInterceptor = class TimeoutInterceptor {
    constructor(timeoutSeconds = 30) {
        this.timeoutSeconds = timeoutSeconds;
    }
    intercept(context, next) {
        return next.handle().pipe((0, operators_1.timeout)(this.timeoutSeconds * 1000), (0, operators_1.catchError)(err => {
            if (err instanceof rxjs_1.TimeoutError) {
                return (0, rxjs_1.throwError)(() => new common_1.RequestTimeoutException('Request timed out'));
            }
            return (0, rxjs_1.throwError)(() => err);
        }));
    }
};
exports.TimeoutInterceptor = TimeoutInterceptor;
exports.TimeoutInterceptor = TimeoutInterceptor = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [Number])
], TimeoutInterceptor);


/***/ }),

/***/ "./src/modules/biometrics/interfaces/biometric.interface.ts":
/*!******************************************************************!*\
  !*** ./src/modules/biometrics/interfaces/biometric.interface.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/modules/biometrics/services/anvis-biometrics.service.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/biometrics/services/anvis-biometrics.service.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var AnvizBiometricsService_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnvizBiometricsService = void 0;
const biometrics_device_type_enum_1 = __webpack_require__(/*! @/common/enums/biometrics-device-type.enum */ "./src/common/enums/biometrics-device-type.enum.ts");
const punch_method_enum_1 = __webpack_require__(/*! @/common/enums/punch-method.enum */ "./src/common/enums/punch-method.enum.ts");
const punch_type_enum_1 = __webpack_require__(/*! @/common/enums/punch-type.enum */ "./src/common/enums/punch-type.enum.ts");
const attendance_event_1 = __webpack_require__(/*! @/common/events/attendance.event */ "./src/common/events/attendance.event.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const biometric_user_dto_1 = __webpack_require__(/*! ../dtos/biometric-user.dto */ "./src/modules/biometrics/dtos/biometric-user.dto.ts");
const biometric_device_entity_1 = __webpack_require__(/*! ../entities/biometric-device.entity */ "./src/modules/biometrics/entities/biometric-device.entity.ts");
const biometric_template_entity_1 = __webpack_require__(/*! ../entities/biometric-template.entity */ "./src/modules/biometrics/entities/biometric-template.entity.ts");
const biometrics_gateway_1 = __webpack_require__(/*! ../gateways/biometrics.gateway */ "./src/modules/biometrics/gateways/biometrics.gateway.ts");
const base_biometrics_service_1 = __webpack_require__(/*! ./base-biometrics.service */ "./src/modules/biometrics/services/base-biometrics.service.ts");
const { UserInfo } = __webpack_require__(/*! ../../../../anviz-protocol/model/user-info */ "./anviz-protocol/model/user-info.js");
// Import the Anviz protocol library
const { Device, Record, RecordInformation, DeviceInfo1, DeviceInfo2 } = __webpack_require__(/*! ../../../../anviz-protocol */ "./anviz-protocol/index.js");
let AnvizBiometricsService = AnvizBiometricsService_1 = class AnvizBiometricsService extends base_biometrics_service_1.BaseBiometricsService {
    constructor(templateRepository, deviceRepository, eventEmitter, biometricsGateway) {
        super(deviceRepository, eventEmitter, biometricsGateway);
        this.templateRepository = templateRepository;
        this.deviceRepository = deviceRepository;
        this.eventEmitter = eventEmitter;
        this.biometricsGateway = biometricsGateway;
        this.logger = new common_1.Logger(AnvizBiometricsService_1.name);
        this.biometricDeviceType = biometrics_device_type_enum_1.BiometricDeviceType.ANVIZ;
        // Command queue to avoid multiple operations on the same device simultaneously
        this.commandQueues = new Map();
        // Flag to track if a device's queue is being processed
        this.processingQueues = new Map();
        // Default command timeout (15 seconds)
        this.commandTimeout = 15000;
    }
    /**
     * Queue a command to be executed on a device
     * @param deviceId Device identifier
     * @param operation Operation name for logging
     * @param execute Function to execute
     * @returns Promise that resolves when the operation completes
     */
    queueCommand(deviceId, operation, execute) {
        return new Promise((resolve, reject) => {
            // Create queue for device if it doesn't exist
            if (!this.commandQueues.has(deviceId)) {
                this.commandQueues.set(deviceId, []);
                this.processingQueues.set(deviceId, false);
            }
            // Create a unique ID for this command
            const commandId = `${operation}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            // Create command queue item
            const queueItem = {
                id: commandId,
                operation,
                execute,
                resolve,
                reject,
                timestamp: Date.now(),
                timeout: setTimeout(() => {
                    // Remove item from queue if it times out
                    this.removeFromQueue(deviceId, commandId);
                    reject(new Error(`Operation '${operation}' timed out after ${this.commandTimeout}ms`));
                }, this.commandTimeout)
            };
            // Add item to device queue
            const queue = this.commandQueues.get(deviceId); // Non-null assertion as we create it above if it doesn't exist
            queue.push(queueItem);
            this.logger.debug(`Queued operation '${operation}' for device ${deviceId}. Queue length: ${queue.length}`);
            // Start processing queue if not already processing
            if (!this.processingQueues.get(deviceId)) {
                this.processQueue(deviceId);
            }
        });
    }
    /**
     * Process the command queue for a device
     * @param deviceId Device identifier
     */
    async processQueue(deviceId) {
        if (!this.commandQueues.has(deviceId))
            return;
        // Set processing flag
        this.processingQueues.set(deviceId, true);
        const queue = this.commandQueues.get(deviceId); // Non-null assertion as we already checked above
        // Process queue items one by one
        while (queue.length > 0) {
            const item = queue[0];
            this.logger.debug(`Executing operation '${item.operation}' for device ${deviceId}`);
            try {
                // Execute the command
                const result = await item.execute();
                // Clear timeout and resolve promise
                if (item.timeout)
                    clearTimeout(item.timeout);
                item.resolve(result);
            }
            catch (error) {
                // Clear timeout and reject promise
                if (item.timeout)
                    clearTimeout(item.timeout);
                item.reject(error);
            }
            finally {
                // Remove item from queue
                queue.shift();
            }
        }
        // Clear processing flag
        this.processingQueues.set(deviceId, false);
    }
    /**
     * Remove an item from the command queue
     * @param deviceId Device identifier
     * @param commandId Command ID to remove
     */
    removeFromQueue(deviceId, commandId) {
        if (!this.commandQueues.has(deviceId))
            return false;
        const queue = this.commandQueues.get(deviceId); // Non-null assertion as we already checked above
        const initialLength = queue.length;
        // Filter out item with matching ID
        const newQueue = queue.filter(item => item.id !== commandId);
        this.commandQueues.set(deviceId, newQueue);
        return newQueue.length !== initialLength;
    }
    // Helper method to execute a promise with timeout
    async executeWithTimeout(promiseFn, timeoutMs, timeoutMessage) {
        return new Promise(async (resolve, reject) => {
            // Create timeout that rejects the promise
            const timeoutId = setTimeout(() => {
                reject(new common_1.RequestTimeoutException(timeoutMessage));
            }, timeoutMs);
            try {
                // Execute the actual promise
                const result = await promiseFn();
                clearTimeout(timeoutId);
                resolve(result);
            }
            catch (error) {
                clearTimeout(timeoutId);
                reject(error);
            }
        });
    }
    /**
     * Connect to an Anviz device with robust retry logic
     * @param dto Connection details
     * @param deviceId Device identifier
     * @returns Connected device information
     */
    async connectWithRetry(dto, deviceId, createdBy) {
        const { ipAddress, port } = dto;
        // Check if already connected
        if (this.connections.has(deviceId)) {
            this.logger.warn(`Device ${deviceId} is already connected. Disconnecting first...`);
            await this.disconnect(deviceId);
        }
        try {
            // Create a connection promise with timeout
            const connectionPromise = async () => {
                // Create a new Anviz device connection
                const anvizDevice = new Device(ipAddress, port);
                // Set up connection events with proper reconnection handling
                anvizDevice.listener = {
                    onConnectionLost: async () => {
                        this.logger.warn(`Connection lost to Anviz device ${deviceId}`);
                        // Clear any heartbeat interval
                        if (anvizDevice._heartbeatInterval) {
                            clearInterval(anvizDevice._heartbeatInterval);
                            anvizDevice._heartbeatInterval = null;
                        }
                        await this.disconnect(deviceId);
                        // Schedule automatic reconnection
                        this.scheduleReconnect(deviceId);
                    },
                    onError: async (error) => {
                        const errorMessage = error instanceof Error ? error.message : String(error);
                        this.logger.error(`Anviz device ${deviceId} error: ${errorMessage}`);
                        // Clear any heartbeat interval
                        if (anvizDevice._heartbeatInterval) {
                            clearInterval(anvizDevice._heartbeatInterval);
                            anvizDevice._heartbeatInterval = null;
                        }
                    },
                    onRecord: (record) => {
                        // Validate and standardize the record
                        if (!record || typeof record.userId === 'undefined' || !record.dateTime) {
                            this.logger.warn(`Received invalid record from device ${deviceId}`);
                            return;
                        }
                        const standardizedRecord = {
                            userId: record.userId.toString(),
                            // used the system date instead of the device date because time is not accurate and consistent
                            timestamp: new Date(),
                            punchType: record.type,
                            punchMethod: this.getPunchMethod(record.backupCode),
                            deviceId: deviceId,
                        };
                        this.logger.log(`Received attendance record from device ${deviceId}: ${JSON.stringify(standardizedRecord)}`);
                        // Emit the attendance event
                        this.eventEmitter.emit(attendance_event_1.ATTENDANCE_EVENTS.ATTENDANCE_RECORDED, new attendance_event_1.AttendanceRecordedEvent([standardizedRecord], deviceId));
                        anvizDevice.clearAllRecords();
                    }
                };
                anvizDevice.connect();
                // Connection successful - configure device
                await new Promise((resolve, reject) => {
                    anvizDevice.getDeviceInfo2((info) => {
                        try {
                            info.realTimeModeSetting = 1; // enable real time mode
                            info.relayMode = 3; // 0 control lock, 1 scheduled bell, 3 disabled
                            info.lockDelay = 2; // 2 seconds
                            anvizDevice.setDeviceInfo2(info);
                            // Fetch and process any pending records
                            anvizDevice.getNewRecords((records) => {
                                try {
                                    if (records && records.length > 0) {
                                        for (let i = 0; i < records.length; ++i) {
                                            anvizDevice.listener.onRecord(records[i]);
                                        }
                                        anvizDevice.clearAllRecordsSign();
                                    }
                                    resolve();
                                }
                                catch (err) {
                                    reject(err);
                                }
                            });
                        }
                        catch (err) {
                            reject(err);
                        }
                    });
                });
                // Store the connection
                this.connections.set(deviceId, anvizDevice);
                // Fetch device information
                const deviceInfo = await this.getAnvizDeviceInfo(deviceId);
                // Check if device ID already exists
                let existingDevice = await this.deviceRepository.findOne({ where: { deviceId } });
                // Create a standardized device object
                let device = {
                    id: existingDevice === null || existingDevice === void 0 ? void 0 : existingDevice.id,
                    deviceId,
                    ipAddress,
                    port,
                    serialNumber: deviceInfo.serialNumber || 'Unknown',
                    firmware: deviceInfo.firmwareVersion || 'Unknown',
                    isConnected: true,
                    isOffline: false,
                    provider: biometrics_device_type_enum_1.BiometricDeviceType.ANVIZ,
                    lastSync: new Date(),
                    organizationId: dto.organizationId,
                    branchId: dto.branchId,
                    departmentId: dto.departmentId,
                    userId: dto.userId,
                    createdBy
                };
                // Set up heartbeat to monitor connection health
                if (anvizDevice._heartbeatInterval) {
                    clearInterval(anvizDevice._heartbeatInterval);
                }
                anvizDevice._heartbeatInterval = setInterval(() => {
                    this.verifyDeviceConnection(anvizDevice, deviceId)
                        .then(() => {
                        // Connection is healthy
                    })
                        .catch((error) => {
                        this.logger.error(`Device ${deviceId} connection verification failed: ${error.message}`);
                        // If heartbeat fails, connection is likely lost
                        if (anvizDevice.listener && anvizDevice.listener.onConnectionLost) {
                            anvizDevice.listener.onConnectionLost();
                        }
                    });
                }, 10000); // Check every 30 seconds to reduce overhead
                // log
                this.logger.log(`Connected to Anviz device ${deviceId} (${deviceInfo.serialNumber})`);
                // check if device already exists
                if (!existingDevice) {
                    // Create new device
                    const newDevice = this.deviceRepository.create(device);
                    existingDevice = await this.deviceRepository.save(newDevice);
                    this.logger.log(`Created new Anviz device ${deviceId} in database`);
                }
                else {
                    // Update existing device
                    await this.deviceRepository.update(existingDevice.id, { lastSync: new Date(), isConnected: true, isOffline: false });
                    this.logger.log(`Updated Anviz device ${deviceId} in database`);
                }
                await this.biometricsGateway.pingAll();
                return existingDevice;
            };
            // Execute with timeout
            return await this.executeWithTimeout(connectionPromise, 30000, `Connection to device ${deviceId} timed out after 30 seconds`);
        }
        catch (error) {
            // Schedule automatic reconnection
            this.logger.error(`Failed to connect to Anviz device ${deviceId}: ${error.message}`);
            throw new common_1.InternalServerErrorException(`Failed to connect to Anviz device ${deviceId}: ${error.message}`);
        }
    }
    /**
     * Map Anviz punch types to system punch types
     */
    mapPunchType(backupCode) {
        switch (backupCode) {
            case 0:
                return punch_type_enum_1.PunchType.CHECK_IN;
            case 1:
                return punch_type_enum_1.PunchType.CHECK_OUT;
            case 2:
                return punch_type_enum_1.PunchType.BREAK_OUT;
            case 3:
                return punch_type_enum_1.PunchType.BREAK_IN;
            case 4:
                return punch_type_enum_1.PunchType.OVERTIME_IN;
            case 5:
                return punch_type_enum_1.PunchType.OVERTIME_OUT;
            default:
                return punch_type_enum_1.PunchType.CHECK_IN;
        }
    }
    /**
     * Schedule a reconnection attempt
     * @param deviceId Device identifier
     * @param attempt Current attempt number (default: 0)
     */
    scheduleReconnect(deviceId, attempt = 0) {
        // Calculate backoff time (exponential with max of 5 minutes)
        const backoffMs = Math.min(5000 * Math.pow(1.5, attempt), 300000);
        // Create new timer
        setTimeout(async () => {
            try {
                // Check if device exists in database before reconnecting
                const deviceInfo = await this.deviceRepository.findOne({ where: { deviceId } });
                if (!deviceInfo) {
                    this.logger.warn(`Device ${deviceId} no longer exists in database. Stopping reconnection attempts.`);
                    return;
                }
                // Try to reconnect
                await this.connectWithRetry({
                    ipAddress: deviceInfo.ipAddress,
                    port: deviceInfo.port,
                    deviceType: biometrics_device_type_enum_1.BiometricDeviceType.ANVIZ
                }, deviceId);
            }
            catch (error) {
                // If reconnection fails, schedule another attempt
                this.scheduleReconnect(deviceId, attempt + 1);
            }
        }, backoffMs);
        return attempt + 1;
    }
    /**
     * Verify device connection is still active and responsive
     * @param device Anviz device instance
     * @param deviceId Device identifier
     */
    verifyDeviceConnection(device, deviceId) {
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error(`Device ${deviceId} connection verification timeout`));
            }, 5000);
            try {
                device.getSerialNumber((serialNumber) => {
                    clearTimeout(timeoutId);
                    resolve();
                });
            }
            catch (error) {
                clearTimeout(timeoutId);
                reject(error);
            }
        });
    }
    /**
     * Disconnect from an Anviz device
     * @param deviceId Device identifier
     * @param isManual Whether this is a manual disconnect (if false, may trigger reconnection)
     * @returns Disconnected device information
     */
    async disconnect(deviceId, isManual = false) {
        const anvizDevice = this.connections.get(deviceId);
        if (anvizDevice) {
            // Clear heartbeat interval
            if (anvizDevice._heartbeatInterval) {
                clearInterval(anvizDevice._heartbeatInterval);
                anvizDevice._heartbeatInterval = null;
            }
            try {
                anvizDevice.disconnect();
            }
            catch (err) {
                const error = err;
                this.logger.warn(`Error during disconnect for device ${deviceId}: ${error.message}`);
            }
            // Remove from connections map
            this.connections.delete(deviceId);
        }
        // Clear command queue for device
        if (this.commandQueues.has(deviceId)) {
            const queue = this.commandQueues.get(deviceId);
            // Reject all pending commands
            for (const item of queue) {
                if (item.timeout)
                    clearTimeout(item.timeout);
                item.reject(new Error(`Device ${deviceId} disconnected during operation '${item.operation}'`));
            }
            this.commandQueues.delete(deviceId);
            this.processingQueues.delete(deviceId);
        }
        return await this.updateDeviceStatus(deviceId, !isManual, true);
    }
    getPunchMethod(value) {
        switch (value) {
            case 35:
                return punch_method_enum_1.PunchMethod.FINGERPRINT;
            case 19:
                return punch_method_enum_1.PunchMethod.FINGERPRINT;
            case 8:
                return punch_method_enum_1.PunchMethod.RFID;
            case 4:
                return punch_method_enum_1.PunchMethod.PASSWORD;
            default:
                return punch_method_enum_1.PunchMethod.UNKNOWN;
        }
    }
    /**
     * Get device information from Anviz device
     * @param deviceId Device identifier
     */
    getAnvizDeviceInfo(deviceId) {
        return new Promise((resolve, reject) => {
            const anvizDevice = this.getAnvizDevice(deviceId);
            // Get device information (DeviceInfo1 and DeviceInfo2)
            anvizDevice.getDeviceInfo1((deviceInfo1) => {
                anvizDevice.getDeviceInfo2((deviceInfo2) => {
                    // Get serial number
                    anvizDevice.getSerialNumber((serialNumber) => {
                        const info = {
                            serialNumber,
                            firmwareVersion: deviceInfo1.firmwareVersion,
                            deviceType: 'Anviz',
                            attendanceState: deviceInfo1.attendanceState,
                            language: deviceInfo1.language,
                            timeFormat: deviceInfo1.timeFormat,
                            dateFormat: deviceInfo1.dateFormat,
                            fingerprintPrecision: deviceInfo2.fingerprintPrecision,
                            workCodePermission: deviceInfo2.workCodePermission
                        };
                        resolve(info);
                    });
                });
            });
        });
    }
    /**
     * Get device information
     * @param deviceId Device identifier
     */
    async getDeviceInfo(deviceId) {
        try {
            this.checkDeviceConnection(deviceId);
            this.logger.log(`Getting device info for ${deviceId}`);
            const info = await this.getAnvizDeviceInfo(deviceId);
            // Update device in database with latest information
            await this.deviceRepository.update({ id: deviceId }, {
                serialNumber: info.serialNumber,
                firmware: info.firmwareVersion,
                lastSync: new Date()
            });
            return info;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting device info for ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get device info: ${errorMessage}`);
        }
    }
    /**
     * Get users from Anviz device
     * @param deviceId Device identifier
     */
    async getUsers(deviceId) {
        return this.queueCommand(deviceId, 'getUsers', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                this.logger.log(`Getting users from device ${deviceId}`);
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error('Get users operation timed out'));
                    }, 15000);
                    const anvizDevice = this.getAnvizDevice(deviceId);
                    anvizDevice.getUserInfos((userInfos) => {
                        clearTimeout(timeoutId);
                        try {
                            // Validate response
                            if (!Array.isArray(userInfos)) {
                                throw new Error('Invalid response format: expected array of users');
                            }
                            this.logger.log(`Retrieved ${userInfos.length} users from device ${deviceId}`);
                            // Convert Anviz user format to BiometricUserDto format with proper validation
                            const users = userInfos
                                .filter((user) => {
                                // Filter out invalid users
                                if (!user || typeof user.userId === 'undefined' || user.userId === null) {
                                    this.logger.warn(`Skipping invalid user entry from device ${deviceId}`);
                                    return false;
                                }
                                return true;
                            })
                                .map((user) => {
                                try {
                                    // Get enrolled fingerprints for this user
                                    const enrolledFingerprints = [];
                                    if (user.enrollFpState) {
                                        // Parse fingerprint enrollment state (bit mask)
                                        for (let i = 0; i < 10; i++) {
                                            if (user.enrollFpState & (1 << i)) {
                                                enrolledFingerprints.push(i + 1);
                                            }
                                        }
                                    }
                                    // Create BiometricUserDto object
                                    const userDto = new biometric_user_dto_1.BiometricUserDto();
                                    userDto.deviceId = deviceId;
                                    userDto.biometricUserId = user.userId;
                                    userDto.name = user.name || '';
                                    userDto.password = user.password ? user.password === 1048575 ? '' : user.password.toString() : '';
                                    userDto.cardNumber = user.card ? user.card === -1 ? '' : user.card : '';
                                    return userDto;
                                }
                                catch (conversionError) {
                                    this.logger.warn(`Error converting user ${user.userId} from device ${deviceId}: ${conversionError instanceof Error ? conversionError.message : String(conversionError)}`);
                                    // Return a basic user DTO for problematic entries
                                    const basicUserDto = new biometric_user_dto_1.BiometricUserDto();
                                    basicUserDto.deviceId = deviceId;
                                    basicUserDto.biometricUserId = user.userId;
                                    basicUserDto.name = user.name || 'Unknown';
                                    return basicUserDto;
                                }
                            });
                            // Log summary
                            const userSummary = users.reduce((acc, user) => {
                                acc.totalUsers++;
                                if (user.cardNumber) {
                                    acc.usersWithCards++;
                                }
                                return acc;
                            }, { totalUsers: 0, usersWithFingerprints: 0, usersWithCards: 0 });
                            this.logger.log(`Device ${deviceId} user summary: ${userSummary.totalUsers} total, ${userSummary.usersWithFingerprints} with fingerprints, ${userSummary.usersWithCards} with cards`);
                            resolve(users);
                        }
                        catch (error) {
                            reject(error);
                        }
                    });
                });
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error getting users from device ${deviceId}: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to get users: ${errorMessage}`);
            }
        });
    }
    /**
     * Get a specific user by ID from Anviz device
     * @param deviceId Device identifier
     * @param userId User ID to find
     */
    async getUserById(dto) {
        return this.queueCommand(dto.deviceId, 'getUserById', async () => {
            try {
                this.checkDeviceConnection(dto.deviceId);
                this.logger.log(`Getting user ${dto.biometricUserId} from device ${dto.deviceId}`);
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new common_1.RequestTimeoutException(`Get user ${dto.biometricUserId} operation timed out`));
                    }, 10000);
                    const anvizDevice = this.getAnvizDevice(dto.deviceId);
                    // Use getUserInfos to get all users and find the specific one
                    anvizDevice.getUserInfos((userInfos) => {
                        clearTimeout(timeoutId);
                        try {
                            // Validate response
                            if (!Array.isArray(userInfos)) {
                                throw new Error('Invalid response format: expected array of users');
                            }
                            this.logger.debug(`Retrieved ${userInfos.length} users from device ${dto.deviceId}, searching for user ${dto.biometricUserId}`);
                            // Find user with matching userId
                            const foundUser = userInfos.find((user) => {
                                // Handle potential type mismatches
                                const userIdToCheck = typeof user.userId === 'string' ?
                                    parseInt(user.userId) : user.userId;
                                return userIdToCheck === dto.biometricUserId;
                            });
                            if (!foundUser) {
                                this.logger.warn(`User ${dto.biometricUserId} not found on device ${dto.deviceId}`);
                                reject(new common_1.NotFoundException(`User ${dto.biometricUserId} not found on device ${dto.deviceId}`));
                                return;
                            }
                            // Validate found user data
                            if (!foundUser || typeof foundUser.userId === 'undefined' || foundUser.userId === null) {
                                this.logger.warn(`Invalid user data for user ${dto.biometricUserId} from device ${dto.deviceId}`);
                                reject(new base_biometrics_service_1.BiometricException(`Invalid user data for user ${dto.biometricUserId} from device ${dto.deviceId}`));
                                return;
                            }
                            try {
                                // Parse enrolled fingerprints
                                const enrolledFingerprints = [];
                                if (foundUser.enrollFpState) {
                                    // Parse fingerprint enrollment state (bit mask)
                                    for (let i = 0; i < 10; i++) {
                                        if (foundUser.enrollFpState & (1 << i)) {
                                            enrolledFingerprints.push(i + 1);
                                        }
                                    }
                                }
                                // Create BiometricUserDto object with proper validation
                                const userDto = new biometric_user_dto_1.BiometricUserDto();
                                userDto.deviceId = dto.deviceId;
                                userDto.biometricUserId = foundUser.userId;
                                userDto.name = foundUser.name || '';
                                // Handle password validation (Anviz returns 1048575 for empty passwords)
                                if (foundUser.password && foundUser.password !== 1048575) {
                                    userDto.password = foundUser.password;
                                }
                                // Handle card validation (Anviz returns -1 for no card)
                                if (foundUser.card && foundUser.card !== -1) {
                                    userDto.cardNumber = foundUser.card;
                                }
                                this.logger.log(`Found user ${dto.biometricUserId} on device ${dto.deviceId}: ${userDto.name} with ${enrolledFingerprints.length} enrolled fingerprints`);
                                // Log additional user details for debugging
                                this.logger.debug(`User ${dto.biometricUserId} details - Group: ${foundUser.group}, Department: ${foundUser.dpt}, Attendance Mode: ${foundUser.attendanceMode}`);
                                resolve(userDto);
                            }
                            catch (conversionError) {
                                // Return basic user object for problematic entries
                                const basicUserDto = new biometric_user_dto_1.BiometricUserDto();
                                basicUserDto.deviceId = dto.deviceId;
                                basicUserDto.biometricUserId = foundUser.userId;
                                basicUserDto.name = foundUser.name || 'Unknown';
                                resolve(basicUserDto);
                            }
                        }
                        catch (error) {
                            this.logger.error(`Error processing user data for user ${dto.biometricUserId} from device ${dto.deviceId}: ${error instanceof Error ? error.message : String(error)}`);
                            reject(new base_biometrics_service_1.BiometricException(`Failed to process user data: ${error instanceof Error ? error.message : String(error)}`));
                        }
                    });
                });
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error getting user ${dto.biometricUserId} from device ${dto.deviceId}: ${errorMessage}`);
                // Re-throw known exceptions
                if (error instanceof base_biometrics_service_1.BiometricException ||
                    error instanceof common_1.RequestTimeoutException ||
                    error instanceof common_1.NotFoundException ||
                    error instanceof common_1.ConflictException) {
                    throw error;
                }
                throw new base_biometrics_service_1.BiometricException(`Failed to get user: ${errorMessage}`);
            }
        });
    }
    /**
     * Get fingerprint template for a user
     * @param deviceId Device identifier
     * @param userId User ID
     * @param fingerId Finger ID (default: 1 for Anviz devices)
     */
    async getUserFingerprint(deviceId, userId, fingerId = 1) {
        try {
            this.checkDeviceConnection(deviceId);
            this.logger.log(`Getting fingerprint for user ${userId} (finger ${fingerId}) from device ${deviceId}`);
            // First check database for cached template
            try {
                const existingTemplate = await this.templateRepository.findOne({
                    where: {
                        userId,
                        fingerId,
                        provider: 'anviz'
                    }
                });
                if (existingTemplate && existingTemplate.template) {
                    this.logger.log(`Found existing template in database for user ${userId} (finger ${fingerId})`);
                    return {
                        id: `${userId}-${fingerId}`,
                        userId,
                        fingerId,
                        template: existingTemplate.template,
                        provider: 'anviz'
                    };
                }
            }
            catch (dbError) {
                this.logger.warn(`Database lookup failed: ${dbError instanceof Error ? dbError.message : String(dbError)}`);
            }
            return new Promise((resolve, reject) => {
                const anvizDevice = this.getAnvizDevice(deviceId);
                anvizDevice.getFpTemplate(parseInt(userId), fingerId, (templateData) => {
                    try {
                        if (!templateData || templateData.length === 0) {
                            resolve(null);
                            return;
                        }
                        // Create template object
                        const template = {
                            id: `${userId}-${fingerId}`,
                            userId,
                            fingerId,
                            template: Buffer.from(templateData),
                            provider: 'anviz'
                        };
                        // Cache template in database
                        this.templateRepository.save({
                            userId,
                            fingerId,
                            template: Buffer.isBuffer(template.template) ? template.template : Buffer.from(template.template),
                            provider: 'anviz'
                        }).catch(err => {
                            this.logger.warn(`Failed to cache template in database: ${err.message}`);
                        });
                        resolve(template);
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            });
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting fingerprint from device ${deviceId}: ${errorMessage}`);
            if (errorMessage.includes('not found') || errorMessage.includes('No Record')) {
                return null;
            }
            throw new base_biometrics_service_1.BiometricException(`Failed to get fingerprint: ${errorMessage}`);
        }
    }
    /**
     * Register a new user on Anviz device (only creates new users)
     * @param deviceId Device identifier
     * @param userData User data
     */
    async registerUser(deviceId, userData) {
        return this.queueCommand(deviceId, 'registerUser', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                this.logger.log(`Registering user ${userData.biometricUserId} on device ${deviceId}`);
                const anvizDevice = this.getAnvizDevice(deviceId);
                // Check if user already exists
                const existingUser = await new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error('Check existing user operation timed out'));
                    }, 10000);
                    anvizDevice.getUserInfos((userInfos) => {
                        clearTimeout(timeoutId);
                        try {
                            // Find user with matching userId
                            const foundUser = userInfos.find((user) => user.userId === userData.biometricUserId);
                            resolve(foundUser || null);
                        }
                        catch (error) {
                            reject(error);
                        }
                    });
                });
                if (existingUser) {
                    throw new common_1.ConflictException(`User ${userData.biometricUserId} already exists on device ${deviceId}.`);
                }
                // User doesn't exist, create new user
                this.logger.log(`Creating new user ${userData.biometricUserId} on device ${deviceId}`);
                const userInfo = new UserInfo();
                userInfo.userId = userData.biometricUserId;
                userInfo.name = userData.name;
                userInfo.password = userData.password;
                userInfo.card = userData.cardNumber;
                userInfo.group = 0;
                userInfo.dpt = 1; // Department (default: 1)
                userInfo.attendanceMode = 0; // Default mode
                userInfo.enrollFpState = 0;
                userInfo.keep = 0;
                userInfo.specialMessage = 0;
                // Create new user
                await new Promise((resolve, reject) => {
                    const originalHandleResponse = anvizDevice.handleResponse;
                    anvizDevice.handleResponse = (cmd, callback) => {
                        cmd.onResponse = (response) => {
                            try {
                                anvizDevice.handleResponse = originalHandleResponse;
                                if (response.command !== cmd.command) {
                                    reject(new Error(`Command mismatch: expected ${cmd.command}, got ${response.command}`));
                                    return;
                                }
                                if (response.returnValue !== 0) {
                                    reject(new Error(`ACK Error: ${response.returnValue}`));
                                    return;
                                }
                                resolve();
                            }
                            catch (error) {
                                reject(error);
                            }
                        };
                        anvizDevice.send(cmd);
                    };
                    try {
                        anvizDevice.setUserInfo(userInfo);
                    }
                    catch (error) {
                        anvizDevice.handleResponse = originalHandleResponse;
                        reject(error);
                    }
                });
                this.logger.log(`Successfully created new user ${userData.biometricUserId} on device ${deviceId}`);
                // Return standardized user object
                const createdUser = {
                    deviceId,
                    biometricUserId: userData.biometricUserId,
                    name: userData.name,
                    password: userData.password,
                    cardNumber: userData.cardNumber,
                };
                return createdUser;
            }
            catch (error) {
                this.logger.error(`Error registering user on device ${deviceId}: ${error.errorMessage}`);
                throw error;
            }
        });
    }
    /**
     * Update an existing user on Anviz device
     * @param deviceId Device identifier
     * @param userData User data
     */
    async updateUser(deviceId, userData) {
        return this.queueCommand(deviceId, 'updateUser', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                this.logger.log(`Updating user ${userData.biometricUserId} on device ${deviceId}`);
                const anvizDevice = this.getAnvizDevice(deviceId);
                // Check if user exists
                const existingUser = await new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error('Check existing user operation timed out'));
                    }, 10000);
                    anvizDevice.getUserInfos((userInfos) => {
                        clearTimeout(timeoutId);
                        try {
                            // Find user with matching userId
                            const foundUser = userInfos.find((user) => user.userId === userData.biometricUserId);
                            resolve(foundUser || null);
                        }
                        catch (error) {
                            reject(error);
                        }
                    });
                });
                if (!existingUser) {
                    throw new common_1.NotFoundException(`User ${userData.biometricUserId} does not exist on device ${deviceId}.`);
                }
                this.logger.log(`User ${userData.biometricUserId} exists on device ${deviceId}. Proceeding with update.`);
                // Update existing user, preserving existing fields when new values aren't provided
                const userInfo = new UserInfo();
                userInfo.userId = userData.biometricUserId;
                userInfo.name = userData.name;
                userInfo.password = userData.password || existingUser.password || 0;
                userInfo.card = userData.cardNumber || existingUser.card || 0;
                userInfo.group = existingUser.group || 0;
                userInfo.dpt = existingUser.dpt || 1;
                userInfo.attendanceMode = existingUser.attendanceMode || 0;
                userInfo.enrollFpState = existingUser.enrollFpState || 0;
                userInfo.keep = existingUser.keep || 0;
                userInfo.specialMessage = existingUser.specialMessage || 0;
                // Update the user
                await new Promise((resolve, reject) => {
                    const originalHandleResponse = anvizDevice.handleResponse;
                    anvizDevice.handleResponse = (cmd, callback) => {
                        cmd.onResponse = (response) => {
                            try {
                                anvizDevice.handleResponse = originalHandleResponse;
                                if (response.command !== cmd.command) {
                                    reject(new Error(`Command mismatch: expected ${cmd.command}, got ${response.command}`));
                                    return;
                                }
                                if (response.returnValue !== 0) {
                                    reject(new Error(`ACK Error: ${response.returnValue}`));
                                    return;
                                }
                                resolve();
                            }
                            catch (error) {
                                reject(error);
                            }
                        };
                        anvizDevice.send(cmd);
                    };
                    try {
                        anvizDevice.setUserInfo(userInfo);
                    }
                    catch (error) {
                        anvizDevice.handleResponse = originalHandleResponse;
                        reject(error);
                    }
                });
                this.logger.log(`Successfully updated user ${userData.biometricUserId} on device ${deviceId}`);
                // Return standardized user object
                const updatedUser = {
                    deviceId,
                    biometricUserId: userData.biometricUserId,
                    name: userData.name,
                    password: userData.password,
                    cardNumber: userData.cardNumber,
                };
                return updatedUser;
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error updating user on device ${deviceId}: ${errorMessage}`);
                throw error;
            }
        });
    }
    /**
     * Delete a user from Anviz device
     * @param deviceId Device identifier
     * @param userId User ID to delete
     */
    async deleteUser(deviceId, userId) {
        this.checkDeviceConnection(deviceId);
        this.logger.log(`Deleting user ${userId} from device ${deviceId}`);
        const anvizDevice = this.getAnvizDevice(deviceId);
        // Delete user
        anvizDevice.deleteUser(userId);
        return true;
    }
    /**
     * Get attendance records from Anviz device
     * @param deviceId Device identifier
     * @param startDate Start date for filtering (optional)
     * @param endDate End date for filtering (optional)
     */
    async getAttendanceRecords(deviceId, startDate, endDate) {
        try {
            this.checkDeviceConnection(deviceId);
            this.logger.log(`Getting attendance records from device ${deviceId}`);
            return new Promise((resolve, reject) => {
                const anvizDevice = this.getAnvizDevice(deviceId);
                // Get all records
                anvizDevice.getAllRecords((records) => {
                    try {
                        // Convert Anviz records to system format
                        let attendanceRecords = records.map((record) => {
                            const timestamp = new Date(record.dateTime);
                            // Filter by date if provided
                            if ((startDate && timestamp < startDate) ||
                                (endDate && timestamp > endDate)) {
                                return null;
                            }
                            return {
                                userId: record.userId.toString(),
                                timestamp: timestamp,
                                type: record.type || 0,
                                deviceId: deviceId,
                                status: record.workTypes ? record.workTypes[0] : 0
                            };
                        });
                        // Filter out null records (those outside date range)
                        attendanceRecords = attendanceRecords.filter(record => record !== null);
                        resolve(attendanceRecords);
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            });
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting attendance records from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get attendance records: ${errorMessage}`);
        }
    }
    /**
     * Get attendance records size
     * @param deviceId Device identifier
     */
    async getAttendanceSize(deviceId) {
        try {
            this.checkDeviceConnection(deviceId);
            return new Promise((resolve, reject) => {
                const anvizDevice = this.getAnvizDevice(deviceId);
                anvizDevice.getRecordInformation((info) => {
                    try {
                        resolve(info.allRecordAmount || 0);
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            });
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting attendance size from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get attendance size: ${errorMessage}`);
        }
    }
    /**
     * Clear attendance records from device
     * @param deviceId Device identifier
     */
    async clearAttendanceRecords(deviceId) {
        try {
            this.checkDeviceConnection(deviceId);
            this.logger.log(`Clearing attendance records from device ${deviceId}`);
            return new Promise((resolve, reject) => {
                const anvizDevice = this.getAnvizDevice(deviceId);
                anvizDevice.clearAllRecords((result) => {
                    try {
                        resolve(true);
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            });
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error clearing attendance records from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to clear attendance records: ${errorMessage}`);
        }
    }
    /**
     * Unlock door of Anviz device
     * @param deviceId Device identifier
     */
    async unlockDoor(deviceId) {
        try {
            this.checkDeviceConnection(deviceId);
            this.logger.log(`Unlocking door for device ${deviceId}`);
            const anvizDevice = this.getAnvizDevice(deviceId);
            anvizDevice.openLock();
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error unlocking door for device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to unlock door: ${errorMessage}`);
        }
    }
    /**
     * Get the Anviz device connection, throwing an exception if not connected
     * @param deviceId Device identifier
     */
    getAnvizDevice(deviceId) {
        const anvizDevice = this.connections.get(deviceId);
        if (!anvizDevice) {
            throw new base_biometrics_service_1.BiometricException(`Device ${deviceId} not connected`, common_1.HttpStatus.NOT_FOUND);
        }
        return anvizDevice;
    }
    /**
     * Check if device is connected
     * @param deviceId Device identifier
     */
    checkDeviceConnection(deviceId) {
        if (!this.connections.has(deviceId)) {
            throw new base_biometrics_service_1.BiometricException(`Device ${deviceId} not connected`, common_1.HttpStatus.NOT_FOUND);
        }
    }
    /**
     * Get device time
     * @param deviceId Device identifier
     */
    async getTime(deviceId) {
        return this.queueCommand(deviceId, 'getTime', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new common_1.RequestTimeoutException('Get time operation timed out'));
                    }, 5000);
                    const anvizDevice = this.getAnvizDevice(deviceId);
                    anvizDevice.getDateTime((date) => {
                        clearTimeout(timeoutId);
                        resolve(date);
                    });
                });
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error getting device time: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to get device time: ${errorMessage}`);
            }
        });
    }
    /**
     * Set device time
     * @param deviceId Device identifier
     * @param time Date to set
     */
    async setTime(deviceId, time) {
        return this.queueCommand(deviceId, 'setTime', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error('Set time operation timed out'));
                    }, 5000);
                    try {
                        const anvizDevice = this.getAnvizDevice(deviceId);
                        anvizDevice.setDateTime(time);
                        clearTimeout(timeoutId);
                        resolve(true);
                    }
                    catch (error) {
                        clearTimeout(timeoutId);
                        reject(error);
                    }
                });
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error setting device time: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to set device time: ${errorMessage}`);
            }
        });
    }
    /**
     * Get the firmware version from device
     * @param deviceId Device identifier
     */
    async getFirmwareVersion(deviceId) {
        return this.queueCommand(deviceId, 'getFirmwareVersion', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                const info = await this.getAnvizDeviceInfo(deviceId);
                return info.firmwareVersion || 'Unknown';
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error getting firmware version: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to get firmware version: ${errorMessage}`);
            }
        });
    }
    /**
     * Get the serial number from device
     * @param deviceId Device identifier
     */
    async getSerialNumber(deviceId) {
        return this.queueCommand(deviceId, 'getSerialNumber', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error('Get serial number operation timed out'));
                    }, 5000);
                    const anvizDevice = this.getAnvizDevice(deviceId);
                    anvizDevice.getSerialNumber((serialNumber) => {
                        clearTimeout(timeoutId);
                        resolve(serialNumber || 'Unknown');
                    });
                });
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error getting serial number: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to get serial number: ${errorMessage}`);
            }
        });
    }
    /**
     * Get device name - Not directly supported by Anviz, returns model name from device info
     * @param deviceId Device identifier
     */
    async getDeviceName(deviceId) {
        return this.queueCommand(deviceId, 'getDeviceName', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                // Anviz doesn't provide a direct method to get the device name, so we return the device type
                const info = await this.getAnvizDeviceInfo(deviceId);
                return info.deviceType || 'Anviz Device';
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error getting device name: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to get device name: ${errorMessage}`);
            }
        });
    }
    /**
     * Restart the Anviz device - Not directly supported by Anviz protocol
     * @param deviceId Device identifier
     */
    async restartDevice(deviceId) {
        return this.queueCommand(deviceId, 'restartDevice', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                // Anviz doesn't provide a direct method to restart the device
                // We'll simulate it by disconnecting and reconnecting
                const deviceInfo = await this.deviceRepository.findOne({ where: { deviceId } });
                if (!deviceInfo) {
                    throw new base_biometrics_service_1.BiometricException(`Device ${deviceId} not found in database`, common_1.HttpStatus.NOT_FOUND);
                }
                await this.disconnect(deviceId, true);
                // Wait a moment before reconnecting
                await new Promise(resolve => setTimeout(resolve, 2000));
                await this.connectWithRetry({
                    ipAddress: deviceInfo.ipAddress,
                    port: deviceInfo.port,
                    deviceType: biometrics_device_type_enum_1.BiometricDeviceType.ANVIZ
                }, deviceId);
                return true;
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error restarting device: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to restart device: ${errorMessage}`, common_1.HttpStatus.NOT_IMPLEMENTED);
            }
        });
    }
    /**
     * Get user details (enhanced user information)
     * @param deviceId Device identifier
     */
    async getUserDetails(deviceId) {
        // For Anviz devices, getUserDetails and getUsers return the same information
        return this.getUsers(deviceId);
    }
    /**
     * Enroll a user's fingerprint
     * Anviz devices don't support direct enrollment via API, must be done on the device
     * @param deviceId Device identifier
     * @param userId User ID
     * @param fingerId Finger ID
     */
    async enrollUser(deviceId, userId, fingerId) {
        throw new base_biometrics_service_1.BiometricException('Fingerprint enrollment via API is not supported by Anviz devices. Users must enroll fingerprints directly on the device.', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    /**
     * Verify fingerprint on device - Not directly supported by Anviz via API
     * @param deviceId Device identifier
     * @param template Template to verify
     */
    async verifyFingerprint(deviceId, template) {
        throw new base_biometrics_service_1.BiometricException('Fingerprint verification via API is not supported by Anviz devices', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    /**
     * Sync users from one device to another
     * @param sourceDeviceId Source device ID
     * @param targetDeviceId Target device ID
     */
    async syncUsers(sourceDeviceId, targetDeviceId) {
        return this.queueCommand(sourceDeviceId, `syncUsers-to-${targetDeviceId}`, async () => {
            try {
                this.checkDeviceConnection(sourceDeviceId);
                this.checkDeviceConnection(targetDeviceId);
                this.logger.log(`Syncing users from device ${sourceDeviceId} to device ${targetDeviceId}`);
                // Get users from source device
                const users = await this.getUsers(sourceDeviceId);
                // Create sync queue for target device
                let syncCount = 0;
                // Process each user
                for (const user of users) {
                    // try {
                    //     // Register user on target device
                    //     await this.registerUser(targetDeviceId, {
                    //         userId: user.userId,
                    //         name: user.name,
                    //         password: user.password,
                    //         cardNumber: user.cardNumber,
                    //     });
                    //     syncCount++;
                    // } catch (userError) {
                    //     const error = userError as Error;
                    //     this.logger.warn(`Error syncing user ${user.userId}: ${error.message}`);
                    //     // Continue with next user
                    // }
                }
                this.logger.log(`Successfully synced ${syncCount} users from ${sourceDeviceId} to ${targetDeviceId}`);
                return syncCount;
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error syncing users: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to sync users: ${errorMessage}`);
            }
        });
    }
    /**
     * Execute a custom command on the device
     * @param deviceId Device identifier
     * @param command Command to execute
     * @param data Additional data for the command
     */
    async executeCommand(deviceId, command, data) {
        return this.queueCommand(deviceId, `executeCommand-${command}`, async () => {
            try {
                this.checkDeviceConnection(deviceId);
                this.logger.log(`Executing custom command '${command}' on device ${deviceId}`);
                // Map command string to Anviz protocol command code
                const commandMap = {
                    'get_device_id': 0x74,
                    'set_device_id': 0x75,
                    'get_device_info1': 0x30,
                    'set_device_info1': 0x31,
                    'get_device_info2': 0x32,
                    'set_device_info2': 0x33,
                    'get_serial_number': 0x24,
                    'get_date_time': 0x38,
                    'set_date_time': 0x39,
                    'get_record_info': 0x3C,
                    'get_records': 0x40,
                    'clear_records': 0x4E,
                    'get_user_info': 0x72,
                    'set_user_info': 0x73,
                    'delete_user': 0x4C,
                    'get_fp_template': 0x44,
                    'set_fp_template': 0x45,
                    'open_lock': 0x5E
                };
                const commandCode = commandMap[command.toLowerCase()];
                if (!commandCode) {
                    throw new base_biometrics_service_1.BiometricException(`Unsupported command: ${command}`, common_1.HttpStatus.BAD_REQUEST);
                }
                // Convert data string to Buffer if provided
                let dataBuffer;
                if (data) {
                    try {
                        // Try to parse as JSON first
                        const jsonData = JSON.parse(data);
                        // Convert JSON to buffer (implementation depends on command)
                        // This is a simplified example
                        dataBuffer = Buffer.from(JSON.stringify(jsonData));
                    }
                    catch (_a) {
                        // If not JSON, treat as hex string
                        dataBuffer = Buffer.from(data, 'hex');
                    }
                }
                // Execute command (this is a simplified example)
                // In a real implementation, you would need to handle different commands differently
                throw new base_biometrics_service_1.BiometricException('Custom command execution is not fully implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error executing command: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to execute command: ${errorMessage}`);
            }
        });
    }
};
exports.AnvizBiometricsService = AnvizBiometricsService;
exports.AnvizBiometricsService = AnvizBiometricsService = AnvizBiometricsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(biometric_template_entity_1.BiometricTemplate)),
    __param(1, (0, typeorm_1.InjectRepository)(biometric_device_entity_1.BiometricDevice)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _c : Object, typeof (_d = typeof biometrics_gateway_1.BiometricsGateway !== "undefined" && biometrics_gateway_1.BiometricsGateway) === "function" ? _d : Object])
], AnvizBiometricsService);


/***/ }),

/***/ "./src/modules/biometrics/services/base-biometrics.service.ts":
/*!********************************************************************!*\
  !*** ./src/modules/biometrics/services/base-biometrics.service.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseBiometricsService = exports.BiometricException = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
/**
 * Base exception class for biometric-related errors
 */
class BiometricException extends common_1.HttpException {
    constructor(message, statusCode = common_1.HttpStatus.INTERNAL_SERVER_ERROR) {
        super(message, statusCode);
    }
}
exports.BiometricException = BiometricException;
/**
 * Abstract base class for all biometric service implementations
 * Provides common functionality and defines the interface that all biometric services must implement
 */
class BaseBiometricsService {
    constructor(deviceRepository, eventEmitter, biometricsGateway) {
        this.deviceRepository = deviceRepository;
        this.eventEmitter = eventEmitter;
        this.biometricsGateway = biometricsGateway;
        // Make logger protected so it can be inherited by derived classes
        this.logger = new common_1.Logger(this.constructor.name);
        this.connections = new Map();
        this.activeMonitoring = new Map();
        this.initializeFromDatabase();
    }
    /**
     * Load previously connected devices from database on service startup
     */
    async initializeFromDatabase() {
        try {
            const savedDevices = await this.deviceRepository.find({ where: { isConnected: true } });
            if (savedDevices.length > 0) {
                // Try to reconnect to devices in parallel
                await Promise.allSettled(savedDevices.map(device => 
                // convert device to ConnectDeviceDto using class transformer
                this.connect({
                    deviceId: device.deviceId,
                    ipAddress: device.ipAddress,
                    port: device.port,
                    deviceType: device.provider,
                }, device.createdBy)
                    .catch()));
            }
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Error initializing devices from database: ${errorMessage}`);
        }
    }
    emitAttendanceEvent(record) {
        try {
            this.eventEmitter.emit('biometric.attendance', record);
        }
        catch (error) {
            this.logger.error(`Error emitting attendance event: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Connect to a Biometric device
     * @param ipAddress Device IP address
     * @param port Device port
     * @returns Connected device information
     */
    async connect(dto, createdBy) {
        if (this.biometricDeviceType !== dto.deviceType) {
            throw new common_1.InternalServerErrorException(`Device type mismatch: expected ${this.biometricDeviceType}, got ${dto.deviceType}`);
        }
        const deviceId = this.generateDeviceId(dto.ipAddress, dto.port);
        // Create new connection with retry logic
        return await this.connectWithRetry(dto, deviceId, createdBy);
    }
    /**
   * Update device connection and online status in memory and database
   * @param deviceId Device identifier
   * @param isConnected Whether the device is connected
   * @param isOffline Whether the device is considered offline
   * @returns Updated device information
   */
    async updateDeviceStatus(deviceId, isConnected, isOffline) {
        // Find the device in the database
        let device = await this.deviceRepository.findOne({ where: { deviceId } });
        if (!device) {
            this.logger.warn(`Device ${deviceId} not found in database during status update`);
            throw new BiometricException(`Device ${deviceId} not found`, common_1.HttpStatus.NOT_FOUND);
        }
        // Update properties
        device.isConnected = isConnected;
        device.isOffline = isOffline;
        // Update lastSync for successful connections
        if (isConnected) {
            device.lastSync = new Date();
        }
        // Save to database
        device = await this.deviceRepository.save(device);
        this.biometricsGateway.pingAll();
        return device;
    }
    // Device information methods (optional with default implementation)
    async getDeviceInfo(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async getSerialNumber(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async getFirmwareVersion(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async getDeviceName(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async restartDevice(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    // Time management methods (optional)
    async getTime(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async setTime(deviceId, time) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    // User management methods (optional)
    async enrollUser(deviceId, userId, fingerId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async deleteUser(deviceId, userId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async verifyFingerprint(deviceId, template) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async getUsers(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async getUserById(dto) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async syncUsers(sourceDeviceId, targetDeviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    // Attendance management methods (optional)
    async getAttendanceRecords(deviceId, startDate, endDate) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async clearAttendanceRecords(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async getAttendanceSize(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    // Real-time monitoring methods (optional)
    startRealTimeMonitoring(deviceId, callback) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    stopRealTimeMonitoring(monitoringId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    // Door control (optional)
    async unlockDoor(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    // Command execution (optional)
    async executeCommand(deviceId, command, data) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    /**
     * Generate a unique device ID from IP address and port
     * @param ipAddress Device IP address
     * @param port Device port
     * @returns Unique device identifier
     */
    generateDeviceId(ipAddress, port) {
        return `${ipAddress}:${port}`;
    }
    /**
     * Safely handle errors by ensuring proper type conversion
     * @param error The error to process
     * @returns Standardized error message string
     */
    formatErrorMessage(error) {
        return error instanceof Error ? error.message : String(error);
    }
}
exports.BaseBiometricsService = BaseBiometricsService;


/***/ }),

/***/ "./src/modules/biometrics/services/biometric-devices.service.ts":
/*!**********************************************************************!*\
  !*** ./src/modules/biometrics/services/biometric-devices.service.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricDevicesService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const biometric_device_entity_1 = __webpack_require__(/*! ../entities/biometric-device.entity */ "./src/modules/biometrics/entities/biometric-device.entity.ts");
let BiometricDevicesService = class BiometricDevicesService extends base_service_1.BaseService {
    constructor(biometricDevicesRepository, usersService) {
        super(biometricDevicesRepository, usersService);
        this.biometricDevicesRepository = biometricDevicesRepository;
        this.usersService = usersService;
    }
};
exports.BiometricDevicesService = BiometricDevicesService;
exports.BiometricDevicesService = BiometricDevicesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(biometric_device_entity_1.BiometricDevice)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], BiometricDevicesService);


/***/ }),

/***/ "./src/modules/biometrics/services/biometrics-factory.service.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/biometrics/services/biometrics-factory.service.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricsFactoryService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const biometric_interface_1 = __webpack_require__(/*! ../interfaces/biometric.interface */ "./src/modules/biometrics/interfaces/biometric.interface.ts");
const biometric_devices_service_1 = __webpack_require__(/*! ./biometric-devices.service */ "./src/modules/biometrics/services/biometric-devices.service.ts");
let BiometricsFactoryService = class BiometricsFactoryService {
    constructor(zktecoService, anvizService, biometricDevicesService) {
        this.zktecoService = zktecoService;
        this.anvizService = anvizService;
        this.biometricDevicesService = biometricDevicesService;
    }
    /**
     * Get the appropriate biometric service based on device type
     * @param deviceType Type of biometric device (zkteco or anviz)
     */
    getService(deviceType) {
        switch (deviceType.toLowerCase()) {
            case 'anviz':
                return this.anvizService;
            case 'zkteco':
            default:
                return this.zktecoService;
        }
    }
    /**
     * Get the appropriate biometric service for an existing device
     * @param deviceId Device identifier
     */
    async getServiceByDeviceId(deviceId) {
        // Look up the device in the database
        const device = await this.biometricDevicesService.findOneByOrFail({ deviceId });
        // Return the appropriate service based on the provider
        return this.getService(device.provider);
    }
};
exports.BiometricsFactoryService = BiometricsFactoryService;
exports.BiometricsFactoryService = BiometricsFactoryService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)('ZKTECO_SERVICE')),
    __param(1, (0, common_1.Inject)('ANVIZ_SERVICE')),
    __metadata("design:paramtypes", [typeof (_a = typeof biometric_interface_1.IBiometricService !== "undefined" && biometric_interface_1.IBiometricService) === "function" ? _a : Object, typeof (_b = typeof biometric_interface_1.IBiometricService !== "undefined" && biometric_interface_1.IBiometricService) === "function" ? _b : Object, typeof (_c = typeof biometric_devices_service_1.BiometricDevicesService !== "undefined" && biometric_devices_service_1.BiometricDevicesService) === "function" ? _c : Object])
], BiometricsFactoryService);


/***/ }),

/***/ "./src/modules/biometrics/services/biometrics-polling.service.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/biometrics/services/biometrics-polling.service.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var BiometricsPollingService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricsPollingService = void 0;
const biometrics_device_type_enum_1 = __webpack_require__(/*! @/common/enums/biometrics-device-type.enum */ "./src/common/enums/biometrics-device-type.enum.ts");
const punch_method_enum_1 = __webpack_require__(/*! @/common/enums/punch-method.enum */ "./src/common/enums/punch-method.enum.ts");
const attendance_event_1 = __webpack_require__(/*! @/common/events/attendance.event */ "./src/common/events/attendance.event.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
let BiometricsPollingService = BiometricsPollingService_1 = class BiometricsPollingService {
    constructor(configService, eventEmitter) {
        this.configService = configService;
        this.eventEmitter = eventEmitter;
        this.logger = new common_1.Logger(BiometricsPollingService_1.name);
        this.devicePollers = new Map();
        this.connections = new Map();
        this.recordCache = new Set();
    }
    // Lifecycle hooks
    onModuleInit() {
        // this.logger.log('Biometric polling service initialized');
    }
    onModuleDestroy() {
        this.stopAllPolling();
    }
    // Provide a way to register device connections
    registerDeviceConnection(deviceId, device) {
        this.connections.set(deviceId, device);
        // this.logger.log(`Registered device ${deviceId} for polling`);
    }
    // Start polling for a specific device
    startPolling(deviceId) {
        const device = this.connections.get(deviceId);
        if (!device) {
            this.logger.warn(`Cannot start polling for device ${deviceId}: Device not registered`);
            return false;
        }
        // Check if already polling
        if (this.devicePollers.has(deviceId)) {
            this.logger.warn(`Already polling device ${deviceId}`);
            return true;
        }
        const pollingInterval = this.configService.get('BIOMETRIC_DEVICE_POLLING_INTERVAL', 1000);
        // let lastAttendanceCount = 0;
        let lastCheckedTime = new Date();
        // Start the interval for polling
        const intervalId = setInterval(async () => {
            if (!this.connections.has(deviceId)) {
                // log 
                this.logger.warn(`Device ${deviceId} not registered, stopping polling`);
                this.stopPolling(deviceId);
                return;
            }
            try {
                // Get current attendance size
                const currentCount = await device.getAttendanceSize();
                // If there are new records
                if (currentCount > 0) {
                    // Get all attendance records - returns { data: records, err: error }
                    const response = await device.getAttendances();
                    // Extract the records array from the response
                    const records = response.data || [];
                    // Filter new records and use a cache to prevent duplicates
                    const filteredRecords = records.filter((record) => {
                        // Basic validation
                        const hasValidUserId = record.user_id !== undefined &&
                            record.user_id !== null &&
                            record.user_id.trim() !== ''; // Check after trimming
                        if (!hasValidUserId)
                            return false;
                        // Year validation
                        const recordTime = new Date(record.record_time);
                        const recordYear = recordTime.getFullYear();
                        const currentYear = new Date().getFullYear();
                        const isReasonableYear = Math.abs(recordYear - currentYear) <= 5;
                        if (!isReasonableYear)
                            return false;
                        // Create a unique key to detect duplicates
                        const cacheKey = `${record.user_id}-${record.record_time}-${record.type || 0}`;
                        // Skip if we've seen this record before
                        if (this.recordCache.has(cacheKey)) {
                            return false;
                        }
                        // Add to cache and accept the record
                        this.recordCache.add(cacheKey);
                        // Limit cache size to prevent memory leaks
                        if (this.recordCache.size > 10000) {
                            // Remove oldest entries (converting to array first)
                            const cacheArray = Array.from(this.recordCache);
                            this.recordCache = new Set(cacheArray.slice(-5000));
                        }
                        return true;
                    });
                    if (filteredRecords.length > 0) {
                        this.logger.log(`[${deviceId}] Processing ${filteredRecords.length} new attendance records`);
                        let attendances = [];
                        // Process each new record
                        filteredRecords.forEach((record) => {
                            // Standardize record format
                            const standardizedRecord = {
                                userId: record.user_id.trim(), // Trim any whitespace
                                timestamp: new Date(record.record_time || Date.now()),
                                deviceId: deviceId,
                                punchMethod: this.getPunchMethod(record.status || 0, device.provider),
                                punchType: record.type, // Default to 0 if not provided
                            };
                            // Add to the attendance list
                            attendances.push(standardizedRecord);
                        });
                        // Emit event for new records
                        this.eventEmitter.emit(attendance_event_1.ATTENDANCE_EVENTS.ATTENDANCE_RECORDED, new attendance_event_1.AttendanceRecordedEvent(attendances, deviceId));
                    }
                    // Update counters
                    // lastAttendanceCount = currentCount;
                }
                // Update timestamp
                lastCheckedTime = new Date();
            }
            catch (error) {
                this.logger.error(`Polling error for ${deviceId}: ${error instanceof Error
                    ? JSON.stringify(Object.assign({}, error, { message: error.message, stack: error.stack }))
                    : JSON.stringify(error)}`);
            }
        }, pollingInterval);
        // Store interval info to clean up later
        this.devicePollers.set(deviceId, {
            intervalId: intervalId,
            lastCheckedTime,
        });
        this.logger.log(`Started polling for device ${deviceId} at ${pollingInterval}ms intervals`);
        return true;
    }
    getPunchMethod(value, deviceType) {
        if (deviceType === biometrics_device_type_enum_1.BiometricDeviceType.ZKTECO) {
            switch (value) {
                case 0:
                    return punch_method_enum_1.PunchMethod.FINGERPRINT;
                default:
                    return punch_method_enum_1.PunchMethod.UNKNOWN;
            }
        }
        else {
            return punch_method_enum_1.PunchMethod.UNKNOWN;
        }
    }
    // Stop polling for a specific device
    stopPolling(deviceId) {
        const poller = this.devicePollers.get(deviceId);
        if (!poller) {
            return false;
        }
        clearInterval(poller.intervalId);
        this.devicePollers.delete(deviceId);
        this.logger.log(`Stopped polling for device ${deviceId}`);
        return true;
    }
    // Stop all polling
    stopAllPolling() {
        this.logger.log(`Stopping all device polling (${this.devicePollers.size} active)`);
        for (const [deviceId, poller] of this.devicePollers.entries()) {
            clearInterval(poller.intervalId);
            this.logger.log(`Stopped polling for device ${deviceId}`);
        }
        this.devicePollers.clear();
    }
};
exports.BiometricsPollingService = BiometricsPollingService;
exports.BiometricsPollingService = BiometricsPollingService = BiometricsPollingService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object, typeof (_b = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _b : Object])
], BiometricsPollingService);


/***/ }),

/***/ "./src/modules/biometrics/services/zkteco-biometrics.service.ts":
/*!**********************************************************************!*\
  !*** ./src/modules/biometrics/services/zkteco-biometrics.service.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZKTecoBiometricsService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const ZKLib = __webpack_require__(/*! zkteco-js */ "zkteco-js");
const biometrics_device_type_enum_1 = __webpack_require__(/*! @/common/enums/biometrics-device-type.enum */ "./src/common/enums/biometrics-device-type.enum.ts");
const punch_method_enum_1 = __webpack_require__(/*! @/common/enums/punch-method.enum */ "./src/common/enums/punch-method.enum.ts");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const biometric_device_entity_1 = __webpack_require__(/*! ../entities/biometric-device.entity */ "./src/modules/biometrics/entities/biometric-device.entity.ts");
const biometric_template_entity_1 = __webpack_require__(/*! ../entities/biometric-template.entity */ "./src/modules/biometrics/entities/biometric-template.entity.ts");
const biometrics_gateway_1 = __webpack_require__(/*! ../gateways/biometrics.gateway */ "./src/modules/biometrics/gateways/biometrics.gateway.ts");
const base_biometrics_service_1 = __webpack_require__(/*! ./base-biometrics.service */ "./src/modules/biometrics/services/base-biometrics.service.ts");
const biometrics_polling_service_1 = __webpack_require__(/*! ./biometrics-polling.service */ "./src/modules/biometrics/services/biometrics-polling.service.ts");
/**
 * ZKTeco implementation of the biometric service
 * Handles communication with ZKTeco biometric devices
 */
let ZKTecoBiometricsService = class ZKTecoBiometricsService extends base_biometrics_service_1.BaseBiometricsService {
    updateUser(deviceId, userData) {
        throw new Error('Method not implemented.');
    }
    registerUser(deviceId, userData) {
        throw new Error('Method not implemented.');
    }
    constructor(configService, deviceRepository, biometricsPollingService, templateRepository, eventEmitter, biometricsGateway) {
        super(deviceRepository, eventEmitter, biometricsGateway);
        this.configService = configService;
        this.deviceRepository = deviceRepository;
        this.biometricsPollingService = biometricsPollingService;
        this.templateRepository = templateRepository;
        this.eventEmitter = eventEmitter;
        this.biometricsGateway = biometricsGateway;
        this.biometricDeviceType = biometrics_device_type_enum_1.BiometricDeviceType.ZKTECO;
        // Listen for attendance events from polling service
        this.eventEmitter.on('attendance.recorded', (record) => {
            this.emitAttendanceEvent(record);
            // Call any registered callback
            const monitorInfo = this.activeMonitoring.get(record.deviceId);
            if (monitorInfo && typeof monitorInfo.callback === 'function') {
                monitorInfo.callback(record);
            }
        });
    }
    // /**
    //  * Register a new user on the ZKTeco device without fingerprint enrollment
    //  * @param deviceId Device identifier
    //  * @param userData User data to register
    //  * @returns Created user information
    //  */
    // async registerUser(
    //     deviceId: string, 
    //     userData: BiometricUserDto
    // ): Promise<BiometricUserDto> {
    //     const zkDevice = this.getConnectedDevice(deviceId);
    //     try {
    //         this.logger.log(`Registering user ${userData.userId} on device ${deviceId}`);
    //         // Convert userId to numeric ID if possible, or use a default
    //         const uid = parseInt(userData.userId) || Math.floor(Math.random() * 9000) + 1000;
    //         // Prepare parameters with defaults
    //         const name = userData.name || `User ${userData.userId}`;
    //         const password = userData.password || '';
    //         const cardno = userData.cardNumber ? parseInt(userData.cardNumber) : 0;
    //         // Validate input parameters
    //         if (uid <= 0 || uid > 65535) {
    //             throw new Error('User ID must be a positive integer less than 65535');
    //         }
    //         if (name.length > 24) {
    //             throw new Error('Name must be less than 24 characters');
    //         }
    //         if (password.length > 8) {
    //             throw new Error('Password must be less than 8 characters');
    //         }
    //         // Create/update the user on the device
    //         await zkDevice.setUser(uid, userData.userId, name, password, cardno);
    //         // Create a standardized user object to return
    //         const createdUser: IBiometricUser = {
    //             userId: userData.userId,
    //             name: name,
    //             password: password,
    //             cardNumber: cardno.toString(),
    //         };
    //         this.logger.log(`Successfully registered user ${userData.userId} on device ${deviceId}`);
    //         return createdUser;
    //     } catch (error) {
    //         // log error object as json
    //         this.logger.error(`Error registering user on device ${deviceId}: ${JSON.stringify(error)}`);
    //         const errorMessage = error instanceof Error ? error.message : String(error);
    //         this.logger.error(`Error registering user on device ${deviceId}: ${errorMessage}`);
    //         throw new BiometricException(`Failed to register user: ${errorMessage}`, HttpStatus.BAD_REQUEST);
    //     }
    // }
    /**
     * Get fingerprint template for a specific user and finger
     * @param deviceId Device identifier
     * @param userId User ID
     * @param fingerId Finger ID (0-9)
     * @returns Fingerprint template data
     */
    async getUserFingerprint(deviceId, userId, fingerId = 0) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Retrieving fingerprint template for user ${userId} (finger ${fingerId}) from device ${deviceId}`);
            // First check database for existing template
            try {
                const existingTemplate = await this.templateRepository.findOne({
                    where: {
                        userId,
                        fingerId,
                        provider: 'zkteco'
                    }
                });
                if (existingTemplate && existingTemplate.template) {
                    this.logger.log(`Found existing template in database for user ${userId} (finger ${fingerId})`);
                    return {
                        id: `${userId}-${fingerId}`,
                        userId,
                        fingerId,
                        template: existingTemplate.template,
                        provider: 'zkteco'
                    };
                }
            }
            catch (dbError) {
                this.logger.warn(`Database lookup failed: ${dbError instanceof Error ? dbError.message : String(dbError)}`);
            }
            // Convert userId to numeric ID if it's a number
            const uid = parseInt(userId) || Number(userId);
            if (isNaN(uid)) {
                throw new Error(`Invalid user ID format: ${userId}`);
            }
            // Create data buffer for the command
            const cmdData = Buffer.alloc(8);
            cmdData.writeUInt32LE(uid, 0); // User ID in little-endian format
            cmdData.writeUInt32LE(fingerId, 4); // Finger ID in little-endian format
            // Check if executeCmd is available
            if (typeof zkDevice.executeCmd !== 'function') {
                throw new Error('Device does not support the required commands');
            }
            // Clear any pending data
            try {
                await zkDevice.freeData();
            }
            catch (err) {
                this.logger.warn(`Could not free data buffer: ${err instanceof Error ? err.message : String(err)}`);
            }
            // Proper device state management
            await zkDevice.disableDevice();
            await zkDevice.enableDevice();
            // Add a small delay to ensure device is ready
            await new Promise(resolve => setTimeout(resolve, 200));
            // Execute the command to get the fingerprint template
            // CMD_USERTEMP_RRQ = 9 (0x0009)
            const result = await zkDevice.executeCmd('CMD_USERTEMP_RRQ', cmdData);
            // Log raw result for debugging
            this.logger.debug(`Raw result from device: length=${(result === null || result === void 0 ? void 0 : result.length) || 0}, first bytes: ${result ? result.slice(0, 20).toString('hex') : 'null'}`);
            // Check if we got a valid response
            if (!result || result.length < 12) {
                this.logger.warn(`No fingerprint template found for user ${userId} (finger ${fingerId})`);
                return null;
            }
            // Parse the result according to ZKTeco protocol
            const templateData = result.subarray(12);
            if (templateData.length === 0) {
                this.logger.warn(`Empty template data for user ${userId} (finger ${fingerId})`);
                return null;
            }
            this.logger.debug(`Retrieved fingerprint template for user ${userId} (finger ${fingerId}): ${templateData.length} bytes`);
            // Create a standardized template object
            const template = {
                id: `${userId}-${fingerId}`,
                userId,
                fingerId,
                template: templateData,
                provider: 'zkteco'
            };
            // Optionally save the template to database
            try {
                await this.templateRepository.save({
                    userId,
                    fingerId,
                    template: templateData,
                    provider: 'zkteco'
                });
                this.logger.debug(`Saved fingerprint template for user ${userId} (finger ${fingerId}) to database`);
            }
            catch (dbError) {
                this.logger.warn(`Could not save template to database: ${dbError instanceof Error ? dbError.message : String(dbError)}`);
                // Continue even if database save fails
            }
            return template;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error retrieving fingerprint template from device ${deviceId}: ${errorMessage}`);
            // Check if it's a "template not exist" error, which should return null instead of throwing
            if (errorMessage.includes('not exist') || errorMessage.includes('No Record')) {
                this.logger.warn(`No fingerprint template exists for user ${userId} (finger ${fingerId})`);
                return null;
            }
            throw new base_biometrics_service_1.BiometricException(`Failed to get fingerprint template: ${errorMessage}`);
        }
    }
    /**
     * Connect to a device with retry logic
     * @param deviceId Device identifier
     * @param ipAddress Device IP address
     * @param port Device port
     * @returns Connected device information
     */
    async connectWithRetry(dto, deviceId) {
        const timeout = this.configService.get('ZKTECO_TIMEOUT', 5000);
        const retryAttempts = this.configService.get('ZKTECO_RETRY_ATTEMPTS', 3);
        const retryDelay = this.configService.get('ZKTECO_RETRY_DELAY', 1000);
        const { ipAddress, port } = dto;
        let attempts = 0;
        let lastError = new Error('No connection attempts made');
        while (attempts < retryAttempts) {
            try {
                attempts++;
                this.logger.log(`Connecting to device ${deviceId} (attempt ${attempts}/${retryAttempts})`);
                // Create ZK instance with parameters, not options object
                // According to the example: new ZKLib(host, port, timeout, retry)
                const zk = new ZKLib(ipAddress, port, timeout, retryDelay);
                // Create socket connection first (as per example)
                await zk.createSocket();
                // Collect comprehensive device information
                let deviceInfo = await zk.getInfo();
                // Try to get additional device information
                try {
                    const serialNumber = await zk.getSerialNumber();
                    const firmware = await zk.getFirmware();
                    const platform = await zk.getPlatform();
                    const deviceName = await zk.getDeviceName();
                    const deviceVersion = await zk.getDeviceVersion();
                    const os = await zk.getOS();
                    // Enhance device info with additional details
                    deviceInfo = Object.assign(Object.assign({}, deviceInfo), { serialNumber: serialNumber || (deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.serialNumber), firmware: firmware || (deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.firmware), platform: platform || (deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.platform), deviceName: deviceName, deviceVersion: deviceVersion, os: os });
                }
                catch (infoError) {
                    this.logger.warn(`Could not retrieve comprehensive device info: ${infoError instanceof Error ? infoError.message : String(infoError)}`);
                }
                // Store connection
                this.connections.set(deviceId, zk);
                // Create device object with enhanced info
                const device = {
                    deviceId,
                    ipAddress,
                    port,
                    provider: this.biometricDeviceType,
                    model: (deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.deviceName) || (deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.model) || 'Unknown',
                    serialNumber: (deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.serialNumber) || 'Unknown',
                    firmware: deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.firmware,
                    platform: deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.platform,
                    deviceVersion: deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.deviceVersion,
                    os: deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.os,
                    isConnected: true,
                };
                // Store in database
                const save = await this.deviceRepository.save(device);
                // Register the connection with the polling service
                this.biometricsPollingService.registerDeviceConnection(deviceId, zk);
                // Start polling instead of direct setup
                this.biometricsPollingService.startPolling(deviceId);
                this.logger.log(`Successfully connected to ZKTeco device at ${ipAddress}:${port}`);
                return save;
            }
            catch (error) {
                // Ensure error is properly typed
                this.logger.warn(`Connection attempt ${attempts} to device ${deviceId}`);
                // If we have retries left, wait before trying again
                if (attempts < retryAttempts) {
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                }
            }
        }
        // If we get here, all connection attempts failed
        this.logger.error(`Failed to connect to ZKTeco device after ${attempts} attempts: ${lastError.message}`);
        throw new base_biometrics_service_1.BiometricException(`Failed to connect to device: ${lastError.message}`, common_1.HttpStatus.SERVICE_UNAVAILABLE);
    }
    async disconnect(deviceId, isManual = true) {
        // Stop the polling first
        this.biometricsPollingService.stopPolling(deviceId);
        const zkDevice = this.connections.get(deviceId);
        if (!zkDevice) {
            throw new common_1.BadRequestException(`Device ${deviceId} not connected`);
        }
        // Clear monitoring first
        this.activeMonitoring.delete(deviceId);
        ~
        // Use disconnect method
        await zkDevice.disconnect();
        this.connections.delete(deviceId);
        return await this.updateDeviceStatus(deviceId, false, isManual ? false : true);
    }
    /**
     * Get connected device by ID, throwing an exception if not found
     * @param deviceId Device identifier
     * @returns ZK device instance
     */
    getConnectedDevice(deviceId) {
        const zkDevice = this.connections.get(deviceId);
        if (!zkDevice) {
            throw new base_biometrics_service_1.BiometricException(`Device ${deviceId} not connected or not found`, common_1.HttpStatus.NOT_FOUND);
        }
        return zkDevice;
    }
    /**
     * Get device information
     * @param deviceId Device identifier
     * @returns Device information
     */
    async getDeviceInfo(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const info = await zkDevice.getInfo();
            this.logger.debug(`Retrieved device info for ${deviceId}: ${JSON.stringify(info)}`);
            return info;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting device info from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get device info: ${errorMessage}`);
        }
    }
    /**
     * Get device serial number
     * @param deviceId Device identifier
     * @returns Device serial number
     */
    async getSerialNumber(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const serialNumber = await zkDevice.getSerialNumber();
            this.logger.debug(`Retrieved serial number for ${deviceId}: ${serialNumber}`);
            return serialNumber;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting serial number from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get serial number: ${errorMessage}`);
        }
    }
    /**
     * Get firmware version
     * @param deviceId Device identifier
     * @returns Firmware version
     */
    async getFirmwareVersion(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const firmware = await zkDevice.getFaceOn();
            this.logger.debug(`Retrieved firmware version for ${deviceId}: ${firmware}`);
            return firmware;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting firmware version from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get firmware version: ${errorMessage}`);
        }
    }
    /**
     * Get device platform
     * @param deviceId Device identifier
     * @returns Platform information
     */
    async getPlatform(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const platform = await zkDevice.getPlatform();
            this.logger.debug(`Retrieved platform info for ${deviceId}: ${platform}`);
            return platform;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting platform info from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get platform info: ${errorMessage}`);
        }
    }
    /**
     * Get device name
     * @param deviceId Device identifier
     * @returns Device name
     */
    async getDeviceName(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const name = await zkDevice.getDeviceName();
            this.logger.debug(`Retrieved device name for ${deviceId}: ${name}`);
            return name;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting device name from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get device name: ${errorMessage}`);
        }
    }
    /**
     * Get device OS version
     * @param deviceId Device identifier
     * @returns OS version
     */
    async getOS(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const os = await zkDevice.getOS();
            this.logger.debug(`Retrieved OS info for ${deviceId}: ${os}`);
            return os;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting OS info from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get OS info: ${errorMessage}`);
        }
    }
    /**
     * Get device version
     * @param deviceId Device identifier
     * @returns Device version
     */
    async getDeviceVersion(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const version = await zkDevice.getDeviceVersion();
            this.logger.debug(`Retrieved device version for ${deviceId}: ${version}`);
            return version;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting device version from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get device version: ${errorMessage}`);
        }
    }
    /**
     * Get device PIN
     * @param deviceId Device identifier
     * @returns Device PIN
     */
    async getPIN(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const pin = await zkDevice.getPIN();
            this.logger.debug(`Retrieved PIN for ${deviceId}: ${pin}`);
            return pin;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting PIN from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get PIN: ${errorMessage}`);
        }
    }
    /**
     * Check if face recognition is enabled
     * @param deviceId Device identifier
     * @returns True if face recognition is enabled
     */
    async getFaceOn(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const faceOn = await zkDevice.getFaceOn();
            this.logger.debug(`Retrieved face recognition status for ${deviceId}: ${faceOn}`);
            return faceOn;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting face recognition status from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get face recognition status: ${errorMessage}`);
        }
    }
    /**
     * Get Self-Service-Recorder status
     * @param deviceId Device identifier
     * @returns SSR status
     */
    async getSSR(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const ssr = await zkDevice.getSSR();
            this.logger.debug(`Retrieved SSR status for ${deviceId}: ${JSON.stringify(ssr)}`);
            return ssr;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting SSR status from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get SSR status: ${errorMessage}`);
        }
    }
    /**
     * Get device time
     * @param deviceId Device identifier
     * @returns Current device time
     */
    async getTime(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const time = await zkDevice.getTime();
            this.logger.debug(`Retrieved time for ${deviceId}: ${time}`);
            return time;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting time from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get time: ${errorMessage}`);
        }
    }
    /**
     * Set device time
     * @param deviceId Device identifier
     * @param time Date to set
     * @returns Success indicator
     */
    async setTime(deviceId, time) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            await zkDevice.setTime(time);
            this.logger.debug(`Set time for ${deviceId} to ${time}`);
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error setting time for ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to set time: ${errorMessage}`);
        }
    }
    /**
     * Get work code from device
     * @param deviceId Device identifier
     * @returns Work code
     */
    async getWorkCode(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const workCode = await zkDevice.getWorkCode();
            this.logger.debug(`Retrieved work code for ${deviceId}: ${workCode}`);
            return workCode;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting work code from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get work code: ${errorMessage}`);
        }
    }
    /**
     * Get attendance log size
     * @param deviceId Device identifier
     * @returns Attendance log size
     */
    async getAttendanceSize(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const size = await zkDevice.getAttendanceSize();
            this.logger.debug(`Retrieved attendance size for ${deviceId}: ${size}`);
            return size;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting attendance size from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get attendance size: ${errorMessage}`);
        }
    }
    /**
     * Get users from a device
     * @param deviceId Device identifier
     * @returns Array of user IDs
     */
    async getUsers(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Getting users from device ${deviceId}`);
            const response = await zkDevice.getUsers();
            // Extract the data array from the response object
            const users = response && response.data && Array.isArray(response.data)
                ? response.data
                : [];
            if (users.length === 0) {
                return [];
            }
            // Extract essential information for each user
            const userInfo = users.map((user) => {
                var _a;
                return ({
                    userId: user.userId || user.id || '',
                    name: user.name || '',
                    password: user.password || '',
                    role: user.role || 0,
                    uid: user.uid || parseInt(user.userId) || 0,
                    cardNumber: ((_a = user.cardno) === null || _a === void 0 ? void 0 : _a.toString()) || ''
                });
            }).filter((user) => user.userId && user.role <= 14);
            this.logger.log(`Found ${userInfo.length} users on device ${deviceId}`);
            return userInfo;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting users from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get users: ${errorMessage}`);
        }
    }
    /**
     * Delete a user from the device with specific ZKTeco protocol implementation
     * @param deviceId Device identifier
     * @param userId User ID to delete
     * @returns True if deleted successfully
     */
    async deleteUser(deviceId, userId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Deleting user ${userId} from device ${deviceId}`);
            // Convert userId to numeric ID
            const uid = userId;
            // Validate input parameter
            if (isNaN(uid) || uid <= 0 || uid > 65535) {
                throw new Error('Invalid user ID: must be a positive number less than 65535');
            }
            // Clear any pending data
            try {
                await zkDevice.freeData();
            }
            catch (err) {
                this.logger.warn(`Could not free data buffer: ${err instanceof Error ? err.message : String(err)}`);
            }
            if (typeof zkDevice.deleteUser === 'function') {
                const response = await zkDevice.deleteUser(uid);
                // Check the response for success
                const success = response && response.length > 0;
                // After successful deletion from device, also remove templates from database
                if (success) {
                    try {
                        // const deleteResult = await this.templateRepository.delete({
                        //     userId: userId,
                        //     provider: 'zkteco'
                        // });
                        // this.logger.debug(`Deleted ${deleteResult.affected || 0} templates from database for user ${userId}`);
                    }
                    catch (dbError) {
                        this.logger.warn(`Failed to delete templates from database: ${dbError instanceof Error ? dbError.message : String(dbError)}`);
                        // Continue even if database deletion fails
                    }
                }
                this.logger.log(`User ${userId} deletion ${success ? 'successful' : 'failed'}`);
                return success;
            }
            else {
                throw new Error('Device does not support direct user deletion through this library');
            }
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error deleting user ${userId} from device ${deviceId}: ${errorMessage}`);
            // If the user doesn't exist, consider it a success
            if (errorMessage.includes('not found') || errorMessage.includes('does not exist')) {
                this.logger.warn(`User ${userId} not found on device ${deviceId}, considering deletion successful`);
                return true;
            }
            throw new base_biometrics_service_1.BiometricException(`Failed to delete user: ${errorMessage}`);
        }
    }
    /**
     * Enroll a user's fingerprint
     * @param deviceId Device identifier
     * @param userId User ID
     * @param fingerId Finger ID (0-9)
     * @returns Biometric template
     */
    async enrollUser(deviceId, userId, fingerId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Enrolling fingerprint for user ${userId} (finger ${fingerId}) on device ${deviceId}`);
            // First create or ensure the user exists
            // Convert userId to numeric if possible, or use a default
            const uid = parseInt(userId) || 1;
            const name = `User ${userId}`; // Default name if not provided
            // // Create/update the user first
            // await this.setUser(deviceId, uid, userId, name);
            // Start enrollment mode using executeCmd
            // According to ZKTeco protocol, CMD_STARTENROLL (61 or 0x3d) initiates enrollment
            const enrollData = Buffer.alloc(24);
            enrollData.writeUInt32LE(uid, 0); // User ID
            enrollData.writeUInt32LE(fingerId, 4); // Finger index (0-9)
            enrollData.writeUInt32LE(1, 8); // Flag (1 = valid)
            this.logger.log(`Starting enrollment process for user ${userId} (finger ${fingerId})`);
            // Use executeCmd to start enrollment if available
            let templateData;
            if (typeof zkDevice.executeCmd === 'function') {
                const result = await zkDevice.executeCmd('CMD_STARTENROLL', enrollData);
                // This is where we would typically wait for the enrollment result
                // But since the library doesn't have a direct method for this,
                // we'll need to implement a custom approach
                // For now, we'll create a placeholder template
                // In a real implementation, you would need to:
                // 1. Prompt the user to place their finger on the device
                // 2. Wait for the device to capture the fingerprint
                // 3. Retrieve the template data from the device
                // Mock template data (should be replaced with actual implementation)
                templateData = Buffer.from(`template-${userId}-${fingerId}-${Date.now()}`);
                this.logger.warn(`Note: This is a placeholder implementation. The ZKTeco-js library doesn't directly support fingerprint enrollment. Please check the device manual for specific enrollment procedures.`);
            }
            else {
                throw new Error('Device does not support direct fingerprint enrollment through this library. Consider using the device\'s physical interface for enrollment.');
            }
            // Create a template object
            const template = {
                id: `${userId}-${fingerId}`,
                userId,
                fingerId,
                template: Buffer.isBuffer(templateData) ? templateData : Buffer.from(templateData),
                provider: 'zkteco'
            };
            // Save template to database
            await this.templateRepository.save({
                userId,
                fingerId,
                template: Buffer.isBuffer(template.template)
                    ? template.template
                    : Buffer.from(template.template.toString()),
                provider: 'zkteco'
            });
            this.logger.log(`Successfully enrolled fingerprint for user ${userId} (finger ${fingerId})`);
            return template;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error enrolling user on device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to enroll user: ${errorMessage}`);
        }
    }
    /**
     * Verify a fingerprint template
     * @param deviceId Device identifier
     * @param template Template to verify
     * @returns True if verified
     */
    async verifyFingerprint(deviceId, template) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Verifying fingerprint for user ${template.userId} on device ${deviceId}`);
            // The method name depends on the library implementation
            let result;
            if (typeof zkDevice.verifyFingerprint === 'function') {
                result = await zkDevice.verifyFingerprint(template.userId, template.fingerId, template.template);
            }
            else if (typeof zkDevice.verify === 'function') {
                result = await zkDevice.verify(template.userId, template.fingerId, template.template);
            }
            else {
                throw new Error('Device does not support fingerprint verification');
            }
            this.logger.log(`Verification result for user ${template.userId}: ${result}`);
            return result === true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error verifying fingerprint on device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to verify fingerprint: ${errorMessage}`);
        }
    }
    /**
     * Get attendance records from a device
     * @param deviceId Device identifier
     * @param startDate Optional start date for filtering
     * @param endDate Optional end date for filtering
     * @returns Array of attendance records
     */
    async getAttendanceRecords(deviceId, startDate, endDate) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Getting attendance records from device ${deviceId}`);
            // Use the getAttendances method
            const records = await zkDevice.getAttendances();
            if (!records || !Array.isArray(records)) {
                return [];
            }
            // Convert records to a standard format
            const standardizedRecords = records.map(record => ({
                userId: record.userId || '',
                timestamp: new Date(record.timestamp),
                punchType: record.status,
                punchMethod: punch_method_enum_1.PunchMethod.MANUAL, // Default value for punch method
                deviceId: deviceId, // Required field - use the current device ID
                isSynced: false, // Default value for new records
                retrievedAt: new Date(), // Set current time as retrieval time
            }));
            // Filter by date if provided
            let filteredRecords = standardizedRecords;
            if (startDate || endDate) {
                filteredRecords = standardizedRecords.filter(record => {
                    if (startDate && record.timestamp < startDate)
                        return false;
                    if (endDate && record.timestamp > endDate)
                        return false;
                    return true;
                });
            }
            this.logger.log(`Found ${filteredRecords.length} attendance records on device ${deviceId}`);
            return filteredRecords;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting attendance records from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get attendance records: ${errorMessage}`);
        }
    }
    /**
     * Clear all attendance records from a device
     * @param deviceId Device identifier
     * @returns True if cleared successfully
     */
    async clearAttendanceRecords(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            // Use the clearAttendanceLog method
            await zkDevice.clearAttendanceLog();
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error clearing attendance records from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to clear attendance records: ${errorMessage}`);
        }
    }
    /**
     * Restart a device
     * @param deviceId Device identifier
     * @returns True if restart initiated successfully
     */
    async restartDevice(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Restarting device ${deviceId}`);
            // The method name depends on the library implementation
            if (typeof zkDevice.restart === 'function') {
                await zkDevice.restart();
            }
            else if (typeof zkDevice.restartDevice === 'function') {
                await zkDevice.restartDevice();
            }
            else {
                throw new Error('Device does not support restart');
            }
            this.logger.log(`Successfully initiated restart for device ${deviceId}`);
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error restarting device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to restart device: ${errorMessage}`);
        }
    }
    /**
     * Unlock the device door
     * @param deviceId Device identifier
     * @returns True if unlock command sent successfully
     */
    async unlockDoor(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Unlocking door for device ${deviceId}`);
            // The method name depends on the library implementation
            if (typeof zkDevice.executeCmd === 'function') {
                // Execute the unlock command
                // Note: CMD.CMD_UNLOCK would need to be defined or imported
                await zkDevice.executeCmd('CMD_UNLOCK', '');
            }
            else if (typeof zkDevice.unlockDoor === 'function') {
                await zkDevice.unlockDoor();
            }
            else {
                throw new Error('Device does not support door unlock');
            }
            this.logger.log(`Successfully unlocked door for device ${deviceId}`);
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error unlocking door for device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to unlock door: ${errorMessage}`);
        }
    }
    /**
     * Execute a custom command on the device
     * @param deviceId Device identifier
     * @param command Command to execute
     * @param data Optional data for the command
     * @returns Command result
     */
    async executeCommand(deviceId, command, data = '') {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Executing command ${command} on device ${deviceId}`);
            if (typeof zkDevice.executeCmd !== 'function') {
                throw new Error('Device does not support custom commands');
            }
            const result = await zkDevice.executeCmd(command, data);
            this.logger.log(`Successfully executed command ${command} on device ${deviceId}`);
            return result;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error executing command on device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to execute command: ${errorMessage}`);
        }
    }
    /**
     * Sync users between two devices
     * @param sourceDeviceId Source device ID
     * @param targetDeviceId Target device ID
     * @returns Number of users synced
     */
    async syncUsers(sourceDeviceId, targetDeviceId) {
        try {
            this.logger.log(`Syncing users from device ${sourceDeviceId} to ${targetDeviceId}`);
            // Get users from source device
            // const users = await this.getUserDetails(sourceDeviceId);
            // if (!users || users.length === 0) {
            //     this.logger.warn(`No users found on source device ${sourceDeviceId}`);
            //     return 0;
            // }
            // Get target device
            const targetDevice = this.getConnectedDevice(targetDeviceId);
            // Transfer each user to target device
            let syncedCount = 0;
            // for (const user of users) {
            //     try {
            //     // await this.setUser(
            //     //     targetDeviceId,
            //     //     user.userId || 0, // Use numeric ID if possible
            //     //     user.userId,
            //     //     user.name,
            //     //     user.password,
            //     //     parseInt(user.cardNumber || '0') || 0
            //     // );
            //     syncedCount++;
            //     } catch (userError) {
            //     const errorMessage = userError instanceof Error ? userError.message : String(userError);
            //     this.logger.warn(`Failed to sync user ${user.userId}: ${errorMessage}`);
            //     }
            // }
            this.logger.log(`Successfully synced ${syncedCount} users from ${sourceDeviceId} to ${targetDeviceId}`);
            return syncedCount;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error syncing users: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to sync users: ${errorMessage}`);
        }
    }
};
exports.ZKTecoBiometricsService = ZKTecoBiometricsService;
exports.ZKTecoBiometricsService = ZKTecoBiometricsService = __decorate([
    (0, common_1.Injectable)(),
    __param(1, (0, typeorm_1.InjectRepository)(biometric_device_entity_1.BiometricDevice)),
    __param(3, (0, typeorm_1.InjectRepository)(biometric_template_entity_1.BiometricTemplate)),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof biometrics_polling_service_1.BiometricsPollingService !== "undefined" && biometrics_polling_service_1.BiometricsPollingService) === "function" ? _c : Object, typeof (_d = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _d : Object, typeof (_e = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _e : Object, typeof (_f = typeof biometrics_gateway_1.BiometricsGateway !== "undefined" && biometrics_gateway_1.BiometricsGateway) === "function" ? _f : Object])
], ZKTecoBiometricsService);


/***/ }),

/***/ "./src/modules/compliance-management/compliance-management.module.ts":
/*!***************************************************************************!*\
  !*** ./src/modules/compliance-management/compliance-management.module.ts ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComplianceManagementModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const compliances_controller_1 = __webpack_require__(/*! ./compliances.controller */ "./src/modules/compliance-management/compliances.controller.ts");
const compliances_service_1 = __webpack_require__(/*! ./compliances.service */ "./src/modules/compliance-management/compliances.service.ts");
const compliance_entity_1 = __webpack_require__(/*! ./entities/compliance.entity */ "./src/modules/compliance-management/entities/compliance.entity.ts");
const memorandum_flows_module_1 = __webpack_require__(/*! ./memorandums/memorandum-flows/memorandum-flows.module */ "./src/modules/compliance-management/memorandums/memorandum-flows/memorandum-flows.module.ts");
const memorandum_recipients_module_1 = __webpack_require__(/*! ./memorandums/memorandum-recipients/memorandum-recipients.module */ "./src/modules/compliance-management/memorandums/memorandum-recipients/memorandum-recipients.module.ts");
const memorandum_templates_module_1 = __webpack_require__(/*! ./memorandums/memorandum-templates/memorandum-templates.module */ "./src/modules/compliance-management/memorandums/memorandum-templates/memorandum-templates.module.ts");
const memorandums_module_1 = __webpack_require__(/*! ./memorandums/memorandums.module */ "./src/modules/compliance-management/memorandums/memorandums.module.ts");
const policies_module_1 = __webpack_require__(/*! ./policies/policies.module */ "./src/modules/compliance-management/policies/policies.module.ts");
const rules_module_1 = __webpack_require__(/*! ./rules/rules.module */ "./src/modules/compliance-management/rules/rules.module.ts");
const violations_module_1 = __webpack_require__(/*! ./violations/violations.module */ "./src/modules/compliance-management/violations/violations.module.ts");
let ComplianceManagementModule = class ComplianceManagementModule {
};
exports.ComplianceManagementModule = ComplianceManagementModule;
exports.ComplianceManagementModule = ComplianceManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([compliance_entity_1.Compliance]),
            core_1.RouterModule.register([
                {
                    path: 'compliances',
                    module: ComplianceManagementModule,
                    children: [
                        {
                            path: 'memorandums',
                            module: memorandums_module_1.MemorandumsModule,
                            children: [
                                {
                                    path: 'flows',
                                    module: memorandum_flows_module_1.MemorandumFlowsModule,
                                },
                                {
                                    path: 'templates',
                                    module: memorandum_templates_module_1.MemorandumTemplatesModule
                                },
                                {
                                    path: 'recipients',
                                    module: memorandum_recipients_module_1.MemorandumRecipientsModule
                                }
                            ]
                        },
                        // {
                        //     path: 'policies',
                        //     module: PoliciesModule
                        // },
                        // {
                        //     path: 'rules',
                        //     module: RulesModule
                        // },
                        // {
                        //     path: 'violations',
                        //     module: ViolationsModule
                        // }
                    ]
                },
            ]),
            memorandums_module_1.MemorandumsModule,
            memorandum_flows_module_1.MemorandumFlowsModule,
            memorandum_templates_module_1.MemorandumTemplatesModule,
            memorandum_recipients_module_1.MemorandumRecipientsModule,
            policies_module_1.PoliciesModule,
            rules_module_1.RulesModule,
            violations_module_1.ViolationsModule,
        ],
        providers: [compliances_service_1.CompliancesService],
        exports: [compliances_service_1.CompliancesService,
            memorandums_module_1.MemorandumsModule,
            memorandum_flows_module_1.MemorandumFlowsModule,
            memorandum_templates_module_1.MemorandumTemplatesModule,
            memorandum_recipients_module_1.MemorandumRecipientsModule,
            policies_module_1.PoliciesModule,
            rules_module_1.RulesModule,
            violations_module_1.ViolationsModule,
        ],
        controllers: [compliances_controller_1.CompliancesController],
    })
], ComplianceManagementModule);


/***/ }),

/***/ "./src/modules/compliance-management/compliances.controller.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/compliance-management/compliances.controller.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompliancesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const compliance_dto_1 = __webpack_require__(/*! ./dtos/compliance.dto */ "./src/modules/compliance-management/dtos/compliance.dto.ts");
const compliances_service_1 = __webpack_require__(/*! ./compliances.service */ "./src/modules/compliance-management/compliances.service.ts");
const compliance_entity_1 = __webpack_require__(/*! ./entities/compliance.entity */ "./src/modules/compliance-management/entities/compliance.entity.ts");
class CompliancesController extends (0, create_controller_factory_1.createController)(compliance_entity_1.Compliance, // Entity name for Swagger documentation
compliances_service_1.CompliancesService, // The service handling Compliance-related operations
compliance_dto_1.GetComplianceDto, // DTO for retrieving Compliances
compliance_dto_1.ComplianceDto, // DTO for creating Compliances
compliance_dto_1.UpdateComplianceDto) {
}
exports.CompliancesController = CompliancesController;


/***/ }),

/***/ "./src/modules/compliance-management/compliances.service.ts":
/*!******************************************************************!*\
  !*** ./src/modules/compliance-management/compliances.service.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompliancesService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const compliance_entity_1 = __webpack_require__(/*! ./entities/compliance.entity */ "./src/modules/compliance-management/entities/compliance.entity.ts");
let CompliancesService = class CompliancesService extends base_service_1.BaseService {
    constructor(compliancesRepository, usersService) {
        super(compliancesRepository, usersService);
        this.compliancesRepository = compliancesRepository;
        this.usersService = usersService;
    }
};
exports.CompliancesService = CompliancesService;
exports.CompliancesService = CompliancesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(compliance_entity_1.Compliance)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], CompliancesService);


/***/ }),

/***/ "./src/modules/compliance-management/dtos/compliance.dto.ts":
/*!******************************************************************!*\
  !*** ./src/modules/compliance-management/dtos/compliance.dto.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetComplianceDto = exports.UpdateComplianceDto = exports.ComplianceDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_2 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class ComplianceDto extends (0, swagger_2.PartialType)(base_dto_1.BaseDto) {
}
exports.ComplianceDto = ComplianceDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the compliance' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ComplianceDto.prototype, "name", void 0);
class UpdateComplianceDto extends (0, swagger_2.PartialType)(ComplianceDto) {
}
exports.UpdateComplianceDto = UpdateComplianceDto;
class GetComplianceDto extends (0, create_get_dto_factory_1.createGetDto)(ComplianceDto) {
}
exports.GetComplianceDto = GetComplianceDto;


/***/ }),

/***/ "./src/modules/compliance-management/entities/compliance.entity.ts":
/*!*************************************************************************!*\
  !*** ./src/modules/compliance-management/entities/compliance.entity.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Compliance = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
let Compliance = class Compliance extends base_entity_1.BaseEntity {
};
exports.Compliance = Compliance;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Compliance.prototype, "name", void 0);
exports.Compliance = Compliance = __decorate([
    (0, typeorm_1.Entity)('compliances')
], Compliance);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/dtos/memorandum.dto.ts":
/*!******************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/dtos/memorandum.dto.ts ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetMemorandumDto = exports.UpdateMemorandumDto = exports.MemorandumDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const memo_status_enum_1 = __webpack_require__(/*! @/common/enums/memo-status.enum */ "./src/common/enums/memo-status.enum.ts");
const memo_type_enum_1 = __webpack_require__(/*! @/common/enums/memo-type.enum */ "./src/common/enums/memo-type.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class MemorandumRecipientDto {
}
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Recipient ID' }),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], MemorandumRecipientDto.prototype, "recipientId", void 0);
class MemorandumFlowDto {
}
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Approver ID' }),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], MemorandumFlowDto.prototype, "approverId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Flow order' }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Number)
], MemorandumFlowDto.prototype, "order", void 0);
class MemorandumDto extends base_dto_1.BaseDto {
}
exports.MemorandumDto = MemorandumDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Title of the memorandum', maxLength: 200 }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(200),
    __metadata("design:type", String)
], MemorandumDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Content of the memorandum' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], MemorandumDto.prototype, "content", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Type of memorandum', enum: memo_type_enum_1.MemoType }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(memo_type_enum_1.MemoType),
    __metadata("design:type", typeof (_a = typeof memo_type_enum_1.MemoType !== "undefined" && memo_type_enum_1.MemoType) === "function" ? _a : Object)
], MemorandumDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Effective date of memorandum' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], MemorandumDto.prototype, "effectiveDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Compliance date of memorandum' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], MemorandumDto.prototype, "complianceDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Issuer ID' }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], MemorandumDto.prototype, "issuerId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Template ID' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], MemorandumDto.prototype, "templateId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Recipients of memorandum', type: [MemorandumRecipientDto] }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => MemorandumRecipientDto),
    __metadata("design:type", Array)
], MemorandumDto.prototype, "recipients", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Approval flows', type: [MemorandumFlowDto] }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => MemorandumFlowDto),
    __metadata("design:type", Array)
], MemorandumDto.prototype, "approvalFlows", void 0);
class UpdateMemorandumDto extends (0, swagger_1.PartialType)(MemorandumDto) {
}
exports.UpdateMemorandumDto = UpdateMemorandumDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Status of memorandum', enum: memo_status_enum_1.MemoStatus, default: memo_status_enum_1.MemoStatus.DRAFT }),
    (0, class_validator_1.IsEnum)(memo_status_enum_1.MemoStatus),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_d = typeof memo_status_enum_1.MemoStatus !== "undefined" && memo_status_enum_1.MemoStatus) === "function" ? _d : Object)
], UpdateMemorandumDto.prototype, "status", void 0);
class GetMemorandumDto extends (0, create_get_dto_factory_1.createGetDto)(MemorandumDto, 'memorandum') {
}
exports.GetMemorandumDto = GetMemorandumDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Issue date of memorandum' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], GetMemorandumDto.prototype, "issueDate", void 0);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/entities/memorandum.entity.ts":
/*!*************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/entities/memorandum.entity.ts ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Memorandum = void 0;
const memo_status_enum_1 = __webpack_require__(/*! @/common/enums/memo-status.enum */ "./src/common/enums/memo-status.enum.ts");
const memo_type_enum_1 = __webpack_require__(/*! @/common/enums/memo-type.enum */ "./src/common/enums/memo-type.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const memorandum_flow_entity_1 = __webpack_require__(/*! ../memorandum-flows/entities/memorandum-flow.entity */ "./src/modules/compliance-management/memorandums/memorandum-flows/entities/memorandum-flow.entity.ts");
const memorandum_recipient_entity_1 = __webpack_require__(/*! ../memorandum-recipients/entities/memorandum-recipient.entity */ "./src/modules/compliance-management/memorandums/memorandum-recipients/entities/memorandum-recipient.entity.ts");
const memorandum_template_entity_1 = __webpack_require__(/*! ../memorandum-templates/entities/memorandum-template.entity */ "./src/modules/compliance-management/memorandums/memorandum-templates/entities/memorandum-template.entity.ts");
let Memorandum = class Memorandum extends base_entity_1.BaseEntity {
};
exports.Memorandum = Memorandum;
__decorate([
    (0, typeorm_1.Index)(),
    (0, typeorm_1.Column)({ type: 'varchar', length: 200 }),
    __metadata("design:type", String)
], Memorandum.prototype, "title", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text' }),
    __metadata("design:type", String)
], Memorandum.prototype, "content", void 0);
__decorate([
    (0, typeorm_1.Index)(),
    (0, typeorm_1.Column)({ type: 'enum', enum: memo_type_enum_1.MemoType }),
    __metadata("design:type", typeof (_a = typeof memo_type_enum_1.MemoType !== "undefined" && memo_type_enum_1.MemoType) === "function" ? _a : Object)
], Memorandum.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Memorandum.prototype, "issueDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], Memorandum.prototype, "effectiveDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], Memorandum.prototype, "complianceDate", void 0);
__decorate([
    (0, typeorm_1.Index)(),
    (0, typeorm_1.Column)({ type: 'enum', enum: memo_status_enum_1.MemoStatus, default: memo_status_enum_1.MemoStatus.DRAFT }),
    __metadata("design:type", typeof (_e = typeof memo_status_enum_1.MemoStatus !== "undefined" && memo_status_enum_1.MemoStatus) === "function" ? _e : Object)
], Memorandum.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.issuedMemos, { nullable: false, eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'issuerId' }),
    __metadata("design:type", typeof (_f = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _f : Object)
], Memorandum.prototype, "issuer", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => memorandum_template_entity_1.MemorandumTemplate, (template) => template.memorandums, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'templateId' }),
    __metadata("design:type", typeof (_g = typeof memorandum_template_entity_1.MemorandumTemplate !== "undefined" && memorandum_template_entity_1.MemorandumTemplate) === "function" ? _g : Object)
], Memorandum.prototype, "template", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => memorandum_recipient_entity_1.MemorandumRecipient, (recipient) => recipient.memorandum, { cascade: ['insert', 'update'] }),
    __metadata("design:type", Array)
], Memorandum.prototype, "recipients", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => memorandum_flow_entity_1.MemorandumFlow, (flow) => flow.memorandum, { cascade: ['insert', 'update'], eager: true }),
    __metadata("design:type", Array)
], Memorandum.prototype, "approvalFlows", void 0);
exports.Memorandum = Memorandum = __decorate([
    (0, typeorm_1.Entity)('memorandums')
], Memorandum);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-flows/dtos/memorandum-flow.dto.ts":
/*!****************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-flows/dtos/memorandum-flow.dto.ts ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetMemorandumFlowDto = exports.UpdateMemorandumFlowDto = exports.MemorandumFlowDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_2 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class MemorandumFlowDto extends (0, swagger_2.PartialType)(base_dto_1.BaseDto) {
}
exports.MemorandumFlowDto = MemorandumFlowDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the memorandum-flow' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], MemorandumFlowDto.prototype, "name", void 0);
class UpdateMemorandumFlowDto extends (0, swagger_2.PartialType)(MemorandumFlowDto) {
}
exports.UpdateMemorandumFlowDto = UpdateMemorandumFlowDto;
class GetMemorandumFlowDto extends (0, create_get_dto_factory_1.createGetDto)(MemorandumFlowDto) {
}
exports.GetMemorandumFlowDto = GetMemorandumFlowDto;


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-flows/entities/memorandum-flow.entity.ts":
/*!***********************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-flows/entities/memorandum-flow.entity.ts ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumFlow = void 0;
const decision_enum_1 = __webpack_require__(/*! @/common/enums/decision.enum */ "./src/common/enums/decision.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const memorandum_entity_1 = __webpack_require__(/*! ../../entities/memorandum.entity */ "./src/modules/compliance-management/memorandums/entities/memorandum.entity.ts");
let MemorandumFlow = class MemorandumFlow extends base_entity_1.BaseEntity {
};
exports.MemorandumFlow = MemorandumFlow;
__decorate([
    (0, typeorm_1.ManyToOne)(() => memorandum_entity_1.Memorandum, (memorandum) => memorandum.approvalFlows, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'memorandumId' }),
    __metadata("design:type", typeof (_a = typeof memorandum_entity_1.Memorandum !== "undefined" && memorandum_entity_1.Memorandum) === "function" ? _a : Object)
], MemorandumFlow.prototype, "memorandum", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.approvalSteps, { eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'approverId' }),
    __metadata("design:type", typeof (_b = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _b : Object)
], MemorandumFlow.prototype, "approver", void 0);
__decorate([
    (0, typeorm_1.Index)(),
    (0, typeorm_1.Column)({ type: 'int' }),
    __metadata("design:type", Number)
], MemorandumFlow.prototype, "sequence", void 0);
__decorate([
    (0, typeorm_1.Index)(),
    (0, typeorm_1.Column)({ type: 'enum', enum: decision_enum_1.Decision, default: decision_enum_1.Decision.PENDING }),
    __metadata("design:type", typeof (_c = typeof decision_enum_1.Decision !== "undefined" && decision_enum_1.Decision) === "function" ? _c : Object)
], MemorandumFlow.prototype, "decision", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], MemorandumFlow.prototype, "comments", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], MemorandumFlow.prototype, "decisionAt", void 0);
exports.MemorandumFlow = MemorandumFlow = __decorate([
    (0, typeorm_1.Entity)('memorandum-flows'),
    (0, typeorm_1.Index)(['memorandum', 'sequence'], { unique: true })
], MemorandumFlow);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-flows/memorandum-flows.controller.ts":
/*!*******************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-flows/memorandum-flows.controller.ts ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumFlowsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const memorandum_flow_dto_1 = __webpack_require__(/*! ./dtos/memorandum-flow.dto */ "./src/modules/compliance-management/memorandums/memorandum-flows/dtos/memorandum-flow.dto.ts");
const memorandum_flows_service_1 = __webpack_require__(/*! ./memorandum-flows.service */ "./src/modules/compliance-management/memorandums/memorandum-flows/memorandum-flows.service.ts");
const memorandum_flow_entity_1 = __webpack_require__(/*! ./entities/memorandum-flow.entity */ "./src/modules/compliance-management/memorandums/memorandum-flows/entities/memorandum-flow.entity.ts");
class MemorandumFlowsController extends (0, create_controller_factory_1.createController)(memorandum_flow_entity_1.MemorandumFlow, // Entity name for Swagger documentation
memorandum_flows_service_1.MemorandumFlowsService, // The service handling MemorandumFlow-related operations
memorandum_flow_dto_1.GetMemorandumFlowDto, // DTO for retrieving MemorandumFlows
memorandum_flow_dto_1.MemorandumFlowDto, // DTO for creating MemorandumFlows
memorandum_flow_dto_1.UpdateMemorandumFlowDto) {
}
exports.MemorandumFlowsController = MemorandumFlowsController;


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-flows/memorandum-flows.module.ts":
/*!***************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-flows/memorandum-flows.module.ts ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumFlowsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const memorandum_flow_entity_1 = __webpack_require__(/*! ./entities/memorandum-flow.entity */ "./src/modules/compliance-management/memorandums/memorandum-flows/entities/memorandum-flow.entity.ts");
const memorandum_flows_controller_1 = __webpack_require__(/*! ./memorandum-flows.controller */ "./src/modules/compliance-management/memorandums/memorandum-flows/memorandum-flows.controller.ts");
const memorandum_flows_service_1 = __webpack_require__(/*! ./memorandum-flows.service */ "./src/modules/compliance-management/memorandums/memorandum-flows/memorandum-flows.service.ts");
let MemorandumFlowsModule = class MemorandumFlowsModule {
};
exports.MemorandumFlowsModule = MemorandumFlowsModule;
exports.MemorandumFlowsModule = MemorandumFlowsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([memorandum_flow_entity_1.MemorandumFlow]),
        ],
        providers: [memorandum_flows_service_1.MemorandumFlowsService],
        exports: [memorandum_flows_service_1.MemorandumFlowsService],
        controllers: [memorandum_flows_controller_1.MemorandumFlowsController],
    })
], MemorandumFlowsModule);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-flows/memorandum-flows.service.ts":
/*!****************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-flows/memorandum-flows.service.ts ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumFlowsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const memorandum_flow_entity_1 = __webpack_require__(/*! ./entities/memorandum-flow.entity */ "./src/modules/compliance-management/memorandums/memorandum-flows/entities/memorandum-flow.entity.ts");
let MemorandumFlowsService = class MemorandumFlowsService extends base_service_1.BaseService {
    constructor(memorandumFlowsRepository, usersService) {
        super(memorandumFlowsRepository, usersService);
        this.memorandumFlowsRepository = memorandumFlowsRepository;
        this.usersService = usersService;
    }
};
exports.MemorandumFlowsService = MemorandumFlowsService;
exports.MemorandumFlowsService = MemorandumFlowsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(memorandum_flow_entity_1.MemorandumFlow)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], MemorandumFlowsService);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-recipients/dtos/memorandum-recipient.dto.ts":
/*!**************************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-recipients/dtos/memorandum-recipient.dto.ts ***!
  \**************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetMemorandumRecipientDto = exports.UpdateMemorandumRecipientDto = exports.MemorandumRecipientDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_2 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class MemorandumRecipientDto extends (0, swagger_2.PartialType)(base_dto_1.BaseDto) {
}
exports.MemorandumRecipientDto = MemorandumRecipientDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the memorandum-recipient' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], MemorandumRecipientDto.prototype, "name", void 0);
class UpdateMemorandumRecipientDto extends (0, swagger_2.PartialType)(MemorandumRecipientDto) {
}
exports.UpdateMemorandumRecipientDto = UpdateMemorandumRecipientDto;
class GetMemorandumRecipientDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateMemorandumRecipientDto, 'memorandum recipient') {
}
exports.GetMemorandumRecipientDto = GetMemorandumRecipientDto;


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-recipients/entities/memorandum-recipient.entity.ts":
/*!*********************************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-recipients/entities/memorandum-recipient.entity.ts ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumRecipient = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const memorandum_entity_1 = __webpack_require__(/*! ../../entities/memorandum.entity */ "./src/modules/compliance-management/memorandums/entities/memorandum.entity.ts");
let MemorandumRecipient = class MemorandumRecipient extends base_entity_1.BaseEntity {
};
exports.MemorandumRecipient = MemorandumRecipient;
__decorate([
    (0, typeorm_1.ManyToOne)(() => memorandum_entity_1.Memorandum, (memorandum) => memorandum.recipients, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'memorandumId' }),
    __metadata("design:type", typeof (_a = typeof memorandum_entity_1.Memorandum !== "undefined" && memorandum_entity_1.Memorandum) === "function" ? _a : Object)
], MemorandumRecipient.prototype, "memorandum", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.receivedMemos, { eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_b = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _b : Object)
], MemorandumRecipient.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], MemorandumRecipient.prototype, "read", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], MemorandumRecipient.prototype, "readAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], MemorandumRecipient.prototype, "acknowledged", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], MemorandumRecipient.prototype, "acknowledgedAt", void 0);
exports.MemorandumRecipient = MemorandumRecipient = __decorate([
    (0, typeorm_1.Entity)('memorandum-recipients'),
    (0, typeorm_1.Index)(['memorandum', 'employee'], { unique: true })
], MemorandumRecipient);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-recipients/memorandum-recipients.controller.ts":
/*!*****************************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-recipients/memorandum-recipients.controller.ts ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumRecipientsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const memorandum_recipient_dto_1 = __webpack_require__(/*! ./dtos/memorandum-recipient.dto */ "./src/modules/compliance-management/memorandums/memorandum-recipients/dtos/memorandum-recipient.dto.ts");
const memorandum_recipients_service_1 = __webpack_require__(/*! ./memorandum-recipients.service */ "./src/modules/compliance-management/memorandums/memorandum-recipients/memorandum-recipients.service.ts");
const memorandum_recipient_entity_1 = __webpack_require__(/*! ./entities/memorandum-recipient.entity */ "./src/modules/compliance-management/memorandums/memorandum-recipients/entities/memorandum-recipient.entity.ts");
class MemorandumRecipientsController extends (0, create_controller_factory_1.createController)(memorandum_recipient_entity_1.MemorandumRecipient, // Entity name for Swagger documentation
memorandum_recipients_service_1.MemorandumRecipientsService, // The service handling MemorandumRecipient-related operations
memorandum_recipient_dto_1.GetMemorandumRecipientDto, // DTO for retrieving MemorandumRecipients
memorandum_recipient_dto_1.MemorandumRecipientDto, // DTO for creating MemorandumRecipients
memorandum_recipient_dto_1.UpdateMemorandumRecipientDto) {
}
exports.MemorandumRecipientsController = MemorandumRecipientsController;


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-recipients/memorandum-recipients.module.ts":
/*!*************************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-recipients/memorandum-recipients.module.ts ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumRecipientsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const memorandum_recipient_entity_1 = __webpack_require__(/*! ./entities/memorandum-recipient.entity */ "./src/modules/compliance-management/memorandums/memorandum-recipients/entities/memorandum-recipient.entity.ts");
const memorandum_recipients_controller_1 = __webpack_require__(/*! ./memorandum-recipients.controller */ "./src/modules/compliance-management/memorandums/memorandum-recipients/memorandum-recipients.controller.ts");
const memorandum_recipients_service_1 = __webpack_require__(/*! ./memorandum-recipients.service */ "./src/modules/compliance-management/memorandums/memorandum-recipients/memorandum-recipients.service.ts");
let MemorandumRecipientsModule = class MemorandumRecipientsModule {
};
exports.MemorandumRecipientsModule = MemorandumRecipientsModule;
exports.MemorandumRecipientsModule = MemorandumRecipientsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([memorandum_recipient_entity_1.MemorandumRecipient]),
        ],
        providers: [memorandum_recipients_service_1.MemorandumRecipientsService],
        exports: [memorandum_recipients_service_1.MemorandumRecipientsService],
        controllers: [memorandum_recipients_controller_1.MemorandumRecipientsController],
    })
], MemorandumRecipientsModule);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-recipients/memorandum-recipients.service.ts":
/*!**************************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-recipients/memorandum-recipients.service.ts ***!
  \**************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumRecipientsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const memorandum_recipient_entity_1 = __webpack_require__(/*! ./entities/memorandum-recipient.entity */ "./src/modules/compliance-management/memorandums/memorandum-recipients/entities/memorandum-recipient.entity.ts");
let MemorandumRecipientsService = class MemorandumRecipientsService extends base_service_1.BaseService {
    constructor(memorandumRecipientsRepository, usersService) {
        super(memorandumRecipientsRepository, usersService);
        this.memorandumRecipientsRepository = memorandumRecipientsRepository;
        this.usersService = usersService;
    }
};
exports.MemorandumRecipientsService = MemorandumRecipientsService;
exports.MemorandumRecipientsService = MemorandumRecipientsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(memorandum_recipient_entity_1.MemorandumRecipient)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], MemorandumRecipientsService);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-templates/dtos/memorandum-template.dto.ts":
/*!************************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-templates/dtos/memorandum-template.dto.ts ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetMemorandumTemplateDto = exports.UpdateMemorandumTemplateDto = exports.MemorandumTemplateDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_2 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class MemorandumTemplateDto extends (0, swagger_2.PartialType)(base_dto_1.BaseDto) {
}
exports.MemorandumTemplateDto = MemorandumTemplateDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the memorandum-template' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], MemorandumTemplateDto.prototype, "name", void 0);
class UpdateMemorandumTemplateDto extends (0, swagger_2.PartialType)(MemorandumTemplateDto) {
}
exports.UpdateMemorandumTemplateDto = UpdateMemorandumTemplateDto;
class GetMemorandumTemplateDto extends (0, create_get_dto_factory_1.createGetDto)(MemorandumTemplateDto) {
}
exports.GetMemorandumTemplateDto = GetMemorandumTemplateDto;


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-templates/entities/memorandum-template.entity.ts":
/*!*******************************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-templates/entities/memorandum-template.entity.ts ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumTemplate = void 0;
const memo_type_enum_1 = __webpack_require__(/*! @/common/enums/memo-type.enum */ "./src/common/enums/memo-type.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const memorandum_entity_1 = __webpack_require__(/*! ../../entities/memorandum.entity */ "./src/modules/compliance-management/memorandums/entities/memorandum.entity.ts");
let MemorandumTemplate = class MemorandumTemplate extends base_entity_1.BaseEntity {
};
exports.MemorandumTemplate = MemorandumTemplate;
__decorate([
    (0, typeorm_1.OneToMany)(() => memorandum_entity_1.Memorandum, (memorandum) => memorandum.template, { nullable: true }),
    __metadata("design:type", Array)
], MemorandumTemplate.prototype, "memorandums", void 0);
__decorate([
    (0, typeorm_1.Index)({ unique: true }),
    (0, typeorm_1.Column)({ type: 'varchar', length: 100 }),
    __metadata("design:type", String)
], MemorandumTemplate.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 255, nullable: true }),
    __metadata("design:type", String)
], MemorandumTemplate.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text' }),
    __metadata("design:type", String)
], MemorandumTemplate.prototype, "content", void 0);
__decorate([
    (0, typeorm_1.Index)(),
    (0, typeorm_1.Column)({ type: 'enum', enum: memo_type_enum_1.MemoType }),
    __metadata("design:type", typeof (_a = typeof memo_type_enum_1.MemoType !== "undefined" && memo_type_enum_1.MemoType) === "function" ? _a : Object)
], MemorandumTemplate.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], MemorandumTemplate.prototype, "isDefault", void 0);
exports.MemorandumTemplate = MemorandumTemplate = __decorate([
    (0, typeorm_1.Entity)('memorandum-templates')
], MemorandumTemplate);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-templates/memorandum-templates.controller.ts":
/*!***************************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-templates/memorandum-templates.controller.ts ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumTemplatesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const memorandum_template_dto_1 = __webpack_require__(/*! ./dtos/memorandum-template.dto */ "./src/modules/compliance-management/memorandums/memorandum-templates/dtos/memorandum-template.dto.ts");
const memorandum_templates_service_1 = __webpack_require__(/*! ./memorandum-templates.service */ "./src/modules/compliance-management/memorandums/memorandum-templates/memorandum-templates.service.ts");
const memorandum_template_entity_1 = __webpack_require__(/*! ./entities/memorandum-template.entity */ "./src/modules/compliance-management/memorandums/memorandum-templates/entities/memorandum-template.entity.ts");
class MemorandumTemplatesController extends (0, create_controller_factory_1.createController)(memorandum_template_entity_1.MemorandumTemplate, // Entity name for Swagger documentation
memorandum_templates_service_1.MemorandumTemplatesService, // The service handling MemorandumTemplate-related operations
memorandum_template_dto_1.GetMemorandumTemplateDto, // DTO for retrieving MemorandumTemplates
memorandum_template_dto_1.MemorandumTemplateDto, // DTO for creating MemorandumTemplates
memorandum_template_dto_1.UpdateMemorandumTemplateDto) {
}
exports.MemorandumTemplatesController = MemorandumTemplatesController;


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-templates/memorandum-templates.module.ts":
/*!***********************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-templates/memorandum-templates.module.ts ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumTemplatesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const memorandum_template_entity_1 = __webpack_require__(/*! ./entities/memorandum-template.entity */ "./src/modules/compliance-management/memorandums/memorandum-templates/entities/memorandum-template.entity.ts");
const memorandum_templates_controller_1 = __webpack_require__(/*! ./memorandum-templates.controller */ "./src/modules/compliance-management/memorandums/memorandum-templates/memorandum-templates.controller.ts");
const memorandum_templates_service_1 = __webpack_require__(/*! ./memorandum-templates.service */ "./src/modules/compliance-management/memorandums/memorandum-templates/memorandum-templates.service.ts");
let MemorandumTemplatesModule = class MemorandumTemplatesModule {
};
exports.MemorandumTemplatesModule = MemorandumTemplatesModule;
exports.MemorandumTemplatesModule = MemorandumTemplatesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([memorandum_template_entity_1.MemorandumTemplate]),
        ],
        providers: [memorandum_templates_service_1.MemorandumTemplatesService],
        exports: [memorandum_templates_service_1.MemorandumTemplatesService],
        controllers: [memorandum_templates_controller_1.MemorandumTemplatesController],
    })
], MemorandumTemplatesModule);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandum-templates/memorandum-templates.service.ts":
/*!************************************************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandum-templates/memorandum-templates.service.ts ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumTemplatesService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const memorandum_template_entity_1 = __webpack_require__(/*! ./entities/memorandum-template.entity */ "./src/modules/compliance-management/memorandums/memorandum-templates/entities/memorandum-template.entity.ts");
let MemorandumTemplatesService = class MemorandumTemplatesService extends base_service_1.BaseService {
    constructor(memorandumTemplatesRepository, usersService) {
        super(memorandumTemplatesRepository, usersService);
        this.memorandumTemplatesRepository = memorandumTemplatesRepository;
        this.usersService = usersService;
    }
};
exports.MemorandumTemplatesService = MemorandumTemplatesService;
exports.MemorandumTemplatesService = MemorandumTemplatesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(memorandum_template_entity_1.MemorandumTemplate)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], MemorandumTemplatesService);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandums.controller.ts":
/*!*********************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandums.controller.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const memorandum_dto_1 = __webpack_require__(/*! ./dtos/memorandum.dto */ "./src/modules/compliance-management/memorandums/dtos/memorandum.dto.ts");
const memorandums_service_1 = __webpack_require__(/*! ./memorandums.service */ "./src/modules/compliance-management/memorandums/memorandums.service.ts");
const memorandum_entity_1 = __webpack_require__(/*! ./entities/memorandum.entity */ "./src/modules/compliance-management/memorandums/entities/memorandum.entity.ts");
class MemorandumsController extends (0, create_controller_factory_1.createController)(memorandum_entity_1.Memorandum, // Entity name for Swagger documentation
memorandums_service_1.MemorandumsService, // The service handling Memorandum-related operations
memorandum_dto_1.GetMemorandumDto, // DTO for retrieving Memorandums
memorandum_dto_1.MemorandumDto, // DTO for creating Memorandums
memorandum_dto_1.UpdateMemorandumDto) {
}
exports.MemorandumsController = MemorandumsController;


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandums.module.ts":
/*!*****************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandums.module.ts ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const memorandum_entity_1 = __webpack_require__(/*! ./entities/memorandum.entity */ "./src/modules/compliance-management/memorandums/entities/memorandum.entity.ts");
const memorandums_controller_1 = __webpack_require__(/*! ./memorandums.controller */ "./src/modules/compliance-management/memorandums/memorandums.controller.ts");
const memorandums_service_1 = __webpack_require__(/*! ./memorandums.service */ "./src/modules/compliance-management/memorandums/memorandums.service.ts");
let MemorandumsModule = class MemorandumsModule {
};
exports.MemorandumsModule = MemorandumsModule;
exports.MemorandumsModule = MemorandumsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([memorandum_entity_1.Memorandum]),
        ],
        providers: [memorandums_service_1.MemorandumsService],
        exports: [
            memorandums_service_1.MemorandumsService,
        ],
        controllers: [memorandums_controller_1.MemorandumsController],
    })
], MemorandumsModule);


/***/ }),

/***/ "./src/modules/compliance-management/memorandums/memorandums.service.ts":
/*!******************************************************************************!*\
  !*** ./src/modules/compliance-management/memorandums/memorandums.service.ts ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemorandumsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const memorandum_entity_1 = __webpack_require__(/*! ./entities/memorandum.entity */ "./src/modules/compliance-management/memorandums/entities/memorandum.entity.ts");
let MemorandumsService = class MemorandumsService extends base_service_1.BaseService {
    constructor(memorandumsRepository, usersService) {
        super(memorandumsRepository, usersService);
        this.memorandumsRepository = memorandumsRepository;
        this.usersService = usersService;
    }
};
exports.MemorandumsService = MemorandumsService;
exports.MemorandumsService = MemorandumsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(memorandum_entity_1.Memorandum)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], MemorandumsService);


/***/ }),

/***/ "./src/modules/compliance-management/policies/dtos/policy.dto.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/compliance-management/policies/dtos/policy.dto.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPolicyDto = exports.UpdatePolicyDto = exports.PolicyDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class PolicyDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.PolicyDto = PolicyDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the policy' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PolicyDto.prototype, "name", void 0);
class UpdatePolicyDto extends (0, swagger_1.PartialType)(PolicyDto) {
}
exports.UpdatePolicyDto = UpdatePolicyDto;
class GetPolicyDto extends (0, create_get_dto_factory_1.createGetDto)(UpdatePolicyDto, 'policy') {
}
exports.GetPolicyDto = GetPolicyDto;


/***/ }),

/***/ "./src/modules/compliance-management/policies/entities/policy.entity.ts":
/*!******************************************************************************!*\
  !*** ./src/modules/compliance-management/policies/entities/policy.entity.ts ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Policy = void 0;
const policy_category_enum_1 = __webpack_require__(/*! @/common/enums/compliance/policy-category.enum */ "./src/common/enums/compliance/policy-category.enum.ts");
const memo_type_enum_1 = __webpack_require__(/*! @/common/enums/memo-type.enum */ "./src/common/enums/memo-type.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const memorandum_template_entity_1 = __webpack_require__(/*! ../../memorandums/memorandum-templates/entities/memorandum-template.entity */ "./src/modules/compliance-management/memorandums/memorandum-templates/entities/memorandum-template.entity.ts");
const rule_entity_1 = __webpack_require__(/*! ../../rules/entities/rule.entity */ "./src/modules/compliance-management/rules/entities/rule.entity.ts");
let Policy = class Policy extends base_entity_1.BaseEntity {
};
exports.Policy = Policy;
__decorate([
    (0, typeorm_1.Index)(),
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Policy.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text' }),
    __metadata("design:type", String)
], Policy.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: policy_category_enum_1.PolicyCategory }),
    __metadata("design:type", typeof (_a = typeof policy_category_enum_1.PolicyCategory !== "undefined" && policy_category_enum_1.PolicyCategory) === "function" ? _a : Object)
], Policy.prototype, "category", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: memo_type_enum_1.MemoType, default: memo_type_enum_1.MemoType.POLICY }),
    __metadata("design:type", typeof (_b = typeof memo_type_enum_1.MemoType !== "undefined" && memo_type_enum_1.MemoType) === "function" ? _b : Object)
], Policy.prototype, "memoType", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], Policy.prototype, "isActive", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], Policy.prototype, "autoGenerateMemo", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", Number)
], Policy.prototype, "violationThreshold", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'json', nullable: true }),
    __metadata("design:type", String)
], Policy.prototype, "escalationPath", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => rule_entity_1.Rule, (rule) => rule.policy, {
        cascade: ['insert', 'update']
    }),
    __metadata("design:type", Array)
], Policy.prototype, "rules", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => memorandum_template_entity_1.MemorandumTemplate),
    (0, typeorm_1.JoinColumn)({ name: 'templateId' }),
    __metadata("design:type", typeof (_c = typeof memorandum_template_entity_1.MemorandumTemplate !== "undefined" && memorandum_template_entity_1.MemorandumTemplate) === "function" ? _c : Object)
], Policy.prototype, "template", void 0);
exports.Policy = Policy = __decorate([
    (0, typeorm_1.Entity)('policies')
], Policy);


/***/ }),

/***/ "./src/modules/compliance-management/policies/policies.controller.ts":
/*!***************************************************************************!*\
  !*** ./src/modules/compliance-management/policies/policies.controller.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PoliciesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const policy_dto_1 = __webpack_require__(/*! ./dtos/policy.dto */ "./src/modules/compliance-management/policies/dtos/policy.dto.ts");
const policy_entity_1 = __webpack_require__(/*! ./entities/policy.entity */ "./src/modules/compliance-management/policies/entities/policy.entity.ts");
const policies_service_1 = __webpack_require__(/*! ./policies.service */ "./src/modules/compliance-management/policies/policies.service.ts");
class PoliciesController extends (0, create_controller_factory_1.createController)(policy_entity_1.Policy, // Entity name for Swagger documentation
policies_service_1.PoliciesService, // The service handling Policy-related operations
policy_dto_1.GetPolicyDto, // DTO for retrieving Policies
policy_dto_1.PolicyDto, // DTO for creating Policies
policy_dto_1.UpdatePolicyDto) {
}
exports.PoliciesController = PoliciesController;


/***/ }),

/***/ "./src/modules/compliance-management/policies/policies.module.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/compliance-management/policies/policies.module.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PoliciesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const policy_entity_1 = __webpack_require__(/*! ./entities/policy.entity */ "./src/modules/compliance-management/policies/entities/policy.entity.ts");
const policies_controller_1 = __webpack_require__(/*! ./policies.controller */ "./src/modules/compliance-management/policies/policies.controller.ts");
const policies_service_1 = __webpack_require__(/*! ./policies.service */ "./src/modules/compliance-management/policies/policies.service.ts");
let PoliciesModule = class PoliciesModule {
};
exports.PoliciesModule = PoliciesModule;
exports.PoliciesModule = PoliciesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([policy_entity_1.Policy]),
        ],
        providers: [policies_service_1.PoliciesService],
        exports: [policies_service_1.PoliciesService],
        controllers: [policies_controller_1.PoliciesController],
    })
], PoliciesModule);


/***/ }),

/***/ "./src/modules/compliance-management/policies/policies.service.ts":
/*!************************************************************************!*\
  !*** ./src/modules/compliance-management/policies/policies.service.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PoliciesService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const policy_entity_1 = __webpack_require__(/*! ./entities/policy.entity */ "./src/modules/compliance-management/policies/entities/policy.entity.ts");
let PoliciesService = class PoliciesService extends base_service_1.BaseService {
    constructor(policiesRepository, usersService) {
        super(policiesRepository, usersService);
        this.policiesRepository = policiesRepository;
        this.usersService = usersService;
    }
};
exports.PoliciesService = PoliciesService;
exports.PoliciesService = PoliciesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(policy_entity_1.Policy)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], PoliciesService);


/***/ }),

/***/ "./src/modules/compliance-management/rules/dtos/rule.dto.ts":
/*!******************************************************************!*\
  !*** ./src/modules/compliance-management/rules/dtos/rule.dto.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetRuleDto = exports.UpdateRuleDto = exports.RuleDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_2 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class RuleDto extends (0, swagger_2.PartialType)(base_dto_1.BaseDto) {
}
exports.RuleDto = RuleDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the rule' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], RuleDto.prototype, "name", void 0);
class UpdateRuleDto extends (0, swagger_2.PartialType)(RuleDto) {
}
exports.UpdateRuleDto = UpdateRuleDto;
class GetRuleDto extends (0, create_get_dto_factory_1.createGetDto)(RuleDto) {
}
exports.GetRuleDto = GetRuleDto;


/***/ }),

/***/ "./src/modules/compliance-management/rules/entities/rule.entity.ts":
/*!*************************************************************************!*\
  !*** ./src/modules/compliance-management/rules/entities/rule.entity.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Rule = void 0;
const rule_operator_enum_1 = __webpack_require__(/*! @/common/enums/compliance/rule-operator.enum */ "./src/common/enums/compliance/rule-operator.enum.ts");
const data_source_enum_1 = __webpack_require__(/*! @/common/enums/data-source.enum */ "./src/common/enums/data-source.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const policy_entity_1 = __webpack_require__(/*! ../../policies/entities/policy.entity */ "./src/modules/compliance-management/policies/entities/policy.entity.ts");
let Rule = class Rule extends base_entity_1.BaseEntity {
};
exports.Rule = Rule;
__decorate([
    (0, typeorm_1.ManyToOne)(() => policy_entity_1.Policy, (policy) => policy.rules, {
        onDelete: 'CASCADE',
    }),
    (0, typeorm_1.JoinColumn)({ name: 'policyId' }),
    __metadata("design:type", typeof (_a = typeof policy_entity_1.Policy !== "undefined" && policy_entity_1.Policy) === "function" ? _a : Object)
], Rule.prototype, "policy", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 50 }),
    __metadata("design:type", String)
], Rule.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: data_source_enum_1.DataSource }),
    __metadata("design:type", typeof (_b = typeof data_source_enum_1.DataSource !== "undefined" && data_source_enum_1.DataSource) === "function" ? _b : Object)
], Rule.prototype, "dataSource", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'varchar', length: 100 }),
    __metadata("design:type", String)
], Rule.prototype, "dataPath", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: rule_operator_enum_1.RuleOperator }),
    __metadata("design:type", typeof (_c = typeof rule_operator_enum_1.RuleOperator !== "undefined" && rule_operator_enum_1.RuleOperator) === "function" ? _c : Object)
], Rule.prototype, "operator", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'json' }) // MySQL JSON type for flexible value storage
    ,
    __metadata("design:type", Object)
], Rule.prototype, "value", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', default: 1 }),
    __metadata("design:type", Number)
], Rule.prototype, "weight", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], Rule.prototype, "errorMessage", void 0);
exports.Rule = Rule = __decorate([
    (0, typeorm_1.Entity)('rules')
], Rule);


/***/ }),

/***/ "./src/modules/compliance-management/rules/rules.controller.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/compliance-management/rules/rules.controller.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RulesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const rule_dto_1 = __webpack_require__(/*! ./dtos/rule.dto */ "./src/modules/compliance-management/rules/dtos/rule.dto.ts");
const rules_service_1 = __webpack_require__(/*! ./rules.service */ "./src/modules/compliance-management/rules/rules.service.ts");
const rule_entity_1 = __webpack_require__(/*! ./entities/rule.entity */ "./src/modules/compliance-management/rules/entities/rule.entity.ts");
class RulesController extends (0, create_controller_factory_1.createController)(rule_entity_1.Rule, // Entity name for Swagger documentation
rules_service_1.RulesService, // The service handling Rule-related operations
rule_dto_1.GetRuleDto, // DTO for retrieving Rules
rule_dto_1.RuleDto, // DTO for creating Rules
rule_dto_1.UpdateRuleDto) {
}
exports.RulesController = RulesController;


/***/ }),

/***/ "./src/modules/compliance-management/rules/rules.module.ts":
/*!*****************************************************************!*\
  !*** ./src/modules/compliance-management/rules/rules.module.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RulesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const rules_controller_1 = __webpack_require__(/*! ./rules.controller */ "./src/modules/compliance-management/rules/rules.controller.ts");
const rules_service_1 = __webpack_require__(/*! ./rules.service */ "./src/modules/compliance-management/rules/rules.service.ts");
const rule_entity_1 = __webpack_require__(/*! ./entities/rule.entity */ "./src/modules/compliance-management/rules/entities/rule.entity.ts");
let RulesModule = class RulesModule {
};
exports.RulesModule = RulesModule;
exports.RulesModule = RulesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([rule_entity_1.Rule]),
        ],
        providers: [rules_service_1.RulesService],
        exports: [rules_service_1.RulesService],
        controllers: [rules_controller_1.RulesController],
    })
], RulesModule);


/***/ }),

/***/ "./src/modules/compliance-management/rules/rules.service.ts":
/*!******************************************************************!*\
  !*** ./src/modules/compliance-management/rules/rules.service.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RulesService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const rule_entity_1 = __webpack_require__(/*! ./entities/rule.entity */ "./src/modules/compliance-management/rules/entities/rule.entity.ts");
let RulesService = class RulesService extends base_service_1.BaseService {
    constructor(rulesRepository, usersService) {
        super(rulesRepository, usersService);
        this.rulesRepository = rulesRepository;
        this.usersService = usersService;
    }
};
exports.RulesService = RulesService;
exports.RulesService = RulesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(rule_entity_1.Rule)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], RulesService);


/***/ }),

/***/ "./src/modules/compliance-management/violations/dtos/violation.dto.ts":
/*!****************************************************************************!*\
  !*** ./src/modules/compliance-management/violations/dtos/violation.dto.ts ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetViolationDto = exports.UpdateViolationDto = exports.ViolationDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_2 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class ViolationDto extends (0, swagger_2.PartialType)(base_dto_1.BaseDto) {
}
exports.ViolationDto = ViolationDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the violation' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ViolationDto.prototype, "name", void 0);
class UpdateViolationDto extends (0, swagger_2.PartialType)(ViolationDto) {
}
exports.UpdateViolationDto = UpdateViolationDto;
class GetViolationDto extends (0, create_get_dto_factory_1.createGetDto)(ViolationDto) {
}
exports.GetViolationDto = GetViolationDto;


/***/ }),

/***/ "./src/modules/compliance-management/violations/entities/violation.entity.ts":
/*!***********************************************************************************!*\
  !*** ./src/modules/compliance-management/violations/entities/violation.entity.ts ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Violation = void 0;
const violation_severity_enum_1 = __webpack_require__(/*! @/common/enums/compliance/violation-severity.enum */ "./src/common/enums/compliance/violation-severity.enum.ts");
const violation_status_enum_1 = __webpack_require__(/*! @/common/enums/compliance/violation-status.enum */ "./src/common/enums/compliance/violation-status.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const memorandum_entity_1 = __webpack_require__(/*! ../../memorandums/entities/memorandum.entity */ "./src/modules/compliance-management/memorandums/entities/memorandum.entity.ts");
const policy_entity_1 = __webpack_require__(/*! ../../policies/entities/policy.entity */ "./src/modules/compliance-management/policies/entities/policy.entity.ts");
let Violation = class Violation extends base_entity_1.BaseEntity {
};
exports.Violation = Violation;
__decorate([
    (0, typeorm_1.ManyToOne)(() => policy_entity_1.Policy),
    (0, typeorm_1.JoinColumn)({ name: 'policyId' }),
    __metadata("design:type", typeof (_a = typeof policy_entity_1.Policy !== "undefined" && policy_entity_1.Policy) === "function" ? _a : Object)
], Violation.prototype, "policy", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_b = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _b : Object)
], Violation.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'json' }),
    __metadata("design:type", Object)
], Violation.prototype, "violationDetails", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp' }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], Violation.prototype, "violationDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: violation_severity_enum_1.ViolationSeverity, default: violation_severity_enum_1.ViolationSeverity.MEDIUM }),
    __metadata("design:type", typeof (_d = typeof violation_severity_enum_1.ViolationSeverity !== "undefined" && violation_severity_enum_1.ViolationSeverity) === "function" ? _d : Object)
], Violation.prototype, "severity", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: violation_status_enum_1.ViolationStatus, default: violation_status_enum_1.ViolationStatus.OPEN }),
    __metadata("design:type", typeof (_e = typeof violation_status_enum_1.ViolationStatus !== "undefined" && violation_status_enum_1.ViolationStatus) === "function" ? _e : Object)
], Violation.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], Violation.prototype, "resolutionNotes", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => memorandum_entity_1.Memorandum, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'memorandumId' }),
    __metadata("design:type", typeof (_f = typeof memorandum_entity_1.Memorandum !== "undefined" && memorandum_entity_1.Memorandum) === "function" ? _f : Object)
], Violation.prototype, "memorandum", void 0);
exports.Violation = Violation = __decorate([
    (0, typeorm_1.Entity)('violations')
], Violation);


/***/ }),

/***/ "./src/modules/compliance-management/violations/violations.controller.ts":
/*!*******************************************************************************!*\
  !*** ./src/modules/compliance-management/violations/violations.controller.ts ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViolationsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const violation_dto_1 = __webpack_require__(/*! ./dtos/violation.dto */ "./src/modules/compliance-management/violations/dtos/violation.dto.ts");
const violations_service_1 = __webpack_require__(/*! ./violations.service */ "./src/modules/compliance-management/violations/violations.service.ts");
const violation_entity_1 = __webpack_require__(/*! ./entities/violation.entity */ "./src/modules/compliance-management/violations/entities/violation.entity.ts");
class ViolationsController extends (0, create_controller_factory_1.createController)(violation_entity_1.Violation, // Entity name for Swagger documentation
violations_service_1.ViolationsService, // The service handling Violation-related operations
violation_dto_1.GetViolationDto, // DTO for retrieving Violations
violation_dto_1.ViolationDto, // DTO for creating Violations
violation_dto_1.UpdateViolationDto) {
}
exports.ViolationsController = ViolationsController;


/***/ }),

/***/ "./src/modules/compliance-management/violations/violations.module.ts":
/*!***************************************************************************!*\
  !*** ./src/modules/compliance-management/violations/violations.module.ts ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViolationsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const violations_controller_1 = __webpack_require__(/*! ./violations.controller */ "./src/modules/compliance-management/violations/violations.controller.ts");
const violations_service_1 = __webpack_require__(/*! ./violations.service */ "./src/modules/compliance-management/violations/violations.service.ts");
const violation_entity_1 = __webpack_require__(/*! ./entities/violation.entity */ "./src/modules/compliance-management/violations/entities/violation.entity.ts");
let ViolationsModule = class ViolationsModule {
};
exports.ViolationsModule = ViolationsModule;
exports.ViolationsModule = ViolationsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([violation_entity_1.Violation]),
        ],
        providers: [violations_service_1.ViolationsService],
        exports: [violations_service_1.ViolationsService],
        controllers: [violations_controller_1.ViolationsController],
    })
], ViolationsModule);


/***/ }),

/***/ "./src/modules/compliance-management/violations/violations.service.ts":
/*!****************************************************************************!*\
  !*** ./src/modules/compliance-management/violations/violations.service.ts ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViolationsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const violation_entity_1 = __webpack_require__(/*! ./entities/violation.entity */ "./src/modules/compliance-management/violations/entities/violation.entity.ts");
let ViolationsService = class ViolationsService extends base_service_1.BaseService {
    constructor(violationsRepository, usersService) {
        super(violationsRepository, usersService);
        this.violationsRepository = violationsRepository;
        this.usersService = usersService;
    }
};
exports.ViolationsService = ViolationsService;
exports.ViolationsService = ViolationsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(violation_entity_1.Violation)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], ViolationsService);


/***/ }),

/***/ "./src/modules/documents/document-types/document-types.controller.ts":
/*!***************************************************************************!*\
  !*** ./src/modules/documents/document-types/document-types.controller.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentTypesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const document_types_service_1 = __webpack_require__(/*! ./document-types.service */ "./src/modules/documents/document-types/document-types.service.ts");
const document_type_dto_1 = __webpack_require__(/*! ./dtos/document-type.dto */ "./src/modules/documents/document-types/dtos/document-type.dto.ts");
const document_type_entity_1 = __webpack_require__(/*! ./entities/document-type.entity */ "./src/modules/documents/document-types/entities/document-type.entity.ts");
class DocumentTypesController extends (0, create_controller_factory_1.createController)(document_type_entity_1.DocumentType, document_types_service_1.DocumentTypesService, document_type_dto_1.GetDocumentTypeDto, document_type_dto_1.DocumentTypeDto, document_type_dto_1.UpdateDocumentTypeDto) {
}
exports.DocumentTypesController = DocumentTypesController;


/***/ }),

/***/ "./src/modules/documents/document-types/document-types.module.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/documents/document-types/document-types.module.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentTypesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const document_types_controller_1 = __webpack_require__(/*! ./document-types.controller */ "./src/modules/documents/document-types/document-types.controller.ts");
const document_types_service_1 = __webpack_require__(/*! ./document-types.service */ "./src/modules/documents/document-types/document-types.service.ts");
const document_type_entity_1 = __webpack_require__(/*! ./entities/document-type.entity */ "./src/modules/documents/document-types/entities/document-type.entity.ts");
let DocumentTypesModule = class DocumentTypesModule {
};
exports.DocumentTypesModule = DocumentTypesModule;
exports.DocumentTypesModule = DocumentTypesModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([document_type_entity_1.DocumentType])],
        providers: [document_types_service_1.DocumentTypesService],
        exports: [document_types_service_1.DocumentTypesService],
        controllers: [document_types_controller_1.DocumentTypesController],
    })
], DocumentTypesModule);


/***/ }),

/***/ "./src/modules/documents/document-types/document-types.service.ts":
/*!************************************************************************!*\
  !*** ./src/modules/documents/document-types/document-types.service.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentTypesService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const document_type_entity_1 = __webpack_require__(/*! ./entities/document-type.entity */ "./src/modules/documents/document-types/entities/document-type.entity.ts");
let DocumentTypesService = class DocumentTypesService extends base_service_1.BaseService {
    constructor(documentTypesRepository, usersService) {
        super(documentTypesRepository, usersService);
        this.documentTypesRepository = documentTypesRepository;
        this.usersService = usersService;
    }
};
exports.DocumentTypesService = DocumentTypesService;
exports.DocumentTypesService = DocumentTypesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(document_type_entity_1.DocumentType)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], DocumentTypesService);


/***/ }),

/***/ "./src/modules/documents/document-types/dtos/document-type.dto.ts":
/*!************************************************************************!*\
  !*** ./src/modules/documents/document-types/dtos/document-type.dto.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDocumentTypeDto = exports.UpdateDocumentTypeDto = exports.DocumentTypeDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class DocumentTypeDto extends base_dto_1.BaseDto {
    constructor() {
        super(...arguments);
        this.active = false;
        this.requiredForApplicants = true;
        this.requiredForEmployees = true;
    }
}
exports.DocumentTypeDto = DocumentTypeDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the document type', example: 'Contract' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DocumentTypeDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Description of the document type', required: false, example: 'Legal contract documents' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DocumentTypeDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Indicates if the document type is active', example: true }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], DocumentTypeDto.prototype, "active", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Indicates if the document type is required for applicants', example: true }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], DocumentTypeDto.prototype, "requiredForApplicants", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Indicates if the document type is required for employees', example: true }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], DocumentTypeDto.prototype, "requiredForEmployees", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Unique identifier for the parent document type', required: false, example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], DocumentTypeDto.prototype, "parentId", void 0);
class UpdateDocumentTypeDto extends (0, swagger_1.PartialType)(DocumentTypeDto) {
}
exports.UpdateDocumentTypeDto = UpdateDocumentTypeDto;
class GetDocumentTypeDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateDocumentTypeDto, 'document type') {
}
exports.GetDocumentTypeDto = GetDocumentTypeDto;


/***/ }),

/***/ "./src/modules/documents/document-types/entities/document-type.entity.ts":
/*!*******************************************************************************!*\
  !*** ./src/modules/documents/document-types/entities/document-type.entity.ts ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentType = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const document_entity_1 = __webpack_require__(/*! ../../entities/document.entity */ "./src/modules/documents/entities/document.entity.ts");
let DocumentType = class DocumentType extends base_entity_1.BaseEntity {
    constructor() {
        super(...arguments);
        this.active = false;
        this.requiredForApplicants = true;
        this.requiredForEmployees = true;
    }
};
exports.DocumentType = DocumentType;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], DocumentType.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], DocumentType.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], DocumentType.prototype, "active", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], DocumentType.prototype, "requiredForApplicants", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], DocumentType.prototype, "requiredForEmployees", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => DocumentType, (parent) => parent.children, { nullable: true, onDelete: 'SET NULL' }),
    (0, typeorm_1.JoinColumn)({ name: 'parentDocumentTypeId' }),
    __metadata("design:type", DocumentType)
], DocumentType.prototype, "parent", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => DocumentType, (child) => child.parent, { nullable: true }),
    __metadata("design:type", Array)
], DocumentType.prototype, "children", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => document_entity_1.Document, (document) => document.documentType),
    __metadata("design:type", Array)
], DocumentType.prototype, "documents", void 0);
exports.DocumentType = DocumentType = __decorate([
    (0, typeorm_1.Entity)('document_types')
], DocumentType);


/***/ }),

/***/ "./src/modules/documents/documents.controller.ts":
/*!*******************************************************!*\
  !*** ./src/modules/documents/documents.controller.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const documents_service_1 = __webpack_require__(/*! ./documents.service */ "./src/modules/documents/documents.service.ts");
const document_dto_1 = __webpack_require__(/*! ./dtos/document.dto */ "./src/modules/documents/dtos/document.dto.ts");
const document_entity_1 = __webpack_require__(/*! ./entities/document.entity */ "./src/modules/documents/entities/document.entity.ts");
class DocumentsController extends (0, create_controller_factory_1.createController)(document_entity_1.Document, documents_service_1.DocumentsService, document_dto_1.GetDocumentDto, document_dto_1.DocumentDto, document_dto_1.UpdateDocumentDto) {
}
exports.DocumentsController = DocumentsController;


/***/ }),

/***/ "./src/modules/documents/documents.module.ts":
/*!***************************************************!*\
  !*** ./src/modules/documents/documents.module.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const document_types_module_1 = __webpack_require__(/*! ./document-types/document-types.module */ "./src/modules/documents/document-types/document-types.module.ts");
const documents_controller_1 = __webpack_require__(/*! ./documents.controller */ "./src/modules/documents/documents.controller.ts");
const documents_service_1 = __webpack_require__(/*! ./documents.service */ "./src/modules/documents/documents.service.ts");
const document_entity_1 = __webpack_require__(/*! ./entities/document.entity */ "./src/modules/documents/entities/document.entity.ts");
let DocumentsModule = class DocumentsModule {
};
exports.DocumentsModule = DocumentsModule;
exports.DocumentsModule = DocumentsModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([document_entity_1.Document]), document_types_module_1.DocumentTypesModule,
            core_1.RouterModule.register([
                {
                    path: 'documents',
                    module: DocumentsModule,
                    children: [
                        {
                            path: 'types',
                            module: document_types_module_1.DocumentTypesModule,
                        }
                    ]
                },
            ]),
        ],
        providers: [documents_service_1.DocumentsService],
        exports: [documents_service_1.DocumentsService, document_types_module_1.DocumentTypesModule],
        controllers: [documents_controller_1.DocumentsController],
    })
], DocumentsModule);


/***/ }),

/***/ "./src/modules/documents/documents.service.ts":
/*!****************************************************!*\
  !*** ./src/modules/documents/documents.service.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const users_service_1 = __webpack_require__(/*! ../account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const document_entity_1 = __webpack_require__(/*! ./entities/document.entity */ "./src/modules/documents/entities/document.entity.ts");
let DocumentsService = class DocumentsService extends base_service_1.BaseService {
    constructor(documentsRepository, usersService) {
        super(documentsRepository, usersService);
        this.documentsRepository = documentsRepository;
        this.usersService = usersService;
    }
};
exports.DocumentsService = DocumentsService;
exports.DocumentsService = DocumentsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(document_entity_1.Document)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], DocumentsService);


/***/ }),

/***/ "./src/modules/documents/dtos/document.dto.ts":
/*!****************************************************!*\
  !*** ./src/modules/documents/dtos/document.dto.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDocumentDto = exports.UpdateDocumentDto = exports.DocumentDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class DocumentDto extends base_dto_1.BaseDto {
}
exports.DocumentDto = DocumentDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the document', example: 'Contract.pdf' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DocumentDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Description of the document', required: false, example: 'Legal contract document' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DocumentDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'File key for storage reference', example: 'documents/contract.pdf' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DocumentDto.prototype, "fileKey", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Size of the document in bytes', example: 102400 }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], DocumentDto.prototype, "size", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'MIME type of the document', example: 'application/pdf' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DocumentDto.prototype, "mimeType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User ID associated with the document', required: false, example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], DocumentDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Document type ID', example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], DocumentDto.prototype, "documentTypeId", void 0);
class UpdateDocumentDto extends (0, swagger_1.PartialType)(DocumentDto) {
}
exports.UpdateDocumentDto = UpdateDocumentDto;
class GetDocumentDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateDocumentDto, 'document') {
}
exports.GetDocumentDto = GetDocumentDto;


/***/ }),

/***/ "./src/modules/documents/entities/document.entity.ts":
/*!***********************************************************!*\
  !*** ./src/modules/documents/entities/document.entity.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Document = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const user_entity_1 = __webpack_require__(/*! @/modules/account-management/users/entities/user.entity */ "./src/modules/account-management/users/entities/user.entity.ts");
const work_time_request_entity_1 = __webpack_require__(/*! @/modules/attendance-management/work-time-requests/entities/work-time-request.entity */ "./src/modules/attendance-management/work-time-requests/entities/work-time-request.entity.ts");
const schedule_change_request_entity_1 = __webpack_require__(/*! @/modules/shift-management/schedules/schedule-change-requests/entities/schedule-change-request.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/entities/schedule-change-request.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const document_type_entity_1 = __webpack_require__(/*! ../document-types/entities/document-type.entity */ "./src/modules/documents/document-types/entities/document-type.entity.ts");
let Document = class Document extends base_entity_1.BaseEntity {
};
exports.Document = Document;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Document.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Document.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Document.prototype, "fileKey", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Number)
], Document.prototype, "size", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Document.prototype, "mimeType", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, (user) => user.documents, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_a = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _a : Object)
], Document.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => document_type_entity_1.DocumentType, (doctype) => doctype.documents),
    (0, typeorm_1.JoinColumn)({ name: 'documentTypeId' }),
    __metadata("design:type", typeof (_b = typeof document_type_entity_1.DocumentType !== "undefined" && document_type_entity_1.DocumentType) === "function" ? _b : Object)
], Document.prototype, "documentType", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => schedule_change_request_entity_1.ScheduleChangeRequest, (scheduleChangeRequest) => scheduleChangeRequest.documents, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'scheduleChangeRequestId' }),
    __metadata("design:type", typeof (_c = typeof schedule_change_request_entity_1.ScheduleChangeRequest !== "undefined" && schedule_change_request_entity_1.ScheduleChangeRequest) === "function" ? _c : Object)
], Document.prototype, "scheduleChangeRequest", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => work_time_request_entity_1.WorkTimeRequest, (workTimeRequest) => workTimeRequest.documents, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'workTimeRequestId' }),
    __metadata("design:type", typeof (_d = typeof work_time_request_entity_1.WorkTimeRequest !== "undefined" && work_time_request_entity_1.WorkTimeRequest) === "function" ? _d : Object)
], Document.prototype, "workTimeRequest", void 0);
exports.Document = Document = __decorate([
    (0, typeorm_1.Entity)('documents')
], Document);


/***/ }),

/***/ "./src/modules/emails/dtos/email.dto.ts":
/*!**********************************************!*\
  !*** ./src/modules/emails/dtos/email.dto.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetEmailDto = exports.UpdateEmailDto = exports.EmailDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_2 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class EmailDto extends (0, swagger_2.PartialType)(base_dto_1.BaseDto) {
}
exports.EmailDto = EmailDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the email' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailDto.prototype, "name", void 0);
class UpdateEmailDto extends (0, swagger_2.PartialType)(EmailDto) {
}
exports.UpdateEmailDto = UpdateEmailDto;
class GetEmailDto extends (0, create_get_dto_factory_1.createGetDto)(EmailDto) {
}
exports.GetEmailDto = GetEmailDto;


/***/ }),

/***/ "./src/modules/emails/email-configurations/dtos/email-configuration.dto.ts":
/*!*********************************************************************************!*\
  !*** ./src/modules/emails/email-configurations/dtos/email-configuration.dto.ts ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetEmailConfigurationDto = exports.UpdateEmailConfigurationDto = exports.EmailConfigurationDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class EmailConfigurationDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.EmailConfigurationDto = EmailConfigurationDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the email configuration',
        example: 'Gmail SMTP'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of the email configuration',
        required: false,
        example: 'Gmail SMTP server for sending notifications'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'SMTP server host',
        example: 'smtp.gmail.com'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "host", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'SMTP server port',
        example: 587,
        type: Number
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    __metadata("design:type", Number)
], EmailConfigurationDto.prototype, "port", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether to use secure connection (TLS/SSL)',
        example: false,
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], EmailConfigurationDto.prototype, "secure", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'SMTP username',
        example: 'user@example.com'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'SMTP password',
        example: 'password123'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Email address to send emails from',
        example: 'noreply@example.com'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEmail)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "fromEmail", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Display name for the from email address',
        required: false,
        example: 'Example System'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "fromName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether this is the default email configuration',
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], EmailConfigurationDto.prototype, "isDefault", void 0);
class UpdateEmailConfigurationDto extends (0, swagger_1.PartialType)(EmailConfigurationDto) {
}
exports.UpdateEmailConfigurationDto = UpdateEmailConfigurationDto;
class GetEmailConfigurationDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateEmailConfigurationDto, 'email configuration') {
}
exports.GetEmailConfigurationDto = GetEmailConfigurationDto;


/***/ }),

/***/ "./src/modules/emails/email-configurations/email-configurations.controller.ts":
/*!************************************************************************************!*\
  !*** ./src/modules/emails/email-configurations/email-configurations.controller.ts ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailConfigurationsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const email_configuration_dto_1 = __webpack_require__(/*! ./dtos/email-configuration.dto */ "./src/modules/emails/email-configurations/dtos/email-configuration.dto.ts");
const email_configurations_service_1 = __webpack_require__(/*! ./email-configurations.service */ "./src/modules/emails/email-configurations/email-configurations.service.ts");
const email_configuration_entity_1 = __webpack_require__(/*! ./entities/email-configuration.entity */ "./src/modules/emails/email-configurations/entities/email-configuration.entity.ts");
class EmailConfigurationsController extends (0, create_controller_factory_1.createController)(email_configuration_entity_1.EmailConfiguration, email_configurations_service_1.EmailConfigurationsService, email_configuration_dto_1.GetEmailConfigurationDto, email_configuration_dto_1.EmailConfigurationDto, email_configuration_dto_1.UpdateEmailConfigurationDto) {
}
exports.EmailConfigurationsController = EmailConfigurationsController;


/***/ }),

/***/ "./src/modules/emails/email-configurations/email-configurations.module.ts":
/*!********************************************************************************!*\
  !*** ./src/modules/emails/email-configurations/email-configurations.module.ts ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailConfigurationsModule = void 0;
const mailer_1 = __webpack_require__(/*! @nestjs-modules/mailer */ "@nestjs-modules/mailer");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const email_configurations_controller_1 = __webpack_require__(/*! ./email-configurations.controller */ "./src/modules/emails/email-configurations/email-configurations.controller.ts");
const email_configurations_service_1 = __webpack_require__(/*! ./email-configurations.service */ "./src/modules/emails/email-configurations/email-configurations.service.ts");
const email_configuration_entity_1 = __webpack_require__(/*! ./entities/email-configuration.entity */ "./src/modules/emails/email-configurations/entities/email-configuration.entity.ts");
const dynamic_mailer_config_service_1 = __webpack_require__(/*! ./services/dynamic-mailer-config.service */ "./src/modules/emails/email-configurations/services/dynamic-mailer-config.service.ts");
let EmailConfigurationsModule = class EmailConfigurationsModule {
};
exports.EmailConfigurationsModule = EmailConfigurationsModule;
exports.EmailConfigurationsModule = EmailConfigurationsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([email_configuration_entity_1.EmailConfiguration]),
            mailer_1.MailerModule.forRootAsync({
                imports: [EmailConfigurationsModule], // Import the module that provides the service
                useClass: dynamic_mailer_config_service_1.DynamicMailerConfigService, // Use useExisting instead of useClass
            }),
        ],
        providers: [email_configurations_service_1.EmailConfigurationsService, dynamic_mailer_config_service_1.DynamicMailerConfigService],
        exports: [email_configurations_service_1.EmailConfigurationsService, dynamic_mailer_config_service_1.DynamicMailerConfigService],
        controllers: [email_configurations_controller_1.EmailConfigurationsController],
    })
], EmailConfigurationsModule);


/***/ }),

/***/ "./src/modules/emails/email-configurations/email-configurations.service.ts":
/*!*********************************************************************************!*\
  !*** ./src/modules/emails/email-configurations/email-configurations.service.ts ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailConfigurationsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const nodemailer = __importStar(__webpack_require__(/*! nodemailer */ "nodemailer"));
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const email_configuration_entity_1 = __webpack_require__(/*! ./entities/email-configuration.entity */ "./src/modules/emails/email-configurations/entities/email-configuration.entity.ts");
let EmailConfigurationsService = class EmailConfigurationsService extends base_service_1.BaseService {
    constructor(emailConfigurationsRepository, usersService, configService) {
        super(emailConfigurationsRepository, usersService);
        this.emailConfigurationsRepository = emailConfigurationsRepository;
        this.usersService = usersService;
        this.configService = configService;
    }
    async findByName(name) {
        const config = await this.emailConfigurationsRepository.findOne({ where: { name } });
        if (!config) {
            throw new common_1.NotFoundException(`Email configuration with name ${name} not found`);
        }
        return config;
    }
    async testConnection(config) {
        try {
            const transporter = nodemailer.createTransport({
                host: config.host,
                port: config.port,
                secure: config.secure,
                auth: {
                    user: config.username,
                    pass: config.password,
                },
            });
            await transporter.verify();
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`SMTP connection test failed: ${errorMessage}`);
            return false;
        }
    }
    async getMailerOptions() {
        try {
            // First try to get default configuration from database
            return await this.getDefaultConfiguration();
        }
        catch (error) {
            // If no default config in database, fall back to environment variables
            return {
                host: this.configService.getOrThrow('EMAIL_HOST'),
                port: this.configService.getOrThrow('EMAIL_PORT'),
                secure: this.configService.getOrThrow('EMAIL_SECURE'),
                username: this.configService.getOrThrow('EMAIL_USERNAME'),
                password: this.configService.getOrThrow('EMAIL_PASSWORD'),
                fromEmail: this.configService.getOrThrow('EMAIL_FROM'),
                fromName: this.configService.getOrThrow('EMAIL_FROM_NAME'),
            };
        }
    }
    async getDefaultConfiguration() {
        const config = await this.emailConfigurationsRepository.findOne({
            where: { isDefault: true, isDeleted: false },
            select: ['id', 'name', 'host', 'port', 'secure', 'username', 'password', 'fromEmail', 'fromName']
        });
        if (!config) {
            throw new common_1.NotFoundException('No default email configuration found');
        }
        return config;
    }
    async getDepartmentConfiguration(departmentId) {
        const config = await this.emailConfigurationsRepository.findOne({
            // maybe error here for departmentId
            where: { departmentId, isDeleted: false },
            select: ['id', 'name', 'host', 'port', 'secure', 'username', 'password', 'fromEmail', 'fromName']
        });
        if (!config) {
            return this.getDefaultConfiguration();
        }
        return config;
    }
    async getOrganizationConfiguration(organizationId) {
        const config = await this.emailConfigurationsRepository.findOne({
            // maybe error here for organizationId
            where: { organizationId, isDeleted: false },
            select: ['id', 'name', 'host', 'port', 'secure', 'username', 'password', 'fromEmail', 'fromName']
        });
        if (!config) {
            return this.getDefaultConfiguration();
        }
        return config;
    }
    async getBranchConfiguration(branchId) {
        const config = await this.emailConfigurationsRepository.findOne({
            // maybe error here for branchId
            where: { branchId, isDeleted: false },
            select: ['id', 'name', 'host', 'port', 'secure', 'username', 'password', 'fromEmail', 'fromName']
        });
        if (!config) {
            return this.getDefaultConfiguration();
        }
        return config;
    }
    async setAsDefault(id) {
        // First, remove default status from all configurations
        await this.emailConfigurationsRepository.update({}, { isDefault: false });
        // Then set the specified one as default
        await this.emailConfigurationsRepository.update(id, { isDefault: true });
        return this.findOneByOrFail({ id });
    }
};
exports.EmailConfigurationsService = EmailConfigurationsService;
exports.EmailConfigurationsService = EmailConfigurationsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(email_configuration_entity_1.EmailConfiguration)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object])
], EmailConfigurationsService);


/***/ }),

/***/ "./src/modules/emails/email-configurations/entities/email-configuration.entity.ts":
/*!****************************************************************************************!*\
  !*** ./src/modules/emails/email-configurations/entities/email-configuration.entity.ts ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailConfiguration = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const email_entity_1 = __webpack_require__(/*! ../../entities/email.entity */ "./src/modules/emails/entities/email.entity.ts");
let EmailConfiguration = class EmailConfiguration extends base_entity_1.BaseEntity {
};
exports.EmailConfiguration = EmailConfiguration;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "host", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int' }),
    __metadata("design:type", Number)
], EmailConfiguration.prototype, "port", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], EmailConfiguration.prototype, "secure", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "username", void 0);
__decorate([
    (0, typeorm_1.Column)({ select: false }),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "password", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "fromEmail", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "fromName", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], EmailConfiguration.prototype, "isDefault", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => email_entity_1.Email, (email) => email.emailConfiguration, { cascade: true, nullable: true }),
    __metadata("design:type", Array)
], EmailConfiguration.prototype, "emails", void 0);
exports.EmailConfiguration = EmailConfiguration = __decorate([
    (0, typeorm_1.Entity)('email-configurations')
], EmailConfiguration);


/***/ }),

/***/ "./src/modules/emails/email-configurations/services/dynamic-mailer-config.service.ts":
/*!*******************************************************************************************!*\
  !*** ./src/modules/emails/email-configurations/services/dynamic-mailer-config.service.ts ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicMailerConfigService = void 0;
const handlebars_adapter_1 = __webpack_require__(/*! @nestjs-modules/mailer/dist/adapters/handlebars.adapter */ "@nestjs-modules/mailer/dist/adapters/handlebars.adapter");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const email_configurations_service_1 = __webpack_require__(/*! ../email-configurations.service */ "./src/modules/emails/email-configurations/email-configurations.service.ts");
let DynamicMailerConfigService = class DynamicMailerConfigService {
    constructor(emailConfigService) {
        this.emailConfigService = emailConfigService;
    }
    async createMailerOptions() {
        // Get default configuration from database
        const defaultConfig = await this.emailConfigService.getMailerOptions();
        return {
            transport: {
                host: defaultConfig.host,
                port: defaultConfig.port,
                secure: defaultConfig.secure,
                auth: {
                    user: defaultConfig.username,
                    pass: defaultConfig.password,
                },
                debug: process.env.NODE_ENV !== 'production', // Enable debug output
                logger: process.env.NODE_ENV !== 'production', // Log to console
            },
            defaults: {
                from: `"${defaultConfig.fromName || defaultConfig.fromEmail}" <${defaultConfig.fromEmail}>`,
            },
            template: {
                // We'll use in-memory templates instead of filesystem templates
                // since our templates are stored in the database
                adapter: new handlebars_adapter_1.HandlebarsAdapter({
                    // Global helpers can be added here
                    formatDate: (value) => new Date(value).toLocaleDateString(),
                    year: () => new Date().getFullYear(),
                }),
                options: {
                    strict: true,
                },
            },
        };
    }
};
exports.DynamicMailerConfigService = DynamicMailerConfigService;
exports.DynamicMailerConfigService = DynamicMailerConfigService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof email_configurations_service_1.EmailConfigurationsService !== "undefined" && email_configurations_service_1.EmailConfigurationsService) === "function" ? _a : Object])
], DynamicMailerConfigService);


/***/ }),

/***/ "./src/modules/emails/email-templates/dtos/email-template.dto.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/emails/email-templates/dtos/email-template.dto.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetEmailTemplateDto = exports.UpdateEmailTemplateDto = exports.EmailTemplateDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_2 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class EmailTemplateDto extends (0, swagger_2.PartialType)(base_dto_1.BaseDto) {
}
exports.EmailTemplateDto = EmailTemplateDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the email-template' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailTemplateDto.prototype, "name", void 0);
class UpdateEmailTemplateDto extends (0, swagger_2.PartialType)(EmailTemplateDto) {
}
exports.UpdateEmailTemplateDto = UpdateEmailTemplateDto;
class GetEmailTemplateDto extends (0, create_get_dto_factory_1.createGetDto)(EmailTemplateDto) {
}
exports.GetEmailTemplateDto = GetEmailTemplateDto;


/***/ }),

/***/ "./src/modules/emails/email-templates/email-templates.controller.ts":
/*!**************************************************************************!*\
  !*** ./src/modules/emails/email-templates/email-templates.controller.ts ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailTemplatesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const email_template_dto_1 = __webpack_require__(/*! ./dtos/email-template.dto */ "./src/modules/emails/email-templates/dtos/email-template.dto.ts");
const email_templates_service_1 = __webpack_require__(/*! ./email-templates.service */ "./src/modules/emails/email-templates/email-templates.service.ts");
const email_template_entity_1 = __webpack_require__(/*! ./entities/email-template.entity */ "./src/modules/emails/email-templates/entities/email-template.entity.ts");
class EmailTemplatesController extends (0, create_controller_factory_1.createController)(email_template_entity_1.EmailTemplate, email_templates_service_1.EmailTemplatesService, email_template_dto_1.GetEmailTemplateDto, email_template_entity_1.EmailTemplate, email_template_dto_1.UpdateEmailTemplateDto) {
    async previewTemplate(body) {
        return this.baseService.renderTemplate(body.templateName, body.context, body.department);
    }
}
exports.EmailTemplatesController = EmailTemplatesController;
__decorate([
    (0, common_1.Post)('templates/preview'),
    (0, swagger_1.ApiOperation)({ summary: 'Preview rendered email template' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], EmailTemplatesController.prototype, "previewTemplate", null);


/***/ }),

/***/ "./src/modules/emails/email-templates/email-templates.module.ts":
/*!**********************************************************************!*\
  !*** ./src/modules/emails/email-templates/email-templates.module.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailTemplatesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const email_templates_controller_1 = __webpack_require__(/*! ./email-templates.controller */ "./src/modules/emails/email-templates/email-templates.controller.ts");
const email_templates_service_1 = __webpack_require__(/*! ./email-templates.service */ "./src/modules/emails/email-templates/email-templates.service.ts");
const email_template_entity_1 = __webpack_require__(/*! ./entities/email-template.entity */ "./src/modules/emails/email-templates/entities/email-template.entity.ts");
let EmailTemplatesModule = class EmailTemplatesModule {
};
exports.EmailTemplatesModule = EmailTemplatesModule;
exports.EmailTemplatesModule = EmailTemplatesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([email_template_entity_1.EmailTemplate]),
        ],
        providers: [email_templates_service_1.EmailTemplatesService],
        exports: [email_templates_service_1.EmailTemplatesService],
        controllers: [email_templates_controller_1.EmailTemplatesController],
    })
], EmailTemplatesModule);


/***/ }),

/***/ "./src/modules/emails/email-templates/email-templates.service.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/emails/email-templates/email-templates.service.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailTemplatesService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const Handlebars = __importStar(__webpack_require__(/*! handlebars */ "handlebars"));
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const email_template_entity_1 = __webpack_require__(/*! ./entities/email-template.entity */ "./src/modules/emails/email-templates/entities/email-template.entity.ts");
let EmailTemplatesService = class EmailTemplatesService extends base_service_1.BaseService {
    constructor(emailTemplatesRepository, usersService) {
        super(emailTemplatesRepository, usersService);
        this.emailTemplatesRepository = emailTemplatesRepository;
        this.usersService = usersService;
    }
    async findByName(name) {
        const template = await this.emailTemplatesRepository.findOne({ where: { name, isActive: true } });
        if (!template) {
            throw new common_1.NotFoundException(`Email template with name ${name} not found`);
        }
        return template;
    }
    async findDepartmentTemplate(name, departmentId) {
        const template = await this.emailTemplatesRepository.findOne({
            // maybe error here
            where: { name, departmentId, isActive: true }
        });
        if (!template) {
            // Fall back to general template if department-specific not found
            return this.findByName(name);
        }
        return template;
    }
    async renderTemplate(name, context, department) {
        // Get the appropriate template based on department or default
        const template = department
            ? await this.findDepartmentTemplate(name, department).catch(() => this.findByName(name))
            : await this.findByName(name);
        // Compile the templates
        const compiledSubject = Handlebars.compile(template.subject);
        const compiledHtml = Handlebars.compile(template.htmlContent);
        const compiledText = template.textContent ? Handlebars.compile(template.textContent) : null;
        // Render with provided context
        return {
            subject: compiledSubject(context),
            html: compiledHtml(context),
            text: compiledText ? compiledText(context) : undefined,
        };
    }
    async validateContext(templateName, context) {
        const template = await this.findByName(templateName);
        const missingVariables = [];
        if (template.requiredVariables) {
            for (const variable of template.requiredVariables) {
                if (context[variable] === undefined) {
                    missingVariables.push(variable);
                }
            }
        }
        return {
            isValid: missingVariables.length === 0,
            missingVariables
        };
    }
};
exports.EmailTemplatesService = EmailTemplatesService;
exports.EmailTemplatesService = EmailTemplatesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(email_template_entity_1.EmailTemplate)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], EmailTemplatesService);


/***/ }),

/***/ "./src/modules/emails/email-templates/entities/email-template.entity.ts":
/*!******************************************************************************!*\
  !*** ./src/modules/emails/email-templates/entities/email-template.entity.ts ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailTemplate = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
let EmailTemplate = class EmailTemplate extends base_entity_1.BaseEntity {
};
exports.EmailTemplate = EmailTemplate;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], EmailTemplate.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], EmailTemplate.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], EmailTemplate.prototype, "subject", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], EmailTemplate.prototype, "htmlContent", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], EmailTemplate.prototype, "textContent", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], EmailTemplate.prototype, "isActive", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", Array)
], EmailTemplate.prototype, "requiredVariables", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", Array)
], EmailTemplate.prototype, "optionalVariables", void 0);
exports.EmailTemplate = EmailTemplate = __decorate([
    (0, typeorm_1.Entity)('email-templates')
], EmailTemplate);


/***/ }),

/***/ "./src/modules/emails/emails.controller.ts":
/*!*************************************************!*\
  !*** ./src/modules/emails/emails.controller.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const email_dto_1 = __webpack_require__(/*! ./dtos/email.dto */ "./src/modules/emails/dtos/email.dto.ts");
const emails_service_1 = __webpack_require__(/*! ./emails.service */ "./src/modules/emails/emails.service.ts");
const email_entity_1 = __webpack_require__(/*! ./entities/email.entity */ "./src/modules/emails/entities/email.entity.ts");
class EmailsController extends (0, create_controller_factory_1.createController)(email_entity_1.Email, emails_service_1.EmailsService, email_dto_1.GetEmailDto, email_dto_1.EmailDto, email_dto_1.UpdateEmailDto) {
    // // Email sending endpoints
    // @Post('send')
    // @HttpCode(HttpStatus.OK)
    // @ApiOperation({ summary: 'Send an email' })
    // @ApiResponse({ status: HttpStatus.OK, description: 'Email sent successfully' })
    // async sendEmail(@Body() sendEmailDto: EmailDto): Promise<{ success: boolean; message: string }> {
    //   const result = await this.baseService.send(sendEmailDto);
    //   return {
    //     success: result,
    //     message: result 
    //       ? 'Email sent successfully' 
    //       : 'Failed to send email',
    //   };
    // }
    async sendTemplatedEmail(body) {
        const result = await this.baseService.sendTemplatedEmail(body.to, body.templateName, body.context, {
            cc: body.cc,
            bcc: body.bcc,
            department: body.department,
            organization: body.organization,
        });
        return {
            success: result,
            message: result
                ? 'Templated email sent successfully'
                : 'Failed to send templated email',
        };
    }
}
exports.EmailsController = EmailsController;
__decorate([
    (0, common_1.Post)('send-template'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Send a templated email' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Email sent successfully' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], EmailsController.prototype, "sendTemplatedEmail", null);


/***/ }),

/***/ "./src/modules/emails/emails.module.ts":
/*!*********************************************!*\
  !*** ./src/modules/emails/emails.module.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const email_configurations_module_1 = __webpack_require__(/*! ./email-configurations/email-configurations.module */ "./src/modules/emails/email-configurations/email-configurations.module.ts");
const email_templates_module_1 = __webpack_require__(/*! ./email-templates/email-templates.module */ "./src/modules/emails/email-templates/email-templates.module.ts");
const emails_controller_1 = __webpack_require__(/*! ./emails.controller */ "./src/modules/emails/emails.controller.ts");
const emails_service_1 = __webpack_require__(/*! ./emails.service */ "./src/modules/emails/emails.service.ts");
const email_entity_1 = __webpack_require__(/*! ./entities/email.entity */ "./src/modules/emails/entities/email.entity.ts");
const email_seeder_service_1 = __webpack_require__(/*! ./services/email-seeder.service */ "./src/modules/emails/services/email-seeder.service.ts");
let EmailsModule = class EmailsModule {
};
exports.EmailsModule = EmailsModule;
exports.EmailsModule = EmailsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([email_entity_1.Email]),
            core_1.RouterModule.register([
                {
                    path: 'emails',
                    module: EmailsModule,
                },
            ]),
            email_templates_module_1.EmailTemplatesModule,
            email_configurations_module_1.EmailConfigurationsModule,
        ],
        providers: [email_seeder_service_1.EmailSeederService, emails_service_1.EmailsService],
        exports: [
            emails_service_1.EmailsService,
            email_templates_module_1.EmailTemplatesModule,
            email_configurations_module_1.EmailConfigurationsModule,
        ],
        controllers: [emails_controller_1.EmailsController],
    })
], EmailsModule);


/***/ }),

/***/ "./src/modules/emails/emails.service.ts":
/*!**********************************************!*\
  !*** ./src/modules/emails/emails.service.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailsService = void 0;
const email_status_enum_1 = __webpack_require__(/*! @/common/enums/email-status.enum */ "./src/common/enums/email-status.enum.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const mailer_1 = __webpack_require__(/*! @nestjs-modules/mailer */ "@nestjs-modules/mailer");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const email_configurations_service_1 = __webpack_require__(/*! ./email-configurations/email-configurations.service */ "./src/modules/emails/email-configurations/email-configurations.service.ts");
const email_templates_service_1 = __webpack_require__(/*! ./email-templates/email-templates.service */ "./src/modules/emails/email-templates/email-templates.service.ts");
const email_entity_1 = __webpack_require__(/*! ./entities/email.entity */ "./src/modules/emails/entities/email.entity.ts");
let EmailsService = class EmailsService extends base_service_1.BaseService {
    constructor(emailsRepository, usersService, emailConfigService, emailTemplateService, mailerService) {
        super(emailsRepository, usersService);
        this.emailsRepository = emailsRepository;
        this.usersService = usersService;
        this.emailConfigService = emailConfigService;
        this.emailTemplateService = emailTemplateService;
        this.mailerService = mailerService;
    }
    /**
     * Send an email with complete flexibility for sender configuration
     */
    async send(options) {
        // Create a database record immediately with PENDING status
        const emailRecord = new email_entity_1.Email({});
        emailRecord.to = Array.isArray(options.to) ? options.to.join(', ') : options.to;
        emailRecord.cc = Array.isArray(options.cc) ? options.cc.join(', ') : options.cc;
        emailRecord.bcc = Array.isArray(options.bcc) ? options.bcc.join(', ') : options.bcc;
        emailRecord.subject = options.subject || '';
        emailRecord.templateName = options.templateName;
        emailRecord.status = email_status_enum_1.EmailStatus.PENDING;
        emailRecord.sentAt = new Date();
        try {
            // Determine which email configuration to use
            let emailConfig;
            if (options.configId) {
                emailConfig = await this.emailConfigService.findOneByOrFail({ id: options.configId });
            }
            else if (options.configName) {
                emailConfig = await this.emailConfigService.findByName(options.configName);
            }
            else if (options.department) {
                emailConfig = await this.emailConfigService.getDepartmentConfiguration(options.department);
            }
            else if (options.organization) {
                emailConfig = await this.emailConfigService.getOrganizationConfiguration(options.organization);
            }
            else if (options.branch) {
                emailConfig = await this.emailConfigService.getBranchConfiguration(options.branch);
            }
            else {
                emailConfig = await this.emailConfigService.getDefaultConfiguration();
            }
            // Set the email configuration relationship
            emailRecord.emailConfiguration = emailConfig;
            // test connection first before sending
            const testConnection = await this.emailConfigService.testConnection(emailConfig);
            if (!testConnection) {
                this.logger.error(`Failed to connect to email server for configuration: ${emailConfig.name}`);
                return false;
            }
            // Prepare email content
            let subject = options.subject;
            let html = options.html;
            let text = options.text;
            // If using a template
            if (options.templateName) {
                const validation = await this.emailTemplateService.validateContext(options.templateName, options.templateContext || {});
                if (!validation.isValid) {
                    const errorMsg = `Missing required variables for template ${options.templateName}: ${validation.missingVariables.join(', ')}`;
                    this.logger.error(errorMsg);
                    // Update the email record with FAILED status
                    emailRecord.status = email_status_enum_1.EmailStatus.FAILED;
                    emailRecord.error = errorMsg;
                    await this.emailsRepository.save(emailRecord);
                    return false;
                }
                const rendered = await this.emailTemplateService.renderTemplate(options.templateName, options.templateContext || {}, options.department);
                subject = rendered.subject;
                html = rendered.html;
                text = rendered.text;
            }
            // Update email record with content
            emailRecord.subject = subject || '';
            emailRecord.htmlContent = html;
            emailRecord.textContent = text;
            // Create a unique transporter name based on the configuration
            const transporterName = `config_${emailConfig.id}`;
            // Add or update the transporter for this configuration
            this.mailerService.addTransporter(transporterName, {
                host: emailConfig.host,
                port: emailConfig.port,
                secure: emailConfig.secure,
                auth: {
                    user: emailConfig.username,
                    pass: emailConfig.password,
                },
            });
            // Send the email using the specific transporter
            const mailOptions = {
                to: options.to,
                cc: options.cc,
                bcc: options.bcc,
                subject,
                text,
                html,
                attachments: options.attachments,
                from: options.from || `"${emailConfig.fromName || emailConfig.fromEmail}" <${emailConfig.fromEmail}>`,
                transporterName: transporterName, // Use the transporter we just added
            };
            await this.mailerService.sendMail(mailOptions);
            // You can also send the email to the platform emails for the recipients in here
            //
            /// Update the email record with SENT status
            emailRecord.status = email_status_enum_1.EmailStatus.SENT;
            await this.emailsRepository.save(emailRecord);
            this.logger.log(`Email sent to ${options.to}, subject: ${subject}, using config: ${emailConfig.name}`);
            return true;
        }
        catch (error) {
            const errorMessage = `Failed to send email: ${error instanceof Error ? error.message : 'Unknown error'}`;
            this.logger.error(errorMessage, error instanceof Error ? error.stack : undefined);
            // Update the email record with FAILED status and error details
            emailRecord.status = email_status_enum_1.EmailStatus.FAILED;
            emailRecord.error = errorMessage;
            await this.emailsRepository.save(emailRecord);
            return false;
        }
    }
    /**
     * Send a templated email with simpler options
     */
    async sendTemplatedEmail(to, templateName, context, options = {}) {
        return this.send({
            to,
            cc: options.cc,
            bcc: options.bcc,
            templateName,
            templateContext: context,
            department: options.department,
            organization: options.organization,
            branch: options.branch,
            attachments: options.attachments,
        });
    }
    /**
     * Send a direct email without a template
     */
    async sendDirectEmail(to, subject, content, options = {}) {
        return this.send({
            to,
            cc: options.cc,
            bcc: options.bcc,
            subject,
            html: content.html,
            text: content.text,
            department: options.department,
            organization: options.organization,
            branch: options.branch,
            attachments: options.attachments,
        });
    }
    /**
     * Send a notification to multiple recipients
     */
    async sendBulkNotification(recipients, subject, content, options = {}) {
        const batchSize = options.batchSize || 50;
        let success = 0;
        let failed = 0;
        // Process in batches to avoid overwhelming the email server
        for (let i = 0; i < recipients.length; i += batchSize) {
            const batch = recipients.slice(i, i + batchSize);
            for (const recipient of batch) {
                let result;
                if ('templateName' in content) {
                    result = await this.sendTemplatedEmail(recipient, content.templateName, content.context, {
                        department: options.department,
                        organization: options.organization,
                    });
                }
                else {
                    result = await this.sendDirectEmail(recipient, subject, { html: content.html, text: content.text }, {
                        department: options.department,
                        organization: options.organization,
                    });
                }
                if (result) {
                    success++;
                }
                else {
                    failed++;
                }
            }
            // Add a small delay between batches
            if (i + batchSize < recipients.length) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
        return { success, failed };
    }
};
exports.EmailsService = EmailsService;
exports.EmailsService = EmailsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(email_entity_1.Email)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof email_configurations_service_1.EmailConfigurationsService !== "undefined" && email_configurations_service_1.EmailConfigurationsService) === "function" ? _c : Object, typeof (_d = typeof email_templates_service_1.EmailTemplatesService !== "undefined" && email_templates_service_1.EmailTemplatesService) === "function" ? _d : Object, typeof (_e = typeof mailer_1.MailerService !== "undefined" && mailer_1.MailerService) === "function" ? _e : Object])
], EmailsService);


/***/ }),

/***/ "./src/modules/emails/entities/email.entity.ts":
/*!*****************************************************!*\
  !*** ./src/modules/emails/entities/email.entity.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Email = void 0;
const email_status_enum_1 = __webpack_require__(/*! @/common/enums/email-status.enum */ "./src/common/enums/email-status.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const email_configuration_entity_1 = __webpack_require__(/*! ../email-configurations/entities/email-configuration.entity */ "./src/modules/emails/email-configurations/entities/email-configuration.entity.ts");
let Email = class Email extends base_entity_1.BaseEntity {
};
exports.Email = Email;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Email.prototype, "to", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Email.prototype, "cc", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Email.prototype, "bcc", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Email.prototype, "subject", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], Email.prototype, "htmlContent", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], Email.prototype, "textContent", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Email.prototype, "sentAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: email_status_enum_1.EmailStatus }),
    __metadata("design:type", typeof (_b = typeof email_status_enum_1.EmailStatus !== "undefined" && email_status_enum_1.EmailStatus) === "function" ? _b : Object)
], Email.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Email.prototype, "error", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Email.prototype, "templateName", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => email_configuration_entity_1.EmailConfiguration, (emailConfiguration) => emailConfiguration.emails),
    (0, typeorm_1.JoinColumn)({ name: 'emailConfigurationId' }),
    __metadata("design:type", typeof (_c = typeof email_configuration_entity_1.EmailConfiguration !== "undefined" && email_configuration_entity_1.EmailConfiguration) === "function" ? _c : Object)
], Email.prototype, "emailConfiguration", void 0);
exports.Email = Email = __decorate([
    (0, typeorm_1.Entity)('emails')
], Email);


/***/ }),

/***/ "./src/modules/emails/services/email-seeder.service.ts":
/*!*************************************************************!*\
  !*** ./src/modules/emails/services/email-seeder.service.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var EmailSeederService_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailSeederService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const email_configurations_service_1 = __webpack_require__(/*! ../email-configurations/email-configurations.service */ "./src/modules/emails/email-configurations/email-configurations.service.ts");
const email_templates_service_1 = __webpack_require__(/*! ../email-templates/email-templates.service */ "./src/modules/emails/email-templates/email-templates.service.ts");
let EmailSeederService = EmailSeederService_1 = class EmailSeederService {
    constructor(emailConfigService, emailTemplatesService, configService) {
        this.emailConfigService = emailConfigService;
        this.emailTemplatesService = emailTemplatesService;
        this.configService = configService;
        this.logger = new common_1.Logger(EmailSeederService_1.name);
    }
    async onModuleInit() {
        await this.seedDefaultEmailConfiguration();
        await this.seedDefaultEmailTemplates();
    }
    async seedDefaultEmailConfiguration() {
        try {
            // Check if a default configuration already exists
            try {
                await this.emailConfigService.getDefaultConfiguration();
                // this.logger.log('Default email configuration already exists, skipping seeder');
                return;
            }
            catch (error) {
                // No default config exists, proceed with seeding
                // this.logger.log('Creating default email configuration...');
            }
            // Create default email configuration using environment variables
            const defaultConfig = await this.emailConfigService.create({
                name: 'Default System Email',
                description: 'Default email configuration for system emails like verification, password reset, etc.',
                host: this.configService.getOrThrow('EMAIL_HOST'),
                port: this.configService.getOrThrow('EMAIL_PORT'),
                secure: this.configService.getOrThrow('EMAIL_SECURE'),
                username: this.configService.getOrThrow('EMAIL_USERNAME'),
                password: this.configService.getOrThrow('EMAIL_PASSWORD'),
                fromEmail: this.configService.getOrThrow('EMAIL_FROM'),
                fromName: this.configService.getOrThrow('EMAIL_FROM_NAME'),
                isDefault: true,
            });
            // this.logger.log(`Default email configuration created: ${defaultConfig.id}`);
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Failed to seed default email configuration: ${errorMessage}`);
        }
    }
    async seedDefaultEmailTemplates() {
        try {
            // Define default templates to seed
            const templates = [
                {
                    name: 'email-verification',
                    subject: 'Verify Your Email Address',
                    description: 'Email sent to users to verify their email address',
                    htmlContent: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h2>Verify Your Email Address</h2>
              <p>Hello {{firstName}},</p>
              <p>Thank you for registering. Please click the button below to verify your email address:</p>
              <p style="text-align: center;">
                <a href="{{verificationUrl}}" style="background-color: #4CAF50; color: white; padding: 10px 20px; text-decoration: none; border-radius: 4px; display: inline-block;">
                  Verify Email
                </a>
              </p>
              <p>If the button doesn't work, you can copy and paste this link into your browser:</p>
              <p>{{verificationUrl}}</p>
              <p>This link will expire in {{expiry}} hours.</p>
              <p>If you didn't create an account, you can safely ignore this email.</p>
              <p>Thanks,<br>The Team</p>
            </div>
          `,
                    textContent: `
            Verify Your Email Address
            
            Hello {{firstName}},
            
            Thank you for registering. Please click the link below to verify your email address:
            
            {{verificationUrl}}
            
            This link will expire in {{expiry}} hours.
            
            If you didn't create an account, you can safely ignore this email.
            
            Thanks,
            The Team
          `,
                    requiredVariables: ['firstName', 'verificationUrl', 'expiry'],
                    optionalVariables: ['lastName'],
                    isActive: true,
                },
                {
                    name: 'password-reset',
                    subject: 'Reset Your Password',
                    description: 'Email sent to users to reset their password',
                    htmlContent: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h2>Reset Your Password</h2>
              <p>Hello {{firstName}},</p>
              <p>We received a request to reset your password. Click the button below to set a new password:</p>
              <p style="text-align: center;">
                <a href="{{resetUrl}}" style="background-color: #4CAF50; color: white; padding: 10px 20px; text-decoration: none; border-radius: 4px; display: inline-block;">
                  Reset Password
                </a>
              </p>
              <p>If the button doesn't work, you can copy and paste this link into your browser:</p>
              <p>{{resetUrl}}</p>
              <p>This link will expire in 1 hour.</p>
              <p>If you didn't request a password reset, you can safely ignore this email.</p>
              <p>Thanks,<br>The Team</p>
            </div>
          `,
                    textContent: `
            Reset Your Password
            
            Hello {{firstName}},
            
            We received a request to reset your password. Click the link below to set a new password:
            
            {{resetUrl}}
            
            This link will expire in 1 hour.
            
            If you didn't request a password reset, you can safely ignore this email.
            
            Thanks,
            The Team
          `,
                    requiredVariables: ['firstName', 'resetUrl'],
                    optionalVariables: ['lastName'],
                    isActive: true,
                },
                {
                    name: 'welcome',
                    subject: 'Welcome to {{appName}}',
                    description: 'Welcome email sent to users after registration',
                    htmlContent: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h2>Welcome to {{appName}}!</h2>
              <p>Hello {{firstName}},</p>
              <p>Thank you for joining us. We're excited to have you as a member of our community.</p>
              <p>Here are a few things you can do to get started:</p>
              <ul>
                <li>Complete your profile</li>
                <li>Explore our features</li>
                <li>Connect with other members</li>
              </ul>
              <p>If you have any questions, feel free to reply to this email.</p>
              <p>Best regards,<br>The {{appName}} Team</p>
            </div>
          `,
                    textContent: `
            Welcome to {{appName}}!
            
            Hello {{firstName}},
            
            Thank you for joining us. We're excited to have you as a member of our community.
            
            Here are a few things you can do to get started:
            - Complete your profile
            - Explore our features
            - Connect with other members
            
            If you have any questions, feel free to reply to this email.
            
            Best regards,
            The {{appName}} Team
          `,
                    requiredVariables: ['firstName', 'appName'],
                    optionalVariables: ['lastName'],
                    isActive: true,
                }
            ];
            // Seed each template if it doesn't exist
            for (const template of templates) {
                // Check if template already exists
                try {
                    await this.emailTemplatesService.findByName(template.name);
                    // this.logger.log(`Email template '${template.name}' already exists, skipping`);
                }
                catch (error) {
                    // Template doesn't exist, create it
                    const createdTemplate = await this.emailTemplatesService.create(template);
                    // this.logger.log(`Created email template: ${template.name} (${createdTemplate.id})`);
                }
            }
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Failed to seed email templates: ${errorMessage}`);
        }
    }
};
exports.EmailSeederService = EmailSeederService;
exports.EmailSeederService = EmailSeederService = EmailSeederService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof email_configurations_service_1.EmailConfigurationsService !== "undefined" && email_configurations_service_1.EmailConfigurationsService) === "function" ? _a : Object, typeof (_b = typeof email_templates_service_1.EmailTemplatesService !== "undefined" && email_templates_service_1.EmailTemplatesService) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object])
], EmailSeederService);


/***/ }),

/***/ "./src/modules/employee-management/dtos/employee.dto.ts":
/*!**************************************************************!*\
  !*** ./src/modules/employee-management/dtos/employee.dto.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetEmployeeDto = exports.UpdateEmployeeDto = exports.EmployeeDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const reference_dto_1 = __webpack_require__(/*! @/common/dtos/reference.dto */ "./src/common/dtos/reference.dto.ts");
const employment_condition_enum_1 = __webpack_require__(/*! @/common/enums/employment/employment-condition.enum */ "./src/common/enums/employment/employment-condition.enum.ts");
const employment_status_enum_1 = __webpack_require__(/*! @/common/enums/employment/employment-status.enum */ "./src/common/enums/employment/employment-status.enum.ts");
const employment_type_enum_1 = __webpack_require__(/*! @/common/enums/employment/employment-type.enum */ "./src/common/enums/employment/employment-type.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class EmployeeDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.EmployeeDto = EmployeeDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User ID associated with the employee' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], EmployeeDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employment status of the employee',
        enum: employment_status_enum_1.EmploymentStatus,
        default: employment_status_enum_1.EmploymentStatus.PENDING,
    }),
    (0, class_validator_1.IsEnum)(employment_status_enum_1.EmploymentStatus),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_a = typeof employment_status_enum_1.EmploymentStatus !== "undefined" && employment_status_enum_1.EmploymentStatus) === "function" ? _a : Object)
], EmployeeDto.prototype, "employmentStatus", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employment condition of the employee',
        enum: employment_condition_enum_1.EmploymentCondition,
        default: employment_condition_enum_1.EmploymentCondition.PROBATIONARY,
    }),
    (0, class_validator_1.IsEnum)(employment_condition_enum_1.EmploymentCondition),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_b = typeof employment_condition_enum_1.EmploymentCondition !== "undefined" && employment_condition_enum_1.EmploymentCondition) === "function" ? _b : Object)
], EmployeeDto.prototype, "employmentCondition", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employment type of the employee',
        enum: employment_type_enum_1.EmploymentType,
        default: employment_type_enum_1.EmploymentType.FULL_TIME,
    }),
    (0, class_validator_1.IsEnum)(employment_type_enum_1.EmploymentType),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_c = typeof employment_type_enum_1.EmploymentType !== "undefined" && employment_type_enum_1.EmploymentType) === "function" ? _c : Object)
], EmployeeDto.prototype, "employmentType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date when employee commenced work',
        type: Date,
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], EmployeeDto.prototype, "commencementDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Available leave credits',
        required: false,
        default: 0,
        minimum: 0,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], EmployeeDto.prototype, "leaveCredits", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Monthly rate of the employee',
        required: false,
        default: 0,
        type: Number,
        minimum: 0
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({ maxDecimalPlaces: 2 }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], EmployeeDto.prototype, "monthlyRate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Roles associated with this employee',
        type: [reference_dto_1.ReferenceDto]
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], EmployeeDto.prototype, "roles", void 0);
class UpdateEmployeeDto extends (0, swagger_1.PartialType)(EmployeeDto) {
}
exports.UpdateEmployeeDto = UpdateEmployeeDto;
class GetEmployeeDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateEmployeeDto, "employee") {
}
exports.GetEmployeeDto = GetEmployeeDto;


/***/ }),

/***/ "./src/modules/employee-management/employee-management.module.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/employee-management/employee-management.module.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeeManagementModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const employee_payroll_item_types_module_1 = __webpack_require__(/*! ./employee-payroll-item-types/employee-payroll-item-types.module */ "./src/modules/employee-management/employee-payroll-item-types/employee-payroll-item-types.module.ts");
const employees_controller_1 = __webpack_require__(/*! ./employees.controller */ "./src/modules/employee-management/employees.controller.ts");
const employees_service_1 = __webpack_require__(/*! ./employees.service */ "./src/modules/employee-management/employees.service.ts");
const employee_entity_1 = __webpack_require__(/*! ./entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const permissions_module_1 = __webpack_require__(/*! ./roles/permissions/permissions.module */ "./src/modules/employee-management/roles/permissions/permissions.module.ts");
const roles_module_1 = __webpack_require__(/*! ./roles/roles.module */ "./src/modules/employee-management/roles/roles.module.ts");
let EmployeeManagementModule = class EmployeeManagementModule {
};
exports.EmployeeManagementModule = EmployeeManagementModule;
exports.EmployeeManagementModule = EmployeeManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([employee_entity_1.Employee]),
            roles_module_1.RolesModule,
            core_1.RouterModule.register([
                {
                    path: 'employees',
                    module: EmployeeManagementModule,
                    children: [
                        {
                            path: 'roles',
                            module: roles_module_1.RolesModule,
                            children: [
                                {
                                    path: 'permissions',
                                    module: permissions_module_1.PermissionsModule,
                                }
                            ]
                        },
                        {
                            path: 'payroll-item-types',
                            module: employee_payroll_item_types_module_1.EmployeePayrollItemTypesModule
                        }
                    ]
                }
            ]),
            roles_module_1.RolesModule,
            employee_payroll_item_types_module_1.EmployeePayrollItemTypesModule,
        ],
        providers: [employees_service_1.EmployeesService],
        exports: [
            roles_module_1.RolesModule,
            employees_service_1.EmployeesService,
            employee_payroll_item_types_module_1.EmployeePayrollItemTypesModule,
        ],
        controllers: [employees_controller_1.EmployeesController],
    })
], EmployeeManagementModule);


/***/ }),

/***/ "./src/modules/employee-management/employee-payroll-item-types/dtos/employee-compensation.dto.ts":
/*!*******************************************************************************************************!*\
  !*** ./src/modules/employee-management/employee-payroll-item-types/dtos/employee-compensation.dto.ts ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeeCompensationDto = void 0;
const occurrence_enum_1 = __webpack_require__(/*! @/common/enums/occurrence.enum */ "./src/common/enums/occurrence.enum.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class EmployeeCompensationDto {
}
exports.EmployeeCompensationDto = EmployeeCompensationDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The type of rate occurrence',
        enum: occurrence_enum_1.Occurrence,
        example: occurrence_enum_1.Occurrence.MONTHLY,
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(occurrence_enum_1.Occurrence),
    __metadata("design:type", typeof (_a = typeof occurrence_enum_1.Occurrence !== "undefined" && occurrence_enum_1.Occurrence) === "function" ? _a : Object)
], EmployeeCompensationDto.prototype, "rateType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The compensation amount',
        example: 30000,
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], EmployeeCompensationDto.prototype, "amount", void 0);


/***/ }),

/***/ "./src/modules/employee-management/employee-payroll-item-types/dtos/employee-payroll-item-type.dto.ts":
/*!************************************************************************************************************!*\
  !*** ./src/modules/employee-management/employee-payroll-item-types/dtos/employee-payroll-item-type.dto.ts ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetEmployeePayrollItemTypeDto = exports.UpdateEmployeePayrollItemTypeDto = exports.EmployeePayrollItemTypeDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const reference_dto_1 = __webpack_require__(/*! @/common/dtos/reference.dto */ "./src/common/dtos/reference.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class EmployeePayrollItemTypeDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.EmployeePayrollItemTypeDto = EmployeePayrollItemTypeDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employee reference',
        required: true
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _a : Object)
], EmployeePayrollItemTypeDto.prototype, "employee", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Payroll item type reference',
        required: true
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_b = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _b : Object)
], EmployeePayrollItemTypeDto.prototype, "payrollItemType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Reference number for this payroll item type',
        example: 'REF-12345',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], EmployeePayrollItemTypeDto.prototype, "referenceNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether this payroll item type is active',
        example: true,
        default: true
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], EmployeePayrollItemTypeDto.prototype, "isActive", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether this payroll item type is applicable',
        example: true,
        default: true
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], EmployeePayrollItemTypeDto.prototype, "isApplicable", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Amount value for this payroll item type',
        example: 1000.50,
        required: false,
        type: Number
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], EmployeePayrollItemTypeDto.prototype, "amount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Percentage value for this payroll item type',
        example: 15.5,
        required: false,
        type: Number,
        minimum: 0,
        maximum: 100
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.Max)(100),
    __metadata("design:type", Number)
], EmployeePayrollItemTypeDto.prototype, "percentage", void 0);
class UpdateEmployeePayrollItemTypeDto extends (0, swagger_1.PartialType)(EmployeePayrollItemTypeDto) {
}
exports.UpdateEmployeePayrollItemTypeDto = UpdateEmployeePayrollItemTypeDto;
class GetEmployeePayrollItemTypeDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateEmployeePayrollItemTypeDto, 'employee payroll item type') {
}
exports.GetEmployeePayrollItemTypeDto = GetEmployeePayrollItemTypeDto;


/***/ }),

/***/ "./src/modules/employee-management/employee-payroll-item-types/employee-payroll-item-types.controller.ts":
/*!***************************************************************************************************************!*\
  !*** ./src/modules/employee-management/employee-payroll-item-types/employee-payroll-item-types.controller.ts ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeePayrollItemTypesController = void 0;
const authorize_decorator_1 = __webpack_require__(/*! @/common/decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const current_user_decorator_1 = __webpack_require__(/*! @/common/decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const generalresponse_dto_1 = __webpack_require__(/*! @/common/dtos/generalresponse.dto */ "./src/common/dtos/generalresponse.dto.ts");
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const payroll_item_dto_1 = __webpack_require__(/*! @/modules/payroll-management/payroll-items/dtos/payroll-item.dto */ "./src/modules/payroll-management/payroll-items/dtos/payroll-item.dto.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const employee_compensation_dto_1 = __webpack_require__(/*! ./dtos/employee-compensation.dto */ "./src/modules/employee-management/employee-payroll-item-types/dtos/employee-compensation.dto.ts");
const employee_payroll_item_type_dto_1 = __webpack_require__(/*! ./dtos/employee-payroll-item-type.dto */ "./src/modules/employee-management/employee-payroll-item-types/dtos/employee-payroll-item-type.dto.ts");
const employee_payroll_item_types_service_1 = __webpack_require__(/*! ./employee-payroll-item-types.service */ "./src/modules/employee-management/employee-payroll-item-types/employee-payroll-item-types.service.ts");
const employee_payroll_item_type_entity_1 = __webpack_require__(/*! ./entities/employee-payroll-item-type.entity */ "./src/modules/employee-management/employee-payroll-item-types/entities/employee-payroll-item-type.entity.ts");
class EmployeePayrollItemTypesController extends (0, create_controller_factory_1.createController)(employee_payroll_item_type_entity_1.EmployeePayrollItemType, // Entity name for Swagger documentation
employee_payroll_item_types_service_1.EmployeePayrollItemTypesService, // The service handling EmployeePayrollItemType-related operations
employee_payroll_item_type_dto_1.GetEmployeePayrollItemTypeDto, // DTO for retrieving EmployeePayrollItemTypes
employee_payroll_item_type_dto_1.EmployeePayrollItemTypeDto, // DTO for creating EmployeePayrollItemTypes
employee_payroll_item_type_dto_1.UpdateEmployeePayrollItemTypeDto) {
    async deleteMany(ids, hardDelete) {
        return super.deleteMany(ids, hardDelete);
    }
    async delete(id) {
        return super.delete(id);
    }
    async setupEmployeeCompensation(employeeId, dto, userId) {
        const compensation = await this.baseService.setupEmployeeCompensation(dto, employeeId, userId);
        return (0, class_transformer_1.plainToInstance)(payroll_item_dto_1.GetPayrollItemDto, compensation);
    }
}
exports.EmployeePayrollItemTypesController = EmployeePayrollItemTypesController;
__decorate([
    (0, common_1.Post)('base-compensation/:employeeId'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.CREATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Setup employee base compensation',
        description: 'Set up default compensation for an employee. Deactivates any existing base compensation items before creating a new one.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'employeeId',
        description: 'The unique identifier of the employee',
        example: 'fa985931-6d3f-4468-a1d9-f071a3cb930c',
        type: 'uuid',
        required: true,
    }),
    (0, swagger_1.ApiBody)({
        description: 'Employee compensation details',
        type: employee_compensation_dto_1.EmployeeCompensationDto,
        required: true,
    }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Compensation has been successfully set up',
        type: payroll_item_dto_1.GetPayrollItemDto
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid employee ID format or invalid rate type', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Employee or payroll item type not found', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal server error', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized', type: generalresponse_dto_1.GeneralResponseDto }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'Forbidden', type: generalresponse_dto_1.GeneralResponseDto }),
    __param(0, (0, common_1.Param)('employeeId', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_a = typeof employee_compensation_dto_1.EmployeeCompensationDto !== "undefined" && employee_compensation_dto_1.EmployeeCompensationDto) === "function" ? _a : Object, String]),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], EmployeePayrollItemTypesController.prototype, "setupEmployeeCompensation", null);


/***/ }),

/***/ "./src/modules/employee-management/employee-payroll-item-types/employee-payroll-item-types.module.ts":
/*!***********************************************************************************************************!*\
  !*** ./src/modules/employee-management/employee-payroll-item-types/employee-payroll-item-types.module.ts ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeePayrollItemTypesModule = void 0;
const payroll_item_types_module_1 = __webpack_require__(/*! @/modules/payroll-management/payroll-item-types/payroll-item-types.module */ "./src/modules/payroll-management/payroll-item-types/payroll-item-types.module.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const employee_payroll_item_types_controller_1 = __webpack_require__(/*! ./employee-payroll-item-types.controller */ "./src/modules/employee-management/employee-payroll-item-types/employee-payroll-item-types.controller.ts");
const employee_payroll_item_types_service_1 = __webpack_require__(/*! ./employee-payroll-item-types.service */ "./src/modules/employee-management/employee-payroll-item-types/employee-payroll-item-types.service.ts");
const employee_payroll_item_type_entity_1 = __webpack_require__(/*! ./entities/employee-payroll-item-type.entity */ "./src/modules/employee-management/employee-payroll-item-types/entities/employee-payroll-item-type.entity.ts");
let EmployeePayrollItemTypesModule = class EmployeePayrollItemTypesModule {
};
exports.EmployeePayrollItemTypesModule = EmployeePayrollItemTypesModule;
exports.EmployeePayrollItemTypesModule = EmployeePayrollItemTypesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([employee_payroll_item_type_entity_1.EmployeePayrollItemType]),
            payroll_item_types_module_1.PayrollItemTypesModule,
        ],
        providers: [employee_payroll_item_types_service_1.EmployeePayrollItemTypesService],
        exports: [employee_payroll_item_types_service_1.EmployeePayrollItemTypesService],
        controllers: [employee_payroll_item_types_controller_1.EmployeePayrollItemTypesController],
    })
], EmployeePayrollItemTypesModule);


/***/ }),

/***/ "./src/modules/employee-management/employee-payroll-item-types/employee-payroll-item-types.service.ts":
/*!************************************************************************************************************!*\
  !*** ./src/modules/employee-management/employee-payroll-item-types/employee-payroll-item-types.service.ts ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeePayrollItemTypesService = void 0;
const occurrence_enum_1 = __webpack_require__(/*! @/common/enums/occurrence.enum */ "./src/common/enums/occurrence.enum.ts");
const payroll_item_category_enum_1 = __webpack_require__(/*! @/common/enums/payroll/payroll-item-category.enum */ "./src/common/enums/payroll/payroll-item-category.enum.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const employee_compensation_dto_1 = __webpack_require__(/*! @/modules/employee-management/employee-payroll-item-types/dtos/employee-compensation.dto */ "./src/modules/employee-management/employee-payroll-item-types/dtos/employee-compensation.dto.ts");
const payroll_item_types_service_1 = __webpack_require__(/*! @/modules/payroll-management/payroll-item-types/payroll-item-types.service */ "./src/modules/payroll-management/payroll-item-types/payroll-item-types.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const employee_payroll_item_type_entity_1 = __webpack_require__(/*! ./entities/employee-payroll-item-type.entity */ "./src/modules/employee-management/employee-payroll-item-types/entities/employee-payroll-item-type.entity.ts");
let EmployeePayrollItemTypesService = class EmployeePayrollItemTypesService extends base_service_1.BaseService {
    constructor(employeePayrollItemTypesRepository, usersService, payrollItemTypesService) {
        super(employeePayrollItemTypesRepository, usersService);
        this.employeePayrollItemTypesRepository = employeePayrollItemTypesRepository;
        this.usersService = usersService;
        this.payrollItemTypesService = payrollItemTypesService;
    }
    /**
     * Set up an employee's default compensation
     * @param employeeId Employee ID
     * @param rateType Type of rate (MONTHLY, DAILY, HOURLY)
     * @param amount Rate amount
     * @param userId User performing the action
     */
    async setupEmployeeCompensation(dto, employeeId, userId) {
        const { rateType, amount } = dto;
        // Deactivate any existing compensation items
        const existingItems = await this.employeePayrollItemTypesRepository.find({
            where: {
                employee: { id: employeeId },
                payrollItemType: { category: payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION },
                isActive: true
            },
            relations: { payrollItemType: true, employee: true },
        });
        // Get the appropriate payroll item type
        let itemTypeName;
        switch (rateType) {
            case occurrence_enum_1.Occurrence.MONTHLY:
                itemTypeName = 'Monthly Salary';
                break;
            case occurrence_enum_1.Occurrence.DAILY:
                itemTypeName = 'Daily Rate';
                break;
            case occurrence_enum_1.Occurrence.HOURLY:
                itemTypeName = 'Hourly Rate';
                break;
            default:
                throw new common_1.BadRequestException(`Invalid rate type: ${rateType}`);
        }
        const payrollItemType = await this.payrollItemTypesService.findOneByOrFail({
            name: itemTypeName,
            isActive: true
        });
        // Create new compensation item
        const newItem = new employee_payroll_item_type_entity_1.EmployeePayrollItemType({
            employee: { id: employeeId },
            payrollItemType,
            amount,
            isActive: true,
        });
        for (const item of existingItems) {
            await this.update(item.id, { isActive: false }, userId);
        }
        return this.create(newItem, userId);
    }
    /**
     * Gets the base compensation item for an employee
     */
    async getEmployeeBaseCompensation(employeeId) {
        // Find the employee's active compensation item
        const compensationItems = await this.employeePayrollItemTypesRepository.find({
            where: {
                employee: { id: employeeId },
                payrollItemType: { category: payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION },
                isActive: true
            },
            relations: { payrollItemType: true, employee: true },
            order: { createdAt: 'DESC' }
        });
        if (!compensationItems.length) {
            throw new common_1.BadRequestException(`No active base compensation defined for employee ${employeeId}`);
        }
        let compensation = new employee_compensation_dto_1.EmployeeCompensationDto();
        // Prioritize Monthly Salary over Daily Rate over Hourly Rate
        const monthlyItem = compensationItems.find(item => item.payrollItemType.name === 'Monthly Salary');
        if (monthlyItem) {
            compensation.rateType = occurrence_enum_1.Occurrence.MONTHLY;
            compensation.amount = monthlyItem.amount || monthlyItem.payrollItemType.defaultAmount || 0;
            return compensation;
        }
        const dailyItem = compensationItems.find(item => item.payrollItemType.name === 'Daily Rate');
        if (dailyItem) {
            compensation.rateType = occurrence_enum_1.Occurrence.DAILY;
            compensation.amount = dailyItem.amount || dailyItem.payrollItemType.defaultAmount || 0;
            return compensation;
        }
        const hourlyItem = compensationItems.find(item => item.payrollItemType.name === 'Hourly Rate');
        if (hourlyItem) {
            compensation.rateType = occurrence_enum_1.Occurrence.HOURLY;
            compensation.amount = hourlyItem.amount || hourlyItem.payrollItemType.defaultAmount || 0;
            return compensation;
        }
        // Default to the first compensation item found
        compensation.rateType = compensationItems[0].payrollItemType.defaultOccurrence;
        compensation.amount = compensationItems[0].amount || compensationItems[0].payrollItemType.defaultAmount || 0;
        return compensation;
    }
};
exports.EmployeePayrollItemTypesService = EmployeePayrollItemTypesService;
exports.EmployeePayrollItemTypesService = EmployeePayrollItemTypesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(employee_payroll_item_type_entity_1.EmployeePayrollItemType)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof payroll_item_types_service_1.PayrollItemTypesService !== "undefined" && payroll_item_types_service_1.PayrollItemTypesService) === "function" ? _c : Object])
], EmployeePayrollItemTypesService);


/***/ }),

/***/ "./src/modules/employee-management/employee-payroll-item-types/entities/employee-payroll-item-type.entity.ts":
/*!*******************************************************************************************************************!*\
  !*** ./src/modules/employee-management/employee-payroll-item-types/entities/employee-payroll-item-type.entity.ts ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeePayrollItemType = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const payroll_item_type_entity_1 = __webpack_require__(/*! @/modules/payroll-management/payroll-item-types/entities/payroll-item-type.entity */ "./src/modules/payroll-management/payroll-item-types/entities/payroll-item-type.entity.ts");
const payroll_item_entity_1 = __webpack_require__(/*! @/modules/payroll-management/payroll-items/entities/payroll-item.entity */ "./src/modules/payroll-management/payroll-items/entities/payroll-item.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const employee_entity_1 = __webpack_require__(/*! ../../entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
let EmployeePayrollItemType = class EmployeePayrollItemType extends base_entity_1.BaseEntity {
};
exports.EmployeePayrollItemType = EmployeePayrollItemType;
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.payrollItemTypes, { cascade: true }),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_a = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _a : Object)
], EmployeePayrollItemType.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => payroll_item_type_entity_1.PayrollItemType, (payrollItemType) => payrollItemType.employeePayrollItemTypes, { cascade: true }),
    (0, typeorm_1.JoinColumn)({ name: 'payrollItemTypeId' }),
    __metadata("design:type", typeof (_b = typeof payroll_item_type_entity_1.PayrollItemType !== "undefined" && payroll_item_type_entity_1.PayrollItemType) === "function" ? _b : Object)
], EmployeePayrollItemType.prototype, "payrollItemType", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => payroll_item_entity_1.PayrollItem, (payrollItem) => payrollItem.employeePayrollItemType, { nullable: true }),
    __metadata("design:type", Array)
], EmployeePayrollItemType.prototype, "payrollItems", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], EmployeePayrollItemType.prototype, "referenceNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], EmployeePayrollItemType.prototype, "isActive", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], EmployeePayrollItemType.prototype, "isApplicable", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 15,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], EmployeePayrollItemType.prototype, "amount", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 15,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], EmployeePayrollItemType.prototype, "percentage", void 0);
exports.EmployeePayrollItemType = EmployeePayrollItemType = __decorate([
    (0, typeorm_1.Entity)('employee-payroll-item-types')
], EmployeePayrollItemType);


/***/ }),

/***/ "./src/modules/employee-management/employees.controller.ts":
/*!*****************************************************************!*\
  !*** ./src/modules/employee-management/employees.controller.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const employee_dto_1 = __webpack_require__(/*! ./dtos/employee.dto */ "./src/modules/employee-management/dtos/employee.dto.ts");
const employees_service_1 = __webpack_require__(/*! ./employees.service */ "./src/modules/employee-management/employees.service.ts");
const employee_entity_1 = __webpack_require__(/*! ./entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
class EmployeesController extends (0, create_controller_factory_1.createController)(employee_entity_1.Employee, employees_service_1.EmployeesService, employee_dto_1.GetEmployeeDto, employee_dto_1.EmployeeDto, employee_dto_1.UpdateEmployeeDto) {
}
exports.EmployeesController = EmployeesController;


/***/ }),

/***/ "./src/modules/employee-management/employees.service.ts":
/*!**************************************************************!*\
  !*** ./src/modules/employee-management/employees.service.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeesService = void 0;
const role_enum_1 = __webpack_require__(/*! @/common/enums/role.enum */ "./src/common/enums/role.enum.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const employee_entity_1 = __webpack_require__(/*! ./entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const roles_service_1 = __webpack_require__(/*! ./roles/roles.service */ "./src/modules/employee-management/roles/roles.service.ts");
let EmployeesService = class EmployeesService extends base_service_1.BaseService {
    constructor(employeesRepository, usersService, rolesService) {
        super(employeesRepository, usersService);
        this.employeesRepository = employeesRepository;
        this.usersService = usersService;
        this.rolesService = rolesService;
    }
    async create(createDto, createdBy) {
        var _a, _b;
        // Get the highest employee number
        const highestEmpNum = await this.employeesRepository
            .createQueryBuilder('employee')
            .select('MAX(employee.employeeNumber)', 'max')
            .getRawOne();
        // Increment by 1 (or start at 1000 if no employees exist)
        const nextEmpNum = ((highestEmpNum === null || highestEmpNum === void 0 ? void 0 : highestEmpNum.max) || 999) + 1;
        // check if createDto has employeeNumber
        if (!createDto.employeeNumber) {
            createDto.employeeNumber = nextEmpNum;
        }
        // find employee role by name
        const employeeRole = await this.rolesService.findOneByOrFail({
            name: role_enum_1.Role.EMPLOYEE,
        });
        // store temporary roles
        const tempRoles = createDto.roles || [];
        // filter out non existing roles
        const existingRoles = await this.rolesService.getRepository().findBy({
            id: (0, typeorm_2.In)(tempRoles.map(role => role.id)),
        });
        // map existing roles id to the createDto
        createDto.roles = existingRoles.map(role => {
            return {
                id: role.id,
            };
        });
        // assign employee role to employee by adding to the roles array
        if (!((_a = createDto.roles) === null || _a === void 0 ? void 0 : _a.some(role => role.id === employeeRole.id))) {
            (_b = createDto.roles) === null || _b === void 0 ? void 0 : _b.push(employeeRole);
        }
        // find the user id
        if (createDto.userId) {
            const user = await this.usersService.findOneByOrFail({ id: createDto.userId });
            user.isEmployee = true;
            await this.usersService.update(user.id, user, createdBy);
            createDto.user = user;
        }
        else {
            // if no userId is provided, throw an error
            throw new common_1.NotFoundException('User ID is required to create an employee');
        }
        return await super.create(createDto, createdBy);
    }
    async getEmployeesByIds(employeeIds) {
        const employees = await this.employeesRepository.findBy({
            id: (0, typeorm_2.In)(employeeIds),
        });
        if (employees.length !== employeeIds.length) {
            throw new common_1.NotFoundException('Employee/s does not exist');
        }
        return employees;
    }
};
exports.EmployeesService = EmployeesService;
exports.EmployeesService = EmployeesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(employee_entity_1.Employee)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof roles_service_1.RolesService !== "undefined" && roles_service_1.RolesService) === "function" ? _c : Object])
], EmployeesService);


/***/ }),

/***/ "./src/modules/employee-management/entities/employee.entity.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/employee-management/entities/employee.entity.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Employee = void 0;
const employment_condition_enum_1 = __webpack_require__(/*! @/common/enums/employment/employment-condition.enum */ "./src/common/enums/employment/employment-condition.enum.ts");
const employment_status_enum_1 = __webpack_require__(/*! @/common/enums/employment/employment-status.enum */ "./src/common/enums/employment/employment-status.enum.ts");
const employment_type_enum_1 = __webpack_require__(/*! @/common/enums/employment/employment-type.enum */ "./src/common/enums/employment/employment-type.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const user_entity_1 = __webpack_require__(/*! @/modules/account-management/users/entities/user.entity */ "./src/modules/account-management/users/entities/user.entity.ts");
const attendance_entity_1 = __webpack_require__(/*! @/modules/attendance-management/entities/attendance.entity */ "./src/modules/attendance-management/entities/attendance.entity.ts");
const final_work_hour_entity_1 = __webpack_require__(/*! @/modules/attendance-management/final-work-hours/entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
const work_time_request_entity_1 = __webpack_require__(/*! @/modules/attendance-management/work-time-requests/entities/work-time-request.entity */ "./src/modules/attendance-management/work-time-requests/entities/work-time-request.entity.ts");
const memorandum_entity_1 = __webpack_require__(/*! @/modules/compliance-management/memorandums/entities/memorandum.entity */ "./src/modules/compliance-management/memorandums/entities/memorandum.entity.ts");
const memorandum_flow_entity_1 = __webpack_require__(/*! @/modules/compliance-management/memorandums/memorandum-flows/entities/memorandum-flow.entity */ "./src/modules/compliance-management/memorandums/memorandum-flows/entities/memorandum-flow.entity.ts");
const memorandum_recipient_entity_1 = __webpack_require__(/*! @/modules/compliance-management/memorandums/memorandum-recipients/entities/memorandum-recipient.entity */ "./src/modules/compliance-management/memorandums/memorandum-recipients/entities/memorandum-recipient.entity.ts");
const role_entity_1 = __webpack_require__(/*! @/modules/employee-management/roles/entities/role.entity */ "./src/modules/employee-management/roles/entities/role.entity.ts");
const payroll_entity_1 = __webpack_require__(/*! @/modules/payroll-management/entities/payroll.entity */ "./src/modules/payroll-management/entities/payroll.entity.ts");
const group_entity_1 = __webpack_require__(/*! @/modules/shift-management/groups/entities/group.entity */ "./src/modules/shift-management/groups/entities/group.entity.ts");
const schedule_entity_1 = __webpack_require__(/*! @/modules/shift-management/schedules/entities/schedule.entity */ "./src/modules/shift-management/schedules/entities/schedule.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const employee_payroll_item_type_entity_1 = __webpack_require__(/*! ../employee-payroll-item-types/entities/employee-payroll-item-type.entity */ "./src/modules/employee-management/employee-payroll-item-types/entities/employee-payroll-item-type.entity.ts");
let Employee = class Employee extends base_entity_1.BaseEntity {
};
exports.Employee = Employee;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", Number)
], Employee.prototype, "employeeNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: employment_status_enum_1.EmploymentStatus,
        default: employment_status_enum_1.EmploymentStatus.PENDING
    }),
    __metadata("design:type", typeof (_a = typeof employment_status_enum_1.EmploymentStatus !== "undefined" && employment_status_enum_1.EmploymentStatus) === "function" ? _a : Object)
], Employee.prototype, "employmentStatus", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: employment_condition_enum_1.EmploymentCondition,
        default: employment_condition_enum_1.EmploymentCondition.PROBATIONARY
    }),
    __metadata("design:type", typeof (_b = typeof employment_condition_enum_1.EmploymentCondition !== "undefined" && employment_condition_enum_1.EmploymentCondition) === "function" ? _b : Object)
], Employee.prototype, "employmentCondition", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Employee.prototype, "biometricsPassword", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", Number)
], Employee.prototype, "biometricsRole", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Employee.prototype, "cardNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: employment_type_enum_1.EmploymentType,
        default: employment_type_enum_1.EmploymentType.FULL_TIME
    }),
    __metadata("design:type", typeof (_c = typeof employment_type_enum_1.EmploymentType !== "undefined" && employment_type_enum_1.EmploymentType) === "function" ? _c : Object)
], Employee.prototype, "employmentType", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], Employee.prototype, "commencementDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 0 }),
    __metadata("design:type", Number)
], Employee.prototype, "leaveCredits", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 0 }),
    __metadata("design:type", Number)
], Employee.prototype, "offsetLeaveCredits", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => user_entity_1.User, (user) => user.employee, { eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_e = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _e : Object)
], Employee.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => role_entity_1.Role, (role) => role.employees, { nullable: true }),
    (0, typeorm_1.JoinTable)({
        name: 'employee_roles',
        joinColumn: { name: 'employee_id', referencedColumnName: 'id' },
        inverseJoinColumn: { name: 'role_id', referencedColumnName: 'id' },
    }),
    __metadata("design:type", Array)
], Employee.prototype, "roles", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => employee_payroll_item_type_entity_1.EmployeePayrollItemType, (employeePayrollItemType) => employeePayrollItemType.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "payrollItemTypes", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => group_entity_1.Group, (group) => group.employees, { nullable: true, eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'groupId' }),
    __metadata("design:type", typeof (_f = typeof group_entity_1.Group !== "undefined" && group_entity_1.Group) === "function" ? _f : Object)
], Employee.prototype, "group", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => schedule_entity_1.Schedule, (schedule) => schedule.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "schedules", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => attendance_entity_1.Attendance, (attendance) => attendance.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "attendances", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => final_work_hour_entity_1.FinalWorkHour, (finalWorkHour) => finalWorkHour.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "finalWorkHours", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => payroll_entity_1.Payroll, (payroll) => payroll.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "payrolls", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => work_time_request_entity_1.WorkTimeRequest, (workTimeRequest) => workTimeRequest.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "workTimeRequests", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => memorandum_entity_1.Memorandum, (memorandum) => memorandum.issuer, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "issuedMemos", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => memorandum_recipient_entity_1.MemorandumRecipient, (memorandumRecipient) => memorandumRecipient.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "receivedMemos", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => memorandum_flow_entity_1.MemorandumFlow, (memorandumFlow) => memorandumFlow.approver, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "approvalSteps", void 0);
exports.Employee = Employee = __decorate([
    (0, typeorm_1.Entity)('employees')
], Employee);


/***/ }),

/***/ "./src/modules/employee-management/roles/dtos/role.dto.ts":
/*!****************************************************************!*\
  !*** ./src/modules/employee-management/roles/dtos/role.dto.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetRoleDto = exports.UpdateRoleDto = exports.RoleDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const reference_dto_1 = __webpack_require__(/*! @/common/dtos/reference.dto */ "./src/common/dtos/reference.dto.ts");
const role_scope_type_enum_1 = __webpack_require__(/*! @/common/enums/role-scope-type.enum */ "./src/common/enums/role-scope-type.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class RoleDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
    constructor() {
        super(...arguments);
        this.scope = role_scope_type_enum_1.RoleScopeType.OWNED;
    }
}
exports.RoleDto = RoleDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The name of the role',
        example: 'admin',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(100),
    (0, class_validator_1.MinLength)(3),
    __metadata("design:type", String)
], RoleDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Description of the role',
        example: 'Administrator with full access',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.MaxLength)(500),
    (0, class_validator_1.MinLength)(3),
    __metadata("design:type", String)
], RoleDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'The scope of the role',
        enum: role_scope_type_enum_1.RoleScopeType,
        default: role_scope_type_enum_1.RoleScopeType.OWNED,
    }),
    (0, class_validator_1.IsEnum)(role_scope_type_enum_1.RoleScopeType),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof role_scope_type_enum_1.RoleScopeType !== "undefined" && role_scope_type_enum_1.RoleScopeType) === "function" ? _a : Object)
], RoleDto.prototype, "scope", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'List of permissions assigned to this role',
        type: [reference_dto_1.ReferenceDto],
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], RoleDto.prototype, "permissions", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Employees associated with this role',
        type: [reference_dto_1.ReferenceDto]
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], RoleDto.prototype, "employees", void 0);
class UpdateRoleDto extends (0, swagger_1.PartialType)(RoleDto) {
}
exports.UpdateRoleDto = UpdateRoleDto;
class GetRoleDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateRoleDto, 'role') {
}
exports.GetRoleDto = GetRoleDto;


/***/ }),

/***/ "./src/modules/employee-management/roles/entities/role.entity.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/employee-management/roles/entities/role.entity.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Role = void 0;
const role_scope_type_enum_1 = __webpack_require__(/*! @/common/enums/role-scope-type.enum */ "./src/common/enums/role-scope-type.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const permission_entity_1 = __webpack_require__(/*! @/modules/employee-management/roles/permissions/entities/permission.entity */ "./src/modules/employee-management/roles/permissions/entities/permission.entity.ts");
const department_entity_1 = __webpack_require__(/*! @/modules/organization-management/branches/departments/entities/department.entity */ "./src/modules/organization-management/branches/departments/entities/department.entity.ts");
const branch_entity_1 = __webpack_require__(/*! @/modules/organization-management/branches/entities/branch.entity */ "./src/modules/organization-management/branches/entities/branch.entity.ts");
const organization_entity_1 = __webpack_require__(/*! @/modules/organization-management/entities/organization.entity */ "./src/modules/organization-management/entities/organization.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const employee_entity_1 = __webpack_require__(/*! ../../entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
let Role = class Role extends base_entity_1.BaseEntity {
};
exports.Role = Role;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Role.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Role.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: role_scope_type_enum_1.RoleScopeType,
        default: role_scope_type_enum_1.RoleScopeType.OWNED,
    }),
    __metadata("design:type", typeof (_a = typeof role_scope_type_enum_1.RoleScopeType !== "undefined" && role_scope_type_enum_1.RoleScopeType) === "function" ? _a : Object)
], Role.prototype, "scope", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => permission_entity_1.Permission, (permission) => permission.roles, { nullable: true, cascade: true }),
    (0, typeorm_1.JoinTable)({
        name: 'role_permissions',
        joinColumn: { name: 'role_id', referencedColumnName: 'id' },
        inverseJoinColumn: { name: 'permission_id', referencedColumnName: 'id' },
    }),
    __metadata("design:type", Array)
], Role.prototype, "permissions", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => employee_entity_1.Employee, (employee) => employee.roles, { nullable: true }),
    __metadata("design:type", Array)
], Role.prototype, "employees", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => organization_entity_1.Organization, (organization) => organization.roles, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'organizationId' }),
    __metadata("design:type", typeof (_b = typeof organization_entity_1.Organization !== "undefined" && organization_entity_1.Organization) === "function" ? _b : Object)
], Role.prototype, "organization", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => branch_entity_1.Branch, (branch) => branch.roles, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'branchId' }),
    __metadata("design:type", typeof (_c = typeof branch_entity_1.Branch !== "undefined" && branch_entity_1.Branch) === "function" ? _c : Object)
], Role.prototype, "branch", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => department_entity_1.Department, (department) => department.roles, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'departmentId' }),
    __metadata("design:type", typeof (_d = typeof department_entity_1.Department !== "undefined" && department_entity_1.Department) === "function" ? _d : Object)
], Role.prototype, "department", void 0);
exports.Role = Role = __decorate([
    (0, typeorm_1.Entity)('roles')
], Role);


/***/ }),

/***/ "./src/modules/employee-management/roles/permissions/dtos/permission.dto.ts":
/*!**********************************************************************************!*\
  !*** ./src/modules/employee-management/roles/permissions/dtos/permission.dto.ts ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPermissionDto = exports.UpdatePermissionDto = exports.PermissionDto = void 0;
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class PermissionDto {
}
exports.PermissionDto = PermissionDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission name', required: false }),
    __metadata("design:type", String)
], PermissionDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission description', required: false }),
    __metadata("design:type", String)
], PermissionDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The action this permission grants',
        enum: action_enum_1.Action,
        enumName: 'Action'
    }),
    __metadata("design:type", typeof (_a = typeof action_enum_1.Action !== "undefined" && action_enum_1.Action) === "function" ? _a : Object)
], PermissionDto.prototype, "action", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'The subject this permission applies to' }),
    __metadata("design:type", String)
], PermissionDto.prototype, "subject", void 0);
class UpdatePermissionDto extends (0, swagger_1.PartialType)(PermissionDto) {
}
exports.UpdatePermissionDto = UpdatePermissionDto;
class GetPermissionDto extends (0, create_get_dto_factory_1.createGetDto)(UpdatePermissionDto, 'permission') {
}
exports.GetPermissionDto = GetPermissionDto;


/***/ }),

/***/ "./src/modules/employee-management/roles/permissions/entities/permission.entity.ts":
/*!*****************************************************************************************!*\
  !*** ./src/modules/employee-management/roles/permissions/entities/permission.entity.ts ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Permission = void 0;
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const action_enum_1 = __webpack_require__(/*! ../../../../../common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const base_entity_1 = __webpack_require__(/*! ../../../../../database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const role_entity_1 = __webpack_require__(/*! ../../entities/role.entity */ "./src/modules/employee-management/roles/entities/role.entity.ts");
let Permission = class Permission extends base_entity_1.BaseEntity {
};
exports.Permission = Permission;
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Permission.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Permission.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: action_enum_1.Action,
    }),
    __metadata("design:type", typeof (_a = typeof action_enum_1.Action !== "undefined" && action_enum_1.Action) === "function" ? _a : Object)
], Permission.prototype, "action", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Permission.prototype, "subject", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => role_entity_1.Role, Role => Role.permissions, { nullable: true }),
    __metadata("design:type", Array)
], Permission.prototype, "roles", void 0);
exports.Permission = Permission = __decorate([
    (0, typeorm_1.Entity)('permissions')
], Permission);


/***/ }),

/***/ "./src/modules/employee-management/roles/permissions/permissions.controller.ts":
/*!*************************************************************************************!*\
  !*** ./src/modules/employee-management/roles/permissions/permissions.controller.ts ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const permission_dto_1 = __webpack_require__(/*! ./dtos/permission.dto */ "./src/modules/employee-management/roles/permissions/dtos/permission.dto.ts");
const permission_entity_1 = __webpack_require__(/*! ./entities/permission.entity */ "./src/modules/employee-management/roles/permissions/entities/permission.entity.ts");
const permissions_service_1 = __webpack_require__(/*! ./permissions.service */ "./src/modules/employee-management/roles/permissions/permissions.service.ts");
class PermissionsController extends (0, create_controller_factory_1.createController)(permission_entity_1.Permission, permissions_service_1.PermissionsService, permission_dto_1.GetPermissionDto) {
    async findOne(id, relations, select) {
        return await super.findOne(id, relations, select);
    }
    async delete(id) {
        return await super.delete(id);
    }
    async deleteMany(ids, hardDelete) {
        return await super.deleteMany(ids, hardDelete);
    }
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async update(id, entityDto, updatedById) {
        return await super.update(id, entityDto, updatedById);
    }
}
exports.PermissionsController = PermissionsController;


/***/ }),

/***/ "./src/modules/employee-management/roles/permissions/permissions.module.ts":
/*!*********************************************************************************!*\
  !*** ./src/modules/employee-management/roles/permissions/permissions.module.ts ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const roles_module_1 = __webpack_require__(/*! ../roles.module */ "./src/modules/employee-management/roles/roles.module.ts");
const permission_entity_1 = __webpack_require__(/*! ./entities/permission.entity */ "./src/modules/employee-management/roles/permissions/entities/permission.entity.ts");
const permissions_controller_1 = __webpack_require__(/*! ./permissions.controller */ "./src/modules/employee-management/roles/permissions/permissions.controller.ts");
const permissions_service_1 = __webpack_require__(/*! ./permissions.service */ "./src/modules/employee-management/roles/permissions/permissions.service.ts");
const permission_seeder_service_1 = __webpack_require__(/*! ./services/permission-seeder.service */ "./src/modules/employee-management/roles/permissions/services/permission-seeder.service.ts");
let PermissionsModule = class PermissionsModule {
};
exports.PermissionsModule = PermissionsModule;
exports.PermissionsModule = PermissionsModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([permission_entity_1.Permission]), roles_module_1.RolesModule],
        providers: [permissions_service_1.PermissionsService, permission_seeder_service_1.PermissionSeederService],
        exports: [permissions_service_1.PermissionsService, permission_seeder_service_1.PermissionSeederService],
        controllers: [permissions_controller_1.PermissionsController],
    })
], PermissionsModule);


/***/ }),

/***/ "./src/modules/employee-management/roles/permissions/permissions.service.ts":
/*!**********************************************************************************!*\
  !*** ./src/modules/employee-management/roles/permissions/permissions.service.ts ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const users_service_1 = __webpack_require__(/*! ../../../account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const roles_service_1 = __webpack_require__(/*! ../roles.service */ "./src/modules/employee-management/roles/roles.service.ts");
const permission_entity_1 = __webpack_require__(/*! ./entities/permission.entity */ "./src/modules/employee-management/roles/permissions/entities/permission.entity.ts");
let PermissionsService = class PermissionsService extends base_service_1.BaseService {
    constructor(permissionsRepository, usersService, rolesService) {
        super(permissionsRepository, usersService);
        this.permissionsRepository = permissionsRepository;
        this.usersService = usersService;
        this.rolesService = rolesService;
        this.cachedPermissions = new Map();
        this.preloadPermissions();
    }
    async getAllPermissions() {
        return this.permissionsRepository.find();
    }
    async preloadPermissions() {
        try {
            const permissions = await this.permissionsRepository.find();
            this.cachedPermissions.clear();
            for (const permission of permissions) {
                const key = this.getPermissionKey(permission.action, permission.subject);
                this.cachedPermissions.set(key, permission);
            }
            // this.logger.log(`Preloaded ${this.cachedPermissions.size} permissions into cache`);
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Failed to preload permissions: ${errorMessage}`);
        }
    }
    getPermissionKey(action, subject) {
        return `${action}:${subject}`;
    }
    /**
     * Find or create a permission
     * @param action The action (Create, Read, Update, Delete, Manage)
     * @param subject The subject (resource name)
     * @param name Optional name for the permission
     * @param description Optional description
     * @returns The permission entity
     */
    async findOrCreate(action, subject, name, description) {
        const permissionKey = this.getPermissionKey(action, subject);
        // Check cache first
        if (this.cachedPermissions.has(permissionKey)) {
            return this.cachedPermissions.get(permissionKey);
        }
        // Find in database
        const existingPermission = await this.permissionsRepository.findOne({
            where: { action, subject }
        });
        if (existingPermission) {
            // Update cache and return
            this.cachedPermissions.set(permissionKey, existingPermission);
            return existingPermission;
        }
        // Create new permission
        const newPermission = this.permissionsRepository.create({
            action,
            subject,
            name: name || `${action}_${subject}`.toUpperCase(),
            description: description || `Permission to ${action.toLowerCase()} ${subject}`
        });
        const savedPermission = await this.permissionsRepository.save(newPermission);
        // Update cache
        this.cachedPermissions.set(permissionKey, savedPermission);
        this.logger.log(`Created new permission: ${permissionKey}`);
        return savedPermission;
    }
    /**
     * Create multiple permissions in a transaction
     * @param permissionsData Array of permission data
     * @returns Created or found permissions
     */
    async createMultiple(permissionsData) {
        return this.transactionService.executeInTransaction(async (queryRunner) => {
            const results = [];
            for (const data of permissionsData) {
                const key = this.getPermissionKey(data.action, data.subject);
                // Check cache first
                if (this.cachedPermissions.has(key)) {
                    results.push(this.cachedPermissions.get(key));
                    continue;
                }
                // Find or create in transaction
                const existingPermission = await queryRunner.manager.findOne(permission_entity_1.Permission, {
                    where: { action: data.action, subject: data.subject }
                });
                if (existingPermission) {
                    this.cachedPermissions.set(key, existingPermission);
                    results.push(existingPermission);
                    continue;
                }
                // Create new
                const newPermission = queryRunner.manager.create(permission_entity_1.Permission, {
                    action: data.action,
                    subject: data.subject,
                    name: data.name || `${data.action}_${data.subject}`.toUpperCase(),
                    description: data.description || `Permission to ${data.action.toLowerCase()} ${data.subject}`
                });
                const savedPermission = await queryRunner.manager.save(newPermission);
                this.cachedPermissions.set(key, savedPermission);
                results.push(savedPermission);
            }
            return results;
        }).catch((error) => {
            this.logger.error(`Failed to create permissions: ${error.message}`);
            throw error;
        });
    }
    /**
     * Get all permissions by subject
     * @param subject The subject name
     * @returns Array of permissions
     */
    async getPermissionsBySubject(subject) {
        // Try to get from cache first
        const cachedPermissions = Array.from(this.cachedPermissions.values())
            .filter(permission => permission.subject === subject);
        if (cachedPermissions.length > 0) {
            return cachedPermissions;
        }
        // Fetch from database
        const permissions = await this.permissionsRepository.find({
            where: { subject }
        });
        // Update cache
        for (const permission of permissions) {
            const key = this.getPermissionKey(permission.action, permission.subject);
            this.cachedPermissions.set(key, permission);
        }
        return permissions;
    }
    async getPermissionsByControllerName(baseName) {
        // Try to get from cache first
        const cachedPermissions = Array.from(this.cachedPermissions.values())
            .filter(permission => permission.subject.includes(baseName));
        if (cachedPermissions.length > 0) {
            return cachedPermissions;
        }
        const permissions = await this.permissionsRepository.find({
            where: {
                subject: baseName
            }
        });
        // Update cache
        for (const permission of permissions) {
            const key = this.getPermissionKey(permission.action, permission.subject);
            this.cachedPermissions.set(key, permission);
        }
        return permissions;
    }
};
exports.PermissionsService = PermissionsService;
exports.PermissionsService = PermissionsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(permission_entity_1.Permission)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof roles_service_1.RolesService !== "undefined" && roles_service_1.RolesService) === "function" ? _c : Object])
], PermissionsService);


/***/ }),

/***/ "./src/modules/employee-management/roles/permissions/services/permission-seeder.service.ts":
/*!*************************************************************************************************!*\
  !*** ./src/modules/employee-management/roles/permissions/services/permission-seeder.service.ts ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PermissionSeederService_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionSeederService = void 0;
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const glob_1 = __webpack_require__(/*! glob */ "glob");
const path = __importStar(__webpack_require__(/*! path */ "path"));
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const permission_entity_1 = __webpack_require__(/*! ../entities/permission.entity */ "./src/modules/employee-management/roles/permissions/entities/permission.entity.ts");
let PermissionSeederService = PermissionSeederService_1 = class PermissionSeederService {
    constructor(permissionRepository) {
        this.permissionRepository = permissionRepository;
        this.logger = new common_1.Logger(PermissionSeederService_1.name);
    }
    // Automatically run on module initialization
    async onModuleInit() {
        if (process.env.NODE_ENV !== 'test') {
            try {
                await this.seedPermissions();
            }
            catch (error) {
                this.logger.error(`Failed to seed permissions: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    async seedPermissions() {
        // this.logger.log('🔍 Scanning controllers for permissions...');
        // Get permissions from controllers created with createController factory
        const factoryControllerPerms = await this.scanFactoryControllers();
        // this.logger.log(`Found ${factoryControllerPerms.length} permissions from factory controllers`);
        // // Get permissions from regular BaseController extensions
        // const baseControllerPerms = await this.scanBaseControllerExtensions();
        // this.logger.log(`Found ${baseControllerPerms.length} permissions from BaseController extensions`);
        // // Get permissions from code patterns
        // const codePatternPerms = await this.scanForPermissions();
        // this.logger.log(`Found ${codePatternPerms.length} permissions from code patterns`);
        // Combine all permissions
        const allPermissions = [...factoryControllerPerms];
        const uniquePermissions = this.removeDuplicates(allPermissions);
        // this.logger.log(`Total unique permissions found: ${uniquePermissions.length}`);
        let created = 0;
        let updated = 0;
        try {
            for (const permDef of uniquePermissions) {
                const result = await this.createOrUpdatePermission(permDef);
                if (result.isNew)
                    created++;
                else
                    updated++;
            }
            // this.logger.log(`Permission seeding completed: ${created} created, ${updated} updated`);
        }
        catch (error) {
            this.logger.error(`Error creating permissions: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }
    /**
     * NEW METHOD: Scan for controllers created with createController factory
     */
    async scanFactoryControllers() {
        const permissions = [];
        const controllers = await this.findControllerFiles();
        // Updated pattern to match controllers that extend from createController() without generic types
        const factoryControllerPattern = /export\s+class\s+(\w+)\s+extends\s+createController\s*\(\s*([\w.]+)\s*,\s*([\w.]+)\s*,\s*([\w.]+)(?:\s*,\s*([\w.]+))?(?:\s*,\s*([\w.]+))?\s*\)/;
        // this.logger.debug(`Scanning ${controllers.length} controller files for factory controllers`);
        for (const file of controllers) {
            try {
                const fileContent = fs.readFileSync(file, 'utf8');
                const factoryMatch = fileContent.match(factoryControllerPattern);
                if (factoryMatch) {
                    const controllerName = factoryMatch[1];
                    const entityClass = factoryMatch[2];
                    const serviceClass = factoryMatch[3];
                    const getDtoClass = factoryMatch[4];
                    const createDtoClass = factoryMatch[5];
                    const updateDtoClass = factoryMatch[6];
                    // Get entity name from class reference
                    // First try to extract from entity class (removing "Entity" suffix if present)
                    let entityName = entityClass.replace(/Entity$/, '');
                    // If entityName contains dots (like module.Entity), get the last part
                    if (entityName.includes('.')) {
                        entityName = entityName.split('.').pop() || entityName;
                    }
                    // this.logger.debug(`Found factory controller: ${controllerName} for entity ${entityName}`);
                    // Always generate MANAGE permission
                    permissions.push(this.createPermissionDefinition(action_enum_1.Action.MANAGE, entityName));
                    // Check for GetDto (Read permission)
                    if (getDtoClass && getDtoClass.trim() !== 'null' && getDtoClass.trim() !== 'undefined') {
                        permissions.push(this.createPermissionDefinition(action_enum_1.Action.READ, entityName));
                    }
                    // Check for CreateDto (Create permission)
                    if (createDtoClass && createDtoClass.trim() !== 'null' && createDtoClass.trim() !== 'undefined') {
                        permissions.push(this.createPermissionDefinition(action_enum_1.Action.CREATE, entityName));
                    }
                    // Check for UpdateDto (Update permission)
                    if (updateDtoClass && updateDtoClass.trim() !== 'null' && updateDtoClass.trim() !== 'undefined') {
                        permissions.push(this.createPermissionDefinition(action_enum_1.Action.UPDATE, entityName));
                    }
                    // Add DELETE permission by default too (since most controllers likely support it)
                    permissions.push(this.createPermissionDefinition(action_enum_1.Action.DELETE, entityName));
                }
            }
            catch (error) {
                this.logger.warn(`Error processing file ${file}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
        return permissions;
    }
    /**
     * Helper to create a permission definition object
     */
    createPermissionDefinition(action, subject) {
        const actionName = this.capitalizeFirstLetter(action);
        return {
            action,
            subject,
            name: `${actionName} ${subject}`,
            description: `Permission to ${action.toLowerCase()} ${subject}`
        };
    }
    /**
     * Scan for controllers extending BaseController directly
     */
    async scanBaseControllerExtensions() {
        const permissions = [];
        const controllers = await this.findControllerFiles();
        const baseControllerPattern = /extends\s+(?:[\w.]+\.)?BaseController\s*<\s*\w+\s*,\s*\w+(?:\s*,\s*\w+)*\s*>/;
        const entityPattern = /(?:super\s*\(\s*[\w\s.,]+,\s*[\w\s.,]+,\s*['"](\w+)['"]|protected\s+readonly\s+entityName\s*[:=]\s*['"](\w+)['"])/;
        // Get all actions from the enum
        const allActions = Object.values(action_enum_1.Action);
        // this.logger.debug(`Scanning ${controllers.length} controller files for BaseController extensions`);
        for (const file of controllers) {
            try {
                const fileContent = fs.readFileSync(file, 'utf8');
                // Skip files that use createController (we handle those separately)
                if (fileContent.includes('extends createController')) {
                    continue;
                }
                // Check if this extends BaseController directly
                if (baseControllerPattern.test(fileContent)) {
                    this.logger.debug(`Found BaseController extension in ${path.basename(file)}`);
                    // Extract entity name
                    const entityMatch = fileContent.match(entityPattern);
                    let entityName = null;
                    if (entityMatch) {
                        // Get the first capturing group that has a value
                        entityName = entityMatch[1] || entityMatch[2];
                        this.logger.debug(`Found entity name: ${entityName} in ${path.basename(file)}`);
                        // If entity name was found, create permissions for all actions
                        if (entityName) {
                            for (const action of allActions) {
                                permissions.push(this.createPermissionDefinition(action, entityName));
                            }
                        }
                    }
                    else {
                        // Try to infer entity name from controller name
                        const controllerName = path.basename(file, '.controller.ts');
                        if (controllerName) {
                            const inferredEntityName = this.singularize(controllerName);
                            this.logger.debug(`Inferred entity name from controller: ${inferredEntityName}`);
                            for (const action of allActions) {
                                permissions.push(this.createPermissionDefinition(action, inferredEntityName));
                            }
                        }
                    }
                }
            }
            catch (error) {
                this.logger.warn(`Error processing file ${file}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
        return permissions;
    }
    /**
     * Capitalize first letter of a string
     */
    capitalizeFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
    }
    /**
     * Simple singularization for English words
     */
    singularize(word) {
        if (word.endsWith('ies')) {
            return word.slice(0, -3) + 'y';
        }
        else if (word.endsWith('s') && !word.endsWith('ss')) {
            return word.slice(0, -1);
        }
        return word;
    }
    async createOrUpdatePermission(permDef) {
        // Check if permission already exists
        let permission = await this.permissionRepository.findOne({
            where: {
                action: permDef.action,
                subject: permDef.subject
            }
        });
        let isNew = false;
        if (!permission) {
            permission = this.permissionRepository.create({
                action: permDef.action,
                subject: permDef.subject,
                name: permDef.name,
                description: permDef.description
            });
            isNew = true;
        }
        else {
            // Update existing permission with any new metadata
            permission.name = permDef.name || permission.name;
            permission.description = permDef.description || permission.description;
        }
        await this.permissionRepository.save(permission);
        return { permission, isNew };
    }
    // Keep your existing scan methods
    async scanForPermissions() {
        // Existing code...
        return [];
    }
    extractNamedPermissions(fileContent, permissions) {
        // Existing code...
    }
    extractAuthorizationRules(fileContent, permissions) {
        // Existing code...
    }
    async findControllerFiles() {
        try {
            return await (0, glob_1.glob)('src/**/*.controller.ts', { ignore: 'node_modules/**' });
        }
        catch (err) {
            throw err;
        }
    }
    mapActionNameToEnum(actionName) {
        const map = {
            'Create': action_enum_1.Action.CREATE,
            'Read': action_enum_1.Action.READ,
            'Update': action_enum_1.Action.UPDATE,
            'Delete': action_enum_1.Action.DELETE,
            'Manage': action_enum_1.Action.MANAGE
        };
        return map[actionName] || action_enum_1.Action.READ;
    }
    removeDuplicates(permissions) {
        const uniqueSet = new Map();
        for (const perm of permissions) {
            const key = `${perm.action}:${perm.subject}`;
            uniqueSet.set(key, perm);
        }
        return Array.from(uniqueSet.values());
    }
};
exports.PermissionSeederService = PermissionSeederService;
exports.PermissionSeederService = PermissionSeederService = PermissionSeederService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(permission_entity_1.Permission)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], PermissionSeederService);


/***/ }),

/***/ "./src/modules/employee-management/roles/roles.controller.ts":
/*!*******************************************************************!*\
  !*** ./src/modules/employee-management/roles/roles.controller.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RolesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const role_dto_1 = __webpack_require__(/*! ./dtos/role.dto */ "./src/modules/employee-management/roles/dtos/role.dto.ts");
const role_entity_1 = __webpack_require__(/*! ./entities/role.entity */ "./src/modules/employee-management/roles/entities/role.entity.ts");
const roles_service_1 = __webpack_require__(/*! ./roles.service */ "./src/modules/employee-management/roles/roles.service.ts");
class RolesController extends (0, create_controller_factory_1.createController)(role_entity_1.Role, roles_service_1.RolesService, role_dto_1.GetRoleDto, role_dto_1.RoleDto, role_dto_1.UpdateRoleDto) {
}
exports.RolesController = RolesController;


/***/ }),

/***/ "./src/modules/employee-management/roles/roles.module.ts":
/*!***************************************************************!*\
  !*** ./src/modules/employee-management/roles/roles.module.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RolesModule = void 0;
const users_module_1 = __webpack_require__(/*! @/modules/account-management/users/users.module */ "./src/modules/account-management/users/users.module.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const role_entity_1 = __webpack_require__(/*! ./entities/role.entity */ "./src/modules/employee-management/roles/entities/role.entity.ts");
const roles_controller_1 = __webpack_require__(/*! ./roles.controller */ "./src/modules/employee-management/roles/roles.controller.ts");
const roles_service_1 = __webpack_require__(/*! ./roles.service */ "./src/modules/employee-management/roles/roles.service.ts");
let RolesModule = class RolesModule {
};
exports.RolesModule = RolesModule;
exports.RolesModule = RolesModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([role_entity_1.Role]), users_module_1.UsersModule],
        controllers: [roles_controller_1.RolesController],
        providers: [roles_service_1.RolesService],
        exports: [roles_service_1.RolesService],
    })
], RolesModule);


/***/ }),

/***/ "./src/modules/employee-management/roles/roles.service.ts":
/*!****************************************************************!*\
  !*** ./src/modules/employee-management/roles/roles.service.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RolesService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const users_service_1 = __webpack_require__(/*! ../../account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const role_entity_1 = __webpack_require__(/*! ./entities/role.entity */ "./src/modules/employee-management/roles/entities/role.entity.ts");
let RolesService = class RolesService extends base_service_1.BaseService {
    constructor(rolesRepository, usersService) {
        super(rolesRepository, usersService);
        this.rolesRepository = rolesRepository;
        this.usersService = usersService;
    }
    async getAllRoles() {
        return this.rolesRepository.find({ relations: ['permissions'] });
    }
    async findRoleWithPermissions(roleId) {
        const role = await this.rolesRepository.findOne({
            where: { id: roleId },
            relations: ['permissions'],
        });
        if (!role) {
            throw new common_1.NotFoundException(`Role with ID ${roleId} not found`);
        }
        return role;
    }
};
exports.RolesService = RolesService;
exports.RolesService = RolesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(role_entity_1.Role)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], RolesService);


/***/ }),

/***/ "./src/modules/files/config/file-provider.config.ts":
/*!**********************************************************!*\
  !*** ./src/modules/files/config/file-provider.config.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fileProviders = exports.fileProviderConfig = exports.FILE_SERVICE = void 0;
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const local_file_service_1 = __webpack_require__(/*! ../services/local-file.service */ "./src/modules/files/services/local-file.service.ts");
exports.FILE_SERVICE = 'FILE_SERVICE';
exports.fileProviderConfig = {
    provide: exports.FILE_SERVICE,
    useFactory: (configService) => {
        // Read provider from options or config
        const fileProvider = configService.get('FILE_PROVIDER') ||
            'local';
        // Select the appropriate implementation based on provider
        switch (fileProvider.toLowerCase()) {
            case 'cloudflare':
                // return new CloudflareFileService(configService);
                throw new Error('Cloudflare provider not implemented yet');
            case 's3':
                // return new S3FileService(configService);
                throw new Error('S3 provider not implemented yet');
            case 'local':
            default:
                return new local_file_service_1.LocalFileService(configService);
        }
    },
    inject: [config_1.ConfigService],
};
exports.fileProviders = [exports.fileProviderConfig, local_file_service_1.LocalFileService];


/***/ }),

/***/ "./src/modules/files/dtos/directory-metadata.dto.ts":
/*!**********************************************************!*\
  !*** ./src/modules/files/dtos/directory-metadata.dto.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirectoryMetadata = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class DirectoryMetadata {
}
exports.DirectoryMetadata = DirectoryMetadata;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Directory path/key' }),
    __metadata("design:type", String)
], DirectoryMetadata.prototype, "key", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Directory name' }),
    __metadata("design:type", String)
], DirectoryMetadata.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Directory creation date' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], DirectoryMetadata.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Last modified date' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], DirectoryMetadata.prototype, "lastModified", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Item count in directory' }),
    __metadata("design:type", Number)
], DirectoryMetadata.prototype, "itemCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Total size of all files in directory' }),
    __metadata("design:type", Number)
], DirectoryMetadata.prototype, "size", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether this is a parent directory link' }),
    __metadata("design:type", Boolean)
], DirectoryMetadata.prototype, "isParent", void 0);


/***/ }),

/***/ "./src/modules/files/dtos/file-list-options.dto.ts":
/*!*********************************************************!*\
  !*** ./src/modules/files/dtos/file-list-options.dto.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileListOptionsDto = exports.ScopeContext = exports.SortDirection = exports.FileSortField = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
var FileSortField;
(function (FileSortField) {
    FileSortField["NAME"] = "name";
    FileSortField["SIZE"] = "size";
    FileSortField["DATE_CREATED"] = "createdAt";
    FileSortField["DATE_MODIFIED"] = "lastModified";
    FileSortField["TYPE"] = "mimeType";
})(FileSortField || (exports.FileSortField = FileSortField = {}));
var SortDirection;
(function (SortDirection) {
    SortDirection["ASC"] = "asc";
    SortDirection["DESC"] = "desc";
})(SortDirection || (exports.SortDirection = SortDirection = {}));
class ScopeContext {
}
exports.ScopeContext = ScopeContext;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Organization ID for filtering',
        example: '123e4567-e89b-12d3-a456-426614174000',
        type: String,
        format: 'uuid'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], ScopeContext.prototype, "organizationId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Branch ID for filtering',
        example: '123e4567-e89b-12d3-a456-426614174000',
        type: String,
        format: 'uuid'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], ScopeContext.prototype, "branchId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Department ID for filtering',
        example: '123e4567-e89b-12d3-a456-426614174000',
        type: String,
        format: 'uuid'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ScopeContext.prototype, "departmentId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'User ID for filtering files owned by a specific user',
        type: String,
        example: '123e4567-e89b-12d3-a456-426614174000',
        format: 'uuid'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ScopeContext.prototype, "userId", void 0);
class FileListOptionsDto {
    constructor() {
        this.includeUrls = true;
        this.includeDirs = true;
        this.showHidden = false;
    }
}
exports.FileListOptionsDto = FileListOptionsDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Scope context for filtering files',
        type: ScopeContext
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Type)(() => ScopeContext),
    __metadata("design:type", ScopeContext)
], FileListOptionsDto.prototype, "scope", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Additional folder path within the scope',
        example: 'invoices/2023',
        type: String
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FileListOptionsDto.prototype, "folder", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Page number for pagination',
        default: 1,
        minimum: 1,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    __metadata("design:type", Number)
], FileListOptionsDto.prototype, "page", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum number of items to return (1-1000)',
        minimum: 1,
        maximum: 1000,
        default: 50
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(1000),
    __metadata("design:type", Number)
], FileListOptionsDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include file URLs in response',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => {
        if (typeof value === 'string')
            return value.toLowerCase() === 'true';
        return Boolean(value);
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], FileListOptionsDto.prototype, "includeUrls", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include directories in results',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => {
        if (typeof value === 'string')
            return value.toLowerCase() === 'true';
        return Boolean(value);
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], FileListOptionsDto.prototype, "includeDirs", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        enum: FileSortField,
        description: 'Field to sort by',
        default: FileSortField.NAME
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(FileSortField),
    __metadata("design:type", String)
], FileListOptionsDto.prototype, "sortBy", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        enum: SortDirection,
        description: 'Sort direction',
        default: SortDirection.ASC
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(SortDirection),
    __metadata("design:type", String)
], FileListOptionsDto.prototype, "sortDirection", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Search term for filtering files by name',
        example: 'contract'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_transformer_1.Transform)(({ value }) => value === null || value === void 0 ? void 0 : value.trim()),
    __metadata("design:type", String)
], FileListOptionsDto.prototype, "searchTerm", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Show hidden files (starting with .)',
        default: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => {
        if (typeof value === 'string')
            return value.toLowerCase() === 'true';
        return Boolean(value);
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], FileListOptionsDto.prototype, "showHidden", void 0);


/***/ }),

/***/ "./src/modules/files/dtos/file-list-response.dto.ts":
/*!**********************************************************!*\
  !*** ./src/modules/files/dtos/file-list-response.dto.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileListResponseDto = exports.FilePaginationDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const directory_metadata_dto_1 = __webpack_require__(/*! ./directory-metadata.dto */ "./src/modules/files/dtos/directory-metadata.dto.ts");
const file_list_options_dto_1 = __webpack_require__(/*! ./file-list-options.dto */ "./src/modules/files/dtos/file-list-options.dto.ts");
const file_meta_data_dto_1 = __webpack_require__(/*! ./file-meta-data.dto */ "./src/modules/files/dtos/file-meta-data.dto.ts");
class FilePaginationDto {
}
exports.FilePaginationDto = FilePaginationDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Current page number',
        example: 1,
        minimum: 1
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.Min)(1),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], FilePaginationDto.prototype, "page", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Number of items per page',
        example: 10,
        minimum: 1,
        maximum: 100
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(100),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], FilePaginationDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Total number of items',
        example: 150,
        minimum: 0
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], FilePaginationDto.prototype, "totalCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Total number of pages',
        example: 15,
        minimum: 0
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], FilePaginationDto.prototype, "totalPages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether there is a next page available',
        example: true
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], FilePaginationDto.prototype, "hasNextPage", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether there is a previous page available',
        example: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Boolean)
], FilePaginationDto.prototype, "hasPreviousPage", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Next page number if available',
        example: 2,
        minimum: 1
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], FilePaginationDto.prototype, "nextPage", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Previous page number if available',
        example: null,
        minimum: 1
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], FilePaginationDto.prototype, "previousPage", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Items per page (alias for limit)',
        example: 10,
        minimum: 1,
        maximum: 100
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(100),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], FilePaginationDto.prototype, "itemsPerPage", void 0);
class FileListResponseDto {
}
exports.FileListResponseDto = FileListResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({ type: [file_meta_data_dto_1.FileMetadata], description: 'List of files' }),
    __metadata("design:type", Array)
], FileListResponseDto.prototype, "files", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ type: [directory_metadata_dto_1.DirectoryMetadata], description: 'List of directories' }),
    __metadata("design:type", Array)
], FileListResponseDto.prototype, "directories", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Pagination information',
        type: FilePaginationDto
    }),
    __metadata("design:type", FilePaginationDto)
], FileListResponseDto.prototype, "pagination", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Parent directory path' }),
    __metadata("design:type", String)
], FileListResponseDto.prototype, "parentDir", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Breadcrumb navigation path segments',
        type: [Object],
        example: [{ name: 'Home', path: '/' }, { name: 'Documents', path: '/documents' }]
    }),
    __metadata("design:type", typeof (_a = typeof Array !== "undefined" && Array) === "function" ? _a : Object)
], FileListResponseDto.prototype, "breadcrumbs", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Scope context for filtering files',
        type: file_list_options_dto_1.ScopeContext
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Type)(() => file_list_options_dto_1.ScopeContext),
    __metadata("design:type", typeof (_b = typeof file_list_options_dto_1.ScopeContext !== "undefined" && file_list_options_dto_1.ScopeContext) === "function" ? _b : Object)
], FileListResponseDto.prototype, "scope", void 0);


/***/ }),

/***/ "./src/modules/files/dtos/file-meta-data.dto.ts":
/*!******************************************************!*\
  !*** ./src/modules/files/dtos/file-meta-data.dto.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileMetadata = void 0;
class FileMetadata {
}
exports.FileMetadata = FileMetadata;


/***/ }),

/***/ "./src/modules/files/dtos/file-upload.dto.ts":
/*!***************************************************!*\
  !*** ./src/modules/files/dtos/file-upload.dto.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileUploadDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class FileUploadDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.FileUploadDto = FileUploadDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'The folder path where the file will be uploaded',
        example: 'documents/reports',
        maxLength: 255
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(255),
    __metadata("design:type", String)
], FileUploadDto.prototype, "folder", void 0);


/***/ }),

/***/ "./src/modules/files/files.controller.ts":
/*!***********************************************!*\
  !*** ./src/modules/files/files.controller.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var FilesController_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilesController = void 0;
const authorize_decorator_1 = __webpack_require__(/*! @/common/decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const current_user_decorator_1 = __webpack_require__(/*! @/common/decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const generic_api_responses_decorator_1 = __webpack_require__(/*! @/common/decorators/generic-api-responses.decorator */ "./src/common/decorators/generic-api-responses.decorator.ts");
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const role_scope_type_enum_1 = __webpack_require__(/*! @/common/enums/role-scope-type.enum */ "./src/common/enums/role-scope-type.enum.ts");
const utility_helper_1 = __webpack_require__(/*! @/common/helpers/utility.helper */ "./src/common/helpers/utility.helper.ts");
const jwt_payload_interface_1 = __webpack_require__(/*! @/common/interfaces/jwt-payload.interface */ "./src/common/interfaces/jwt-payload.interface.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const platform_express_1 = __webpack_require__(/*! @nestjs/platform-express */ "@nestjs/platform-express");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const express_1 = __webpack_require__(/*! express */ "express");
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const file_provider_config_1 = __webpack_require__(/*! ./config/file-provider.config */ "./src/modules/files/config/file-provider.config.ts");
const directory_metadata_dto_1 = __webpack_require__(/*! ./dtos/directory-metadata.dto */ "./src/modules/files/dtos/directory-metadata.dto.ts");
const file_list_options_dto_1 = __webpack_require__(/*! ./dtos/file-list-options.dto */ "./src/modules/files/dtos/file-list-options.dto.ts");
const file_list_response_dto_1 = __webpack_require__(/*! ./dtos/file-list-response.dto */ "./src/modules/files/dtos/file-list-response.dto.ts");
const file_meta_data_dto_1 = __webpack_require__(/*! ./dtos/file-meta-data.dto */ "./src/modules/files/dtos/file-meta-data.dto.ts");
const file_upload_dto_1 = __webpack_require__(/*! ./dtos/file-upload.dto */ "./src/modules/files/dtos/file-upload.dto.ts");
const file_service_interface_1 = __webpack_require__(/*! ./interfaces/file-service.interface */ "./src/modules/files/interfaces/file-service.interface.ts");
let FilesController = FilesController_1 = class FilesController {
    constructor(fileService) {
        this.fileService = fileService;
        this.logger = new common_1.Logger(FilesController_1.name);
        this.GLOBAL_FILE_SIZE_LIMIT = 10000;
        this.ORGANIZATION_FILE_SIZE_LIMIT = 5000;
        this.BRANCH_FILE_SIZE_LIMIT = 2500;
        this.DEPARTMENT_FILE_SIZE_LIMIT = 1000;
        this.OWNED_FILE_SIZE_LIMIT = 500;
        this.MAX_FILE_SIZE = 100; // 100MB
    }
    buildTenantFolder(organizationId, branchId, departmentId, additionalPath) {
        const parts = [];
        if (organizationId) {
            parts.push('organizations', organizationId);
            if (branchId) {
                parts.push('branches', branchId);
                if (departmentId) {
                    parts.push('departments', departmentId);
                }
            }
        }
        if (additionalPath) {
            parts.push(additionalPath);
        }
        return parts.join('/');
    }
    getEffectiveTenantContext(resourceScope, requestedOrgId, requestedBranchId, requestedDeptId, requestedUserId) {
        var _a, _b, _c, _d, _e, _f;
        switch (resourceScope.type) {
            case role_scope_type_enum_1.RoleScopeType.GLOBAL:
                return {
                    organizationId: requestedOrgId,
                    branchId: requestedBranchId,
                    departmentId: requestedDeptId
                };
            case role_scope_type_enum_1.RoleScopeType.ORGANIZATION:
                return {
                    organizationId: requestedOrgId || ((_a = resourceScope.organizations) === null || _a === void 0 ? void 0 : _a[0]),
                    branchId: requestedBranchId,
                    departmentId: requestedDeptId
                };
            case role_scope_type_enum_1.RoleScopeType.BRANCH:
                return {
                    organizationId: requestedOrgId || ((_b = resourceScope.organizations) === null || _b === void 0 ? void 0 : _b[0]),
                    branchId: requestedBranchId || ((_c = resourceScope.branches) === null || _c === void 0 ? void 0 : _c[0]),
                    departmentId: requestedDeptId
                };
            case role_scope_type_enum_1.RoleScopeType.DEPARTMENT:
                return {
                    organizationId: requestedOrgId || ((_d = resourceScope.organizations) === null || _d === void 0 ? void 0 : _d[0]),
                    branchId: requestedBranchId || ((_e = resourceScope.branches) === null || _e === void 0 ? void 0 : _e[0]),
                    departmentId: requestedDeptId || ((_f = resourceScope.departments) === null || _f === void 0 ? void 0 : _f[0])
                };
            case role_scope_type_enum_1.RoleScopeType.OWNED:
                return {
                    organizationId: requestedOrgId,
                    branchId: requestedBranchId,
                    departmentId: requestedDeptId
                };
            default:
                return {};
        }
    }
    async uploadFile(file, req, query, user) {
        if (!file) {
            throw new common_1.BadRequestException('No file provided');
        }
        const resourceScope = req.resourceScope;
        try {
            // Extract tenant context from query
            const tenantContext = {
                organizationId: query.organizationId,
                branchId: query.branchId,
                departmentId: query.departmentId,
                userId: query.userId
            };
            // Validate tenant access and get the base tenant directory
            const tenantDirectory = utility_helper_1.UtilityHelper.validateAndGetTenantDirectory(resourceScope, tenantContext);
            // Build the full upload path
            let uploadPath = tenantDirectory;
            if (query.folder) {
                // Sanitize the folder path to prevent directory traversal
                const sanitizedFolder = query.folder
                    .replace(/\.\./g, '') // Remove ..
                    .replace(/^\/+/, '') // Remove leading slashes
                    .replace(/\/+/g, '/'); // Normalize multiple slashes
                if (sanitizedFolder) {
                    uploadPath = path_1.default.join(tenantDirectory, sanitizedFolder);
                }
            }
            // log upload path
            this.logger.log(`Uploading file to path: ${uploadPath}`);
            // Validate the final path is within the allowed tenant directory
            if (!utility_helper_1.UtilityHelper.validateFilePath(uploadPath, tenantDirectory)) {
                throw new common_1.ForbiddenException('Invalid file path: outside allowed directory');
            }
            // Additional file validation based on scope
            this.validateFileUpload(file, resourceScope, uploadPath);
            // Create upload options with tenant metadata
            const uploadOptions = {
                folder: uploadPath,
                token: req.headers.authorization,
                organizationId: tenantContext.organizationId,
                branchId: tenantContext.branchId,
                departmentId: tenantContext.departmentId,
                userId: user === null || user === void 0 ? void 0 : user.sub,
                scope: resourceScope.type,
                maxSizeBytes: this.MAX_FILE_SIZE * 1024 * 1024, // 100MB
                metadata: {
                    uploadedBy: (user === null || user === void 0 ? void 0 : user.sub) || 'anonymous',
                    uploadedAt: new Date().toISOString(),
                    tenantDirectory: tenantDirectory,
                    originalPath: uploadPath
                }
            };
            // Upload the file
            return await this.fileService.uploadFile(file, uploadOptions);
        }
        catch (error) {
            this.logger.error(`File upload failed for user ${user === null || user === void 0 ? void 0 : user.sub}: ${error instanceof Error ? error.message : String(error)}`);
            if (error instanceof common_1.ForbiddenException || error instanceof common_1.BadRequestException) {
                throw error;
            }
            throw new common_1.BadRequestException(`File upload failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Validates file upload based on scope and path restrictions
     */
    validateFileUpload(file, resourceScope, uploadPath) {
        // File size limits based on scope
        const maxSizeByScope = {
            [role_scope_type_enum_1.RoleScopeType.GLOBAL]: this.GLOBAL_FILE_SIZE_LIMIT * 1024 * 1024, // 100MB
            [role_scope_type_enum_1.RoleScopeType.ORGANIZATION]: this.ORGANIZATION_FILE_SIZE_LIMIT * 1024 * 1024, // 50MB
            [role_scope_type_enum_1.RoleScopeType.BRANCH]: this.BRANCH_FILE_SIZE_LIMIT * 1024 * 1024, // 25MB
            [role_scope_type_enum_1.RoleScopeType.DEPARTMENT]: this.DEPARTMENT_FILE_SIZE_LIMIT * 1024 * 1024, // 10MB
            [role_scope_type_enum_1.RoleScopeType.OWNED]: this.OWNED_FILE_SIZE_LIMIT * 1024 * 1024, // 5MB
        };
        const maxSize = maxSizeByScope[resourceScope.type] || maxSizeByScope[role_scope_type_enum_1.RoleScopeType.OWNED];
        if (file.size > maxSize) {
            throw new common_1.BadRequestException(`File size ${(file.size / 1024 / 1024).toFixed(2)}MB exceeds the limit of ${(maxSize / 1024 / 1024).toFixed(2)}MB for ${resourceScope.type} scope`);
        }
        // Restricted file types for certain scopes
        const restrictedTypes = [
            'application/x-executable',
            'application/x-msdownload',
            'application/x-msdos-program'
        ];
        if (resourceScope.type !== role_scope_type_enum_1.RoleScopeType.GLOBAL && restrictedTypes.includes(file.mimetype)) {
            throw new common_1.BadRequestException(`File type ${file.mimetype} is not allowed for ${resourceScope.type} scope`);
        }
        // Path depth restrictions
        // const pathDepth = uploadPath.split('/').length;
        // const maxDepthByScope: any = {
        //   [RoleScopeType.GLOBAL]: 10,
        //   [RoleScopeType.ORGANIZATION]: 8,
        //   [RoleScopeType.BRANCH]: 6,
        //   [RoleScopeType.DEPARTMENT]: 5,
        //   [RoleScopeType.OWNED]: 4,
        // };
        // const maxDepth = maxDepthByScope[resourceScope.type] || maxDepthByScope[RoleScopeType.OWNED];
        // if (pathDepth > maxDepth) {
        //   throw new BadRequestException(
        //     `Upload path depth ${pathDepth} exceeds maximum allowed depth of ${maxDepth} for ${resourceScope.type} scope`
        //   );
        // }
    }
    // @Post('upload-multiple')
    async uploadMultiple(files, req, folder, userId) {
        if (!files || files.length === 0) {
            throw new common_1.BadRequestException('No files provided');
        }
        try {
            const authorization = req.headers.authorization;
            return await this.fileService.uploadFiles(files, {
                folder,
                token: authorization,
                metadata: { uploadedBy: userId || 'anonymous' }
            });
        }
        catch (error) {
            if (error instanceof Error) {
                throw new common_1.BadRequestException(`Files upload failed: ${error.message}`);
            }
            throw new common_1.BadRequestException('Files upload failed');
        }
    }
    async getFileMetadata(key, request) {
        try {
            const authorization = request.headers.authorization;
            return await this.fileService.getFileMetadata(key, authorization);
        }
        catch (error) {
            throw new common_1.NotFoundException(`File not found: ${key}`);
        }
    }
    async validateFileAccess(fileKey, resourceScope, userId, action = 'read') {
        var _a, _b, _c;
        // Extract tenant information from file path
        const pathParts = fileKey.split('/');
        if (pathParts.length < 2) {
            // If it's not in a tenant-specific path, only allow if it's owned scope and matches user
            if (resourceScope.type === role_scope_type_enum_1.RoleScopeType.OWNED) {
                // For owned scope, we'd need to check file metadata to see if user owns it
                // This would require extending the file service to include ownership info
                return;
            }
            else if (resourceScope.type === role_scope_type_enum_1.RoleScopeType.GLOBAL) {
                return; // Global scope can access any file
            }
            throw new common_1.ForbiddenException('Access denied to this file');
        }
        // Parse tenant path structure: organizations/orgId/branches/branchId/departments/deptId/...
        const tenantInfo = this.parseTenantPath(fileKey);
        // Validate access based on scope
        switch (resourceScope.type) {
            case role_scope_type_enum_1.RoleScopeType.GLOBAL:
                return; // Global scope can access any file
            case role_scope_type_enum_1.RoleScopeType.ORGANIZATION:
                if (tenantInfo.organizationId && !((_a = resourceScope.organizations) === null || _a === void 0 ? void 0 : _a.includes(tenantInfo.organizationId))) {
                    throw new common_1.ForbiddenException('Access denied to this organization\'s files');
                }
                break;
            case role_scope_type_enum_1.RoleScopeType.BRANCH:
                if (tenantInfo.branchId && !((_b = resourceScope.branches) === null || _b === void 0 ? void 0 : _b.includes(tenantInfo.branchId))) {
                    throw new common_1.ForbiddenException('Access denied to this branch\'s files');
                }
                break;
            case role_scope_type_enum_1.RoleScopeType.DEPARTMENT:
                if (tenantInfo.departmentId && !((_c = resourceScope.departments) === null || _c === void 0 ? void 0 : _c.includes(tenantInfo.departmentId))) {
                    throw new common_1.ForbiddenException('Access denied to this department\'s files');
                }
                break;
            case role_scope_type_enum_1.RoleScopeType.OWNED:
                // For owned scope, would need to check file metadata for actual ownership
                // This is a simplified check based on path structure
                break;
        }
    }
    parseTenantPath(filePath) {
        const parts = filePath.split('/');
        const result = {};
        for (let i = 0; i < parts.length - 1; i++) {
            if (parts[i] === 'organizations' && parts[i + 1]) {
                result.organizationId = parts[i + 1];
            }
            else if (parts[i] === 'branches' && parts[i + 1]) {
                result.branchId = parts[i + 1];
            }
            else if (parts[i] === 'departments' && parts[i + 1]) {
                result.departmentId = parts[i + 1];
            }
        }
        return result;
    }
    async downloadFile(key, req, res, user) {
        const resourceScope = req.resourceScope;
        // Check if user has access to this file based on the file path and their scope
        await this.validateFileAccess(key, resourceScope, user === null || user === void 0 ? void 0 : user.sub);
        try {
            await this.fileService.downloadFile(key, res);
        }
        catch (error) {
            throw new common_1.NotFoundException(`File not found: ${key}`);
        }
    }
    async streamFile(fileKey, query, req, res, user) {
        var _a, _b;
        const resourceScope = req.resourceScope;
        // Extract tenant context from query
        const tenantContext = {
            organizationId: query.organizationId,
            branchId: query.branchId,
            departmentId: query.departmentId,
            userId: query.userId
        };
        // Get file metadata first to validate access
        const metadata = await this.fileService.getFileMetadata(fileKey, req.headers.authorization);
        // Get file stream with tenant validation
        const stream = await this.fileService.getFileStream(fileKey, {
            scope: resourceScope,
            tenantContext,
            authorization: req.headers.authorization
        });
        // Set appropriate headers for streaming
        res.set({
            'Content-Type': metadata.mimeType,
            'Content-Length': metadata.size.toString(),
            'Content-Disposition': `inline; filename="${encodeURIComponent(metadata.originalName)}"`,
            'Cache-Control': 'public, max-age=31536000', // 1 year cache
            'Last-Modified': (_a = metadata.lastModified) === null || _a === void 0 ? void 0 : _a.toUTCString(),
            'ETag': `"${metadata.size}-${(_b = metadata.lastModified) === null || _b === void 0 ? void 0 : _b.getTime()}"`,
        });
        // Handle range requests for video/audio streaming
        const range = req.headers.range;
        if (range && (metadata.mimeType.startsWith('video/') || metadata.mimeType.startsWith('audio/'))) {
            const parts = range.replace(/bytes=/, "").split("-");
            const start = parseInt(parts[0], 10);
            const end = parts[1] ? parseInt(parts[1], 10) : metadata.size - 1;
            const chunksize = (end - start) + 1;
            res.status(206);
            res.set({
                'Content-Range': `bytes ${start}-${end}/${metadata.size}`,
                'Accept-Ranges': 'bytes',
                'Content-Length': chunksize.toString(),
            });
            // Get range stream from file service
            const rangeStream = await this.fileService.getFileStream(fileKey, {
                scope: resourceScope,
                tenantContext,
                authorization: req.headers.authorization
            });
            rangeStream.pipe(res);
        }
        else {
            // Stream the entire file
            stream.pipe(res);
        }
        this.logger.log(`File streamed: ${fileKey} by user ${user === null || user === void 0 ? void 0 : user.sub} from tenant context: ${JSON.stringify(tenantContext)}`);
    }
    async getFileUrl(key, req) {
        try {
            const authorization = req.headers.authorization;
            const url = await this.fileService.getFileUrl(key, authorization);
            return { url };
        }
        catch (error) {
            throw new common_1.NotFoundException(`File not found: ${key}`);
        }
    }
    async deleteFile(key, req, user) {
        const resourceScope = req.resourceScope;
        // Check if user has delete access to this file
        await this.validateFileAccess(key, resourceScope, user === null || user === void 0 ? void 0 : user.sub, 'delete');
        const success = await this.fileService.deleteFile(key);
        return { success };
    }
    async listFiles(queryDto, req, user) {
        var _a, _b, _c;
        const resourceScope = req.resourceScope;
        if (!resourceScope) {
            throw new common_1.ForbiddenException('Access scope not determined');
        }
        try {
            // Get effective tenant context based on user's scope and request
            const effectiveContext = this.getEffectiveTenantContext(resourceScope, (_a = queryDto.scope) === null || _a === void 0 ? void 0 : _a.organizationId, (_b = queryDto.scope) === null || _b === void 0 ? void 0 : _b.branchId, (_c = queryDto.scope) === null || _c === void 0 ? void 0 : _c.departmentId);
            // Build the folder path for file listing
            const folderPath = this.buildTenantFolder(effectiveContext.organizationId, effectiveContext.branchId, effectiveContext.departmentId, queryDto.folder);
            const authorization = req.headers.authorization;
            // Convert DTO to service options format with proper folder path
            const listOptions = this.convertToServiceOptions(queryDto, folderPath);
            // Get files and directories from the file service
            const serviceResult = await this.fileService.listFiles(listOptions, authorization);
            // Filter files based on user's actual permissions
            const filteredFiles = await this.filterFilesByUserScope(serviceResult.files || [], resourceScope, user === null || user === void 0 ? void 0 : user.sub);
            // The service now returns the proper pagination format, so we use it directly
            const response = {
                files: filteredFiles,
                directories: serviceResult.directories,
                pagination: serviceResult.pagination,
                parentDir: serviceResult.parentDir,
                breadcrumbs: serviceResult.breadcrumbs,
                scope: {
                    organizationId: effectiveContext.organizationId,
                    branchId: effectiveContext.branchId,
                    departmentId: effectiveContext.departmentId,
                    userId: resourceScope.type === role_scope_type_enum_1.RoleScopeType.OWNED ? user === null || user === void 0 ? void 0 : user.sub : undefined
                }
            };
            return response;
        }
        catch (error) {
            this.logger.error(`Error listing files for user ${user === null || user === void 0 ? void 0 : user.sub}:`, error);
            // More specific error handling
            if (error instanceof common_1.ForbiddenException) {
                throw error;
            }
            else if (error instanceof Error) {
                throw new common_1.BadRequestException(`Failed to list files: ${error.message}`);
            }
            throw new common_1.BadRequestException('Failed to list files: Unknown error');
        }
    }
    /**
     * Converts DTO options to service-compatible options
     */
    convertToServiceOptions(queryDto, folderPath) {
        var _a, _b, _c;
        return {
            folder: folderPath || queryDto.folder,
            page: queryDto.page || 1,
            limit: queryDto.limit || 50,
            includeDirs: (_a = queryDto.includeDirs) !== null && _a !== void 0 ? _a : true,
            includeUrls: (_b = queryDto.includeUrls) !== null && _b !== void 0 ? _b : true,
            sortBy: queryDto.sortBy || file_list_options_dto_1.FileSortField.NAME,
            sortDirection: queryDto.sortDirection || file_list_options_dto_1.SortDirection.ASC,
            searchTerm: queryDto.searchTerm,
            showHidden: (_c = queryDto.showHidden) !== null && _c !== void 0 ? _c : false,
            scope: queryDto.scope
        };
    }
    /**
     * Filters files based on user's scope and permissions
     */
    async filterFilesByUserScope(files, resourceScope, userId) {
        if (resourceScope.type === role_scope_type_enum_1.RoleScopeType.GLOBAL) {
            return files; // Global scope can see all files
        }
        return files.filter(file => {
            var _a, _b, _c, _d, _e;
            try {
                // For owned scope, filter files by user ownership
                if (resourceScope.type === role_scope_type_enum_1.RoleScopeType.OWNED) {
                    return ((_a = file.metadata) === null || _a === void 0 ? void 0 : _a.uploadedBy) === userId ||
                        ((_b = file.metadata) === null || _b === void 0 ? void 0 : _b.userId) === userId;
                }
                // For other scopes, validate based on file metadata and path
                const tenantInfo = this.parseTenantPath(file.key);
                // Check organization access
                if (resourceScope.type === role_scope_type_enum_1.RoleScopeType.ORGANIZATION ||
                    resourceScope.type === role_scope_type_enum_1.RoleScopeType.BRANCH ||
                    resourceScope.type === role_scope_type_enum_1.RoleScopeType.DEPARTMENT) {
                    const fileOrgId = ((_c = file.metadata) === null || _c === void 0 ? void 0 : _c.organizationId) || tenantInfo.organizationId;
                    if (fileOrgId && resourceScope.organizations &&
                        !resourceScope.organizations.includes(fileOrgId)) {
                        return false;
                    }
                }
                // Check branch access
                if (resourceScope.type === role_scope_type_enum_1.RoleScopeType.BRANCH ||
                    resourceScope.type === role_scope_type_enum_1.RoleScopeType.DEPARTMENT) {
                    const fileBranchId = ((_d = file.metadata) === null || _d === void 0 ? void 0 : _d.branchId) || tenantInfo.branchId;
                    if (fileBranchId && resourceScope.branches &&
                        !resourceScope.branches.includes(fileBranchId)) {
                        return false;
                    }
                }
                // Check department access
                if (resourceScope.type === role_scope_type_enum_1.RoleScopeType.DEPARTMENT) {
                    const fileDeptId = ((_e = file.metadata) === null || _e === void 0 ? void 0 : _e.departmentId) || tenantInfo.departmentId;
                    if (fileDeptId && resourceScope.departments &&
                        !resourceScope.departments.includes(fileDeptId)) {
                        return false;
                    }
                }
                return true;
            }
            catch (error) {
                this.logger.warn(`Error filtering file ${file.key}:`, error);
                return false; // When in doubt, filter out
            }
        });
    }
    /**
     * Builds breadcrumb navigation for the current path
     */
    buildBreadcrumbs(organizationId, branchId, departmentId, additionalFolder) {
        const breadcrumbs = [
            { name: 'Home', path: '/' }
        ];
        if (organizationId) {
            breadcrumbs.push({
                name: `Org: ${organizationId}`,
                path: `/organizations/${organizationId}`
            });
            if (branchId) {
                breadcrumbs.push({
                    name: `Branch: ${branchId}`,
                    path: `/organizations/${organizationId}/branches/${branchId}`
                });
                if (departmentId) {
                    breadcrumbs.push({
                        name: `Dept: ${departmentId}`,
                        path: `/organizations/${organizationId}/branches/${branchId}/departments/${departmentId}`
                    });
                }
            }
        }
        if (additionalFolder) {
            const folderParts = additionalFolder.split('/');
            let currentPath = breadcrumbs[breadcrumbs.length - 1].path;
            folderParts.forEach(part => {
                currentPath += `/${part}`;
                breadcrumbs.push({
                    name: part,
                    path: currentPath
                });
            });
        }
        return breadcrumbs;
    }
    async fileExists(key) {
        const exists = await this.fileService.fileExists(key);
        return { exists };
    }
    async createDirectory(dirPath, userId) {
        if (!dirPath) {
            throw new common_1.BadRequestException('No directory path provided');
        }
        try {
            return await this.fileService.createDirectory(dirPath);
        }
        catch (error) {
            if (error instanceof Error) {
                throw new common_1.BadRequestException(`Directory creation failed: ${error.message}`);
            }
            throw new common_1.BadRequestException('Directory creation failed');
        }
    }
    async deleteDirectory(dirPath, recursive = false, userId) {
        try {
            const success = await this.fileService.deleteDirectory(dirPath, recursive);
            return { success };
        }
        catch (error) {
            if (error instanceof Error) {
                throw new common_1.BadRequestException(`Directory deletion failed: ${error.message}`);
            }
            throw new common_1.BadRequestException('Directory deletion failed');
        }
    }
    async renameDirectory(dirPath, newPath, userId) {
        if (!newPath) {
            throw new common_1.BadRequestException('No new path provided');
        }
        try {
            return await this.fileService.renameDirectory(dirPath, newPath);
        }
        catch (error) {
            if (error instanceof Error) {
                throw new common_1.BadRequestException(`Directory rename failed: ${error.message}`);
            }
            throw new common_1.BadRequestException('Directory rename failed');
        }
    }
};
exports.FilesController = FilesController;
__decorate([
    (0, common_1.Post)('upload'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.CREATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Upload a Single File with Multi-tenant Security',
        description: 'Uploads a file to the tenant-specific directory with access control based on user scope.'
    }),
    (0, swagger_1.ApiConsumes)('multipart/form-data'),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                file: {
                    type: 'string',
                    format: 'binary',
                    description: 'File to upload'
                }
            }
        }
    }),
    (0, swagger_1.ApiQuery)({
        name: 'organizationId',
        type: String,
        required: false,
        description: 'Organization ID for organization/branch/department scoped uploads'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'branchId',
        required: false,
        type: String,
        description: 'Branch ID for branch/department scoped uploads'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'departmentId',
        type: String,
        required: false,
        description: 'Department ID for department scoped uploads'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'folder',
        required: false,
        type: String,
        description: 'Folder path relative to tenant root directory'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'userId',
        required: false,
        type: String,
        description: 'User ID for user-specific uploads (admin only or owned resources)'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        description: 'File uploaded successfully',
        type: file_meta_data_dto_1.FileMetadata
    }),
    (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
    (0, common_1.UseInterceptors)((0, platform_express_1.FileInterceptor)('file')),
    __param(0, (0, common_1.UploadedFile)()),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, common_1.Query)()),
    __param(3, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof Express !== "undefined" && (_b = Express.Multer) !== void 0 && _b.File) === "function" ? _c : Object, Object, typeof (_d = typeof file_upload_dto_1.FileUploadDto !== "undefined" && file_upload_dto_1.FileUploadDto) === "function" ? _d : Object, typeof (_e = typeof jwt_payload_interface_1.IJwtPayload !== "undefined" && jwt_payload_interface_1.IJwtPayload) === "function" ? _e : Object]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], FilesController.prototype, "uploadFile", null);
__decorate([
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Upload multiple files' }),
    (0, swagger_1.ApiConsumes)('multipart/form-data'),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                files: {
                    type: 'array',
                    items: {
                        type: 'string',
                        format: 'binary'
                    },
                    description: 'Files to upload (max 10)'
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Files uploaded successfully',
        type: [file_meta_data_dto_1.FileMetadata]
    }),
    (0, common_1.UseInterceptors)((0, platform_express_1.FilesInterceptor)('files', 10)),
    __param(0, (0, common_1.UploadedFiles)()),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, common_1.Query)('folder')),
    __param(3, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, typeof (_g = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _g : Object, String, String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], FilesController.prototype, "uploadMultiple", null);
__decorate([
    (0, common_1.Get)('metadata/:key(*)'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({ summary: 'Get file metadata with multi-tenant security' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'File key' }),
    (0, swagger_1.ApiQuery)({
        name: 'organizationId',
        type: String,
        required: false,
        description: 'Organization ID for scoped access'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'branchId',
        required: false,
        type: String,
        description: 'Branch ID for scoped access'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'departmentId',
        type: String,
        required: false,
        description: 'Department ID for scoped access'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'userId',
        required: false,
        type: String,
        description: 'User ID for user-specific access'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'File metadata retrieved successfully',
        type: file_meta_data_dto_1.FileMetadata
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'File not found' }),
    __param(0, (0, common_1.Param)('key')),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_j = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _j : Object]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], FilesController.prototype, "getFileMetadata", null);
__decorate([
    (0, common_1.Get)('download/:key(*)'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({ summary: 'Download a file with access control' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'File key' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'File download' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'File not found' }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'Access denied' }),
    __param(0, (0, common_1.Param)('key')),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, common_1.Res)()),
    __param(3, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, typeof (_l = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _l : Object, typeof (_m = typeof jwt_payload_interface_1.IJwtPayload !== "undefined" && jwt_payload_interface_1.IJwtPayload) === "function" ? _m : Object]),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], FilesController.prototype, "downloadFile", null);
__decorate([
    (0, common_1.Get)('stream/:key(*)'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({ summary: 'Stream a file (for browser viewing) with tenant security' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'File key' }),
    (0, swagger_1.ApiQuery)({
        name: 'organizationId',
        type: String,
        required: false,
        description: 'Organization ID for scoped access'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'branchId',
        required: false,
        type: String,
        description: 'Branch ID for scoped access'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'departmentId',
        type: String,
        required: false,
        description: 'Department ID for scoped access'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'userId',
        required: false,
        type: String,
        description: 'User ID for user-specific access'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'File stream' }),
    (0, generic_api_responses_decorator_1.ApiGenericResponses)(),
    (0, common_1.UseInterceptors)(),
    (0, common_1.Version)(common_1.VERSION_NEUTRAL),
    __param(0, (0, common_1.Param)('key')),
    __param(1, (0, common_1.Query)()),
    __param(2, (0, common_1.Req)()),
    __param(3, (0, common_1.Res)()),
    __param(4, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object, Object, typeof (_p = typeof jwt_payload_interface_1.IJwtPayload !== "undefined" && jwt_payload_interface_1.IJwtPayload) === "function" ? _p : Object]),
    __metadata("design:returntype", typeof (_q = typeof Promise !== "undefined" && Promise) === "function" ? _q : Object)
], FilesController.prototype, "streamFile", null);
__decorate([
    (0, common_1.Get)('url/:key'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get a temporary URL for a file with user current token' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'File key' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'File URL',
        schema: {
            type: 'object',
            properties: {
                url: { type: 'string' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('key')),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_r = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _r : Object]),
    __metadata("design:returntype", typeof (_s = typeof Promise !== "undefined" && Promise) === "function" ? _s : Object)
], FilesController.prototype, "getFileUrl", null);
__decorate([
    (0, common_1.Delete)(':key(*)'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.DELETE }),
    (0, swagger_1.ApiOperation)({ summary: 'Delete a file with access control' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'File key' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'File deleted successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('key')),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, typeof (_t = typeof jwt_payload_interface_1.IJwtPayload !== "undefined" && jwt_payload_interface_1.IJwtPayload) === "function" ? _t : Object]),
    __metadata("design:returntype", typeof (_u = typeof Promise !== "undefined" && Promise) === "function" ? _u : Object)
], FilesController.prototype, "deleteFile", null);
__decorate([
    (0, common_1.Get)('list'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({ summary: 'List files with scope-based access control' }),
    (0, swagger_1.ApiQuery)({
        name: 'page',
        required: false,
        type: Number,
        description: 'Page number for pagination'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'limit',
        required: false,
        type: Number,
        description: 'Number of items per page (max 1000)'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'folder',
        required: false,
        type: String,
        description: 'Folder path to list files from'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'includeUrls',
        required: false,
        type: Boolean,
        description: 'Include downloadable URLs in response'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'includeDirs',
        required: false,
        type: Boolean,
        description: 'Include directories in results'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'sortBy',
        required: false,
        enum: file_list_options_dto_1.FileSortField,
        description: 'Field to sort by (name, size, createdAt, lastModified, mimeType)'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'sortDirection',
        required: false,
        enum: file_list_options_dto_1.SortDirection,
        description: 'Sort direction (asc, desc)'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'searchTerm',
        required: false,
        type: String,
        description: 'Search term for filtering files by name'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'showHidden',
        required: false,
        type: Boolean,
        description: 'Include hidden files (starting with .)'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Files listed successfully',
        type: file_list_response_dto_1.FileListResponseDto
    }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'Access denied' }),
    __param(0, (0, common_1.Query)()),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_v = typeof file_list_options_dto_1.FileListOptionsDto !== "undefined" && file_list_options_dto_1.FileListOptionsDto) === "function" ? _v : Object, Object, typeof (_w = typeof jwt_payload_interface_1.IJwtPayload !== "undefined" && jwt_payload_interface_1.IJwtPayload) === "function" ? _w : Object]),
    __metadata("design:returntype", typeof (_x = typeof Promise !== "undefined" && Promise) === "function" ? _x : Object)
], FilesController.prototype, "listFiles", null);
__decorate([
    (0, common_1.Get)('validate/:key'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Check if a file exists' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'File key' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'File existence status',
        schema: {
            type: 'object',
            properties: {
                exists: { type: 'boolean' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_y = typeof Promise !== "undefined" && Promise) === "function" ? _y : Object)
], FilesController.prototype, "fileExists", null);
__decorate([
    (0, common_1.Post)('directories'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new directory' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                path: {
                    type: 'string',
                    description: 'Directory path to create'
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Directory created successfully',
        type: directory_metadata_dto_1.DirectoryMetadata
    }),
    __param(0, (0, common_1.Body)('path')),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_z = typeof Promise !== "undefined" && Promise) === "function" ? _z : Object)
], FilesController.prototype, "createDirectory", null);
__decorate([
    (0, common_1.Delete)('directories/:path(*)'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Delete a directory' }),
    (0, swagger_1.ApiParam)({ name: 'path', description: 'Directory path to delete' }),
    (0, swagger_1.ApiQuery)({
        name: 'recursive',
        required: false,
        description: 'Whether to recursively delete non-empty directories'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Directory deleted successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('path')),
    __param(1, (0, common_1.Query)('recursive')),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Boolean, String]),
    __metadata("design:returntype", typeof (_0 = typeof Promise !== "undefined" && Promise) === "function" ? _0 : Object)
], FilesController.prototype, "deleteDirectory", null);
__decorate([
    (0, common_1.Put)('directories/:path(*)'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Rename a directory' }),
    (0, swagger_1.ApiParam)({ name: 'path', description: 'Current directory path' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                newPath: {
                    type: 'string',
                    description: 'New directory path'
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Directory renamed successfully',
        type: directory_metadata_dto_1.DirectoryMetadata
    }),
    __param(0, (0, common_1.Param)('path')),
    __param(1, (0, common_1.Body)('newPath')),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", typeof (_1 = typeof Promise !== "undefined" && Promise) === "function" ? _1 : Object)
], FilesController.prototype, "renameDirectory", null);
exports.FilesController = FilesController = FilesController_1 = __decorate([
    (0, swagger_1.ApiTags)('Files'),
    (0, common_1.Controller)('files'),
    __param(0, (0, common_1.Inject)(file_provider_config_1.FILE_SERVICE)),
    __metadata("design:paramtypes", [typeof (_a = typeof file_service_interface_1.IFileService !== "undefined" && file_service_interface_1.IFileService) === "function" ? _a : Object])
], FilesController);


/***/ }),

/***/ "./src/modules/files/files.module.ts":
/*!*******************************************!*\
  !*** ./src/modules/files/files.module.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const file_provider_config_1 = __webpack_require__(/*! ./config/file-provider.config */ "./src/modules/files/config/file-provider.config.ts");
const files_controller_1 = __webpack_require__(/*! ./files.controller */ "./src/modules/files/files.controller.ts");
let FilesModule = class FilesModule {
};
exports.FilesModule = FilesModule;
exports.FilesModule = FilesModule = __decorate([
    (0, common_1.Module)({
        providers: [...file_provider_config_1.fileProviders],
        controllers: [files_controller_1.FilesController],
    })
], FilesModule);


/***/ }),

/***/ "./src/modules/files/interfaces/file-service.interface.ts":
/*!****************************************************************!*\
  !*** ./src/modules/files/interfaces/file-service.interface.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/modules/files/services/base-file.service.ts":
/*!*********************************************************!*\
  !*** ./src/modules/files/services/base-file.service.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseFileService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const crypto = __importStar(__webpack_require__(/*! crypto */ "crypto"));
const csv_writer_1 = __webpack_require__(/*! csv-writer */ "csv-writer");
const ExcelJS = __importStar(__webpack_require__(/*! exceljs */ "exceljs"));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const pdfkit_1 = __importDefault(__webpack_require__(/*! pdfkit */ "pdfkit"));
let BaseFileService = class BaseFileService {
    constructor(uploadDir, baseUrl) {
        this.logger = new common_1.Logger(this.constructor.name);
        this.uploadDir = uploadDir || '';
        this.baseUrl = baseUrl || '';
    }
    // Common implementable methods
    async streamFile(fileKey, res, inline = null) {
        var _a;
        try {
            // Check if file exists first to handle 404 gracefully
            if (!(await this.fileExists(fileKey))) {
                res.status(404).send('File not found');
                return;
            }
            const contentType = await this.getContentType(fileKey);
            const metadata = await this.getFileMetadata(fileKey);
            const filename = path.basename(fileKey);
            const fileSize = metadata.size;
            const filePath = path.join(this.uploadDir, fileKey);
            // Auto-detect if inline should be true based on content type if not explicitly set
            if (inline === null) {
                inline = contentType.startsWith('video/') ||
                    contentType.startsWith('audio/') ||
                    contentType === 'application/pdf' ||
                    contentType.startsWith('image/');
            }
            // Set common headers
            res.setHeader('Access-Control-Allow-Origin', '*');
            res.setHeader('Access-Control-Allow-Headers', 'Range');
            res.setHeader('Accept-Ranges', 'bytes');
            // Set cache control based on file type
            if (contentType.startsWith('image/')) {
                // Cache images longer
                res.setHeader('Cache-Control', 'public, max-age=86400, immutable');
            }
            else if (contentType.startsWith('video/') || contentType.startsWith('audio/')) {
                // Streaming media cache
                res.setHeader('Cache-Control', 'public, max-age=3600');
            }
            else {
                // Default cache for documents and other files
                res.setHeader('Cache-Control', 'public, max-age=3600, must-revalidate');
            }
            // Set content type and disposition
            res.setHeader('Content-Type', contentType);
            res.setHeader('Content-Disposition', `${inline ? 'inline' : 'attachment'}; filename="${encodeURIComponent(filename)}"`);
            // Get range header from request
            const range = res.req.headers.range;
            // Apply range requests for videos, audio, and large files
            const isRangeSupported = contentType.startsWith('video/') ||
                contentType.startsWith('audio/') ||
                contentType === 'application/pdf' ||
                fileSize > 10 * 1024 * 1024; // 10MB+
            // If no range header or range not supported for this file type, send entire file
            if (!range || !isRangeSupported) {
                res.setHeader('Content-Length', fileSize);
                const stream = await this.getFileStream(fileKey);
                return new Promise((resolve, reject) => {
                    stream.pipe(res)
                        .on('finish', () => resolve())
                        .on('error', (err) => {
                        this.logger.error(`Error streaming file: ${err.message}`, err.stack);
                        reject(err);
                    });
                });
            }
            // Handle range request
            const parts = range.replace(/bytes=/, '').split('-');
            const start = parseInt(parts[0], 10);
            const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
            // Validate range request
            if (isNaN(start) || isNaN(end) || start >= fileSize || end >= fileSize) {
                // Return 416 Range Not Satisfiable if range is invalid
                res.status(416);
                res.setHeader('Content-Range', `bytes */${fileSize}`);
                res.end();
                return;
            }
            const chunkSize = end - start + 1;
            // Set partial content headers
            res.status(206);
            res.setHeader('Content-Range', `bytes ${start}-${end}/${fileSize}`);
            res.setHeader('Content-Length', chunkSize);
            // Create read stream with range
            const stream = fs.createReadStream(filePath, { start, end });
            return new Promise((resolve, reject) => {
                stream.pipe(res)
                    .on('finish', () => resolve())
                    .on('error', (err) => {
                    this.logger.error(`Error streaming file range: ${err.message}`, err.stack);
                    reject(err);
                });
            });
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error streaming file: ${err.message}`, err.stack);
            // If headers haven't been sent yet, send appropriate error response
            if (!res.headersSent) {
                if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.includes('not found')) {
                    res.status(404).send('File not found');
                }
                else {
                    res.status(500).send('Error streaming file');
                }
            }
            else {
                // If headers were sent, just end the response
                res.end();
            }
            throw error;
        }
    }
    async downloadFile(fileKey, res) {
        try {
            return this.streamFile(fileKey, res, false);
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error downloading file: ${err.message}`, err.stack);
            throw error;
        }
    }
    generateUniqueFileName(originalName) {
        const timestamp = Date.now();
        const randomString = crypto.randomBytes(8).toString('hex');
        const extension = path.extname(originalName);
        const sanitizedName = path.basename(originalName, extension)
            .replace(/[^a-zA-Z0-9]/g, '-')
            .substring(0, 40);
        return `${sanitizedName}-${timestamp}-${randomString}${extension}`;
    }
    async exportToCsv(data, options) {
        const columns = (options === null || options === void 0 ? void 0 : options.columns) || Object.keys(data[0] || {}).map(id => ({ id, title: id }));
        const csvStringifier = (0, csv_writer_1.createObjectCsvStringifier)({ header: columns });
        const headers = csvStringifier.getHeaderString();
        const records = csvStringifier.stringifyRecords(data);
        return Buffer.from(headers + records);
    }
    async exportToExcel(data, options) {
        var _a;
        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet((options === null || options === void 0 ? void 0 : options.sheetName) || 'Data');
        const columns = ((_a = options === null || options === void 0 ? void 0 : options.columns) === null || _a === void 0 ? void 0 : _a.map(col => ({
            header: col.title,
            key: col.id,
            width: 15
        }))) || Object.keys(data[0] || {}).map(id => ({
            header: id,
            key: id,
            width: 15
        }));
        worksheet.columns = columns;
        if (options === null || options === void 0 ? void 0 : options.headerStyle) {
            worksheet.getRow(1).font = options.headerStyle;
        }
        data.forEach(item => {
            worksheet.addRow(item);
        });
        return await workbook.xlsx.writeBuffer();
    }
    async exportToPdf(data, options) {
        return new Promise((resolve) => {
            const buffers = [];
            const doc = new pdfkit_1.default({
                margin: 50,
                size: 'A4',
                layout: (options === null || options === void 0 ? void 0 : options.orientation) || 'portrait'
            });
            doc.on('data', buffers.push.bind(buffers));
            doc.on('end', () => {
                resolve(Buffer.concat(buffers));
            });
            // Add title
            doc.fontSize(16).text((options === null || options === void 0 ? void 0 : options.filename) || 'Data Export', {
                align: 'center'
            });
            doc.moveDown();
            // Create a simple table
            const columns = (options === null || options === void 0 ? void 0 : options.columns) || Object.keys(data[0] || {}).map(id => ({ id, title: id }));
            const tableTop = 150;
            const tableLeft = 50;
            let rowTop = tableTop;
            // Draw header
            doc.fontSize(12);
            columns.forEach((column, i) => {
                const leftPos = tableLeft + (i * 100);
                doc.font('Helvetica-Bold').text(column.title, leftPos, rowTop);
            });
            // Draw rows
            rowTop += 20;
            data.forEach(row => {
                columns.forEach((column, i) => {
                    const leftPos = tableLeft + (i * 100);
                    doc.font('Helvetica').text(String(row[column.id] || ''), leftPos, rowTop);
                });
                rowTop += 20;
                // Add new page if needed
                if (rowTop > 700) {
                    doc.addPage();
                    rowTop = 50;
                }
            });
            doc.end();
        });
    }
    /**
     * Validates file against size and type constraints
     * Utility method for implementations to use during upload operations
     */
    validateFile(file, options) {
        // Check file size if max size specified
        if ((options === null || options === void 0 ? void 0 : options.maxSizeBytes) && file.size > options.maxSizeBytes) {
            throw new Error(`File size exceeds the limit of ${options.maxSizeBytes} bytes`);
        }
        // Check file type if allowed types specified
        if ((options === null || options === void 0 ? void 0 : options.allowedTypes) && options.allowedTypes.length > 0) {
            const mimeType = options.contentType || file.mimetype;
            if (!options.allowedTypes.includes(mimeType)) {
                throw new Error(`File type ${mimeType} not allowed`);
            }
        }
        return true;
    }
};
exports.BaseFileService = BaseFileService;
exports.BaseFileService = BaseFileService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [String, String])
], BaseFileService);


/***/ }),

/***/ "./src/modules/files/services/local-file.service.ts":
/*!**********************************************************!*\
  !*** ./src/modules/files/services/local-file.service.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalFileService = void 0;
const utility_helper_1 = __webpack_require__(/*! @/common/helpers/utility.helper */ "./src/common/helpers/utility.helper.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const fs_1 = __webpack_require__(/*! fs */ "fs");
const mime = __importStar(__webpack_require__(/*! mime-types */ "mime-types"));
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const file_list_options_dto_1 = __webpack_require__(/*! ../dtos/file-list-options.dto */ "./src/modules/files/dtos/file-list-options.dto.ts");
const base_file_service_1 = __webpack_require__(/*! ./base-file.service */ "./src/modules/files/services/base-file.service.ts");
let LocalFileService = class LocalFileService extends base_file_service_1.BaseFileService {
    constructor(configService) {
        const uploadDir = configService.getOrThrow('FILE_DIRECTORY');
        const baseUrl = configService.getOrThrow('FILE_BASE_URL');
        super(uploadDir, baseUrl);
        this.configService = configService;
        this.chunkUploads = new Map();
        this.uploadDir = uploadDir; // Keep for backward compatibility
        this.baseUrl = baseUrl; // Keep for backward compatibility
        this.tempDir = path_1.default.join(this.uploadDir, 'temp');
        // Ensure upload directories exist
        if (!fs.existsSync(this.uploadDir)) {
            fs.mkdirSync(this.uploadDir, { recursive: true });
        }
        // Ensure temp directory exists
        if (!fs.existsSync(this.tempDir)) {
            fs.mkdirSync(this.tempDir, { recursive: true });
        }
        // Create a dir for tracking upload metadata
        this.metadataDir = path_1.default.join(this.uploadDir, 'metadata');
        if (!fs.existsSync(this.metadataDir)) {
            fs.mkdirSync(this.metadataDir, { recursive: true });
        }
    }
    // Replace chunkUploads in-memory map with file-based storage
    async initiateChunkedUpload(fileInfo) {
        try {
            const uploadId = crypto.randomUUID();
            // Store metadata in a file instead of memory
            const metadataPath = path_1.default.join(this.metadataDir, `${uploadId}.json`);
            await fs_1.promises.writeFile(metadataPath, JSON.stringify({
                info: fileInfo,
                chunks: [],
                chunkPaths: Array(fileInfo.totalChunks).fill(''),
                createdAt: new Date().toISOString()
            }));
            this.logger.log(`Initiated chunked upload ${uploadId} for ${fileInfo.filename}`);
            return uploadId;
        }
        catch (error) {
            throw error;
        }
    }
    // Update getChunkUploadData helper
    async getChunkUploadData(uploadId) {
        const metadataPath = path_1.default.join(this.metadataDir, `${uploadId}.json`);
        if (!fs.existsSync(metadataPath)) {
            throw new Error(`Upload with ID ${uploadId} not found`);
        }
        const data = JSON.parse(await fs_1.promises.readFile(metadataPath, 'utf8'));
        // Convert chunks array back to Set for backwards compatibility
        data.chunks = new Set(data.chunks);
        return data;
    }
    // Update saveChunkUploadData helper
    async saveChunkUploadData(uploadId, data) {
        const metadataPath = path_1.default.join(this.metadataDir, `${uploadId}.json`);
        // Convert Set back to array for storage
        const toSave = Object.assign(Object.assign({}, data), { chunks: Array.from(data.chunks) });
        await fs_1.promises.writeFile(metadataPath, JSON.stringify(toSave));
    }
    async uploadChunk(uploadId, chunkNumber, chunk) {
        try {
            // Get upload tracking data
            const uploadData = this.chunkUploads.get(uploadId);
            if (!uploadData) {
                throw new Error(`Upload with ID ${uploadId} not found`);
            }
            // Validate chunk number
            if (chunkNumber < 0 || chunkNumber >= uploadData.info.totalChunks) {
                throw new Error(`Invalid chunk number ${chunkNumber}. Must be between 0 and ${uploadData.info.totalChunks - 1}`);
            }
            // Create a temporary file for this chunk
            const chunkFileName = `${uploadId}_chunk_${chunkNumber}`;
            const chunkPath = path_1.default.join(this.tempDir, chunkFileName);
            // Write the chunk to disk
            await fs_1.promises.writeFile(chunkPath, chunk);
            // Update tracking data
            uploadData.chunks.add(chunkNumber);
            uploadData.chunkPaths[chunkNumber] = chunkPath;
            // Prepare result
            const result = {
                uploadId,
                chunkNumber,
                receivedSize: chunk.length,
                totalChunksReceived: uploadData.chunks.size,
                completed: uploadData.chunks.size === uploadData.info.totalChunks
            };
            this.logger.log(`Received chunk ${chunkNumber} for upload ${uploadId} (${uploadData.chunks.size}/${uploadData.info.totalChunks})`);
            return result;
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error uploading chunk: ${err.message}`, err.stack);
            throw error;
        }
    }
    async completeChunkedUpload(uploadId) {
        try {
            // Get upload tracking data
            const uploadData = this.chunkUploads.get(uploadId);
            if (!uploadData) {
                throw new Error(`Upload with ID ${uploadId} not found`);
            }
            // Verify all chunks have been received
            if (uploadData.chunks.size !== uploadData.info.totalChunks) {
                throw new Error(`Cannot complete upload: received ${uploadData.chunks.size} of ${uploadData.info.totalChunks} chunks`);
            }
            // Create target directory if needed
            const folder = uploadData.info.folder || '';
            const targetDir = path_1.default.join(this.uploadDir, folder);
            if (folder && !fs.existsSync(targetDir)) {
                fs.mkdirSync(targetDir, { recursive: true });
            }
            // Generate final filename and path
            const fileName = this.generateUniqueFileName(uploadData.info.filename);
            const finalPath = path_1.default.join(targetDir, fileName);
            const fileKey = folder ? `${folder}/${fileName}` : fileName;
            // Combine chunks into the final file
            const writeStream = fs.createWriteStream(finalPath);
            // Process chunks in order
            for (let i = 0; i < uploadData.info.totalChunks; i++) {
                const chunkPath = uploadData.chunkPaths[i];
                if (!chunkPath) {
                    throw new Error(`Missing chunk ${i} for upload ${uploadId}`);
                }
                // Read chunk and append to final file
                const chunkData = await fs_1.promises.readFile(chunkPath);
                writeStream.write(chunkData);
                // Delete temporary chunk file
                await fs_1.promises.unlink(chunkPath).catch(err => this.logger.warn(`Failed to delete chunk file: ${err.message}`));
            }
            // Close the write stream
            await new Promise((resolve, reject) => {
                writeStream.on('finish', resolve);
                writeStream.on('error', reject);
                writeStream.end();
            });
            // Get file stats
            const stats = await fs_1.promises.stat(finalPath);
            // Create metadata
            const metadata = {
                key: fileKey,
                originalName: uploadData.info.filename,
                size: stats.size,
                mimeType: uploadData.info.mimeType,
                url: `${this.baseUrl}/${fileKey}`,
                createdAt: stats.birthtime,
                lastModified: stats.mtime,
                metadata: uploadData.info.metadata
            };
            // Clean up upload tracking data
            this.chunkUploads.delete(uploadId);
            this.logger.log(`Completed chunked upload ${uploadId}, created file ${fileKey}`);
            return metadata;
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error completing chunked upload: ${err.message}`, err.stack);
            // Try to clean up any temporary files if possible
            try {
                const uploadData = this.chunkUploads.get(uploadId);
                if (uploadData) {
                    for (const chunkPath of uploadData.chunkPaths) {
                        if (chunkPath && fs.existsSync(chunkPath)) {
                            await fs_1.promises.unlink(chunkPath).catch(() => { });
                        }
                    }
                }
            }
            catch (_a) { }
            throw error;
        }
    }
    async uploadFile(file, options) {
        try {
            // Validate file
            this.validateFile(file, options);
            const folder = (options === null || options === void 0 ? void 0 : options.folder) || '';
            // Ensure the folder path doesn't allow directory traversal
            const sanitizedFolder = folder
                .replace(/\.\./g, '') // Remove ..
                .replace(/^\/+/, '') // Remove leading slashes
                .replace(/\/+/g, '/') // Normalize multiple slashes
                .replace(/\/+$/, ''); // Remove trailing slashes
            const finalDir = path_1.default.join(this.uploadDir, sanitizedFolder);
            // Security check: ensure the final directory is within uploadDir
            const resolvedFinalDir = path_1.default.resolve(finalDir);
            const resolvedUploadDir = path_1.default.resolve(this.uploadDir);
            if (!resolvedFinalDir.startsWith(resolvedUploadDir)) {
                throw new Error('Invalid upload path: directory traversal detected');
            }
            // Create folder if it doesn't exist
            if (!fs.existsSync(finalDir)) {
                fs.mkdirSync(finalDir, { recursive: true });
                this.logger.log(`Created tenant directory: ${sanitizedFolder}`);
            }
            const fileName = this.generateUniqueFileName(file.originalname);
            const filePath = path_1.default.join(finalDir, fileName);
            const fileKey = sanitizedFolder ? `${sanitizedFolder}/${fileName}` : fileName;
            // Write file
            await fs_1.promises.writeFile(filePath, file.buffer);
            // Get file stats
            const stats = await fs_1.promises.stat(filePath);
            const url = await this.getFileUrl(fileKey, options === null || options === void 0 ? void 0 : options.token);
            const metadata = {
                key: fileKey,
                originalName: file.originalname,
                size: file.size,
                mimeType: file.mimetype,
                url,
                createdAt: stats.birthtime,
                lastModified: stats.mtime,
                metadata: Object.assign({}, options === null || options === void 0 ? void 0 : options.metadata),
            };
            this.logger.log(`File uploaded to tenant directory: ${fileKey}`);
            return metadata;
        }
        catch (error) {
            this.logger.error(`Error uploading file: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }
    // TODO: Implement tenant scoping and separation
    async uploadFiles(files, options) {
        const results = [];
        for (const file of files) {
            const result = await this.uploadFile(file, options);
            results.push(result);
        }
        return results;
    }
    async getFileMetadata(fileKey, authorization) {
        const filePath = path_1.default.join(this.uploadDir, fileKey);
        if (!fs.existsSync(filePath)) {
            throw new Error(`File ${fileKey} not found`);
        }
        const stats = await fs_1.promises.stat(filePath);
        const mimeType = mime.lookup(filePath) || 'application/octet-stream';
        const originalName = path_1.default.basename(fileKey);
        const url = await this.getFileUrl(fileKey, authorization);
        return {
            key: fileKey,
            originalName,
            size: stats.size,
            mimeType,
            url,
            createdAt: stats.birthtime,
            lastModified: stats.mtime,
        };
    }
    async deleteFile(fileKey) {
        const filePath = path_1.default.join(this.uploadDir, fileKey);
        if (!fs.existsSync(filePath)) {
            return false;
        }
        await fs_1.promises.unlink(filePath);
        return true;
    }
    async fileExists(fileKey) {
        try {
            const filePath = path_1.default.join(this.uploadDir, fileKey);
            return fs.existsSync(filePath);
        }
        catch (error) {
            return false;
        }
    }
    async listFiles(options, authorization) {
        var _a, _b, _c;
        try {
            // Set default options with proper typing
            const opts = Object.assign({ page: (options === null || options === void 0 ? void 0 : options.page) || 1, limit: (options === null || options === void 0 ? void 0 : options.limit) || 50, folder: options === null || options === void 0 ? void 0 : options.folder, includeDirs: (_a = options === null || options === void 0 ? void 0 : options.includeDirs) !== null && _a !== void 0 ? _a : true, includeUrls: (_b = options === null || options === void 0 ? void 0 : options.includeUrls) !== null && _b !== void 0 ? _b : true, sortBy: (options === null || options === void 0 ? void 0 : options.sortBy) || file_list_options_dto_1.FileSortField.NAME, sortDirection: (options === null || options === void 0 ? void 0 : options.sortDirection) || file_list_options_dto_1.SortDirection.ASC, searchTerm: options === null || options === void 0 ? void 0 : options.searchTerm, showHidden: (_c = options === null || options === void 0 ? void 0 : options.showHidden) !== null && _c !== void 0 ? _c : false, scope: options === null || options === void 0 ? void 0 : options.scope }, options);
            // Resolve base directory using 'folder' instead of 'prefix'
            const baseDir = opts.folder
                ? path_1.default.join(this.uploadDir, opts.folder)
                : this.uploadDir;
            // Check if directory exists
            if (!fs.existsSync(baseDir)) {
                return {
                    files: [],
                    directories: [],
                    pagination: {
                        page: opts.page,
                        limit: opts.limit,
                        totalCount: 0,
                        totalPages: 0,
                        hasNextPage: false,
                        hasPreviousPage: false,
                        nextPage: undefined,
                        previousPage: undefined,
                        itemsPerPage: opts.limit
                    },
                    breadcrumbs: this.generateBreadcrumbs(opts.folder),
                    parentDir: this.getParentDirectory(opts.folder),
                    scope: opts.scope
                };
            }
            // Initialize result containers
            const files = [];
            const directories = [];
            let totalSize = 0;
            // Helper function to check if file matches filters
            const matchesFilters = async (filePath, stats, fileName) => {
                // Skip hidden files unless showHidden is true
                if (!opts.showHidden && fileName.startsWith('.')) {
                    return false;
                }
                // Text search filter
                if (opts.searchTerm) {
                    const lowerFileName = fileName.toLowerCase();
                    const searchTerm = opts.searchTerm.toLowerCase();
                    if (!lowerFileName.includes(searchTerm))
                        return false;
                }
                return true;
            };
            // Function to process directory content
            const processDirectory = async (dirPath, relPath = '') => {
                // Read directory contents
                const items = await fs_1.promises.readdir(dirPath);
                // Process directories first
                if (opts.includeDirs) {
                    for (const item of items) {
                        // Skip hidden items if not showing hidden
                        if (!opts.showHidden && item.startsWith('.')) {
                            continue;
                        }
                        const itemPath = path_1.default.join(dirPath, item);
                        try {
                            const stats = await fs_1.promises.stat(itemPath);
                            if (stats.isDirectory()) {
                                const dirRelPath = relPath ? `${relPath}/${item}` : item;
                                const dirKey = opts.folder ? `${opts.folder}/${dirRelPath}` : dirRelPath;
                                // Only include directories at the current level (not recursive)
                                if (dirPath === baseDir) {
                                    // Calculate directory size and item count
                                    let dirSize = 0;
                                    let itemCount = 0;
                                    try {
                                        const dirItems = await fs_1.promises.readdir(itemPath);
                                        itemCount = dirItems.length;
                                        dirSize = await this.calculateDirectorySize(itemPath, opts.showHidden);
                                    }
                                    catch (err) {
                                        const error = err;
                                        this.logger.warn(`Error reading directory ${dirKey}: ${error.message}`);
                                    }
                                    directories.push({
                                        key: dirKey,
                                        name: item,
                                        createdAt: stats.birthtime,
                                        lastModified: stats.mtime,
                                        itemCount,
                                        size: dirSize
                                    });
                                }
                            }
                        }
                        catch (err) {
                            // Skip directories we can't access
                            this.logger.warn(`Error processing directory ${itemPath}: ${err.message}`);
                        }
                    }
                }
                // Process files
                for (const item of items) {
                    const itemPath = path_1.default.join(dirPath, item);
                    try {
                        const stats = await fs_1.promises.stat(itemPath);
                        if (stats.isFile()) {
                            const fileRelPath = relPath ? `${relPath}/${item}` : item;
                            const fileKey = opts.folder ? `${opts.folder}/${fileRelPath}` : fileRelPath;
                            // Apply filters
                            if (await matchesFilters(itemPath, stats, item)) {
                                totalSize += stats.size;
                                files.push({
                                    key: fileKey,
                                    originalName: item,
                                    size: stats.size,
                                    mimeType: mime.lookup(itemPath) || 'application/octet-stream',
                                    url: opts.includeUrls ? await this.getFileUrl(fileKey, authorization) : undefined,
                                    createdAt: stats.birthtime,
                                    lastModified: stats.mtime,
                                });
                            }
                        }
                    }
                    catch (err) {
                        // Skip files we can't access
                        this.logger.warn(`Error processing file ${itemPath}: ${err.message}`);
                    }
                }
            };
            // Process main directory
            await processDirectory(baseDir);
            // Apply sorting with directories first
            const sortItems = (a, b) => {
                var _a, _b, _c, _d;
                // Always sort directories before files
                const aIsDir = !('originalName' in a);
                const bIsDir = !('originalName' in b);
                if (aIsDir && !bIsDir)
                    return -1;
                if (!aIsDir && bIsDir)
                    return 1;
                const direction = opts.sortDirection === file_list_options_dto_1.SortDirection.DESC ? -1 : 1;
                switch (opts.sortBy) {
                    case file_list_options_dto_1.FileSortField.NAME:
                        return (a.originalName || a.name).localeCompare(b.originalName || b.name) * direction;
                    case file_list_options_dto_1.FileSortField.SIZE:
                        return ((a.size || 0) - (b.size || 0)) * direction;
                    case file_list_options_dto_1.FileSortField.DATE_CREATED:
                        return (((_a = a.createdAt) === null || _a === void 0 ? void 0 : _a.getTime()) - ((_b = b.createdAt) === null || _b === void 0 ? void 0 : _b.getTime())) * direction;
                    case file_list_options_dto_1.FileSortField.DATE_MODIFIED:
                        return (((_c = a.lastModified) === null || _c === void 0 ? void 0 : _c.getTime()) - ((_d = b.lastModified) === null || _d === void 0 ? void 0 : _d.getTime())) * direction;
                    case file_list_options_dto_1.FileSortField.TYPE:
                        const aType = a.mimeType || '';
                        const bType = b.mimeType || '';
                        return aType.localeCompare(bType) * direction;
                    default:
                        return (a.originalName || a.name).localeCompare(b.originalName || b.name) * direction;
                }
            };
            // Sort files and directories
            files.sort(sortItems);
            directories.sort(sortItems);
            // Generate combined results for pagination
            const combinedItems = [...directories, ...files];
            const totalItems = combinedItems.length;
            // Calculate pagination
            const page = opts.page;
            const limit = opts.limit;
            const totalPages = Math.ceil(totalItems / limit);
            const startIdx = (page - 1) * limit;
            const endIdx = Math.min(startIdx + limit, totalItems);
            // Slice the array based on pagination parameters
            const paginatedItems = combinedItems.slice(startIdx, endIdx);
            // Separate files and directories again
            const paginatedFiles = paginatedItems
                .filter(item => 'originalName' in item);
            const paginatedDirs = paginatedItems
                .filter(item => !('originalName' in item));
            // Build pagination response
            const pagination = {
                page,
                limit,
                totalCount: totalItems,
                totalPages,
                hasNextPage: page < totalPages,
                hasPreviousPage: page > 1,
                nextPage: page < totalPages ? page + 1 : undefined,
                previousPage: page > 1 ? page - 1 : undefined,
                itemsPerPage: limit
            };
            return {
                files: paginatedFiles,
                directories: paginatedDirs,
                pagination,
                parentDir: this.getParentDirectory(opts.folder),
                breadcrumbs: this.generateBreadcrumbs(opts.folder),
                scope: opts.scope
            };
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error listing files: ${err.message}`, err.stack);
            throw error;
        }
    }
    // Helper methods
    generateBreadcrumbs(folderPath) {
        const breadcrumbs = [{ name: 'Home', path: '' }];
        if (folderPath) {
            const segments = folderPath.split('/');
            let currentPath = '';
            for (let i = 0; i < segments.length; i++) {
                currentPath = currentPath ? `${currentPath}/${segments[i]}` : segments[i];
                breadcrumbs.push({
                    name: segments[i],
                    path: currentPath
                });
            }
        }
        return breadcrumbs;
    }
    getParentDirectory(folderPath) {
        if (!folderPath)
            return undefined;
        const segments = folderPath.split('/');
        segments.pop();
        return segments.length > 0 ? segments.join('/') : '';
    }
    // Improved directory size calculation with hidden file option
    async calculateDirectorySize(dirPath, includeHidden = false) {
        let totalSize = 0;
        try {
            const items = await fs_1.promises.readdir(dirPath);
            for (const item of items) {
                // Skip hidden files if not including them
                if (!includeHidden && item.startsWith('.')) {
                    continue;
                }
                const itemPath = path_1.default.join(dirPath, item);
                try {
                    const stats = await fs_1.promises.stat(itemPath);
                    if (stats.isFile()) {
                        totalSize += stats.size;
                    }
                    else if (stats.isDirectory()) {
                        totalSize += await this.calculateDirectorySize(itemPath, includeHidden);
                    }
                }
                catch (err) {
                    // Skip files we can't access
                    this.logger.warn(`Error calculating size for ${itemPath}: ${err.message}`);
                }
            }
        }
        catch (err) {
            this.logger.warn(`Error reading directory ${dirPath}: ${err.message}`);
        }
        return totalSize;
    }
    async createDirectory(dirPath) {
        try {
            const fullPath = path_1.default.join(this.uploadDir, dirPath);
            if (fs.existsSync(fullPath)) {
                throw new Error(`Directory ${dirPath} already exists`);
            }
            await fs_1.promises.mkdir(fullPath, { recursive: true });
            const stats = await fs_1.promises.stat(fullPath);
            return {
                key: dirPath,
                name: path_1.default.basename(dirPath),
                createdAt: stats.birthtime,
                lastModified: stats.mtime,
                itemCount: 0,
                size: 0
            };
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error creating directory: ${err.message}`, err.stack);
            throw error;
        }
    }
    async deleteDirectory(dirPath, recursive = false) {
        try {
            const fullPath = path_1.default.join(this.uploadDir, dirPath);
            if (!fs.existsSync(fullPath)) {
                return false;
            }
            const stats = await fs_1.promises.stat(fullPath);
            if (!stats.isDirectory()) {
                throw new Error(`Path ${dirPath} is not a directory`);
            }
            // Check if directory is empty
            const items = await fs_1.promises.readdir(fullPath);
            if (items.length > 0 && !recursive) {
                throw new Error(`Directory ${dirPath} is not empty. Use recursive=true to delete anyway.`);
            }
            await fs_1.promises.rm(fullPath, { recursive, force: true });
            return true;
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error deleting directory: ${err.message}`, err.stack);
            throw error;
        }
    }
    async renameDirectory(oldPath, newPath) {
        try {
            const oldFullPath = path_1.default.join(this.uploadDir, oldPath);
            const newFullPath = path_1.default.join(this.uploadDir, newPath);
            if (!fs.existsSync(oldFullPath)) {
                throw new Error(`Directory ${oldPath} does not exist`);
            }
            if (fs.existsSync(newFullPath)) {
                throw new Error(`Target directory ${newPath} already exists`);
            }
            const stats = await fs_1.promises.stat(oldFullPath);
            if (!stats.isDirectory()) {
                throw new Error(`Path ${oldPath} is not a directory`);
            }
            await fs_1.promises.rename(oldFullPath, newFullPath);
            const newStats = await fs_1.promises.stat(newFullPath);
            const items = await fs_1.promises.readdir(newFullPath);
            return {
                key: newPath,
                name: path_1.default.basename(newPath),
                createdAt: newStats.birthtime,
                lastModified: newStats.mtime,
                itemCount: items.length,
                size: await this.calculateDirectorySize(newFullPath)
            };
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error renaming directory: ${err.message}`, err.stack);
            throw error;
        }
    }
    async getFileStream(fileKey, options) {
        try {
            // log scope and tentant conext
            this.logger.log(`getFileStream called with fileKey: ${fileKey}, scope: ${JSON.stringify(options === null || options === void 0 ? void 0 : options.scope)}, tenantContext: ${JSON.stringify(options === null || options === void 0 ? void 0 : options.tenantContext)}`);
            // Validate tenant access if scope and tenant context are provided
            if ((options === null || options === void 0 ? void 0 : options.scope) && (options === null || options === void 0 ? void 0 : options.tenantContext)) {
                const allowedTenantPath = utility_helper_1.UtilityHelper.validateAndGetTenantDirectory(options.scope, options.tenantContext);
                // log allowedTenantPath
                this.logger.log(`Allowed tenant path: ${allowedTenantPath}`);
                this.logger.log(`Validating file key: ${fileKey} against allowed tenant path: ${allowedTenantPath}`);
                // Validate the file key is within the allowed tenant directory
                if (!utility_helper_1.UtilityHelper.validateFilePath(fileKey, allowedTenantPath) && allowedTenantPath) {
                    throw new common_1.ForbiddenException(`Access denied: File ${fileKey} is outside your allowed directory`);
                }
            }
            // Sanitize file key to prevent directory traversal
            const sanitizedFileKey = fileKey
                .replace(/\.\./g, '') // Remove ..
                .replace(/^\/+/, '') // Remove leading slashes
                .replace(/\/+/g, '/'); // Normalize multiple slashes
            const filePath = path_1.default.join(this.uploadDir, sanitizedFileKey);
            // Additional security check: ensure the resolved path is within uploadDir
            const resolvedFilePath = path_1.default.resolve(filePath);
            const resolvedUploadDir = path_1.default.resolve(this.uploadDir);
            if (!resolvedFilePath.startsWith(resolvedUploadDir)) {
                throw new Error('Invalid file path: directory traversal detected');
            }
            if (!fs.existsSync(filePath)) {
                throw new Error(`File ${fileKey} not found`);
            }
            // Verify it's actually a file and not a directory
            const stats = await fs_1.promises.stat(filePath);
            if (!stats.isFile()) {
                throw new Error(`Path ${fileKey} is not a file`);
            }
            this.logger.log(`Streaming file: ${sanitizedFileKey}`);
            return fs.createReadStream(filePath);
        }
        catch (error) {
            this.logger.error(`Error streaming file ${fileKey}: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }
    async getFileBuffer(fileKey, options) {
        try {
            // Validate tenant access if scope and tenant context are provided
            if ((options === null || options === void 0 ? void 0 : options.scope) && (options === null || options === void 0 ? void 0 : options.tenantContext)) {
                const allowedTenantPath = utility_helper_1.UtilityHelper.validateAndGetTenantDirectory(options.scope, options.tenantContext);
                // Validate the file key is within the allowed tenant directory
                if (!utility_helper_1.UtilityHelper.validateFilePath(fileKey, allowedTenantPath)) {
                    throw new Error(`Access denied: File ${fileKey} is outside your allowed directory`);
                }
            }
            // Sanitize file key to prevent directory traversal
            const sanitizedFileKey = fileKey
                .replace(/\.\./g, '') // Remove ..
                .replace(/^\/+/, '') // Remove leading slashes
                .replace(/\/+/g, '/'); // Normalize multiple slashes
            const filePath = path_1.default.join(this.uploadDir, sanitizedFileKey);
            // Additional security check: ensure the resolved path is within uploadDir
            const resolvedFilePath = path_1.default.resolve(filePath);
            const resolvedUploadDir = path_1.default.resolve(this.uploadDir);
            if (!resolvedFilePath.startsWith(resolvedUploadDir)) {
                throw new Error('Invalid file path: directory traversal detected');
            }
            if (!fs.existsSync(filePath)) {
                throw new Error(`File ${fileKey} not found`);
            }
            // Verify it's actually a file and not a directory
            const stats = await fs_1.promises.stat(filePath);
            if (!stats.isFile()) {
                throw new Error(`Path ${fileKey} is not a file`);
            }
            this.logger.log(`Reading file buffer: ${sanitizedFileKey}`);
            return fs_1.promises.readFile(filePath);
        }
        catch (error) {
            this.logger.error(`Error reading file ${fileKey}: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }
    async getFileUrl(fileKey, authorization) {
        // Local storage doesn't support presigned URLs with expiration
        // Just return a direct URL
        const encodedFileKey = fileKey;
        const token = (authorization === null || authorization === void 0 ? void 0 : authorization.replace(/^Bearer\s+/i, '')) || '';
        return `${this.baseUrl}/${encodedFileKey}?token=${token}`;
    }
    async getContentType(fileKey) {
        const filePath = path_1.default.join(this.uploadDir, fileKey);
        return mime.lookup(filePath) || 'application/octet-stream';
    }
};
exports.LocalFileService = LocalFileService;
exports.LocalFileService = LocalFileService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], LocalFileService);


/***/ }),

/***/ "./src/modules/logs/activity-logs/activity-logs.controller.ts":
/*!********************************************************************!*\
  !*** ./src/modules/logs/activity-logs/activity-logs.controller.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivityLogsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const activity_logs_service_1 = __webpack_require__(/*! ./activity-logs.service */ "./src/modules/logs/activity-logs/activity-logs.service.ts");
const activity_log_dto_1 = __webpack_require__(/*! ./dtos/activity-log.dto */ "./src/modules/logs/activity-logs/dtos/activity-log.dto.ts");
const activity_log_entity_1 = __webpack_require__(/*! ./entities/activity-log.entity */ "./src/modules/logs/activity-logs/entities/activity-log.entity.ts");
class ActivityLogsController extends (0, create_controller_factory_1.createController)(activity_log_entity_1.ActivityLog, activity_logs_service_1.ActivityLogsService, activity_log_dto_1.GetActivityLogDto) {
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async update(id, entityDto, updatedById) {
        return await super.update(id, entityDto, updatedById);
    }
    async findById(id, relations, select) {
        return await super.findById(id, relations, select);
    }
    async findOne(fieldsString, relations, select) {
        return await super.findOne(fieldsString, relations, select);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    async delete(id) {
        return await super.delete(id);
    }
}
exports.ActivityLogsController = ActivityLogsController;


/***/ }),

/***/ "./src/modules/logs/activity-logs/activity-logs.module.ts":
/*!****************************************************************!*\
  !*** ./src/modules/logs/activity-logs/activity-logs.module.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivityLogsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const activity_logs_controller_1 = __webpack_require__(/*! ./activity-logs.controller */ "./src/modules/logs/activity-logs/activity-logs.controller.ts");
const activity_logs_service_1 = __webpack_require__(/*! ./activity-logs.service */ "./src/modules/logs/activity-logs/activity-logs.service.ts");
const activity_log_entity_1 = __webpack_require__(/*! ./entities/activity-log.entity */ "./src/modules/logs/activity-logs/entities/activity-log.entity.ts");
let ActivityLogsModule = class ActivityLogsModule {
};
exports.ActivityLogsModule = ActivityLogsModule;
exports.ActivityLogsModule = ActivityLogsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([activity_log_entity_1.ActivityLog]),
        ],
        controllers: [activity_logs_controller_1.ActivityLogsController],
        providers: [activity_logs_service_1.ActivityLogsService],
        exports: [activity_logs_service_1.ActivityLogsService],
    })
], ActivityLogsModule);


/***/ }),

/***/ "./src/modules/logs/activity-logs/activity-logs.service.ts":
/*!*****************************************************************!*\
  !*** ./src/modules/logs/activity-logs/activity-logs.service.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivityLogsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const activity_log_entity_1 = __webpack_require__(/*! ./entities/activity-log.entity */ "./src/modules/logs/activity-logs/entities/activity-log.entity.ts");
let ActivityLogsService = class ActivityLogsService extends base_service_1.BaseService {
    constructor(activityLogsRepository, usersService) {
        super(activityLogsRepository, usersService);
        this.activityLogsRepository = activityLogsRepository;
        this.usersService = usersService;
    }
};
exports.ActivityLogsService = ActivityLogsService;
exports.ActivityLogsService = ActivityLogsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(activity_log_entity_1.ActivityLog)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], ActivityLogsService);


/***/ }),

/***/ "./src/modules/logs/activity-logs/dtos/activity-log.dto.ts":
/*!*****************************************************************!*\
  !*** ./src/modules/logs/activity-logs/dtos/activity-log.dto.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetActivityLogDto = exports.UpdateActivityLogDto = exports.ActivityLogDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const log_level_enum_1 = __webpack_require__(/*! @/common/enums/log-level.enum */ "./src/common/enums/log-level.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const user_entity_1 = __webpack_require__(/*! @/modules/account-management/users/entities/user.entity */ "./src/modules/account-management/users/entities/user.entity.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class ActivityLogDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
    constructor() {
        super(...arguments);
        this.logLevel = log_level_enum_1.LogLevel.LOG;
    }
}
exports.ActivityLogDto = ActivityLogDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        enum: action_enum_1.Action,
        description: 'The action performed in the activity log',
        example: action_enum_1.Action.CREATE
    }),
    (0, class_validator_1.IsEnum)(action_enum_1.Action),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof action_enum_1.Action !== "undefined" && action_enum_1.Action) === "function" ? _a : Object)
], ActivityLogDto.prototype, "action", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        type: String,
        description: 'The subject involved in the activity',
        example: 'User profile'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ActivityLogDto.prototype, "subject", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        enum: log_level_enum_1.LogLevel,
        description: 'The log level of the activity',
        default: log_level_enum_1.LogLevel.LOG,
        example: log_level_enum_1.LogLevel.LOG
    }),
    (0, class_validator_1.IsEnum)(log_level_enum_1.LogLevel),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_b = typeof log_level_enum_1.LogLevel !== "undefined" && log_level_enum_1.LogLevel) === "function" ? _b : Object)
], ActivityLogDto.prototype, "logLevel", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        type: () => user_entity_1.User,
        description: 'The user who performed the action'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => user_entity_1.User),
    __metadata("design:type", typeof (_c = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _c : Object)
], ActivityLogDto.prototype, "user", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        type: String,
        description: 'Additional message about the activity',
        example: 'User profile was updated successfully'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ActivityLogDto.prototype, "message", void 0);
class UpdateActivityLogDto extends (0, swagger_1.PartialType)(ActivityLogDto) {
}
exports.UpdateActivityLogDto = UpdateActivityLogDto;
class GetActivityLogDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateActivityLogDto, "activity log") {
}
exports.GetActivityLogDto = GetActivityLogDto;


/***/ }),

/***/ "./src/modules/logs/activity-logs/entities/activity-log.entity.ts":
/*!************************************************************************!*\
  !*** ./src/modules/logs/activity-logs/entities/activity-log.entity.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivityLog = void 0;
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const log_level_enum_1 = __webpack_require__(/*! @/common/enums/log-level.enum */ "./src/common/enums/log-level.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const user_entity_1 = __webpack_require__(/*! @/modules/account-management/users/entities/user.entity */ "./src/modules/account-management/users/entities/user.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
let ActivityLog = class ActivityLog extends base_entity_1.BaseEntity {
};
exports.ActivityLog = ActivityLog;
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: action_enum_1.Action,
        nullable: false,
    }),
    __metadata("design:type", typeof (_a = typeof action_enum_1.Action !== "undefined" && action_enum_1.Action) === "function" ? _a : Object)
], ActivityLog.prototype, "action", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'varchar',
        nullable: false,
    }),
    __metadata("design:type", String)
], ActivityLog.prototype, "subject", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: log_level_enum_1.LogLevel,
        default: log_level_enum_1.LogLevel.LOG,
    }),
    __metadata("design:type", typeof (_b = typeof log_level_enum_1.LogLevel !== "undefined" && log_level_enum_1.LogLevel) === "function" ? _b : Object)
], ActivityLog.prototype, "logLevel", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, { nullable: true, onDelete: 'SET NULL' }),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_c = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _c : Object)
], ActivityLog.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'text',
        nullable: true,
    }),
    __metadata("design:type", String)
], ActivityLog.prototype, "message", void 0);
exports.ActivityLog = ActivityLog = __decorate([
    (0, typeorm_1.Entity)('activity-logs')
], ActivityLog);


/***/ }),

/***/ "./src/modules/logs/logs.module.ts":
/*!*****************************************!*\
  !*** ./src/modules/logs/logs.module.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const activity_logs_module_1 = __webpack_require__(/*! ./activity-logs/activity-logs.module */ "./src/modules/logs/activity-logs/activity-logs.module.ts");
const system_logs_module_1 = __webpack_require__(/*! ./system-logs/system-logs.module */ "./src/modules/logs/system-logs/system-logs.module.ts");
let LogsModule = class LogsModule {
};
exports.LogsModule = LogsModule;
exports.LogsModule = LogsModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            core_1.RouterModule.register([
                {
                    path: 'logs',
                    module: LogsModule,
                    children: [
                        {
                            path: 'activity',
                            module: activity_logs_module_1.ActivityLogsModule,
                        },
                        {
                            path: 'system',
                            module: system_logs_module_1.SystemLogsModule,
                        }
                    ],
                },
            ]),
            activity_logs_module_1.ActivityLogsModule,
            system_logs_module_1.SystemLogsModule,
        ],
        exports: [activity_logs_module_1.ActivityLogsModule, system_logs_module_1.SystemLogsModule],
    })
], LogsModule);


/***/ }),

/***/ "./src/modules/logs/system-logs/dtos/system-log.dto.ts":
/*!*************************************************************!*\
  !*** ./src/modules/logs/system-logs/dtos/system-log.dto.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetSystemLogDto = exports.UpdateSystemLogDto = exports.SystemLogDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const log_level_enum_1 = __webpack_require__(/*! @/common/enums/log-level.enum */ "./src/common/enums/log-level.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SystemLogDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.SystemLogDto = SystemLogDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Log level',
        enum: log_level_enum_1.LogLevel,
        example: log_level_enum_1.LogLevel.LOG,
        required: true
    }),
    (0, class_validator_1.IsEnum)(log_level_enum_1.LogLevel),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof log_level_enum_1.LogLevel !== "undefined" && log_level_enum_1.LogLevel) === "function" ? _a : Object)
], SystemLogDto.prototype, "level", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Log message content',
        example: 'User login successful',
        required: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], SystemLogDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Source of the log (component/module)',
        example: 'AuthService',
        required: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], SystemLogDto.prototype, "location", void 0);
class UpdateSystemLogDto extends (0, swagger_1.PartialType)(SystemLogDto) {
}
exports.UpdateSystemLogDto = UpdateSystemLogDto;
class GetSystemLogDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateSystemLogDto, "system log") {
}
exports.GetSystemLogDto = GetSystemLogDto;


/***/ }),

/***/ "./src/modules/logs/system-logs/entities/system-log.entity.ts":
/*!********************************************************************!*\
  !*** ./src/modules/logs/system-logs/entities/system-log.entity.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemLog = void 0;
const log_level_enum_1 = __webpack_require__(/*! @/common/enums/log-level.enum */ "./src/common/enums/log-level.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
let SystemLog = class SystemLog extends base_entity_1.BaseEntity {
};
exports.SystemLog = SystemLog;
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: log_level_enum_1.LogLevel,
        default: log_level_enum_1.LogLevel.LOG,
    }),
    (0, typeorm_1.Index)('idx_system_log_level'),
    __metadata("design:type", typeof (_a = typeof log_level_enum_1.LogLevel !== "undefined" && log_level_enum_1.LogLevel) === "function" ? _a : Object)
], SystemLog.prototype, "level", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'varchar',
        length: 255,
        nullable: false,
    }),
    (0, typeorm_1.Index)('idx_system_log_location'),
    __metadata("design:type", String)
], SystemLog.prototype, "location", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'text',
        nullable: false,
    }),
    __metadata("design:type", String)
], SystemLog.prototype, "message", void 0);
exports.SystemLog = SystemLog = __decorate([
    (0, typeorm_1.Entity)('system-logs')
], SystemLog);


/***/ }),

/***/ "./src/modules/logs/system-logs/services/system-logger.service.ts":
/*!************************************************************************!*\
  !*** ./src/modules/logs/system-logs/services/system-logger.service.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemLogger = void 0;
const log_level_enum_1 = __webpack_require__(/*! @/common/enums/log-level.enum */ "./src/common/enums/log-level.enum.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const system_logs_service_1 = __webpack_require__(/*! ../system-logs.service */ "./src/modules/logs/system-logs/system-logs.service.ts");
let SystemLogger = class SystemLogger extends common_1.ConsoleLogger {
    constructor(systemLogsService) {
        super();
        this.systemLogsService = systemLogsService;
        // Add a batch queue and process periodically
        this.logQueue = [];
        this.isBatchProcessing = false;
        this.batchSize = 10; // Configurable batch size
        // Define an array of log patterns to ignore (context + message patterns)
        this.ignoredLogPatterns = [
            { context: 'RouterExplorer' },
            { context: 'RoutesResolver' },
            { context: 'InstanceLoader' },
            // { context: 'BaseGateway' },
        ];
    }
    // Helper method to check if a log should be ignored
    shouldIgnoreLog(message, context) {
        if (!context)
            return false;
        return this.ignoredLogPatterns.some(pattern => context === pattern.context);
    }
    log(message, context) {
        if (!this.shouldIgnoreLog(message, context)) {
            super.log(message, context);
            this.saveLog(message, context, log_level_enum_1.LogLevel.LOG);
        }
    }
    error(message, trace, context) {
        if (!this.shouldIgnoreLog(message, context)) {
            super.error(message, trace, context);
            const fullMessage = trace ? `${message}\n${trace}` : message;
            this.saveLog(fullMessage, context, log_level_enum_1.LogLevel.ERROR);
        }
    }
    warn(message, context) {
        if (!this.shouldIgnoreLog(message, context)) {
            super.warn(message, context);
            this.saveLog(message, context, log_level_enum_1.LogLevel.WARN);
        }
    }
    debug(message, context) {
        // if (!this.shouldIgnoreLog(message, context)) {
        //     super.debug(message, context);
        //     this.saveLog(message, context, LogLevel.DEBUG);
        // }
    }
    verbose(message, context) {
        if (!this.shouldIgnoreLog(message, context)) {
            super.verbose(message, context);
            this.saveLog(message, context, log_level_enum_1.LogLevel.VERBOSE);
        }
    }
    /**
     * Save the log message to the database if the logs service is available
     */
    saveLog(message, context = 'Application', level) {
        if (!this.systemLogsService)
            return;
        // Convert objects/arrays to strings to ensure proper storage
        const formattedMessage = message === null ? 'null' :
            typeof message === 'object'
                ? JSON.stringify(message, this.getCircularReplacer())
                : String(message);
        this.logQueue.push({
            level,
            location: context,
            message: formattedMessage
        });
        if (this.logQueue.length >= this.batchSize && !this.isBatchProcessing) {
            this.processBatch();
        }
    }
    processBatch() {
        if (this.logQueue.length === 0)
            return;
        this.isBatchProcessing = true;
        const batch = this.logQueue.splice(0, this.batchSize);
        Promise.all(batch.map(log => this.systemLogsService.create(log)))
            .catch(err => console.error('Failed to process log batch:', err))
            .finally(() => {
            this.isBatchProcessing = false;
            if (this.logQueue.length >= this.batchSize) {
                this.processBatch();
            }
        });
    }
    // Helper function to handle circular references
    getCircularReplacer() {
        const seen = new WeakSet();
        return (key, value) => {
            if (typeof value === 'object' && value !== null) {
                if (seen.has(value)) {
                    return '[Circular Reference]';
                }
                seen.add(value);
            }
            return value;
        };
    }
};
exports.SystemLogger = SystemLogger;
exports.SystemLogger = SystemLogger = __decorate([
    (0, common_1.Injectable)({ scope: common_1.Scope.TRANSIENT }),
    __metadata("design:paramtypes", [typeof (_a = typeof system_logs_service_1.SystemLogsService !== "undefined" && system_logs_service_1.SystemLogsService) === "function" ? _a : Object])
], SystemLogger);


/***/ }),

/***/ "./src/modules/logs/system-logs/system-logs.controller.ts":
/*!****************************************************************!*\
  !*** ./src/modules/logs/system-logs/system-logs.controller.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemLogsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const system_log_dto_1 = __webpack_require__(/*! ./dtos/system-log.dto */ "./src/modules/logs/system-logs/dtos/system-log.dto.ts");
const system_log_entity_1 = __webpack_require__(/*! ./entities/system-log.entity */ "./src/modules/logs/system-logs/entities/system-log.entity.ts");
const system_logs_service_1 = __webpack_require__(/*! ./system-logs.service */ "./src/modules/logs/system-logs/system-logs.service.ts");
class SystemLogsController extends (0, create_controller_factory_1.createController)(system_log_entity_1.SystemLog, system_logs_service_1.SystemLogsService, system_log_dto_1.GetSystemLogDto) {
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async update(id, entityDto, updatedById) {
        return await super.update(id, entityDto, updatedById);
    }
    async findById(id, relations, select) {
        return await super.findById(id, relations, select);
    }
    async findOne(fieldsString, relations, select) {
        return await super.findOne(fieldsString, relations, select);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    async delete(id) {
        return await super.delete(id);
    }
}
exports.SystemLogsController = SystemLogsController;


/***/ }),

/***/ "./src/modules/logs/system-logs/system-logs.module.ts":
/*!************************************************************!*\
  !*** ./src/modules/logs/system-logs/system-logs.module.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemLogsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const system_log_entity_1 = __webpack_require__(/*! ./entities/system-log.entity */ "./src/modules/logs/system-logs/entities/system-log.entity.ts");
const system_logger_service_1 = __webpack_require__(/*! ./services/system-logger.service */ "./src/modules/logs/system-logs/services/system-logger.service.ts");
const system_logs_controller_1 = __webpack_require__(/*! ./system-logs.controller */ "./src/modules/logs/system-logs/system-logs.controller.ts");
const system_logs_service_1 = __webpack_require__(/*! ./system-logs.service */ "./src/modules/logs/system-logs/system-logs.service.ts");
let SystemLogsModule = class SystemLogsModule {
};
exports.SystemLogsModule = SystemLogsModule;
exports.SystemLogsModule = SystemLogsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([system_log_entity_1.SystemLog]),
        ],
        controllers: [system_logs_controller_1.SystemLogsController],
        providers: [system_logs_service_1.SystemLogsService, system_logger_service_1.SystemLogger],
        exports: [system_logs_service_1.SystemLogsService],
    })
], SystemLogsModule);


/***/ }),

/***/ "./src/modules/logs/system-logs/system-logs.service.ts":
/*!*************************************************************!*\
  !*** ./src/modules/logs/system-logs/system-logs.service.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemLogsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const schedule_1 = __webpack_require__(/*! @nestjs/schedule */ "@nestjs/schedule");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const system_log_entity_1 = __webpack_require__(/*! ./entities/system-log.entity */ "./src/modules/logs/system-logs/entities/system-log.entity.ts");
let SystemLogsService = class SystemLogsService extends base_service_1.BaseService {
    constructor(systemLogsRepository, usersService) {
        super(systemLogsRepository, usersService);
        this.systemLogsRepository = systemLogsRepository;
        this.usersService = usersService;
    }
    async cleanUpOldLogs() {
        try {
            this.logger.log('Starting cleanup of old system logs');
            const daysToKeep = 30; // Keep logs for 30 days
            const deletedCount = await this.clearOldSystemLogs(daysToKeep);
            this.logger.log(`Successfully cleaned up ${deletedCount} old system logs`);
        }
        catch (error) {
            this.logger.error(`Error cleaning up old logs: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async clearOldSystemLogs(daysToKeep = 30) {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
        const result = await this.systemLogsRepository
            .createQueryBuilder()
            .delete()
            .where('createdAt < :cutoffDate', { cutoffDate })
            .execute();
        return result.affected || 0;
    }
};
exports.SystemLogsService = SystemLogsService;
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_DAY_AT_2AM),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SystemLogsService.prototype, "cleanUpOldLogs", null);
exports.SystemLogsService = SystemLogsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(system_log_entity_1.SystemLog)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], SystemLogsService);


/***/ }),

/***/ "./src/modules/notifications/dtos/notification.dto.ts":
/*!************************************************************!*\
  !*** ./src/modules/notifications/dtos/notification.dto.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetNotificationDto = exports.UpdateNotificationDto = exports.NotificationDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const reference_dto_1 = __webpack_require__(/*! @/common/dtos/reference.dto */ "./src/common/dtos/reference.dto.ts");
const notification_type_enum_1 = __webpack_require__(/*! @/common/enums/notification-type.enum */ "./src/common/enums/notification-type.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class NotificationDto extends base_dto_1.BaseDto {
    constructor() {
        super(...arguments);
        this.type = notification_type_enum_1.NotificationType.INFO;
    }
}
exports.NotificationDto = NotificationDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Notification title',
        example: 'New Payment Received'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Notification message content',
        example: 'You have received a new payment of $500'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Icon or image URL for the notification',
        example: 'https://example.com/icons/payment.png',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationDto.prototype, "iconOrImage", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The type of notification',
        enum: notification_type_enum_1.NotificationType,
        example: notification_type_enum_1.NotificationType.INFO,
        default: notification_type_enum_1.NotificationType.INFO
    }),
    (0, class_validator_1.IsEnum)(notification_type_enum_1.NotificationType),
    __metadata("design:type", typeof (_a = typeof notification_type_enum_1.NotificationType !== "undefined" && notification_type_enum_1.NotificationType) === "function" ? _a : Object)
], NotificationDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Optional link related to notification',
        example: '/payments/123',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationDto.prototype, "link", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The category of notification',
        example: 'payment',
        required: true
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationDto.prototype, "category", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Optional ID of the target recipient',
        example: '123e4567-e89b-12d3-a456-426614174099',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationDto.prototype, "targetId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Additional metadata for the notification',
        example: { amount: 500, currency: 'USD' },
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_b = typeof Record !== "undefined" && Record) === "function" ? _b : Object)
], NotificationDto.prototype, "metadata", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Recipients of the notification.',
        type: [reference_dto_1.ReferenceDto]
    }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], NotificationDto.prototype, "recipients", void 0);
class UpdateNotificationDto extends (0, swagger_1.PartialType)(NotificationDto) {
}
exports.UpdateNotificationDto = UpdateNotificationDto;
class GetNotificationDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateNotificationDto, 'notification') {
}
exports.GetNotificationDto = GetNotificationDto;


/***/ }),

/***/ "./src/modules/notifications/entities/notification.entity.ts":
/*!*******************************************************************!*\
  !*** ./src/modules/notifications/entities/notification.entity.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Notification = void 0;
const notification_type_enum_1 = __webpack_require__(/*! @/common/enums/notification-type.enum */ "./src/common/enums/notification-type.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const user_entity_1 = __webpack_require__(/*! @/modules/account-management/users/entities/user.entity */ "./src/modules/account-management/users/entities/user.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
let Notification = class Notification extends base_entity_1.BaseEntity {
};
exports.Notification = Notification;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Notification.prototype, "title", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Notification.prototype, "message", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Notification.prototype, "iconOrImage", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: notification_type_enum_1.NotificationType,
        default: notification_type_enum_1.NotificationType.INFO
    }),
    __metadata("design:type", typeof (_a = typeof notification_type_enum_1.NotificationType !== "undefined" && notification_type_enum_1.NotificationType) === "function" ? _a : Object)
], Notification.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Notification.prototype, "link", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], Notification.prototype, "read", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Notification.prototype, "readAt", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Notification.prototype, "category", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", typeof (_c = typeof Record !== "undefined" && Record) === "function" ? _c : Object)
], Notification.prototype, "metadata", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, (user) => user.notifications, { eager: true, cascade: true }),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_d = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _d : Object)
], Notification.prototype, "user", void 0);
exports.Notification = Notification = __decorate([
    (0, typeorm_1.Entity)('notifications')
], Notification);


/***/ }),

/***/ "./src/modules/notifications/gateways/notifications.gateway.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/notifications/gateways/notifications.gateway.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationsGateway = void 0;
const create_gateway_factory_1 = __webpack_require__(/*! @/common/factories/create-gateway.factory */ "./src/common/factories/create-gateway.factory.ts");
class NotificationsGateway extends (0, create_gateway_factory_1.createGateway)('notifications') {
    afterConnect(client) {
        var _a;
        super.afterConnect(client);
        if ((_a = client.user) === null || _a === void 0 ? void 0 : _a.sub) {
            // Notify UserConnectionService that user is online
            this.userConnectionService.userConnected(client.user.sub);
        }
    }
    afterDisconnect(client) {
        var _a;
        super.afterDisconnect(client);
        if ((_a = client.user) === null || _a === void 0 ? void 0 : _a.sub) {
            // Notify UserConnectionService that user is offline
            this.userConnectionService.userDisconnected(client.user.sub);
        }
    }
    // Override emitToUser to check if user is online first
    emitToUser(data, userId) {
        if (!userId) {
            this.logger.warn('No userId provided for emitToUser');
            return;
        }
        // Only emit if user is actually connected
        if (this.userConnectionService.isUserOnline(userId)) {
            super.emitToUser(data, userId);
        }
        else {
            this.logger.debug(`User ${userId} is offline, skipping WebSocket emission`);
        }
    }
}
exports.NotificationsGateway = NotificationsGateway;


/***/ }),

/***/ "./src/modules/notifications/notifications.controller.ts":
/*!***************************************************************!*\
  !*** ./src/modules/notifications/notifications.controller.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationsController = void 0;
const authorize_decorator_1 = __webpack_require__(/*! @/common/decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const current_user_decorator_1 = __webpack_require__(/*! @/common/decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const override_decorator_1 = __webpack_require__(/*! @/common/decorators/override.decorator */ "./src/common/decorators/override.decorator.ts");
const generalresponse_dto_1 = __webpack_require__(/*! @/common/dtos/generalresponse.dto */ "./src/common/dtos/generalresponse.dto.ts");
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const notification_dto_1 = __webpack_require__(/*! ./dtos/notification.dto */ "./src/modules/notifications/dtos/notification.dto.ts");
const notification_entity_1 = __webpack_require__(/*! ./entities/notification.entity */ "./src/modules/notifications/entities/notification.entity.ts");
const notifications_service_1 = __webpack_require__(/*! ./notifications.service */ "./src/modules/notifications/notifications.service.ts");
class NotificationsController extends (0, create_controller_factory_1.createController)(notification_entity_1.Notification, notifications_service_1.NotificationsService, notification_dto_1.GetNotificationDto, notification_dto_1.NotificationDto, notification_dto_1.UpdateNotificationDto) {
    constructor(notificationsService, notificationsGateway) {
        super(notificationsService);
        this.notificationsService = notificationsService;
        this.notificationsGateway = notificationsGateway;
    }
    async delete(id) {
        return await super.delete(id);
    }
    async findOne(fieldsString, relations, select) {
        return await super.findOne(fieldsString, relations, select);
    }
    async create(createNotificationDto, createdById) {
        return await this.notificationsService.createBulkNotifications(createNotificationDto, createdById);
    }
    async markAsRead(id, userId) {
        const notification = await this.notificationsService.update(id, { read: true, readAt: new Date() }, userId);
        return (0, class_transformer_1.plainToInstance)(notification_dto_1.GetNotificationDto, notification);
    }
    async markAllAsRead(userId) {
        const result = await this.notificationsService.markAllAsRead(userId);
        if (!result)
            throw new common_1.NotFoundException('No notifications to mark as read');
        return {
            message: 'All notifications has been marked as read'
        };
    }
    async countUnread(userId) {
        const count = await this.notificationsService.getUnreadCount(userId);
        return { count };
    }
    async clearAll(userId) {
        const result = await this.notificationsService.clearAll(userId);
        if (!result) {
            throw new common_1.NotFoundException('No notifications to clear');
        }
        return {
            message: 'All notifications have been cleared'
        };
    }
}
exports.NotificationsController = NotificationsController;
__decorate([
    (0, override_decorator_1.Override)(),
    (0, swagger_1.ApiOperation)({
        summary: 'Send a Notification to Multiple Users',
        description: 'Creates a notification for multiple recipients at once and queues them for delivery'
    }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof notification_dto_1.NotificationDto !== "undefined" && notification_dto_1.NotificationDto) === "function" ? _a : Object, String]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "create", null);
__decorate([
    (0, common_1.Patch)(':id/read'),
    (0, swagger_1.ApiOperation)({ summary: 'Mark a notification as read' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Notification ID' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Notification marked as read',
        type: notification_dto_1.GetNotificationDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'No notifications to mark as read',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized access',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden access',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Bad request',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], NotificationsController.prototype, "markAsRead", null);
__decorate([
    (0, common_1.Patch)('mark-all-as-read'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({ summary: 'Mark all notifications as read' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'All notifications marked as read',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'No notifications to mark as read',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized access',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden access',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Bad request',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], NotificationsController.prototype, "markAllAsRead", null);
__decorate([
    (0, common_1.Get)('count-unread'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({ summary: 'Get count of unread notifications' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Count of unread notifications',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized access',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden access',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Bad request',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], NotificationsController.prototype, "countUnread", null);
__decorate([
    (0, common_1.Delete)('clear-all'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.DELETE }),
    (0, swagger_1.ApiOperation)({ summary: 'Clear all notifications' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'All notifications cleared',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'No notifications to clear',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized access',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden access',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Bad request',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], NotificationsController.prototype, "clearAll", null);


/***/ }),

/***/ "./src/modules/notifications/notifications.module.ts":
/*!***********************************************************!*\
  !*** ./src/modules/notifications/notifications.module.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationsModule = void 0;
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const account_management_module_1 = __webpack_require__(/*! ../account-management/account-management.module */ "./src/modules/account-management/account-management.module.ts");
const notification_entity_1 = __webpack_require__(/*! ./entities/notification.entity */ "./src/modules/notifications/entities/notification.entity.ts");
const notifications_gateway_1 = __webpack_require__(/*! ./gateways/notifications.gateway */ "./src/modules/notifications/gateways/notifications.gateway.ts");
const notifications_controller_1 = __webpack_require__(/*! ./notifications.controller */ "./src/modules/notifications/notifications.controller.ts");
const notifications_service_1 = __webpack_require__(/*! ./notifications.service */ "./src/modules/notifications/notifications.service.ts");
const notifications_processor_1 = __webpack_require__(/*! ./processor/notifications.processor */ "./src/modules/notifications/processor/notifications.processor.ts");
const push_subscriptions_module_1 = __webpack_require__(/*! ./push-subscriptions/push-subscriptions.module */ "./src/modules/notifications/push-subscriptions/push-subscriptions.module.ts");
const user_connection_service_1 = __webpack_require__(/*! ./services/user-connection.service */ "./src/modules/notifications/services/user-connection.service.ts");
const web_push_service_1 = __webpack_require__(/*! ./services/web-push.service */ "./src/modules/notifications/services/web-push.service.ts");
let NotificationsModule = class NotificationsModule {
};
exports.NotificationsModule = NotificationsModule;
exports.NotificationsModule = NotificationsModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([notification_entity_1.Notification]),
            push_subscriptions_module_1.PushSubscriptionsModule,
            bull_1.BullModule.registerQueue({
                name: 'notifications',
            }),
            core_1.RouterModule.register([
                {
                    path: 'notifications',
                    module: NotificationsModule,
                    children: [
                        {
                            path: 'push',
                            module: push_subscriptions_module_1.PushSubscriptionsModule,
                        }
                    ]
                },
            ]),
            account_management_module_1.AccountManagementModule,
        ],
        providers: [
            notifications_service_1.NotificationsService,
            notifications_gateway_1.NotificationsGateway,
            notifications_processor_1.NotificationsProcessor,
            web_push_service_1.WebPushService,
            user_connection_service_1.UserConnectionService,
        ],
        exports: [
            notifications_service_1.NotificationsService,
            notifications_gateway_1.NotificationsGateway,
            push_subscriptions_module_1.PushSubscriptionsModule,
            web_push_service_1.WebPushService,
            user_connection_service_1.UserConnectionService,
        ],
        controllers: [notifications_controller_1.NotificationsController],
    })
], NotificationsModule);


/***/ }),

/***/ "./src/modules/notifications/notifications.service.ts":
/*!************************************************************!*\
  !*** ./src/modules/notifications/notifications.service.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NotificationsService_1;
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const bull_2 = __webpack_require__(/*! bull */ "bull");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const notification_entity_1 = __webpack_require__(/*! ./entities/notification.entity */ "./src/modules/notifications/entities/notification.entity.ts");
const notifications_gateway_1 = __webpack_require__(/*! ./gateways/notifications.gateway */ "./src/modules/notifications/gateways/notifications.gateway.ts");
const user_connection_service_1 = __webpack_require__(/*! ./services/user-connection.service */ "./src/modules/notifications/services/user-connection.service.ts");
let NotificationsService = NotificationsService_1 = class NotificationsService extends base_service_1.BaseService {
    constructor(notificationRepo, usersService, notificationsGateway, userConnectionService, notificationsQueue) {
        super(notificationRepo, usersService);
        this.notificationRepo = notificationRepo;
        this.usersService = usersService;
        this.notificationsGateway = notificationsGateway;
        this.userConnectionService = userConnectionService;
        this.notificationsQueue = notificationsQueue;
        this.notificationLogger = new common_1.Logger(NotificationsService_1.name);
    }
    async create(createDto, createdBy) {
        const notification = await super.create(createDto, createdBy);
        if (this.userConnectionService.isUserOnline(notification.user.id)) {
            this.notificationsGateway.emitToUser(notification, notification.user.id);
        }
        // Queue for processing instead of immediate sending
        await this.notificationsQueue.add('processNotification', {
            notificationId: notification.id,
            userId: notification.user.id,
        });
        return notification;
    }
    async update(id, updateDto, updatedBy) {
        const notification = await super.update(id, updateDto, updatedBy);
        // Queue for processing if not just updating read status
        if (!updateDto.read) {
            await this.notificationsQueue.add('processNotification', {
                notificationId: notification.id,
                userId: notification.user.id,
                isUpdate: true
            });
        }
        else {
            // Just emit read status update via WebSocket
            if (this.userConnectionService.isUserOnline(notification.user.id)) {
                this.notificationsGateway.emitToUser(notification, notification.user.id);
            }
        }
        return notification;
    }
    async getNotificationsByIds(ids) {
        const notifications = await this.notificationRepo.findBy({ id: (0, typeorm_2.In)(ids) });
        if (notifications.length !== ids.length) {
            const missingIds = ids.filter(id => !notifications.some(notification => notification.id === id));
            this.notificationLogger.warn(`Missing notifications for IDs: ${missingIds.join(', ')}`);
        }
        return notifications;
    }
    async createBulkNotifications(dto, createdBy) {
        const notifications = dto.recipients.map(recipient => {
            if (!recipient.id) {
                this.notificationLogger.warn(`Recipient id is missing for recipient: ${JSON.stringify(recipient)}`);
            }
            return this.notificationRepo.create(Object.assign(Object.assign({}, dto), { user: { id: recipient.id }, read: false, createdBy }));
        });
        const savedNotifications = await this.notificationRepo.save(notifications);
        // Separate online and offline users for different processing
        const onlineNotifications = [];
        const offlineNotifications = [];
        const notificationsByUser = new Map();
        savedNotifications.forEach(notification => {
            const userId = notification.user.id;
            if (!notificationsByUser.has(userId)) {
                notificationsByUser.set(userId, []);
            }
            notificationsByUser.get(userId).push(notification.id);
            // Check if user is online and emit immediately
            if (this.userConnectionService.isUserOnline(userId)) {
                this.notificationsGateway.emitToUser(notification, userId);
                onlineNotifications.push(notification.id);
            }
            else {
                offlineNotifications.push(notification.id);
            }
        });
        // Queue batch processing jobs
        for (const [userId, notificationIds] of notificationsByUser.entries()) {
            await this.notificationsQueue.add('processBatch', {
                notificationIds,
                userId,
                isUserOnline: this.userConnectionService.isUserOnline(userId)
            });
        }
        this.notificationLogger.log(`Processed ${onlineNotifications.length} online users, ${offlineNotifications.length} offline users`);
        return savedNotifications;
    }
    async getUnreadCount(userId) {
        const count = await this.notificationRepo.count({
            where: { user: { id: userId }, read: false }
        });
        return count;
    }
    async markAllAsRead(userId) {
        const result = await this.notificationRepo.update({ user: { id: userId }, read: false }, { read: true, readAt: new Date() });
        if (result.affected) {
            // Emit event to update client
            this.notificationsGateway.pingUser(userId);
            return true;
        }
        return false;
    }
    async clearAll(userId) {
        const result = await this.notificationRepo.softDelete({ user: { id: userId } });
        if (result.affected) {
            // Emit event to update client
            this.notificationsGateway.pingUser(userId);
            return true;
        }
        return false;
    }
};
exports.NotificationsService = NotificationsService;
exports.NotificationsService = NotificationsService = NotificationsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(notification_entity_1.Notification)),
    __param(4, (0, bull_1.InjectQueue)('notifications')),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof notifications_gateway_1.NotificationsGateway !== "undefined" && notifications_gateway_1.NotificationsGateway) === "function" ? _c : Object, typeof (_d = typeof user_connection_service_1.UserConnectionService !== "undefined" && user_connection_service_1.UserConnectionService) === "function" ? _d : Object, typeof (_e = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _e : Object])
], NotificationsService);


/***/ }),

/***/ "./src/modules/notifications/processor/notifications.processor.ts":
/*!************************************************************************!*\
  !*** ./src/modules/notifications/processor/notifications.processor.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NotificationsProcessor_1;
var _a, _b, _c, _d, _e, _f, _g, _h;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationsProcessor = void 0;
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const bull_2 = __webpack_require__(/*! bull */ "bull");
const notifications_gateway_1 = __webpack_require__(/*! ../gateways/notifications.gateway */ "./src/modules/notifications/gateways/notifications.gateway.ts");
const notifications_service_1 = __webpack_require__(/*! ../notifications.service */ "./src/modules/notifications/notifications.service.ts");
const push_subscriptions_service_1 = __webpack_require__(/*! ../push-subscriptions/push-subscriptions.service */ "./src/modules/notifications/push-subscriptions/push-subscriptions.service.ts");
const user_connection_service_1 = __webpack_require__(/*! ../services/user-connection.service */ "./src/modules/notifications/services/user-connection.service.ts");
const web_push_service_1 = __webpack_require__(/*! ../services/web-push.service */ "./src/modules/notifications/services/web-push.service.ts");
let NotificationsProcessor = NotificationsProcessor_1 = class NotificationsProcessor {
    constructor(notificationsService, notificationsGateway, webPushService, pushSubscriptionService, userConnectionService) {
        this.notificationsService = notificationsService;
        this.notificationsGateway = notificationsGateway;
        this.webPushService = webPushService;
        this.pushSubscriptionService = pushSubscriptionService;
        this.userConnectionService = userConnectionService;
        this.logger = new common_1.Logger(NotificationsProcessor_1.name);
        // Rate limiting cache by user
        this.userRateLimits = new Map();
        // Maximum notifications per minute
        this.MAX_NOTIFICATIONS_PER_MINUTE = 10;
    }
    async handleUserOnline(job) {
        const { userId } = job.data;
        // Send accumulated notifications to newly online user
        // This is where you'd fetch and send unread notifications
    }
    async handleProcessNotification(job) {
        const { notificationId, userId, isUpdate } = job.data;
        try {
            // Check rate limiting
            if (this.isRateLimited(userId, notificationId)) {
                this.logger.debug(`Rate limited notification ${notificationId} for user ${userId}`);
                return;
            }
            const notification = await this.notificationsService.findOneByOrFail({ id: notificationId });
            // Check if user is online
            const isUserOnline = this.userConnectionService.isUserOnline(userId);
            if (isUserOnline) {
                // Send via WebSocket
                this.notificationsGateway.emitToUser(notification, userId);
                this.logger.debug(`Sent notification ${notificationId} to online user ${userId} via WebSocket`);
            }
            else {
                // User is offline, send via Web Push
                await this.sendPushNotification(userId, notification);
            }
            return { success: true };
        }
        catch (error) {
            this.logger.error(`Failed to process notification ${notificationId}: ${error.message}`);
            throw error; // Let Bull retry
        }
    }
    async handleProcessBatch(job) {
        const { notificationIds, userId } = job.data;
        try {
            // Apply rate limiting
            const allowedIds = this.applyBatchRateLimit(userId, notificationIds);
            if (allowedIds.length === 0) {
                this.logger.debug(`All notifications rate limited for user ${userId}`);
                return;
            }
            // Get notifications from database
            const notifications = await this.notificationsService.getNotificationsByIds(allowedIds);
            if (notifications.length === 0) {
                this.logger.warn(`No notifications found for batch`);
                return;
            }
            // Check if user is online
            const isUserOnline = this.userConnectionService.isUserOnline(userId);
            if (isUserOnline) {
                // Send via WebSocket
                this.notificationsGateway.pingUser(userId);
            }
            else {
                // User is offline, send as grouped push notification if possible
                if (notifications.length === 1) {
                    // Single notification
                    await this.sendPushNotification(userId, notifications[0]);
                    this.notificationsGateway.emitToUser(notifications[0], userId);
                }
                else {
                    // Group notifications
                    await this.sendGroupedPushNotification(userId, notifications);
                }
            }
        }
        catch (error) {
            this.logger.error(`Failed to process batch notifications: ${error.message}`);
            throw error; // Let Bull retry
        }
    }
    //   @Process('processUserOnline')
    //   async handleUserOnline(job: Job<{ userId: string }>) {
    //     const { userId } = job.data;
    //     try {
    //       // Reset rate limiting for this user
    //       this.resetRateLimit(userId);
    //       // Get recent unread notifications (limited to reasonable number)
    //       const unreadNotifications = await this.notificationsService.getUnreadNotificationsForUser(userId, 15);
    //       if (unreadNotifications.length > 0) {
    //         // Send batch to user
    //         this.notificationsGateway.emitBatchToUser(unreadNotifications, userId);
    //         this.logger.debug(`Sent ${unreadNotifications.length} unread notifications to user ${userId} who just came online`);
    //       }
    //     } catch (error: any) {
    //       this.logger.error(`Failed to process user online event: ${error.message}`);
    //     }
    //   }
    /**
     * Send a push notification
     */
    async sendPushNotification(userId, notification) {
        // Get user's push subscriptions
        const subscriptions = await this.pushSubscriptionService.getUserSubscriptions(userId);
        if (!subscriptions || subscriptions.length === 0) {
            this.logger.debug(`No push subscriptions found for user ${userId}`);
            return;
        }
        // Format payload for Web Push
        const payload = {
            title: notification.title,
            body: notification.body,
            icon: '/assets/icons/icon-192x192.png', // Customize with your app's icon
            badge: '/assets/icons/badge-72x72.png', // Customize with your app's badge
            data: {
                notificationId: notification.id,
                url: notification.url || '/',
                type: notification.type,
                createdAt: notification.createdAt
            },
            actions: this.getNotificationActions(notification)
        };
        // Send to all user subscriptions
        const sendPromises = subscriptions.map(async (sub) => {
            try {
                const subscription = {
                    endpoint: sub.endpoint,
                    keys: {
                        p256dh: sub.p256dh,
                        auth: sub.auth
                    }
                };
                await this.webPushService.sendPushNotification(subscription, payload);
            }
            catch (error) {
                if (error.code === 'SUBSCRIPTION_EXPIRED') {
                    // Remove expired subscription
                    await this.pushSubscriptionService.removeExpiredSubscription(sub.endpoint);
                }
                else {
                    this.logger.error(`Failed to send to subscription: ${error.message}`);
                }
            }
        });
        await Promise.all(sendPromises);
    }
    /**
     * Send grouped push notification
     */
    async sendGroupedPushNotification(userId, notifications) {
        const subscriptions = await this.pushSubscriptionService.getUserSubscriptions(userId);
        if (!subscriptions || subscriptions.length === 0) {
            return;
        }
        // Group by type if available
        const typeGroups = new Map();
        notifications.forEach(notification => {
            const type = notification.type || 'general';
            if (!typeGroups.has(type)) {
                typeGroups.set(type, []);
            }
            typeGroups.get(type).push(notification);
        });
        // For each type, send a grouped notification
        for (const [type, items] of typeGroups.entries()) {
            if (items.length === 1) {
                // Just one notification of this type, send normally
                await this.sendPushNotification(userId, items[0]);
                continue;
            }
            // Create a grouped notification
            const payload = {
                title: `${items.length} new ${type} notifications`,
                body: items.length > 3
                    ? `${items[0].body.substring(0, 30)}... and ${items.length - 1} more`
                    : items.map(n => n.body.substring(0, 30)).join('\n'),
                icon: '/assets/icons/icon-192x192.png',
                badge: '/assets/icons/badge-72x72.png',
                data: {
                    notificationIds: items.map(n => n.id),
                    url: '/notifications',
                    type,
                    count: items.length
                },
                actions: [
                    { action: 'view', title: 'View All' },
                    { action: 'dismiss', title: 'Dismiss' }
                ]
            };
            // Send to all subscriptions
            const sendPromises = subscriptions.map(async (sub) => {
                try {
                    const subscription = {
                        endpoint: sub.endpoint,
                        keys: {
                            p256dh: sub.p256dh,
                            auth: sub.auth
                        }
                    };
                    await this.webPushService.sendPushNotification(subscription, payload);
                }
                catch (error) {
                    if (error.code === 'SUBSCRIPTION_EXPIRED') {
                        await this.pushSubscriptionService.removeExpiredSubscription(sub.endpoint);
                    }
                }
            });
            await Promise.all(sendPromises);
        }
    }
    /**
     * Get appropriate actions based on notification type
     */
    getNotificationActions(notification) {
        // Default actions
        const actions = [
            { action: 'view', title: 'View' },
            { action: 'dismiss', title: 'Dismiss' }
        ];
        // Add custom actions based on notification type
        switch (notification.type) {
            case 'comment':
                actions.push({ action: 'reply', title: 'Reply' });
                break;
            case 'message':
                actions.push({ action: 'reply', title: 'Reply' });
                break;
            case 'task':
                actions.push({ action: 'complete', title: 'Complete' });
                break;
        }
        return actions.slice(0, 2); // Most browsers only support 2 actions
    }
    /**
     * Check if notification should be rate limited
     */
    isRateLimited(userId, notificationId) {
        const now = new Date();
        if (!this.userRateLimits.has(userId)) {
            this.userRateLimits.set(userId, {
                count: 1,
                lastReset: now,
                pendingIds: []
            });
            return false;
        }
        const userLimit = this.userRateLimits.get(userId);
        // Reset if it's been over a minute
        if (now.getTime() - userLimit.lastReset.getTime() > 60000) {
            userLimit.count = 1;
            userLimit.lastReset = now;
            userLimit.pendingIds = [];
            return false;
        }
        // Check if under limit
        if (userLimit.count < this.MAX_NOTIFICATIONS_PER_MINUTE) {
            userLimit.count++;
            return false;
        }
        // Rate limited - store for later
        userLimit.pendingIds.push(notificationId);
        return true;
    }
    /**
     * Apply rate limiting to a batch of notifications
     */
    applyBatchRateLimit(userId, notificationIds) {
        const now = new Date();
        if (!this.userRateLimits.has(userId)) {
            this.userRateLimits.set(userId, {
                count: 0,
                lastReset: now,
                pendingIds: []
            });
        }
        const userLimit = this.userRateLimits.get(userId);
        // Reset if it's been over a minute
        if (now.getTime() - userLimit.lastReset.getTime() > 60000) {
            userLimit.count = 0;
            userLimit.lastReset = now;
            userLimit.pendingIds = [];
        }
        // How many can we send now?
        const available = this.MAX_NOTIFICATIONS_PER_MINUTE - userLimit.count;
        if (available <= 0) {
            // Rate limit all
            userLimit.pendingIds.push(...notificationIds);
            return [];
        }
        if (notificationIds.length <= available) {
            // Can send all
            userLimit.count += notificationIds.length;
            return notificationIds;
        }
        // Send what we can, queue the rest
        const toSend = notificationIds.slice(0, available);
        const toQueue = notificationIds.slice(available);
        userLimit.count += toSend.length;
        userLimit.pendingIds.push(...toQueue);
        return toSend;
    }
    /**
     * Reset rate limit for a user
     */
    resetRateLimit(userId) {
        this.userRateLimits.delete(userId);
    }
};
exports.NotificationsProcessor = NotificationsProcessor;
__decorate([
    (0, bull_1.Process)('handleUserOnline'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_f = typeof bull_2.Job !== "undefined" && bull_2.Job) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], NotificationsProcessor.prototype, "handleUserOnline", null);
__decorate([
    (0, bull_1.Process)('processNotification'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_g = typeof bull_2.Job !== "undefined" && bull_2.Job) === "function" ? _g : Object]),
    __metadata("design:returntype", Promise)
], NotificationsProcessor.prototype, "handleProcessNotification", null);
__decorate([
    (0, bull_1.Process)('processBatch'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_h = typeof bull_2.Job !== "undefined" && bull_2.Job) === "function" ? _h : Object]),
    __metadata("design:returntype", Promise)
], NotificationsProcessor.prototype, "handleProcessBatch", null);
exports.NotificationsProcessor = NotificationsProcessor = NotificationsProcessor_1 = __decorate([
    (0, common_1.Injectable)(),
    (0, bull_1.Processor)('notifications'),
    __metadata("design:paramtypes", [typeof (_a = typeof notifications_service_1.NotificationsService !== "undefined" && notifications_service_1.NotificationsService) === "function" ? _a : Object, typeof (_b = typeof notifications_gateway_1.NotificationsGateway !== "undefined" && notifications_gateway_1.NotificationsGateway) === "function" ? _b : Object, typeof (_c = typeof web_push_service_1.WebPushService !== "undefined" && web_push_service_1.WebPushService) === "function" ? _c : Object, typeof (_d = typeof push_subscriptions_service_1.PushSubscriptionsService !== "undefined" && push_subscriptions_service_1.PushSubscriptionsService) === "function" ? _d : Object, typeof (_e = typeof user_connection_service_1.UserConnectionService !== "undefined" && user_connection_service_1.UserConnectionService) === "function" ? _e : Object])
], NotificationsProcessor);


/***/ }),

/***/ "./src/modules/notifications/push-subscriptions/dtos/push-subscription.dto.ts":
/*!************************************************************************************!*\
  !*** ./src/modules/notifications/push-subscriptions/dtos/push-subscription.dto.ts ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPushSubscriptionDto = exports.UpdatePushSubscriptionDto = exports.PushSubscriptionDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class PushSubscriptionDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.PushSubscriptionDto = PushSubscriptionDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the push-subscription' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PushSubscriptionDto.prototype, "name", void 0);
class UpdatePushSubscriptionDto extends (0, swagger_1.PartialType)(PushSubscriptionDto) {
}
exports.UpdatePushSubscriptionDto = UpdatePushSubscriptionDto;
class GetPushSubscriptionDto extends (0, create_get_dto_factory_1.createGetDto)(UpdatePushSubscriptionDto, 'push subscription') {
}
exports.GetPushSubscriptionDto = GetPushSubscriptionDto;


/***/ }),

/***/ "./src/modules/notifications/push-subscriptions/entities/push-subscription.entity.ts":
/*!*******************************************************************************************!*\
  !*** ./src/modules/notifications/push-subscriptions/entities/push-subscription.entity.ts ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushSubscription = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
let PushSubscription = class PushSubscription extends base_entity_1.BaseEntity {
};
exports.PushSubscription = PushSubscription;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], PushSubscription.prototype, "endpoint", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], PushSubscription.prototype, "p256dh", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], PushSubscription.prototype, "auth", void 0);
exports.PushSubscription = PushSubscription = __decorate([
    (0, typeorm_1.Entity)('push-subscriptions')
], PushSubscription);


/***/ }),

/***/ "./src/modules/notifications/push-subscriptions/push-subscriptions.controller.ts":
/*!***************************************************************************************!*\
  !*** ./src/modules/notifications/push-subscriptions/push-subscriptions.controller.ts ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushSubscriptionsController = void 0;
const authorize_decorator_1 = __webpack_require__(/*! @/common/decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const current_user_decorator_1 = __webpack_require__(/*! @/common/decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const push_subscription_dto_1 = __webpack_require__(/*! ./dtos/push-subscription.dto */ "./src/modules/notifications/push-subscriptions/dtos/push-subscription.dto.ts");
const push_subscription_entity_1 = __webpack_require__(/*! ./entities/push-subscription.entity */ "./src/modules/notifications/push-subscriptions/entities/push-subscription.entity.ts");
const push_subscriptions_service_1 = __webpack_require__(/*! ./push-subscriptions.service */ "./src/modules/notifications/push-subscriptions/push-subscriptions.service.ts");
class PushSubscriptionsController extends (0, create_controller_factory_1.createController)(push_subscription_entity_1.PushSubscription, // Entity name for Swagger documentation
push_subscriptions_service_1.PushSubscriptionsService, // The service handling PushSubscription-related operations
push_subscription_dto_1.GetPushSubscriptionDto) {
    constructor(webPushService, pushSubscriptionsService) {
        super(pushSubscriptionsService);
        this.webPushService = webPushService;
        this.pushSubscriptionsService = pushSubscriptionsService;
    }
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async update(id, entityDto, updatedById) {
        return await super.update(id, entityDto, updatedById);
    }
    async delete(id) {
        return await super.delete(id);
    }
    async deleteMany(ids, hardDelete) {
        return await super.deleteMany(ids, hardDelete);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    getPublicKey() {
        return { publicKey: this.webPushService.getPublicKey() };
    }
    async subscribe(subscription, userId) {
        await this.pushSubscriptionsService.saveSubscription(userId, subscription);
        return { success: true };
    }
    async unsubscribe(subscription, userId) {
        await this.pushSubscriptionsService.removeSubscription(userId, subscription.endpoint);
        return { success: true };
    }
}
exports.PushSubscriptionsController = PushSubscriptionsController;
__decorate([
    (0, swagger_1.ApiOperation)({
        summary: 'Get VAPID public key for push notification subscription',
        description: 'Returns the VAPID public key required for subscribing to push notifications in the browser'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Successfully returned the VAPID public key',
        schema: {
            type: 'object',
            properties: {
                publicKey: {
                    type: 'string',
                    description: 'VAPID public key used for push notification subscription',
                    example: 'BLC8GOevpcpjQiLkO7JmVClQjycvTCYWm6Cq_a-JwvO9B4emcQJwX06KBQeg1ocOcIob5-J_WN5c9Ow0hUvNYoA'
                }
            }
        }
    }),
    (0, common_1.Get)('vapid-public-key'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PushSubscriptionsController.prototype, "getPublicKey", null);
__decorate([
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Subscribe to push notifications' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Subscription saved successfully' }),
    (0, common_1.Post)('subscribe'),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof push_subscription_entity_1.PushSubscription !== "undefined" && push_subscription_entity_1.PushSubscription) === "function" ? _a : Object, String]),
    __metadata("design:returntype", Promise)
], PushSubscriptionsController.prototype, "subscribe", null);
__decorate([
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Unsubscribe from push notifications' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Unsubscribed successfully' }),
    (0, common_1.Post)('unsubscribe'),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", Promise)
], PushSubscriptionsController.prototype, "unsubscribe", null);


/***/ }),

/***/ "./src/modules/notifications/push-subscriptions/push-subscriptions.module.ts":
/*!***********************************************************************************!*\
  !*** ./src/modules/notifications/push-subscriptions/push-subscriptions.module.ts ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushSubscriptionsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const push_subscriptions_controller_1 = __webpack_require__(/*! ./push-subscriptions.controller */ "./src/modules/notifications/push-subscriptions/push-subscriptions.controller.ts");
const push_subscriptions_service_1 = __webpack_require__(/*! ./push-subscriptions.service */ "./src/modules/notifications/push-subscriptions/push-subscriptions.service.ts");
const push_subscription_entity_1 = __webpack_require__(/*! ./entities/push-subscription.entity */ "./src/modules/notifications/push-subscriptions/entities/push-subscription.entity.ts");
let PushSubscriptionsModule = class PushSubscriptionsModule {
};
exports.PushSubscriptionsModule = PushSubscriptionsModule;
exports.PushSubscriptionsModule = PushSubscriptionsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([push_subscription_entity_1.PushSubscription]),
        ],
        providers: [push_subscriptions_service_1.PushSubscriptionsService],
        exports: [push_subscriptions_service_1.PushSubscriptionsService],
        controllers: [push_subscriptions_controller_1.PushSubscriptionsController],
    })
], PushSubscriptionsModule);


/***/ }),

/***/ "./src/modules/notifications/push-subscriptions/push-subscriptions.service.ts":
/*!************************************************************************************!*\
  !*** ./src/modules/notifications/push-subscriptions/push-subscriptions.service.ts ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushSubscriptionsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const push_subscription_entity_1 = __webpack_require__(/*! ./entities/push-subscription.entity */ "./src/modules/notifications/push-subscriptions/entities/push-subscription.entity.ts");
let PushSubscriptionsService = class PushSubscriptionsService extends base_service_1.BaseService {
    constructor(pushSubscriptionsRepository, usersService) {
        super(pushSubscriptionsRepository, usersService);
        this.pushSubscriptionsRepository = pushSubscriptionsRepository;
        this.usersService = usersService;
    }
    /**
     * Save a new push subscription for a user
     */
    async saveSubscription(userId, subscription) {
        // First check if already exists
        const existing = await this.pushSubscriptionsRepository.findOne({
            where: {
                endpoint: subscription.endpoint,
                userId
            }
        });
        if (existing) {
            // Update keys if needed
            existing.p256dh = subscription.keys.p256dh;
            existing.auth = subscription.keys.auth;
            return this.pushSubscriptionsRepository.save(existing);
        }
        // Create new subscription
        const newSubscription = this.pushSubscriptionsRepository.create({
            userId,
            endpoint: subscription.endpoint,
            p256dh: subscription.keys.p256dh,
            auth: subscription.keys.auth
        });
        return this.pushSubscriptionsRepository.save(newSubscription);
    }
    /**
     * Remove a subscription
     */
    async removeSubscription(userId, endpoint) {
        await this.pushSubscriptionsRepository.delete({
            userId,
            endpoint
        });
    }
    /**
     * Get all subscriptions for a user
     */
    async getUserSubscriptions(userId) {
        return this.pushSubscriptionsRepository.find({
            where: { userId }
        });
    }
    /**
     * Remove expired subscription
     */
    async removeExpiredSubscription(endpoint) {
        await this.pushSubscriptionsRepository.delete({ endpoint });
        this.logger.debug(`Removed expired subscription: ${endpoint}`);
    }
};
exports.PushSubscriptionsService = PushSubscriptionsService;
exports.PushSubscriptionsService = PushSubscriptionsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(push_subscription_entity_1.PushSubscription)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], PushSubscriptionsService);


/***/ }),

/***/ "./src/modules/notifications/services/user-connection.service.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/notifications/services/user-connection.service.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var UserConnectionService_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserConnectionService = void 0;
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const bull_2 = __webpack_require__(/*! bull */ "bull");
let UserConnectionService = UserConnectionService_1 = class UserConnectionService {
    constructor(notificationsQueue) {
        this.notificationsQueue = notificationsQueue;
        this.logger = new common_1.Logger(UserConnectionService_1.name);
        // Track online users with connection timestamps
        this.onlineUsers = new Map();
    }
    /**
     * Mark a user as online
     */
    async userConnected(userId) {
        const wasOffline = !this.onlineUsers.has(userId);
        this.onlineUsers.set(userId, new Date());
        if (wasOffline) {
            this.logger.log(`User ${userId} came online`);
            // Queue job to send unread notifications
            await this.notificationsQueue.add('handleUserOnline', {
                userId
            }, {
                delay: 1000 // small delay to ensure connection is stable
            });
        }
    }
    /**
     * Mark a user as offline
     */
    userDisconnected(userId) {
        if (this.onlineUsers.has(userId)) {
            this.onlineUsers.delete(userId);
            this.logger.log(`User ${userId} went offline`);
        }
    }
    /**
     * Check if user is online
     */
    isUserOnline(userId) {
        return this.onlineUsers.has(userId);
    }
    /**
     * Get all online users
     */
    getOnlineUsers() {
        return Array.from(this.onlineUsers.keys());
    }
    /**
     * Get user's last seen time (when they came online)
     */
    getUserLastSeen(userId) {
        return this.onlineUsers.get(userId) || null;
    }
    /**
     * Get online user count
     */
    getOnlineUserCount() {
        return this.onlineUsers.size;
    }
};
exports.UserConnectionService = UserConnectionService;
exports.UserConnectionService = UserConnectionService = UserConnectionService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, bull_1.InjectQueue)('notifications')),
    __metadata("design:paramtypes", [typeof (_a = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _a : Object])
], UserConnectionService);


/***/ }),

/***/ "./src/modules/notifications/services/web-push.service.ts":
/*!****************************************************************!*\
  !*** ./src/modules/notifications/services/web-push.service.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var WebPushService_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebPushService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const webPush = __importStar(__webpack_require__(/*! web-push */ "web-push"));
let WebPushService = WebPushService_1 = class WebPushService {
    constructor(configService) {
        this.configService = configService;
        this.logger = new common_1.Logger(WebPushService_1.name);
        this.initialized = false;
        this.initialize();
    }
    initialize() {
        try {
            const publicKey = this.configService.get('WEB_PUSH_PUBLIC_KEY');
            const privateKey = this.configService.get('WEB_PUSH_PRIVATE_KEY');
            if (!publicKey || !privateKey) {
                this.logger.warn('Web Push keys not configured. Run: npx web-push generate-vapid-keys');
                return;
            }
            // Set VAPID details
            webPush.setVapidDetails(`mailto:${this.configService.getOrThrow('WEB_PUSH_CONTACT_EMAIL')}`, publicKey, privateKey);
            this.initialized = true;
            this.logger.log('Web Push initialized');
        }
        catch (error) {
            this.logger.error(`Failed to initialize Web Push: ${error.message}`);
        }
    }
    /**
     * Send push notification to a subscription
     */
    async sendPushNotification(subscription, payload) {
        if (!this.initialized) {
            this.logger.warn('Web Push not initialized, skipping notification');
            return false;
        }
        try {
            await webPush.sendNotification(subscription, JSON.stringify(payload));
            return true;
        }
        catch (error) {
            // Check for specific errors
            if (error.statusCode === 410) {
                this.logger.warn(`Subscription has expired or been unsubscribed: ${error.message}`);
                // Return an identifier so we know to remove this subscription
                throw { code: 'SUBSCRIPTION_EXPIRED', subscription };
            }
            this.logger.error(`Failed to send push notification: ${error.message}`);
            throw error;
        }
    }
    /**
     * Generate VAPID keys (for initial setup)
     */
    generateVapidKeys() {
        return webPush.generateVAPIDKeys();
    }
    /**
     * Get public key for clients to use
     */
    getPublicKey() {
        return this.configService.get('WEB_PUSH_PUBLIC_KEY', '');
    }
};
exports.WebPushService = WebPushService;
exports.WebPushService = WebPushService = WebPushService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], WebPushService);


/***/ }),

/***/ "./src/modules/organization-management/branches/branches.controller.ts":
/*!*****************************************************************************!*\
  !*** ./src/modules/organization-management/branches/branches.controller.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BranchesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const branches_service_1 = __webpack_require__(/*! ./branches.service */ "./src/modules/organization-management/branches/branches.service.ts");
const branch_dto_1 = __webpack_require__(/*! ./dtos/branch.dto */ "./src/modules/organization-management/branches/dtos/branch.dto.ts");
const branch_entity_1 = __webpack_require__(/*! ./entities/branch.entity */ "./src/modules/organization-management/branches/entities/branch.entity.ts");
class BranchesController extends (0, create_controller_factory_1.createController)(branch_entity_1.Branch, branches_service_1.BranchesService, branch_dto_1.GetBranchDto, branch_dto_1.BranchDto, branch_dto_1.UpdateBranchDto) {
}
exports.BranchesController = BranchesController;


/***/ }),

/***/ "./src/modules/organization-management/branches/branches.module.ts":
/*!*************************************************************************!*\
  !*** ./src/modules/organization-management/branches/branches.module.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BranchesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const branches_controller_1 = __webpack_require__(/*! ./branches.controller */ "./src/modules/organization-management/branches/branches.controller.ts");
const branches_service_1 = __webpack_require__(/*! ./branches.service */ "./src/modules/organization-management/branches/branches.service.ts");
const departments_module_1 = __webpack_require__(/*! ./departments/departments.module */ "./src/modules/organization-management/branches/departments/departments.module.ts");
const branch_entity_1 = __webpack_require__(/*! ./entities/branch.entity */ "./src/modules/organization-management/branches/entities/branch.entity.ts");
let BranchesModule = class BranchesModule {
};
exports.BranchesModule = BranchesModule;
exports.BranchesModule = BranchesModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([branch_entity_1.Branch]),
            departments_module_1.DepartmentsModule],
        controllers: [branches_controller_1.BranchesController],
        providers: [branches_service_1.BranchesService],
        exports: [branches_service_1.BranchesService, departments_module_1.DepartmentsModule],
    })
], BranchesModule);


/***/ }),

/***/ "./src/modules/organization-management/branches/branches.service.ts":
/*!**************************************************************************!*\
  !*** ./src/modules/organization-management/branches/branches.service.ts ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BranchesService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const branch_entity_1 = __webpack_require__(/*! ./entities/branch.entity */ "./src/modules/organization-management/branches/entities/branch.entity.ts");
let BranchesService = class BranchesService extends base_service_1.BaseService {
    constructor(branchesRepository, usersService) {
        super(branchesRepository, usersService);
        this.branchesRepository = branchesRepository;
        this.usersService = usersService;
    }
};
exports.BranchesService = BranchesService;
exports.BranchesService = BranchesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(branch_entity_1.Branch)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], BranchesService);


/***/ }),

/***/ "./src/modules/organization-management/branches/departments/departments.controller.ts":
/*!********************************************************************************************!*\
  !*** ./src/modules/organization-management/branches/departments/departments.controller.ts ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DepartmentsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const departments_service_1 = __webpack_require__(/*! ./departments.service */ "./src/modules/organization-management/branches/departments/departments.service.ts");
const department_dto_1 = __webpack_require__(/*! ./dtos/department.dto */ "./src/modules/organization-management/branches/departments/dtos/department.dto.ts");
const department_entity_1 = __webpack_require__(/*! ./entities/department.entity */ "./src/modules/organization-management/branches/departments/entities/department.entity.ts");
class DepartmentsController extends (0, create_controller_factory_1.createController)(department_entity_1.Department, departments_service_1.DepartmentsService, department_dto_1.GetDepartmentDto, department_dto_1.DepartmentDto, department_dto_1.UpdateDepartmentDto) {
}
exports.DepartmentsController = DepartmentsController;


/***/ }),

/***/ "./src/modules/organization-management/branches/departments/departments.module.ts":
/*!****************************************************************************************!*\
  !*** ./src/modules/organization-management/branches/departments/departments.module.ts ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DepartmentsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const departments_controller_1 = __webpack_require__(/*! ./departments.controller */ "./src/modules/organization-management/branches/departments/departments.controller.ts");
const departments_service_1 = __webpack_require__(/*! ./departments.service */ "./src/modules/organization-management/branches/departments/departments.service.ts");
const department_entity_1 = __webpack_require__(/*! ./entities/department.entity */ "./src/modules/organization-management/branches/departments/entities/department.entity.ts");
let DepartmentsModule = class DepartmentsModule {
};
exports.DepartmentsModule = DepartmentsModule;
exports.DepartmentsModule = DepartmentsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([department_entity_1.Department]),
        ],
        providers: [departments_service_1.DepartmentsService],
        controllers: [departments_controller_1.DepartmentsController],
        exports: [departments_service_1.DepartmentsService],
    })
], DepartmentsModule);


/***/ }),

/***/ "./src/modules/organization-management/branches/departments/departments.service.ts":
/*!*****************************************************************************************!*\
  !*** ./src/modules/organization-management/branches/departments/departments.service.ts ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DepartmentsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const department_entity_1 = __webpack_require__(/*! ./entities/department.entity */ "./src/modules/organization-management/branches/departments/entities/department.entity.ts");
let DepartmentsService = class DepartmentsService extends base_service_1.BaseService {
    constructor(departmentsRepository, usersService) {
        super(departmentsRepository, usersService);
        this.departmentsRepository = departmentsRepository;
        this.usersService = usersService;
    }
};
exports.DepartmentsService = DepartmentsService;
exports.DepartmentsService = DepartmentsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(department_entity_1.Department)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], DepartmentsService);


/***/ }),

/***/ "./src/modules/organization-management/branches/departments/dtos/department.dto.ts":
/*!*****************************************************************************************!*\
  !*** ./src/modules/organization-management/branches/departments/dtos/department.dto.ts ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDepartmentDto = exports.UpdateDepartmentDto = exports.DepartmentDto = void 0;
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const address_dto_1 = __webpack_require__(/*! @/modules/addresses/dtos/address.dto */ "./src/modules/addresses/dtos/address.dto.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class DepartmentDto {
}
exports.DepartmentDto = DepartmentDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Branch ID associated with the branch' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], DepartmentDto.prototype, "branchId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The name of the Department',
        example: 'Acme Corporation',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], DepartmentDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Description of the Department',
        example: 'Leading provider of innovative solutions',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.MaxLength)(500),
    __metadata("design:type", String)
], DepartmentDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'URL or path to the Department logo',
        example: 'https://example.com/logo.png',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], DepartmentDto.prototype, "logo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique alias/slug for the Department',
        example: 'acme-corp',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(50),
    __metadata("design:type", String)
], DepartmentDto.prototype, "alias", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Address information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => address_dto_1.AddressDto),
    __metadata("design:type", typeof (_a = typeof address_dto_1.AddressDto !== "undefined" && address_dto_1.AddressDto) === "function" ? _a : Object)
], DepartmentDto.prototype, "address", void 0);
class UpdateDepartmentDto extends (0, swagger_1.PartialType)(DepartmentDto) {
}
exports.UpdateDepartmentDto = UpdateDepartmentDto;
class GetDepartmentDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateDepartmentDto, 'department') {
}
exports.GetDepartmentDto = GetDepartmentDto;


/***/ }),

/***/ "./src/modules/organization-management/branches/departments/entities/department.entity.ts":
/*!************************************************************************************************!*\
  !*** ./src/modules/organization-management/branches/departments/entities/department.entity.ts ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Department = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const address_entity_1 = __webpack_require__(/*! @/modules/addresses/entities/address.entity */ "./src/modules/addresses/entities/address.entity.ts");
const role_entity_1 = __webpack_require__(/*! @/modules/employee-management/roles/entities/role.entity */ "./src/modules/employee-management/roles/entities/role.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const branch_entity_1 = __webpack_require__(/*! ../../entities/branch.entity */ "./src/modules/organization-management/branches/entities/branch.entity.ts");
let Department = class Department extends base_entity_1.BaseEntity {
};
exports.Department = Department;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Department.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true, type: 'text' }),
    __metadata("design:type", String)
], Department.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Department.prototype, "logo", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Department.prototype, "alias", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Department.prototype, "email", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Department.prototype, "phoneNumber", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => address_entity_1.Address, (address) => address.department, {
        cascade: true
    }),
    __metadata("design:type", typeof (_a = typeof address_entity_1.Address !== "undefined" && address_entity_1.Address) === "function" ? _a : Object)
], Department.prototype, "address", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => branch_entity_1.Branch, (branch) => branch.departments, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'branchId' }),
    __metadata("design:type", typeof (_b = typeof branch_entity_1.Branch !== "undefined" && branch_entity_1.Branch) === "function" ? _b : Object)
], Department.prototype, "branch", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => role_entity_1.Role, (role) => role.department, { nullable: true, cascade: true }),
    __metadata("design:type", Array)
], Department.prototype, "roles", void 0);
exports.Department = Department = __decorate([
    (0, typeorm_1.Entity)('departments')
], Department);


/***/ }),

/***/ "./src/modules/organization-management/branches/dtos/branch.dto.ts":
/*!*************************************************************************!*\
  !*** ./src/modules/organization-management/branches/dtos/branch.dto.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBranchDto = exports.UpdateBranchDto = exports.BranchDto = void 0;
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const address_dto_1 = __webpack_require__(/*! @/modules/addresses/dtos/address.dto */ "./src/modules/addresses/dtos/address.dto.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class BranchDto {
}
exports.BranchDto = BranchDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Organization ID associated with the branch' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], BranchDto.prototype, "organizationId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The name of the branch',
        example: 'Acme Corporation',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], BranchDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Description of the branch',
        example: 'Leading provider of innovative solutions',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.MaxLength)(500),
    __metadata("design:type", String)
], BranchDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'URL or path to the branch logo',
        example: 'https://example.com/logo.png',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], BranchDto.prototype, "logo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique alias/slug for the branch',
        example: 'acme-corp',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(50),
    __metadata("design:type", String)
], BranchDto.prototype, "alias", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Address information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => address_dto_1.AddressDto),
    __metadata("design:type", typeof (_a = typeof address_dto_1.AddressDto !== "undefined" && address_dto_1.AddressDto) === "function" ? _a : Object)
], BranchDto.prototype, "address", void 0);
class UpdateBranchDto extends (0, swagger_1.PartialType)(BranchDto) {
}
exports.UpdateBranchDto = UpdateBranchDto;
class GetBranchDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateBranchDto, 'branch') {
}
exports.GetBranchDto = GetBranchDto;


/***/ }),

/***/ "./src/modules/organization-management/branches/entities/branch.entity.ts":
/*!********************************************************************************!*\
  !*** ./src/modules/organization-management/branches/entities/branch.entity.ts ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Branch = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const address_entity_1 = __webpack_require__(/*! @/modules/addresses/entities/address.entity */ "./src/modules/addresses/entities/address.entity.ts");
const role_entity_1 = __webpack_require__(/*! @/modules/employee-management/roles/entities/role.entity */ "./src/modules/employee-management/roles/entities/role.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const organization_entity_1 = __webpack_require__(/*! ../../entities/organization.entity */ "./src/modules/organization-management/entities/organization.entity.ts");
const department_entity_1 = __webpack_require__(/*! ../departments/entities/department.entity */ "./src/modules/organization-management/branches/departments/entities/department.entity.ts");
let Branch = class Branch extends base_entity_1.BaseEntity {
};
exports.Branch = Branch;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Branch.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true, type: 'text' }),
    __metadata("design:type", String)
], Branch.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Branch.prototype, "logo", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Branch.prototype, "alias", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Branch.prototype, "email", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Branch.prototype, "phoneNumber", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => address_entity_1.Address, (address) => address.branch, {
        cascade: true
    }),
    __metadata("design:type", typeof (_a = typeof address_entity_1.Address !== "undefined" && address_entity_1.Address) === "function" ? _a : Object)
], Branch.prototype, "address", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => organization_entity_1.Organization, (organization) => organization.branches, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'organizationId' }),
    __metadata("design:type", typeof (_b = typeof organization_entity_1.Organization !== "undefined" && organization_entity_1.Organization) === "function" ? _b : Object)
], Branch.prototype, "organization", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => department_entity_1.Department, (department) => department.branch, { cascade: true }),
    __metadata("design:type", Array)
], Branch.prototype, "departments", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => role_entity_1.Role, (role) => role.branch, { nullable: true, cascade: true }),
    __metadata("design:type", Array)
], Branch.prototype, "roles", void 0);
exports.Branch = Branch = __decorate([
    (0, typeorm_1.Entity)('branches')
], Branch);


/***/ }),

/***/ "./src/modules/organization-management/dtos/organization.dto.ts":
/*!**********************************************************************!*\
  !*** ./src/modules/organization-management/dtos/organization.dto.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetOrganizationDto = exports.UpdateOrganizationDto = exports.OrganizationDto = void 0;
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const address_dto_1 = __webpack_require__(/*! @/modules/addresses/dtos/address.dto */ "./src/modules/addresses/dtos/address.dto.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class OrganizationDto {
}
exports.OrganizationDto = OrganizationDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The name of the organization',
        example: 'Acme Corporation',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], OrganizationDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Description of the organization',
        example: 'Leading provider of innovative solutions',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.MaxLength)(500),
    __metadata("design:type", String)
], OrganizationDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'URL or path to the organization logo',
        example: 'https://example.com/logo.png',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], OrganizationDto.prototype, "logo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique alias/slug for the organization',
        example: 'acme-corp',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(50),
    __metadata("design:type", String)
], OrganizationDto.prototype, "alias", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Address information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => address_dto_1.AddressDto),
    __metadata("design:type", typeof (_a = typeof address_dto_1.AddressDto !== "undefined" && address_dto_1.AddressDto) === "function" ? _a : Object)
], OrganizationDto.prototype, "address", void 0);
class UpdateOrganizationDto extends (0, swagger_1.PartialType)(OrganizationDto) {
}
exports.UpdateOrganizationDto = UpdateOrganizationDto;
class GetOrganizationDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateOrganizationDto, 'organization') {
}
exports.GetOrganizationDto = GetOrganizationDto;


/***/ }),

/***/ "./src/modules/organization-management/entities/organization.entity.ts":
/*!*****************************************************************************!*\
  !*** ./src/modules/organization-management/entities/organization.entity.ts ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Organization = void 0;
const address_entity_1 = __webpack_require__(/*! @/modules/addresses/entities/address.entity */ "./src/modules/addresses/entities/address.entity.ts");
const attendance_configuration_entity_1 = __webpack_require__(/*! @/modules/attendance-management/attendance-configurations/entities/attendance-configuration.entity */ "./src/modules/attendance-management/attendance-configurations/entities/attendance-configuration.entity.ts");
const role_entity_1 = __webpack_require__(/*! @/modules/employee-management/roles/entities/role.entity */ "./src/modules/employee-management/roles/entities/role.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const base_entity_1 = __webpack_require__(/*! ../../../database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const branch_entity_1 = __webpack_require__(/*! ../branches/entities/branch.entity */ "./src/modules/organization-management/branches/entities/branch.entity.ts");
let Organization = class Organization extends base_entity_1.BaseEntity {
};
exports.Organization = Organization;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Organization.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true, type: 'text' }),
    __metadata("design:type", String)
], Organization.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Organization.prototype, "logo", void 0);
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Organization.prototype, "alias", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Organization.prototype, "email", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Organization.prototype, "phoneNumber", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => address_entity_1.Address, (address) => address.organization, {
        cascade: true
    }),
    __metadata("design:type", typeof (_a = typeof address_entity_1.Address !== "undefined" && address_entity_1.Address) === "function" ? _a : Object)
], Organization.prototype, "address", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => branch_entity_1.Branch, (branch) => branch.organization, { cascade: true }),
    __metadata("design:type", Array)
], Organization.prototype, "branches", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => role_entity_1.Role, (role) => role.organization, { nullable: true, cascade: true }),
    __metadata("design:type", Array)
], Organization.prototype, "roles", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => attendance_configuration_entity_1.AttendanceConfiguration, (attendanceConfiguration) => attendanceConfiguration.organization, { nullable: true, cascade: true }),
    __metadata("design:type", typeof (_b = typeof attendance_configuration_entity_1.AttendanceConfiguration !== "undefined" && attendance_configuration_entity_1.AttendanceConfiguration) === "function" ? _b : Object)
], Organization.prototype, "attendanceConfiguration", void 0);
exports.Organization = Organization = __decorate([
    (0, typeorm_1.Entity)('organizations')
], Organization);


/***/ }),

/***/ "./src/modules/organization-management/organization-management.module.ts":
/*!*******************************************************************************!*\
  !*** ./src/modules/organization-management/organization-management.module.ts ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationManagementModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const branches_module_1 = __webpack_require__(/*! ./branches/branches.module */ "./src/modules/organization-management/branches/branches.module.ts");
const departments_module_1 = __webpack_require__(/*! ./branches/departments/departments.module */ "./src/modules/organization-management/branches/departments/departments.module.ts");
const organization_entity_1 = __webpack_require__(/*! ./entities/organization.entity */ "./src/modules/organization-management/entities/organization.entity.ts");
const organizations_controller_1 = __webpack_require__(/*! ./organizations.controller */ "./src/modules/organization-management/organizations.controller.ts");
const organizations_service_1 = __webpack_require__(/*! ./organizations.service */ "./src/modules/organization-management/organizations.service.ts");
let OrganizationManagementModule = class OrganizationManagementModule {
};
exports.OrganizationManagementModule = OrganizationManagementModule;
exports.OrganizationManagementModule = OrganizationManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([organization_entity_1.Organization]),
            branches_module_1.BranchesModule,
            departments_module_1.DepartmentsModule,
            core_1.RouterModule.register([
                {
                    path: 'organizations',
                    module: OrganizationManagementModule,
                    children: [
                        {
                            path: 'branches',
                            module: branches_module_1.BranchesModule,
                            children: [
                                {
                                    path: 'departments',
                                    module: departments_module_1.DepartmentsModule
                                }
                            ],
                        }
                    ]
                },
            ]),
        ],
        providers: [organizations_service_1.OrganizationsService],
        exports: [
            organizations_service_1.OrganizationsService,
            branches_module_1.BranchesModule,
        ],
        controllers: [organizations_controller_1.OrganizationsController],
    })
], OrganizationManagementModule);


/***/ }),

/***/ "./src/modules/organization-management/organizations.controller.ts":
/*!*************************************************************************!*\
  !*** ./src/modules/organization-management/organizations.controller.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const organization_dto_1 = __webpack_require__(/*! ./dtos/organization.dto */ "./src/modules/organization-management/dtos/organization.dto.ts");
const organization_entity_1 = __webpack_require__(/*! ./entities/organization.entity */ "./src/modules/organization-management/entities/organization.entity.ts");
const organizations_service_1 = __webpack_require__(/*! ./organizations.service */ "./src/modules/organization-management/organizations.service.ts");
class OrganizationsController extends (0, create_controller_factory_1.createController)(organization_entity_1.Organization, organizations_service_1.OrganizationsService, organization_dto_1.GetOrganizationDto, organization_dto_1.OrganizationDto, organization_dto_1.UpdateOrganizationDto) {
}
exports.OrganizationsController = OrganizationsController;


/***/ }),

/***/ "./src/modules/organization-management/organizations.service.ts":
/*!**********************************************************************!*\
  !*** ./src/modules/organization-management/organizations.service.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const users_service_1 = __webpack_require__(/*! ../account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const organization_entity_1 = __webpack_require__(/*! ./entities/organization.entity */ "./src/modules/organization-management/entities/organization.entity.ts");
let OrganizationsService = class OrganizationsService extends base_service_1.BaseService {
    constructor(organizationsRepository, usersService) {
        super(organizationsRepository, usersService);
        this.organizationsRepository = organizationsRepository;
        this.usersService = usersService;
    }
};
exports.OrganizationsService = OrganizationsService;
exports.OrganizationsService = OrganizationsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(organization_entity_1.Organization)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], OrganizationsService);


/***/ }),

/***/ "./src/modules/payroll-management/cutoffs/cutoffs.controller.ts":
/*!**********************************************************************!*\
  !*** ./src/modules/payroll-management/cutoffs/cutoffs.controller.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CutoffsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const cutoffs_service_1 = __webpack_require__(/*! ./cutoffs.service */ "./src/modules/payroll-management/cutoffs/cutoffs.service.ts");
const cutoff_dto_1 = __webpack_require__(/*! ./dtos/cutoff.dto */ "./src/modules/payroll-management/cutoffs/dtos/cutoff.dto.ts");
const cutoff_entity_1 = __webpack_require__(/*! ./entities/cutoff.entity */ "./src/modules/payroll-management/cutoffs/entities/cutoff.entity.ts");
class CutoffsController extends (0, create_controller_factory_1.createController)(cutoff_entity_1.Cutoff, cutoffs_service_1.CutoffsService, cutoff_dto_1.GetCutoffDto, cutoff_dto_1.CutoffDto, cutoff_dto_1.UpdateCutoffDto) {
}
exports.CutoffsController = CutoffsController;


/***/ }),

/***/ "./src/modules/payroll-management/cutoffs/cutoffs.module.ts":
/*!******************************************************************!*\
  !*** ./src/modules/payroll-management/cutoffs/cutoffs.module.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CutoffsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const cutoffs_controller_1 = __webpack_require__(/*! ./cutoffs.controller */ "./src/modules/payroll-management/cutoffs/cutoffs.controller.ts");
const cutoffs_service_1 = __webpack_require__(/*! ./cutoffs.service */ "./src/modules/payroll-management/cutoffs/cutoffs.service.ts");
const cutoff_entity_1 = __webpack_require__(/*! ./entities/cutoff.entity */ "./src/modules/payroll-management/cutoffs/entities/cutoff.entity.ts");
let CutoffsModule = class CutoffsModule {
};
exports.CutoffsModule = CutoffsModule;
exports.CutoffsModule = CutoffsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([cutoff_entity_1.Cutoff]),
        ],
        providers: [cutoffs_service_1.CutoffsService],
        exports: [cutoffs_service_1.CutoffsService],
        controllers: [cutoffs_controller_1.CutoffsController],
    })
], CutoffsModule);


/***/ }),

/***/ "./src/modules/payroll-management/cutoffs/cutoffs.service.ts":
/*!*******************************************************************!*\
  !*** ./src/modules/payroll-management/cutoffs/cutoffs.service.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CutoffsService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CutoffsService = void 0;
const cutoff_status_enum_1 = __webpack_require__(/*! @/common/enums/payroll/cutoff-status.enum */ "./src/common/enums/payroll/cutoff-status.enum.ts");
const cutoff_type_enum_1 = __webpack_require__(/*! @/common/enums/payroll/cutoff-type.enum */ "./src/common/enums/payroll/cutoff-type.enum.ts");
const utility_helper_1 = __webpack_require__(/*! @/common/helpers/utility.helper */ "./src/common/helpers/utility.helper.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const schedule_1 = __webpack_require__(/*! @nestjs/schedule */ "@nestjs/schedule");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const cutoff_entity_1 = __webpack_require__(/*! ./entities/cutoff.entity */ "./src/modules/payroll-management/cutoffs/entities/cutoff.entity.ts");
let CutoffsService = CutoffsService_1 = class CutoffsService extends base_service_1.BaseService {
    constructor(cutoffsRepository, usersService) {
        super(cutoffsRepository, usersService);
        this.cutoffsRepository = cutoffsRepository;
        this.usersService = usersService;
        this.logger = new common_1.Logger(CutoffsService_1.name);
    }
    /**
     * Initialize cutoffs when application starts
     */
    async onModuleInit() {
        this.logger.log('Checking if cutoffs exist on application startup');
        try {
            const cutoffsCount = await this.cutoffsRepository.count();
            if (cutoffsCount === 0) {
                this.logger.log('No cutoffs found. Generating yearly cutoffs for current year.');
                const currentYear = new Date().getFullYear();
                await this.generateYearlyCutoffs({
                    year: currentYear,
                    startMonth: 0, // January
                    cutoffType: cutoff_type_enum_1.CutoffType.BI_WEEKLY,
                    save: true
                });
                this.logger.log('Initial yearly cutoffs generated successfully');
            }
            else {
                this.logger.log(`Found ${cutoffsCount} existing cutoffs. Skipping initial generation.`);
            }
            // Also update statuses of existing cutoffs on startup
            await this.updateCutoffStatuses();
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error initializing cutoffs: ${error.message}`, error.stack);
            }
            else {
                this.logger.error(`Error initializing cutoffs: ${String(error)}`);
            }
        }
    }
    async generateYearlyCutoffs(options = {}) {
        const { year = new Date().getFullYear(), startMonth = new Date().getMonth(), cutoffType = cutoff_type_enum_1.CutoffType.BI_WEEKLY, save = true } = options;
        // cutoff count
        let cutoffCount = await this.cutoffsRepository.count();
        const cutoffs = [];
        // Generate cutoffs for each month from startMonth to December
        for (let month = startMonth; month < 12; month++) {
            const periodCutoffs = this.generateCutoffsForMonth(year, month, cutoffType);
            cutoffs.push(...periodCutoffs);
        }
        // for each generated cutoff, set the cutoff number
        cutoffs.forEach((cutoff, index) => {
            cutoff.cutoffNumber = cutoffCount + index + 1;
        });
        // Save to database if requested
        if (save && cutoffs.length > 0) {
            await this.cutoffsRepository.save(cutoffs);
        }
        return cutoffs;
    }
    generateCutoffsForMonth(year, month, cutoffType) {
        const cutoffs = [];
        const monthName = new Date(year, month, 1).toLocaleString('default', { month: 'long' });
        switch (cutoffType) {
            case cutoff_type_enum_1.CutoffType.BI_WEEKLY: {
                // For bi-weekly: 1-15 and 16-end of month
                const firstHalfStart = new Date(year, month, 1);
                const firstHalfEnd = new Date(year, month, 15);
                const secondHalfStart = new Date(year, month, 16);
                const secondHalfEnd = new Date(year, month + 1, 0);
                // Calculate business days
                const firstHalfBusinessDays = utility_helper_1.UtilityHelper.getBusinessDays(firstHalfStart, firstHalfEnd);
                const secondHalfBusinessDays = utility_helper_1.UtilityHelper.getBusinessDays(secondHalfStart, secondHalfEnd);
                // Create the cutoff entities
                const firstHalf = new cutoff_entity_1.Cutoff({});
                firstHalf.startDate = firstHalfStart;
                firstHalf.endDate = firstHalfEnd;
                firstHalf.status = cutoff_status_enum_1.CutoffStatus.ACTIVE;
                firstHalf.cutoffPlace = 1;
                firstHalf.cutoffType = cutoffType;
                firstHalf.description = `${monthName} 1-15, ${year} (${firstHalfBusinessDays} business days)`;
                const secondHalf = new cutoff_entity_1.Cutoff({});
                secondHalf.startDate = secondHalfStart;
                secondHalf.endDate = secondHalfEnd;
                secondHalf.status = cutoff_status_enum_1.CutoffStatus.ACTIVE;
                secondHalf.cutoffType = cutoffType;
                secondHalf.cutoffPlace = 2;
                secondHalf.description = `${monthName} 16-${secondHalfEnd.getDate()}, ${year} (${secondHalfBusinessDays} business days)`;
                cutoffs.push(firstHalf, secondHalf);
                break;
            }
            // Add other cutoff types if needed (WEEKLY, MONTHLY, etc.)
            default:
                break;
        }
        return cutoffs;
    }
    async getActiveCutoffs() {
        return await this.repository.find({
            where: {
                status: cutoff_status_enum_1.CutoffStatus.ACTIVE || cutoff_status_enum_1.CutoffStatus.PENDING,
                startDate: (0, typeorm_2.MoreThan)(new Date()),
                isDeleted: false
            },
            order: { startDate: 'ASC' }
        });
    }
    async getActiveCutoff() {
        return await this.repository.findOne({
            where: {
                status: cutoff_status_enum_1.CutoffStatus.ACTIVE || cutoff_status_enum_1.CutoffStatus.PENDING,
                startDate: (0, typeorm_2.MoreThan)(new Date()),
                isDeleted: false
            },
            order: { startDate: 'ASC' }
        });
    }
    /**
     * Updates cutoff statuses based on current date
     * - Active cutoffs with startDate <= today => PENDING
     * - Pending cutoffs with endDate < today => COMPLETED
     */
    async updateCutoffStatuses() {
        this.logger.log('Updating cutoff statuses based on current date');
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);
        yesterday.setHours(0, 0, 0, 0);
        let updated = 0;
        let errors = 0;
        try {
            // Find active cutoffs that have started
            const activeCutoffs = await this.cutoffsRepository.find({
                where: {
                    status: cutoff_status_enum_1.CutoffStatus.ACTIVE,
                    startDate: (0, typeorm_2.LessThanOrEqual)(today)
                }
            });
            if (activeCutoffs.length > 0) {
                this.logger.log(`Found ${activeCutoffs.length} active cutoffs to mark as PENDING`);
                const result = await this.cutoffsRepository.update({ id: (0, typeorm_2.In)(activeCutoffs.map(c => c.id)) }, { status: cutoff_status_enum_1.CutoffStatus.PENDING });
                updated += result.affected || 0;
            }
            // Find pending cutoffs that have ended
            const pendingCutoffs = await this.cutoffsRepository.find({
                where: {
                    status: cutoff_status_enum_1.CutoffStatus.PENDING,
                    endDate: (0, typeorm_2.LessThanOrEqual)(yesterday)
                }
            });
            if (pendingCutoffs.length > 0) {
                this.logger.log(`Found ${pendingCutoffs.length} pending cutoffs to mark as PROCESSING`);
                const result = await this.cutoffsRepository.update({ id: (0, typeorm_2.In)(pendingCutoffs.map(c => c.id)) }, { status: cutoff_status_enum_1.CutoffStatus.PROCESSING });
                updated += result.affected || 0;
            }
            return { updated, errors };
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error updating cutoff statuses: ${error.message}`, error.stack);
            }
            else {
                this.logger.error(`Error updating cutoff statuses: ${String(error)}`);
            }
            errors++;
            return { updated, errors };
        }
    }
    /**
     * Get the current active or pending cutoff
     */
    async getCurrentCutoff() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        // First try to find a PENDING cutoff that includes today
        const pendingCutoff = await this.cutoffsRepository.findOne({
            where: {
                status: cutoff_status_enum_1.CutoffStatus.PENDING,
                startDate: (0, typeorm_2.LessThanOrEqual)(today),
                endDate: (0, typeorm_2.MoreThanOrEqual)(today)
            }
        });
        if (pendingCutoff) {
            return pendingCutoff;
        }
        // If no pending cutoff, try to find the next ACTIVE cutoff
        return this.cutoffsRepository.findOne({
            where: {
                status: cutoff_status_enum_1.CutoffStatus.ACTIVE
            },
            order: {
                startDate: 'ASC'
            }
        });
    }
    /**
     * Scheduled job to automatically update cutoff statuses daily
     */
    async scheduledCutoffStatusUpdate() {
        this.logger.log('Running scheduled cutoff status update');
        const result = await this.updateCutoffStatuses();
        this.logger.log(`Scheduled update complete. Updated: ${result.updated}, Errors: ${result.errors}`);
    }
    /**
     * Scheduled job to generate cutoffs for the next year
     * Runs on January 1st at 1:00 AM
     */
    async generateNextYearCutoffs() {
        const nextYear = new Date().getFullYear() + 1;
        this.logger.log(`Running scheduled yearly cutoff generation for year ${nextYear}`);
        try {
            // Check if cutoffs already exist for the next year
            const existingCutoffs = await this.cutoffsRepository.count({
                where: {
                    startDate: (0, typeorm_2.MoreThanOrEqual)(new Date(`${nextYear}-01-01`)),
                }
            });
            if (existingCutoffs > 0) {
                this.logger.log(`Cutoffs for year ${nextYear} already exist. Skipping generation.`);
                return;
            }
            // Generate cutoffs for the next year
            await this.generateYearlyCutoffs({
                year: nextYear,
                startMonth: 0,
                cutoffType: cutoff_type_enum_1.CutoffType.BI_WEEKLY,
                save: true
            });
            this.logger.log(`Successfully generated ${nextYear} cutoffs`);
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error generating next year cutoffs: ${error.message}`, error.stack);
            }
            else {
                this.logger.error(`Error generating next year cutoffs: ${String(error)}`);
            }
        }
    }
};
exports.CutoffsService = CutoffsService;
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_DAY_AT_MIDNIGHT),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CutoffsService.prototype, "scheduledCutoffStatusUpdate", null);
__decorate([
    (0, schedule_1.Cron)('0 1 1 1 *'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CutoffsService.prototype, "generateNextYearCutoffs", null);
exports.CutoffsService = CutoffsService = CutoffsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(cutoff_entity_1.Cutoff)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], CutoffsService);


/***/ }),

/***/ "./src/modules/payroll-management/cutoffs/dtos/cutoff.dto.ts":
/*!*******************************************************************!*\
  !*** ./src/modules/payroll-management/cutoffs/dtos/cutoff.dto.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetCutoffDto = exports.UpdateCutoffDto = exports.CutoffDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const cutoff_status_enum_1 = __webpack_require__(/*! @/common/enums/payroll/cutoff-status.enum */ "./src/common/enums/payroll/cutoff-status.enum.ts");
const cutoff_type_enum_1 = __webpack_require__(/*! @/common/enums/payroll/cutoff-type.enum */ "./src/common/enums/payroll/cutoff-type.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CutoffDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.CutoffDto = CutoffDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of the cutoff period',
        example: 'First half of January 2023',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CutoffDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Start date of the cutoff period',
        example: '2023-01-01',
        type: Date
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], CutoffDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'End date of the cutoff period',
        example: '2023-01-15',
        type: Date
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], CutoffDto.prototype, "endDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Status of the cutoff period',
        enum: cutoff_status_enum_1.CutoffStatus,
        example: cutoff_status_enum_1.CutoffStatus.ACTIVE,
        default: cutoff_status_enum_1.CutoffStatus.ACTIVE,
        required: true
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(cutoff_status_enum_1.CutoffStatus),
    __metadata("design:type", typeof (_c = typeof cutoff_status_enum_1.CutoffStatus !== "undefined" && cutoff_status_enum_1.CutoffStatus) === "function" ? _c : Object)
], CutoffDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of the cutoff period',
        enum: cutoff_type_enum_1.CutoffType,
        example: cutoff_type_enum_1.CutoffType.BI_WEEKLY,
        default: cutoff_type_enum_1.CutoffType.BI_WEEKLY,
        required: true
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(cutoff_type_enum_1.CutoffType),
    __metadata("design:type", typeof (_d = typeof cutoff_type_enum_1.CutoffType !== "undefined" && cutoff_type_enum_1.CutoffType) === "function" ? _d : Object)
], CutoffDto.prototype, "cutoffType", void 0);
class UpdateCutoffDto extends (0, swagger_1.PartialType)(CutoffDto) {
}
exports.UpdateCutoffDto = UpdateCutoffDto;
class GetCutoffDto extends (0, create_get_dto_factory_1.createGetDto)(CutoffDto, 'cutoff') {
}
exports.GetCutoffDto = GetCutoffDto;


/***/ }),

/***/ "./src/modules/payroll-management/cutoffs/entities/cutoff.entity.ts":
/*!**************************************************************************!*\
  !*** ./src/modules/payroll-management/cutoffs/entities/cutoff.entity.ts ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Cutoff = void 0;
const cutoff_type_enum_1 = __webpack_require__(/*! @/common/enums/payroll/cutoff-type.enum */ "./src/common/enums/payroll/cutoff-type.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const attendance_entity_1 = __webpack_require__(/*! @/modules/attendance-management/entities/attendance.entity */ "./src/modules/attendance-management/entities/attendance.entity.ts");
const final_work_hour_entity_1 = __webpack_require__(/*! @/modules/attendance-management/final-work-hours/entities/final-work-hour.entity */ "./src/modules/attendance-management/final-work-hours/entities/final-work-hour.entity.ts");
const work_time_request_entity_1 = __webpack_require__(/*! @/modules/attendance-management/work-time-requests/entities/work-time-request.entity */ "./src/modules/attendance-management/work-time-requests/entities/work-time-request.entity.ts");
const shift_entity_1 = __webpack_require__(/*! @/modules/shift-management/entities/shift.entity */ "./src/modules/shift-management/entities/shift.entity.ts");
const schedule_entity_1 = __webpack_require__(/*! @/modules/shift-management/schedules/entities/schedule.entity */ "./src/modules/shift-management/schedules/entities/schedule.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const payroll_entity_1 = __webpack_require__(/*! ../../entities/payroll.entity */ "./src/modules/payroll-management/entities/payroll.entity.ts");
const cutoff_status_enum_1 = __webpack_require__(/*! @/common/enums/payroll/cutoff-status.enum */ "./src/common/enums/payroll/cutoff-status.enum.ts");
let Cutoff = class Cutoff extends base_entity_1.BaseEntity {
};
exports.Cutoff = Cutoff;
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Cutoff.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Cutoff.prototype, "startDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Cutoff.prototype, "endDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 1 }),
    __metadata("design:type", Number)
], Cutoff.prototype, "cutoffPlace", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Number)
], Cutoff.prototype, "cutoffNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: cutoff_status_enum_1.CutoffStatus, default: cutoff_status_enum_1.CutoffStatus.ACTIVE }),
    __metadata("design:type", typeof (_c = typeof cutoff_status_enum_1.CutoffStatus !== "undefined" && cutoff_status_enum_1.CutoffStatus) === "function" ? _c : Object)
], Cutoff.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: cutoff_type_enum_1.CutoffType, default: cutoff_type_enum_1.CutoffType.BI_WEEKLY }),
    __metadata("design:type", typeof (_d = typeof cutoff_type_enum_1.CutoffType !== "undefined" && cutoff_type_enum_1.CutoffType) === "function" ? _d : Object)
], Cutoff.prototype, "cutoffType", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => payroll_entity_1.Payroll, (payroll) => payroll.cutoff, { nullable: true }),
    __metadata("design:type", Array)
], Cutoff.prototype, "payrolls", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => schedule_entity_1.Schedule, (schedule) => schedule.cutoff, { nullable: true }),
    __metadata("design:type", Array)
], Cutoff.prototype, "schedules", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => final_work_hour_entity_1.FinalWorkHour, (finalWorkHour) => finalWorkHour.cutoff, { nullable: true }),
    __metadata("design:type", Array)
], Cutoff.prototype, "finalWorkHours", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => shift_entity_1.Shift, (shift) => shift.cutoffs, { nullable: true }),
    __metadata("design:type", Array)
], Cutoff.prototype, "shifts", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => attendance_entity_1.Attendance, (attendance) => attendance.cutoff, { nullable: true }),
    __metadata("design:type", Array)
], Cutoff.prototype, "attendances", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => work_time_request_entity_1.WorkTimeRequest, (workTimeRequest) => workTimeRequest.cutoff, { nullable: true }),
    __metadata("design:type", Array)
], Cutoff.prototype, "workTimeRequests", void 0);
exports.Cutoff = Cutoff = __decorate([
    (0, typeorm_1.Entity)('cutoffs')
], Cutoff);


/***/ }),

/***/ "./src/modules/payroll-management/dtos/payroll-batch-process.dto.ts":
/*!**************************************************************************!*\
  !*** ./src/modules/payroll-management/dtos/payroll-batch-process.dto.ts ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollBatchProcessResponseDto = exports.PayrollBatchProcessRequestDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class BatchInfo {
}
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier for the batch',
        example: '123e4567-ef00-1234-5678-1234567890ab',
        format: 'uuid'
    }),
    (0, class_validator_1.IsUUID)(4, { message: 'batchId must be a valid UUID v4' }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], BatchInfo.prototype, "batchId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Number of employees in this batch',
        example: 100,
        minimum: 1
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsPositive)({ message: 'employeeCount must be a positive number' }),
    __metadata("design:type", Number)
], BatchInfo.prototype, "employeeCount", void 0);
class PayrollBatchProcessRequestDto {
}
exports.PayrollBatchProcessRequestDto = PayrollBatchProcessRequestDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID of the cutoff for which payroll is to be processed',
        example: '123e4567-ef00-1234-5678-1234567890ab',
        format: 'uuid'
    }),
    (0, class_validator_1.IsUUID)(4, { message: 'cutoffId must be a valid UUID v4' }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], PayrollBatchProcessRequestDto.prototype, "cutoffId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Batch size for processing payroll items',
        example: 100,
        default: 100,
        minimum: 1
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsPositive)({ message: 'batchSize must be a positive number' }),
    __metadata("design:type", Number)
], PayrollBatchProcessRequestDto.prototype, "batchSize", void 0);
class PayrollBatchProcessResponseDto extends PayrollBatchProcessRequestDto {
}
exports.PayrollBatchProcessResponseDto = PayrollBatchProcessResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Response message',
        example: 'Payroll batch processing initiated successfully'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], PayrollBatchProcessResponseDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Total number of batches created for processing',
        example: 5,
        minimum: 1
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsPositive)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Number)
], PayrollBatchProcessResponseDto.prototype, "batchCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'List of batches created for processing',
        type: [BatchInfo]
    }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => BatchInfo),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Array)
], PayrollBatchProcessResponseDto.prototype, "batches", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Estimated time for completion of the batch processing',
        example: '2023-10-01T12:00:00Z',
        format: 'date-time'
    }),
    (0, class_validator_1.IsISO8601)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], PayrollBatchProcessResponseDto.prototype, "estimatedCompletionTime", void 0);


/***/ }),

/***/ "./src/modules/payroll-management/dtos/payroll.dto.ts":
/*!************************************************************!*\
  !*** ./src/modules/payroll-management/dtos/payroll.dto.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPayrollDto = exports.UpdatePayrollDto = exports.PayrollDto = exports.StateHistoryItemDto = exports.ComparisonDto = exports.SignificantChangeDto = exports.ContributionDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const payroll_state_enum_1 = __webpack_require__(/*! @/common/enums/payroll/payroll-state.enum */ "./src/common/enums/payroll/payroll-state.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class ContributionDto {
}
exports.ContributionDto = ContributionDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Employee contribution amount', example: 500.00 }),
    (0, class_validator_1.IsNumber)({ maxDecimalPlaces: 2 }),
    __metadata("design:type", Number)
], ContributionDto.prototype, "employee", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Employer contribution amount', example: 500.00 }),
    (0, class_validator_1.IsNumber)({ maxDecimalPlaces: 2 }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], ContributionDto.prototype, "employer", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Total contribution amount', example: 1000.00 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({ maxDecimalPlaces: 2 }),
    __metadata("design:type", Number)
], ContributionDto.prototype, "total", void 0);
class SignificantChangeDto {
}
exports.SignificantChangeDto = SignificantChangeDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Field that changed significantly', example: 'basicPay' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], SignificantChangeDto.prototype, "field", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Previous value', example: 5000 }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Number)
], SignificantChangeDto.prototype, "previousValue", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Current value', example: 5500 }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Number)
], SignificantChangeDto.prototype, "currentValue", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Percentage change', example: 10 }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Number)
], SignificantChangeDto.prototype, "percentageChange", void 0);
class ComparisonDto {
}
exports.ComparisonDto = ComparisonDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the previous payroll', example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ComparisonDto.prototype, "previousPayrollId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Difference in net pay', example: 500 }),
    (0, class_validator_1.IsNumber)({ maxDecimalPlaces: 2 }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Number)
], ComparisonDto.prototype, "netPayDifference", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Difference in gross pay', example: 700 }),
    (0, class_validator_1.IsNumber)({ maxDecimalPlaces: 2 }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Number)
], ComparisonDto.prototype, "grossPayDifference", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Significant changes in the payroll', type: [SignificantChangeDto] }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Type)(() => SignificantChangeDto),
    __metadata("design:type", Array)
], ComparisonDto.prototype, "significantChanges", void 0);
class StateHistoryItemDto {
}
exports.StateHistoryItemDto = StateHistoryItemDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Previous state', enum: payroll_state_enum_1.PayrollState }),
    (0, class_validator_1.IsEnum)(payroll_state_enum_1.PayrollState),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof payroll_state_enum_1.PayrollState !== "undefined" && payroll_state_enum_1.PayrollState) === "function" ? _a : Object)
], StateHistoryItemDto.prototype, "from", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'New state', enum: payroll_state_enum_1.PayrollState }),
    (0, class_validator_1.IsEnum)(payroll_state_enum_1.PayrollState),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_b = typeof payroll_state_enum_1.PayrollState !== "undefined" && payroll_state_enum_1.PayrollState) === "function" ? _b : Object)
], StateHistoryItemDto.prototype, "to", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Timestamp of state change', example: '2023-01-01T00:00:00Z' }),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], StateHistoryItemDto.prototype, "timestamp", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Optional note about state change', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(500),
    __metadata("design:type", String)
], StateHistoryItemDto.prototype, "note", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Additional details about state change', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsObject)(),
    __metadata("design:type", Object)
], StateHistoryItemDto.prototype, "details", void 0);
class PayrollDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.PayrollDto = PayrollDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the related employee', example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], PayrollDto.prototype, "employeeId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the related cutoff period', example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], PayrollDto.prototype, "cutoffId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Monthly rate of the employee', example: 20000.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "monthlyRate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Daily rate of the employee', example: 950.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "dailyRate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Hourly rate of the employee', example: 118.75 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "hourlyRate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total hours with no time in', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalNoTimeInHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total hours with no time out', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalNoTimeOutHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total absent hours', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalAbsentHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total tardiness hours', example: 0.5 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalTardinessHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total undertime hours', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalUndertimeHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total regular work hours', example: 80 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalRegularHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total holiday work hours', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalHolidayHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total special holiday work hours', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalSpecialHolidayHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total rest day work hours', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalRestDayHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total overtime hours', example: 4 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalOvertimeHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total holiday overtime hours', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalHolidayOvertimeHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total special holiday overtime hours', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalSpecialHolidayOvertimeHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total rest day overtime hours', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalRestDayOvertimeHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total night differential hours', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalNightDifferentialHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total work hours', example: 84 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalHours", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Basic pay amount', example: 9500.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "basicPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Overtime pay amount', example: 594.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "overtimePay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Holiday pay amount', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "holidayPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Holiday overtime pay amount', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "holidayOvertimePay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Special holiday pay amount', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "specialHolidayPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Special holiday overtime pay amount', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "specialHolidayOvertimePay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Rest day pay amount', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "restDayPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Rest day overtime pay amount', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "restDayOvertimePay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Night differential pay amount', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "nightDifferentialPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Absences deduction amount', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "absences", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Tardiness deduction amount', example: 59.38 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "tardiness", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Undertime deduction amount', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "undertime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'No time in deduction amount', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "noTimeIn", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'No time out deduction amount', example: 0 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "noTimeOut", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total basic deductions amount', example: 59.38 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalBasicDeductions", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Comparison with previous payroll', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => ComparisonDto),
    __metadata("design:type", ComparisonDto)
], PayrollDto.prototype, "comparisonWithPreviousPayroll", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Currency code', example: 'PHP', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PayrollDto.prototype, "currency", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Exchange rate', example: 1.0, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({ maxDecimalPlaces: 6 }),
    __metadata("design:type", Number)
], PayrollDto.prototype, "exchangeRate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total allowances amount', example: 1000.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalAllowances", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total deductions amount', example: 1559.38 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "totalDeductions", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Gross pay amount', example: 11094.00 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "grossPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Taxable income amount', example: 9534.62 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "taxableIncome", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Net pay amount', example: 8534.62 }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '2' }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], PayrollDto.prototype, "netPay", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Additional notes', example: 'First payroll of the month', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(1000),
    __metadata("design:type", String)
], PayrollDto.prototype, "notes", void 0);
class UpdatePayrollDto extends (0, swagger_1.PartialType)(PayrollDto) {
}
exports.UpdatePayrollDto = UpdatePayrollDto;
class GetPayrollDto extends (0, create_get_dto_factory_1.createGetDto)(UpdatePayrollDto, 'payroll') {
}
exports.GetPayrollDto = GetPayrollDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Payment method', example: 'Bank Transfer', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GetPayrollDto.prototype, "paymentMethod", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Bank account number', example: '1234567890', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GetPayrollDto.prototype, "bankAccount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Bank reference number', example: 'REF12345', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GetPayrollDto.prototype, "bankReferenceNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Check number', example: 'CK001234', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GetPayrollDto.prototype, "checkNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Payment date', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], GetPayrollDto.prototype, "paymentDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Batch ID', example: 'BATCH20231015', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GetPayrollDto.prototype, "batchId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Current state of the payroll', enum: payroll_state_enum_1.PayrollState, default: payroll_state_enum_1.PayrollState.DRAFT }),
    (0, class_validator_1.IsEnum)(payroll_state_enum_1.PayrollState),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_e = typeof payroll_state_enum_1.PayrollState !== "undefined" && payroll_state_enum_1.PayrollState) === "function" ? _e : Object)
], GetPayrollDto.prototype, "state", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'History of state changes', type: [StateHistoryItemDto], required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => StateHistoryItemDto),
    __metadata("design:type", Array)
], GetPayrollDto.prototype, "stateHistory", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Processed timestamp', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_f = typeof Date !== "undefined" && Date) === "function" ? _f : Object)
], GetPayrollDto.prototype, "processedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the user who processed the payroll', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], GetPayrollDto.prototype, "processedBy", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Approved timestamp', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_g = typeof Date !== "undefined" && Date) === "function" ? _g : Object)
], GetPayrollDto.prototype, "approvedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the user who approved the payroll', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], GetPayrollDto.prototype, "approvedBy", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Rejected timestamp', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_h = typeof Date !== "undefined" && Date) === "function" ? _h : Object)
], GetPayrollDto.prototype, "rejectedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the user who rejected the payroll', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], GetPayrollDto.prototype, "rejectedBy", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Reason for rejection', example: 'Incorrect calculations', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(500),
    __metadata("design:type", String)
], GetPayrollDto.prototype, "rejectionReason", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Released timestamp', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_j = typeof Date !== "undefined" && Date) === "function" ? _j : Object)
], GetPayrollDto.prototype, "releasedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the user who released the payroll', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], GetPayrollDto.prototype, "releasedBy", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Voided timestamp', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_k = typeof Date !== "undefined" && Date) === "function" ? _k : Object)
], GetPayrollDto.prototype, "voidedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the user who voided the payroll', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], GetPayrollDto.prototype, "voidedBy", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Count of reprocessing attempts', default: 0 }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Number)
], GetPayrollDto.prototype, "reprocessedCount", void 0);


/***/ }),

/***/ "./src/modules/payroll-management/dtos/recalculate-options.dto.ts":
/*!************************************************************************!*\
  !*** ./src/modules/payroll-management/dtos/recalculate-options.dto.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RecalculateOptionsDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class RecalculateOptionsDto {
}
exports.RecalculateOptionsDto = RecalculateOptionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether to preserve the current state during recalculation',
        example: true,
        default: true,
    }),
    (0, class_validator_1.IsNotEmpty)({ message: 'preserveState is required' }),
    (0, class_validator_1.IsBoolean)({ message: 'preserveState must be a boolean value' }),
    __metadata("design:type", Boolean)
], RecalculateOptionsDto.prototype, "preserveState", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether to recalculate deductions',
        example: true,
        default: false
    }),
    (0, class_validator_1.IsBoolean)({ message: 'recalculateDeductions must be a boolean value' }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], RecalculateOptionsDto.prototype, "recalculateDeductions", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether to recalculate allowances',
        example: true,
        default: false
    }),
    (0, class_validator_1.IsBoolean)({ message: 'recalculateAllowances must be a boolean value' }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], RecalculateOptionsDto.prototype, "recalculateAllowances", void 0);


/***/ }),

/***/ "./src/modules/payroll-management/dtos/release-payroll.dto.ts":
/*!********************************************************************!*\
  !*** ./src/modules/payroll-management/dtos/release-payroll.dto.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReleasePayrollDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class ReleasePayrollDto {
}
exports.ReleasePayrollDto = ReleasePayrollDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Payment method type',
        example: 'BANK_TRANSFER',
        enum: ['BANK_TRANSFER', 'CHECK', 'CASH']
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ReleasePayrollDto.prototype, "paymentMethod", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date when the payment was released',
        example: '2023-04-15T00:00:00Z'
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], ReleasePayrollDto.prototype, "paymentDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Reference number provided by the bank for the transaction',
        example: 'TX12345678'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ReleasePayrollDto.prototype, "bankReferenceNumber", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Bank account number for bank transfers',
        example: '****4567'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ReleasePayrollDto.prototype, "bankAccount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Check number for check payments',
        example: '10024'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ReleasePayrollDto.prototype, "checkNumber", void 0);


/***/ }),

/***/ "./src/modules/payroll-management/entities/payroll.entity.ts":
/*!*******************************************************************!*\
  !*** ./src/modules/payroll-management/entities/payroll.entity.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Payroll = void 0;
const government_contribution_type_enum_1 = __webpack_require__(/*! @/common/enums/payroll/government-contribution-type.enum */ "./src/common/enums/payroll/government-contribution-type.enum.ts");
const payroll_state_enum_1 = __webpack_require__(/*! @/common/enums/payroll/payroll-state.enum */ "./src/common/enums/payroll/payroll-state.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const cutoff_entity_1 = __webpack_require__(/*! ../cutoffs/entities/cutoff.entity */ "./src/modules/payroll-management/cutoffs/entities/cutoff.entity.ts");
const payroll_item_entity_1 = __webpack_require__(/*! ../payroll-items/entities/payroll-item.entity */ "./src/modules/payroll-management/payroll-items/entities/payroll-item.entity.ts");
let Payroll = class Payroll extends base_entity_1.BaseEntity {
    // Virtual properties for better contribution access
    get sssContribution() {
        var _a;
        const sssItem = (_a = this.payrollItems) === null || _a === void 0 ? void 0 : _a.find(item => { var _a; return ((_a = item.payrollItemType) === null || _a === void 0 ? void 0 : _a.governmentMandatedType) === government_contribution_type_enum_1.GovernmentMandatedType.SSS; });
        const employee = Number(Number((sssItem === null || sssItem === void 0 ? void 0 : sssItem.amount) || 0).toFixed(2));
        const employer = Number(Number((sssItem === null || sssItem === void 0 ? void 0 : sssItem.employerAmount) || 0).toFixed(2));
        return {
            employee,
            employer,
            total: Number((employee + employer).toFixed(2))
        };
    }
    get philHealthContribution() {
        var _a;
        const philhealthItem = (_a = this.payrollItems) === null || _a === void 0 ? void 0 : _a.find(item => { var _a; return ((_a = item.payrollItemType) === null || _a === void 0 ? void 0 : _a.governmentMandatedType) === government_contribution_type_enum_1.GovernmentMandatedType.PHILHEALTH; });
        const employee = Number(Number((philhealthItem === null || philhealthItem === void 0 ? void 0 : philhealthItem.amount) || 0).toFixed(2));
        const employer = Number(Number((philhealthItem === null || philhealthItem === void 0 ? void 0 : philhealthItem.employerAmount) || 0).toFixed(2));
        return {
            employee,
            employer,
            total: Number((employee + employer).toFixed(2))
        };
    }
    get pagIbigContribution() {
        var _a;
        const pagibigItem = (_a = this.payrollItems) === null || _a === void 0 ? void 0 : _a.find(item => { var _a; return ((_a = item.payrollItemType) === null || _a === void 0 ? void 0 : _a.governmentMandatedType) === government_contribution_type_enum_1.GovernmentMandatedType.PAGIBIG; });
        const employee = Number(Number((pagibigItem === null || pagibigItem === void 0 ? void 0 : pagibigItem.amount) || 0).toFixed(2));
        const employer = Number(Number((pagibigItem === null || pagibigItem === void 0 ? void 0 : pagibigItem.employerAmount) || 0).toFixed(2));
        return {
            employee,
            employer,
            total: Number((employee + employer).toFixed(2))
        };
    }
    get withholdingTax() {
        var _a;
        const taxItem = (_a = this.payrollItems) === null || _a === void 0 ? void 0 : _a.find(item => { var _a; return ((_a = item.payrollItemType) === null || _a === void 0 ? void 0 : _a.governmentMandatedType) === government_contribution_type_enum_1.GovernmentMandatedType.TAX; });
        return Number(Number((taxItem === null || taxItem === void 0 ? void 0 : taxItem.amount) || 0).toFixed(2));
    }
};
exports.Payroll = Payroll;
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.payrolls),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_a = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _a : Object)
], Payroll.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => cutoff_entity_1.Cutoff, (cutoff) => cutoff.payrolls, { eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'cutoffId' }),
    __metadata("design:type", typeof (_b = typeof cutoff_entity_1.Cutoff !== "undefined" && cutoff_entity_1.Cutoff) === "function" ? _b : Object)
], Payroll.prototype, "cutoff", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => payroll_item_entity_1.PayrollItem, (payrollItem) => payrollItem.payroll, {
        cascade: true,
        nullable: true
    }),
    (0, class_transformer_1.Type)(() => payroll_item_entity_1.PayrollItem),
    __metadata("design:type", Array)
], Payroll.prototype, "payrollItems", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "monthlyRate", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "dailyRate", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "hourlyRate", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalNoTimeInHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalNoTimeOutHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalAbsentHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalTardinessHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalUndertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalRegularHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalHolidayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalSpecialHolidayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalRestDayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalOvertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalHolidayOvertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalSpecialHolidayOvertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalRestDayOvertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalNightDifferentialHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalNightDifferentialOvertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "basicPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "overtimePay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "holidayPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "holidayOvertimePay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "specialHolidayPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "specialHolidayOvertimePay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "restDayPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "restDayOvertimePay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "nightDifferentialPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "nightDifferentialOvertimePay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "absences", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "tardiness", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "undertime", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "noTimeIn", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "noTimeOut", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalBasicDeductions", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", Object)
], Payroll.prototype, "comparisonWithPreviousPayroll", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "currency", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 6, nullable: true }),
    __metadata("design:type", Number)
], Payroll.prototype, "exchangeRate", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalAllowances", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalDeductions", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "grossPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "taxableIncome", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "netPay", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "paymentMethod", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "bankAccount", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "bankReferenceNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "checkNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], Payroll.prototype, "paymentDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "batchId", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: payroll_state_enum_1.PayrollState,
        default: payroll_state_enum_1.PayrollState.DRAFT
    }),
    __metadata("design:type", typeof (_d = typeof payroll_state_enum_1.PayrollState !== "undefined" && payroll_state_enum_1.PayrollState) === "function" ? _d : Object)
], Payroll.prototype, "state", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", typeof (_e = typeof Array !== "undefined" && Array) === "function" ? _e : Object)
], Payroll.prototype, "stateHistory", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_f = typeof Date !== "undefined" && Date) === "function" ? _f : Object)
], Payroll.prototype, "processedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "processedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_g = typeof Date !== "undefined" && Date) === "function" ? _g : Object)
], Payroll.prototype, "approvedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "approvedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_h = typeof Date !== "undefined" && Date) === "function" ? _h : Object)
], Payroll.prototype, "rejectedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "rejectedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "rejectionReason", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_j = typeof Date !== "undefined" && Date) === "function" ? _j : Object)
], Payroll.prototype, "releasedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "releasedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_k = typeof Date !== "undefined" && Date) === "function" ? _k : Object)
], Payroll.prototype, "voidedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "voidedBy", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", Object)
], Payroll.prototype, "calculationDetails", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "reprocessedCount", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "notes", void 0);
exports.Payroll = Payroll = __decorate([
    (0, typeorm_1.Entity)('payrolls')
], Payroll);


/***/ }),

/***/ "./src/modules/payroll-management/payroll-item-types/dtos/payroll-item-type.dto.ts":
/*!*****************************************************************************************!*\
  !*** ./src/modules/payroll-management/payroll-item-types/dtos/payroll-item-type.dto.ts ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPayrollItemTypeDto = exports.UpdatePayrollItemTypeDto = exports.PayrollItemTypeDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const occurrence_enum_1 = __webpack_require__(/*! @/common/enums/occurrence.enum */ "./src/common/enums/occurrence.enum.ts");
const government_contribution_type_enum_1 = __webpack_require__(/*! @/common/enums/payroll/government-contribution-type.enum */ "./src/common/enums/payroll/government-contribution-type.enum.ts");
const payroll_item_category_enum_1 = __webpack_require__(/*! @/common/enums/payroll/payroll-item-category.enum */ "./src/common/enums/payroll/payroll-item-category.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class PayrollItemTypeDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.PayrollItemTypeDto = PayrollItemTypeDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the payroll item type',
        example: 'Basic Salary'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], PayrollItemTypeDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Description of the payroll item type',
        example: 'Basic monthly salary for employees',
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], PayrollItemTypeDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Group of the payroll item type',
        example: 'Salary',
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], PayrollItemTypeDto.prototype, "group", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether the payroll item type has an amount',
        default: false,
        example: false,
        nullable: true
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "hasAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether the payroll item type has a percentage',
        default: false,
        example: false,
        nullable: true
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "hasPercentage", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether the payroll item type has an effectivity date',
        default: false,
        example: false,
        nullable: true
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "hasEffectivity", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Image or icon representing the payroll item type (file key, url, or icon)',
        example: 'https://example.com/icon.png',
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], PayrollItemTypeDto.prototype, "imageOrIcon", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Category of the payroll item type',
        enum: payroll_item_category_enum_1.PayrollItemCategory,
        example: payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION
    }),
    (0, class_validator_1.IsEnum)(payroll_item_category_enum_1.PayrollItemCategory),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof payroll_item_category_enum_1.PayrollItemCategory !== "undefined" && payroll_item_category_enum_1.PayrollItemCategory) === "function" ? _a : Object)
], PayrollItemTypeDto.prototype, "category", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Default occurrence of the payroll item',
        enum: occurrence_enum_1.Occurrence,
        default: occurrence_enum_1.Occurrence.MONTHLY,
        example: occurrence_enum_1.Occurrence.MONTHLY
    }),
    (0, class_validator_1.IsEnum)(occurrence_enum_1.Occurrence),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_b = typeof occurrence_enum_1.Occurrence !== "undefined" && occurrence_enum_1.Occurrence) === "function" ? _b : Object)
], PayrollItemTypeDto.prototype, "defaultOccurrence", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of payroll item calculation',
        enum: ['fixed', 'formula'],
        example: 'fixed'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], PayrollItemTypeDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Default amount for fixed payroll items',
        example: 5000.00,
        nullable: true
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], PayrollItemTypeDto.prototype, "defaultAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the payroll item type is active',
        default: true,
        example: true
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "isActive", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Type of government mandated contribution',
        enum: government_contribution_type_enum_1.GovernmentMandatedType,
        nullable: true,
        example: government_contribution_type_enum_1.GovernmentMandatedType.SSS
    }),
    (0, class_validator_1.IsEnum)(government_contribution_type_enum_1.GovernmentMandatedType),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_c = typeof government_contribution_type_enum_1.GovernmentMandatedType !== "undefined" && government_contribution_type_enum_1.GovernmentMandatedType) === "function" ? _c : Object)
], PayrollItemTypeDto.prototype, "governmentMandatedType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the payroll item is required',
        default: true,
        example: true
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "isRequired", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Date from which the payroll item is effective',
        type: Date,
        nullable: true,
        example: '2023-01-01T00:00:00Z'
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], PayrollItemTypeDto.prototype, "effectiveFrom", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Date until which the payroll item is effective',
        type: Date,
        nullable: true,
        example: '2024-12-31T00:00:00Z'
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], PayrollItemTypeDto.prototype, "effectiveTo", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Percentage value for percentage-based calculations',
        example: 10.5,
        nullable: true
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], PayrollItemTypeDto.prototype, "percentage", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Processing period for the payroll item in a month (e.g., 1 for the first cutoff period of the month)',
        example: 1,
        nullable: true
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], PayrollItemTypeDto.prototype, "processEvery", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Employer contribution percentage',
        example: 5.5,
        nullable: true
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], PayrollItemTypeDto.prototype, "employerPercentage", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether to include in payroll item processing',
        default: true,
        example: true
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "includeInPayrollItemsProcessing", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the payroll item is taxable',
        default: false,
        example: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "isTaxable", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the payroll item is tax deductible',
        default: false,
        example: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "isTaxDeductible", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Tax exemption amount',
        example: 2000.00,
        nullable: true
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], PayrollItemTypeDto.prototype, "taxExemptionAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum amount for calculation',
        example: 1000.00,
        nullable: true
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], PayrollItemTypeDto.prototype, "minAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum amount for calculation',
        example: 10000.00,
        nullable: true
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], PayrollItemTypeDto.prototype, "maxAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum additional amount',
        example: 500.00,
        nullable: true
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], PayrollItemTypeDto.prototype, "minAdditionalAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum additional amount',
        example: 1500.00,
        nullable: true
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], PayrollItemTypeDto.prototype, "maxAdditionalAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum contribution amount',
        example: 200.00,
        nullable: true
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], PayrollItemTypeDto.prototype, "minContribution", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum contribution amount',
        example: 2000.00,
        nullable: true
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], PayrollItemTypeDto.prototype, "maxContribution", void 0);
class UpdatePayrollItemTypeDto extends (0, swagger_1.PartialType)(PayrollItemTypeDto) {
}
exports.UpdatePayrollItemTypeDto = UpdatePayrollItemTypeDto;
class GetPayrollItemTypeDto extends (0, create_get_dto_factory_1.createGetDto)(UpdatePayrollItemTypeDto, 'payroll item type') {
}
exports.GetPayrollItemTypeDto = GetPayrollItemTypeDto;


/***/ }),

/***/ "./src/modules/payroll-management/payroll-item-types/entities/payroll-item-type.entity.ts":
/*!************************************************************************************************!*\
  !*** ./src/modules/payroll-management/payroll-item-types/entities/payroll-item-type.entity.ts ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemType = void 0;
const occurrence_enum_1 = __webpack_require__(/*! @/common/enums/occurrence.enum */ "./src/common/enums/occurrence.enum.ts");
const government_contribution_type_enum_1 = __webpack_require__(/*! @/common/enums/payroll/government-contribution-type.enum */ "./src/common/enums/payroll/government-contribution-type.enum.ts");
const payroll_item_category_enum_1 = __webpack_require__(/*! @/common/enums/payroll/payroll-item-category.enum */ "./src/common/enums/payroll/payroll-item-category.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const employee_payroll_item_type_entity_1 = __webpack_require__(/*! @/modules/employee-management/employee-payroll-item-types/entities/employee-payroll-item-type.entity */ "./src/modules/employee-management/employee-payroll-item-types/entities/employee-payroll-item-type.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const payroll_item_entity_1 = __webpack_require__(/*! ../../payroll-items/entities/payroll-item.entity */ "./src/modules/payroll-management/payroll-items/entities/payroll-item.entity.ts");
let PayrollItemType = class PayrollItemType extends base_entity_1.BaseEntity {
};
exports.PayrollItemType = PayrollItemType;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], PayrollItemType.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], PayrollItemType.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], PayrollItemType.prototype, "imageOrIcon", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: payroll_item_category_enum_1.PayrollItemCategory,
    }),
    __metadata("design:type", typeof (_a = typeof payroll_item_category_enum_1.PayrollItemCategory !== "undefined" && payroll_item_category_enum_1.PayrollItemCategory) === "function" ? _a : Object)
], PayrollItemType.prototype, "category", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: occurrence_enum_1.Occurrence, default: occurrence_enum_1.Occurrence.MONTHLY }),
    __metadata("design:type", typeof (_b = typeof occurrence_enum_1.Occurrence !== "undefined" && occurrence_enum_1.Occurrence) === "function" ? _b : Object)
], PayrollItemType.prototype, "defaultOccurrence", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], PayrollItemType.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 10,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItemType.prototype, "defaultAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isActive", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: government_contribution_type_enum_1.GovernmentMandatedType, nullable: true }),
    __metadata("design:type", typeof (_c = typeof government_contribution_type_enum_1.GovernmentMandatedType !== "undefined" && government_contribution_type_enum_1.GovernmentMandatedType) === "function" ? _c : Object)
], PayrollItemType.prototype, "governmentMandatedType", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isRequired", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], PayrollItemType.prototype, "group", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "hasAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "hasPercentage", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "hasEffectivity", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], PayrollItemType.prototype, "effectiveFrom", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], PayrollItemType.prototype, "effectiveTo", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 10,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItemType.prototype, "percentage", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", Number)
], PayrollItemType.prototype, "processEvery", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 10,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItemType.prototype, "employerPercentage", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "includeInPayrollItemsProcessing", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isTaxable", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isTaxDeductible", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 10,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItemType.prototype, "taxExemptionAmount", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 10,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItemType.prototype, "minAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isAddableToBaseCompensation", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 10,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItemType.prototype, "maxAmount", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 10,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItemType.prototype, "minAdditionalAmount", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 10,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItemType.prototype, "maxAdditionalAmount", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 10,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItemType.prototype, "minContribution", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 10,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItemType.prototype, "maxContribution", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => payroll_item_entity_1.PayrollItem, (payrollItem) => payrollItem.payrollItemType, { nullable: true }),
    __metadata("design:type", Array)
], PayrollItemType.prototype, "payrollItems", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => employee_payroll_item_type_entity_1.EmployeePayrollItemType, (employeePayrollItemType) => employeePayrollItemType.payrollItemType, { nullable: true }),
    __metadata("design:type", Array)
], PayrollItemType.prototype, "employeePayrollItemTypes", void 0);
exports.PayrollItemType = PayrollItemType = __decorate([
    (0, typeorm_1.Entity)('payroll-item-types')
], PayrollItemType);


/***/ }),

/***/ "./src/modules/payroll-management/payroll-item-types/payroll-item-types.controller.ts":
/*!********************************************************************************************!*\
  !*** ./src/modules/payroll-management/payroll-item-types/payroll-item-types.controller.ts ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemTypesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const payroll_item_type_dto_1 = __webpack_require__(/*! ./dtos/payroll-item-type.dto */ "./src/modules/payroll-management/payroll-item-types/dtos/payroll-item-type.dto.ts");
const payroll_item_type_entity_1 = __webpack_require__(/*! ./entities/payroll-item-type.entity */ "./src/modules/payroll-management/payroll-item-types/entities/payroll-item-type.entity.ts");
const payroll_item_types_service_1 = __webpack_require__(/*! ./payroll-item-types.service */ "./src/modules/payroll-management/payroll-item-types/payroll-item-types.service.ts");
class PayrollItemTypesController extends (0, create_controller_factory_1.createController)(payroll_item_type_entity_1.PayrollItemType, payroll_item_types_service_1.PayrollItemTypesService, payroll_item_type_dto_1.GetPayrollItemTypeDto, payroll_item_type_dto_1.PayrollItemTypeDto, payroll_item_type_dto_1.UpdatePayrollItemTypeDto) {
    async delete(id) {
        return super.delete(id);
    }
    softDelete(id, deletedBy) {
        return super.softDelete(id, deletedBy);
    }
    async findOne(fieldsString, relations, select) {
        return super.findOne(fieldsString, relations, select);
    }
}
exports.PayrollItemTypesController = PayrollItemTypesController;


/***/ }),

/***/ "./src/modules/payroll-management/payroll-item-types/payroll-item-types.module.ts":
/*!****************************************************************************************!*\
  !*** ./src/modules/payroll-management/payroll-item-types/payroll-item-types.module.ts ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemTypesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const payroll_item_type_entity_1 = __webpack_require__(/*! ./entities/payroll-item-type.entity */ "./src/modules/payroll-management/payroll-item-types/entities/payroll-item-type.entity.ts");
const payroll_item_types_controller_1 = __webpack_require__(/*! ./payroll-item-types.controller */ "./src/modules/payroll-management/payroll-item-types/payroll-item-types.controller.ts");
const payroll_item_types_service_1 = __webpack_require__(/*! ./payroll-item-types.service */ "./src/modules/payroll-management/payroll-item-types/payroll-item-types.service.ts");
let PayrollItemTypesModule = class PayrollItemTypesModule {
};
exports.PayrollItemTypesModule = PayrollItemTypesModule;
exports.PayrollItemTypesModule = PayrollItemTypesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([payroll_item_type_entity_1.PayrollItemType]),
        ],
        providers: [payroll_item_types_service_1.PayrollItemTypesService],
        exports: [payroll_item_types_service_1.PayrollItemTypesService],
        controllers: [payroll_item_types_controller_1.PayrollItemTypesController],
    })
], PayrollItemTypesModule);


/***/ }),

/***/ "./src/modules/payroll-management/payroll-item-types/payroll-item-types.service.ts":
/*!*****************************************************************************************!*\
  !*** ./src/modules/payroll-management/payroll-item-types/payroll-item-types.service.ts ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemTypesService = void 0;
const occurrence_enum_1 = __webpack_require__(/*! @/common/enums/occurrence.enum */ "./src/common/enums/occurrence.enum.ts");
const government_contribution_type_enum_1 = __webpack_require__(/*! @/common/enums/payroll/government-contribution-type.enum */ "./src/common/enums/payroll/government-contribution-type.enum.ts");
const payroll_item_category_enum_1 = __webpack_require__(/*! @/common/enums/payroll/payroll-item-category.enum */ "./src/common/enums/payroll/payroll-item-category.enum.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const payroll_item_type_entity_1 = __webpack_require__(/*! ./entities/payroll-item-type.entity */ "./src/modules/payroll-management/payroll-item-types/entities/payroll-item-type.entity.ts");
let PayrollItemTypesService = class PayrollItemTypesService extends base_service_1.BaseService {
    constructor(payrollItemTypesRepository, usersService) {
        super(payrollItemTypesRepository, usersService);
        this.payrollItemTypesRepository = payrollItemTypesRepository;
        this.usersService = usersService;
        this.seedDefaultPhilippinePayrollItemTypes();
    }
    /**
     * Seeds default Philippine payroll item types with 2025 rates
     */
    async seedDefaultPhilippinePayrollItemTypes(userId) {
        // Check if there is default data already
        const existingTypes = await this.getRepository().find();
        if (existingTypes.length == 0) {
            // Create new contribution types if none exist
            const newTypes = [];
            // 1. SSS Contribution
            const sssContribution = new payroll_item_type_entity_1.PayrollItemType({
                name: 'SSS Contribution',
                description: 'Social Security System contribution (2025)',
                category: payroll_item_category_enum_1.PayrollItemCategory.DEDUCTION,
                defaultOccurrence: occurrence_enum_1.Occurrence.MONTHLY,
                type: 'formula',
                governmentMandatedType: government_contribution_type_enum_1.GovernmentMandatedType.SSS,
                percentage: 5,
                employerPercentage: 10,
                processEvery: 2,
                isTaxable: false,
                isTaxDeductible: true,
                isRequired: true,
                minAmount: 5000,
                maxAmount: 35000,
                minAdditionalAmount: 10,
                maxAdditionalAmount: 30,
                minContribution: 14500,
                maxContribution: 15000,
            });
            const savedSSS = await this.create(sssContribution, userId);
            newTypes.push(savedSSS);
            // 2. PhilHealth Contribution
            const philhealthContribution = new payroll_item_type_entity_1.PayrollItemType({
                name: 'PhilHealth Contribution',
                description: 'Philippine Health Insurance Corporation contribution (2025)',
                category: payroll_item_category_enum_1.PayrollItemCategory.DEDUCTION,
                defaultOccurrence: occurrence_enum_1.Occurrence.MONTHLY,
                governmentMandatedType: government_contribution_type_enum_1.GovernmentMandatedType.PHILHEALTH,
                percentage: 2.5,
                employerPercentage: 2.5,
                processEvery: 2,
                isTaxable: false,
                isTaxDeductible: true,
                type: 'formula',
                isRequired: true,
                minAmount: 10000,
                maxAmount: 100000
            });
            const savedPhilHealth = await this.create(philhealthContribution, userId);
            newTypes.push(savedPhilHealth);
            // 3. Pag-IBIG Contribution
            const pagibigContribution = new payroll_item_type_entity_1.PayrollItemType({
                name: 'Pag-IBIG Contribution',
                description: 'Home Development Mutual Fund contribution (2025)',
                category: payroll_item_category_enum_1.PayrollItemCategory.DEDUCTION,
                defaultOccurrence: occurrence_enum_1.Occurrence.MONTHLY,
                governmentMandatedType: government_contribution_type_enum_1.GovernmentMandatedType.PAGIBIG,
                percentage: 1,
                employerPercentage: 2,
                processEvery: 2,
                isTaxable: false,
                isTaxDeductible: true,
                isRequired: true,
                type: 'formula',
                minAmount: 1500,
                maxAmount: 10000,
                minContribution: 1,
                maxContribution: 2
            });
            const savedPagIBIG = await this.create(pagibigContribution, userId);
            newTypes.push(savedPagIBIG);
            // 4. Add basic salary compensation types
            const salaryTypes = [
                {
                    name: 'Monthly Salary',
                    category: payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION,
                    unit: 'PHP',
                    group: 'Salary',
                    defaultOccurrence: occurrence_enum_1.Occurrence.MONTHLY,
                    type: 'fixed',
                    isRequired: true,
                    includeInPayrollItemsProcessing: false,
                    isTaxable: true,
                },
                {
                    name: 'Daily Rate',
                    category: payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION,
                    unit: 'PHP',
                    group: 'Salary',
                    defaultOccurrence: occurrence_enum_1.Occurrence.DAILY,
                    type: 'fixed',
                    includeInPayrollItemsProcessing: false,
                    isTaxable: true,
                },
                {
                    name: 'Hourly Rate',
                    category: payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION,
                    unit: 'PHP',
                    group: 'Salary',
                    defaultOccurrence: occurrence_enum_1.Occurrence.HOURLY,
                    includeInPayrollItemsProcessing: false,
                    type: 'fixed',
                    isTaxable: true,
                }
            ];
            for (const salary of salaryTypes) {
                const salaryType = new payroll_item_type_entity_1.PayrollItemType(Object.assign(Object.assign({}, salary), { description: `Employee ${salary.name.toLowerCase()} compensation` }));
                const savedSalary = await this.create(salaryType, userId);
                newTypes.push(savedSalary);
            }
            // 5. 13th Month Pay
            const thirteenthMonthPay = new payroll_item_type_entity_1.PayrollItemType({
                name: '13th Month Pay',
                description: '13th month pay',
                category: payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION,
                governmentMandatedType: government_contribution_type_enum_1.GovernmentMandatedType.THIRTEENTH_MONTH_PAY,
                defaultOccurrence: occurrence_enum_1.Occurrence.ANNUALLY,
                isTaxable: true,
                isTaxDeductible: false,
                taxExemptionAmount: 90000,
                type: 'fixed',
                isRequired: true,
            });
            const savedThirteenthMonthPay = await this.create(thirteenthMonthPay, userId);
            newTypes.push(savedThirteenthMonthPay);
            // 6. Withholding Tax
            const withholdingTax = new payroll_item_type_entity_1.PayrollItemType({
                name: 'Withholding Tax',
                description: 'Withholding tax deduction',
                category: payroll_item_category_enum_1.PayrollItemCategory.DEDUCTION,
                governmentMandatedType: government_contribution_type_enum_1.GovernmentMandatedType.TAX,
                processEvery: 1,
                defaultOccurrence: occurrence_enum_1.Occurrence.MONTHLY,
                type: 'formula',
                isRequired: true,
            });
            const savedWithholdingTax = await this.create(withholdingTax, userId);
            newTypes.push(savedWithholdingTax);
        }
    }
};
exports.PayrollItemTypesService = PayrollItemTypesService;
exports.PayrollItemTypesService = PayrollItemTypesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(payroll_item_type_entity_1.PayrollItemType)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], PayrollItemTypesService);


/***/ }),

/***/ "./src/modules/payroll-management/payroll-items/dtos/payroll-item.dto.ts":
/*!*******************************************************************************!*\
  !*** ./src/modules/payroll-management/payroll-items/dtos/payroll-item.dto.ts ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPayrollItemDto = exports.UpdatePayrollItemDto = exports.PayrollItemDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const occurrence_enum_1 = __webpack_require__(/*! @/common/enums/occurrence.enum */ "./src/common/enums/occurrence.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class PayrollItemDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.PayrollItemDto = PayrollItemDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employee ID associated with this payroll item',
        type: String
    }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], PayrollItemDto.prototype, "employeeId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Payroll item type ID',
        type: String
    }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], PayrollItemDto.prototype, "payrollItemTypeId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Payroll ID (optional)',
        type: String,
        required: false
    }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], PayrollItemDto.prototype, "payrollId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Amount of the payroll item',
        example: 1000.00,
        type: Number
    }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '0,2' }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Number)
], PayrollItemDto.prototype, "amount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employer contribution amount (if applicable)',
        example: 100.00,
        type: Number,
        required: false
    }),
    (0, class_validator_1.IsDecimal)({ decimal_digits: '0,2' }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], PayrollItemDto.prototype, "employerAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Additional parameters for the payroll item calculation',
        example: { rate: 0.05, basis: 'gross_salary' },
        type: Object,
        required: false
    }),
    (0, class_validator_1.IsObject)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_a = typeof Record !== "undefined" && Record) === "function" ? _a : Object)
], PayrollItemDto.prototype, "parameters", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'How often the item is applied (ONCE, DAILY, WEEKLY, MONTHLY, etc.)',
        enum: occurrence_enum_1.Occurrence,
        example: occurrence_enum_1.Occurrence.MONTHLY,
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_b = typeof occurrence_enum_1.Occurrence !== "undefined" && occurrence_enum_1.Occurrence) === "function" ? _b : Object)
], PayrollItemDto.prototype, "occurrence", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the payroll item is active',
        example: true,
        default: true
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemDto.prototype, "isActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the payroll item is taxable',
        example: true,
        default: true
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemDto.prototype, "isTaxable", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date from which the payroll item is effective',
        type: Date,
        required: false
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], PayrollItemDto.prototype, "effectiveFrom", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date until which the payroll item is effective',
        type: Date,
        required: false
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], PayrollItemDto.prototype, "effectiveTo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Reference information for the payroll item',
        example: 'REF-2023-001',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], PayrollItemDto.prototype, "reference", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Government reference number for tax reporting and verification',
        example: 'GVT-1234567',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], PayrollItemDto.prototype, "governmentReferenceNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Calculation details including formula, inputs, steps, and result',
        type: Object,
        required: false,
        example: {
            formula: 'base_salary * 0.05',
            inputs: { base_salary: 50000 },
            steps: ['Multiply base_salary by rate'],
            result: 2500
        }
    }),
    (0, class_validator_1.IsObject)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], PayrollItemDto.prototype, "calculationDetails", void 0);
class UpdatePayrollItemDto extends (0, swagger_1.PartialType)(PayrollItemDto) {
}
exports.UpdatePayrollItemDto = UpdatePayrollItemDto;
class GetPayrollItemDto extends (0, create_get_dto_factory_1.createGetDto)(UpdatePayrollItemDto, 'payroll item') {
}
exports.GetPayrollItemDto = GetPayrollItemDto;


/***/ }),

/***/ "./src/modules/payroll-management/payroll-items/entities/payroll-item.entity.ts":
/*!**************************************************************************************!*\
  !*** ./src/modules/payroll-management/payroll-items/entities/payroll-item.entity.ts ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItem = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const user_entity_1 = __webpack_require__(/*! @/modules/account-management/users/entities/user.entity */ "./src/modules/account-management/users/entities/user.entity.ts");
const employee_payroll_item_type_entity_1 = __webpack_require__(/*! @/modules/employee-management/employee-payroll-item-types/entities/employee-payroll-item-type.entity */ "./src/modules/employee-management/employee-payroll-item-types/entities/employee-payroll-item-type.entity.ts");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const payroll_entity_1 = __webpack_require__(/*! ../../entities/payroll.entity */ "./src/modules/payroll-management/entities/payroll.entity.ts");
const payroll_item_type_entity_1 = __webpack_require__(/*! ../../payroll-item-types/entities/payroll-item-type.entity */ "./src/modules/payroll-management/payroll-item-types/entities/payroll-item-type.entity.ts");
const calculation_details_type_1 = __webpack_require__(/*! ../../types/calculation-details.type */ "./src/modules/payroll-management/types/calculation-details.type.ts");
let PayrollItem = class PayrollItem extends base_entity_1.BaseEntity {
    getCalculationType() {
        var _a;
        return (_a = this.calculationDetails) === null || _a === void 0 ? void 0 : _a.calculationType;
    }
    getEmployeeContribution() {
        if (this.calculationDetails &&
            'employeeContribution' in this.calculationDetails) {
            return this.calculationDetails.employeeContribution;
        }
        return this.amount;
    }
    getEmployerContribution() {
        if (this.calculationDetails &&
            'employerContribution' in this.calculationDetails) {
            return this.calculationDetails.employerContribution;
        }
        return this.employerAmount || 0;
    }
};
exports.PayrollItem = PayrollItem;
__decorate([
    (0, typeorm_1.ManyToOne)(() => payroll_item_type_entity_1.PayrollItemType, (payrollItemType) => payrollItemType.payrollItems),
    (0, typeorm_1.JoinColumn)({ name: 'payrollItemTypeId' }),
    __metadata("design:type", typeof (_a = typeof payroll_item_type_entity_1.PayrollItemType !== "undefined" && payroll_item_type_entity_1.PayrollItemType) === "function" ? _a : Object)
], PayrollItem.prototype, "payrollItemType", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_payroll_item_type_entity_1.EmployeePayrollItemType, (employeePayrollItemType) => employeePayrollItemType.payrollItems),
    (0, typeorm_1.JoinColumn)({ name: 'employeePayrollItemTypeId' }),
    __metadata("design:type", typeof (_b = typeof employee_payroll_item_type_entity_1.EmployeePayrollItemType !== "undefined" && employee_payroll_item_type_entity_1.EmployeePayrollItemType) === "function" ? _b : Object)
], PayrollItem.prototype, "employeePayrollItemType", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => payroll_entity_1.Payroll, (payroll) => payroll.payrollItems, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'payrollId' }),
    (0, class_transformer_1.Exclude)({ toPlainOnly: true }),
    __metadata("design:type", typeof (_c = typeof payroll_entity_1.Payroll !== "undefined" && payroll_entity_1.Payroll) === "function" ? _c : Object)
], PayrollItem.prototype, "payroll", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 15,
        scale: 2,
        default: 0
    }),
    __metadata("design:type", Number)
], PayrollItem.prototype, "amount", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 15,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItem.prototype, "employerAmount", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", typeof (_d = typeof calculation_details_type_1.CalculationDetails !== "undefined" && calculation_details_type_1.CalculationDetails) === "function" ? _d : Object)
], PayrollItem.prototype, "calculationDetails", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 10,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItem.prototype, "taxableAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], PayrollItem.prototype, "paymentStatus", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], PayrollItem.prototype, "paymentDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], PayrollItem.prototype, "paymentReferenceNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], PayrollItem.prototype, "paymentMethod", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], PayrollItem.prototype, "batchNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_f = typeof Date !== "undefined" && Date) === "function" ? _f : Object)
], PayrollItem.prototype, "dueDate", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'processedById' }),
    __metadata("design:type", typeof (_g = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _g : Object)
], PayrollItem.prototype, "processedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_h = typeof Date !== "undefined" && Date) === "function" ? _h : Object)
], PayrollItem.prototype, "processedAt", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", typeof (_j = typeof Record !== "undefined" && Record) === "function" ? _j : Object)
], PayrollItem.prototype, "processingDetails", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], PayrollItem.prototype, "processingNotes", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], PayrollItem.prototype, "remittanceId", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_k = typeof Date !== "undefined" && Date) === "function" ? _k : Object)
], PayrollItem.prototype, "remittanceDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], PayrollItem.prototype, "isIncludedInReport", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], PayrollItem.prototype, "reportId", void 0);
exports.PayrollItem = PayrollItem = __decorate([
    (0, typeorm_1.Entity)('payroll-items')
], PayrollItem);


/***/ }),

/***/ "./src/modules/payroll-management/payroll-items/payroll-items.controller.ts":
/*!**********************************************************************************!*\
  !*** ./src/modules/payroll-management/payroll-items/payroll-items.controller.ts ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const payroll_item_dto_1 = __webpack_require__(/*! ./dtos/payroll-item.dto */ "./src/modules/payroll-management/payroll-items/dtos/payroll-item.dto.ts");
const payroll_item_entity_1 = __webpack_require__(/*! ./entities/payroll-item.entity */ "./src/modules/payroll-management/payroll-items/entities/payroll-item.entity.ts");
const payroll_items_service_1 = __webpack_require__(/*! ./payroll-items.service */ "./src/modules/payroll-management/payroll-items/payroll-items.service.ts");
class PayrollItemsController extends (0, create_controller_factory_1.createController)(payroll_item_entity_1.PayrollItem, payroll_items_service_1.PayrollItemsService, payroll_item_dto_1.GetPayrollItemDto, payroll_item_dto_1.PayrollItemDto, payroll_item_dto_1.UpdatePayrollItemDto) {
    async deleteMany(ids, hardDelete) {
        return super.deleteMany(ids, hardDelete);
    }
    async softDelete(id, deletedBy) {
        return super.softDelete(id, deletedBy);
    }
    async findOne(fieldsString, relations, select) {
        return super.findOne(fieldsString, relations, select);
    }
    delete(id) {
        return super.delete(id);
    }
}
exports.PayrollItemsController = PayrollItemsController;


/***/ }),

/***/ "./src/modules/payroll-management/payroll-items/payroll-items.module.ts":
/*!******************************************************************************!*\
  !*** ./src/modules/payroll-management/payroll-items/payroll-items.module.ts ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const payroll_item_types_module_1 = __webpack_require__(/*! ../payroll-item-types/payroll-item-types.module */ "./src/modules/payroll-management/payroll-item-types/payroll-item-types.module.ts");
const payroll_item_entity_1 = __webpack_require__(/*! ./entities/payroll-item.entity */ "./src/modules/payroll-management/payroll-items/entities/payroll-item.entity.ts");
const payroll_items_controller_1 = __webpack_require__(/*! ./payroll-items.controller */ "./src/modules/payroll-management/payroll-items/payroll-items.controller.ts");
const payroll_items_service_1 = __webpack_require__(/*! ./payroll-items.service */ "./src/modules/payroll-management/payroll-items/payroll-items.service.ts");
let PayrollItemsModule = class PayrollItemsModule {
};
exports.PayrollItemsModule = PayrollItemsModule;
exports.PayrollItemsModule = PayrollItemsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([payroll_item_entity_1.PayrollItem]),
            payroll_item_types_module_1.PayrollItemTypesModule,
        ],
        providers: [payroll_items_service_1.PayrollItemsService],
        exports: [payroll_items_service_1.PayrollItemsService],
        controllers: [payroll_items_controller_1.PayrollItemsController],
    })
], PayrollItemsModule);


/***/ }),

/***/ "./src/modules/payroll-management/payroll-items/payroll-items.service.ts":
/*!*******************************************************************************!*\
  !*** ./src/modules/payroll-management/payroll-items/payroll-items.service.ts ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const payroll_item_types_service_1 = __webpack_require__(/*! ../payroll-item-types/payroll-item-types.service */ "./src/modules/payroll-management/payroll-item-types/payroll-item-types.service.ts");
const payroll_item_entity_1 = __webpack_require__(/*! ./entities/payroll-item.entity */ "./src/modules/payroll-management/payroll-items/entities/payroll-item.entity.ts");
let PayrollItemsService = class PayrollItemsService extends base_service_1.BaseService {
    constructor(payrollItemsRepository, usersService, payrollItemTypesService) {
        super(payrollItemsRepository, usersService);
        this.payrollItemsRepository = payrollItemsRepository;
        this.usersService = usersService;
        this.payrollItemTypesService = payrollItemTypesService;
    }
};
exports.PayrollItemsService = PayrollItemsService;
exports.PayrollItemsService = PayrollItemsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(payroll_item_entity_1.PayrollItem)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof payroll_item_types_service_1.PayrollItemTypesService !== "undefined" && payroll_item_types_service_1.PayrollItemTypesService) === "function" ? _c : Object])
], PayrollItemsService);


/***/ }),

/***/ "./src/modules/payroll-management/payroll-management.module.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/payroll-management/payroll-management.module.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollManagementModule = void 0;
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const final_work_hours_module_1 = __webpack_require__(/*! ../attendance-management/final-work-hours/final-work-hours.module */ "./src/modules/attendance-management/final-work-hours/final-work-hours.module.ts");
const work_time_requests_module_1 = __webpack_require__(/*! ../attendance-management/work-time-requests/work-time-requests.module */ "./src/modules/attendance-management/work-time-requests/work-time-requests.module.ts");
const employee_management_module_1 = __webpack_require__(/*! ../employee-management/employee-management.module */ "./src/modules/employee-management/employee-management.module.ts");
const cutoffs_module_1 = __webpack_require__(/*! ./cutoffs/cutoffs.module */ "./src/modules/payroll-management/cutoffs/cutoffs.module.ts");
const payroll_entity_1 = __webpack_require__(/*! ./entities/payroll.entity */ "./src/modules/payroll-management/entities/payroll.entity.ts");
const payroll_item_types_module_1 = __webpack_require__(/*! ./payroll-item-types/payroll-item-types.module */ "./src/modules/payroll-management/payroll-item-types/payroll-item-types.module.ts");
const payroll_items_module_1 = __webpack_require__(/*! ./payroll-items/payroll-items.module */ "./src/modules/payroll-management/payroll-items/payroll-items.module.ts");
const payrolls_controller_1 = __webpack_require__(/*! ./payrolls.controller */ "./src/modules/payroll-management/payrolls.controller.ts");
const payrolls_service_1 = __webpack_require__(/*! ./payrolls.service */ "./src/modules/payroll-management/payrolls.service.ts");
const payroll_metrics_service_1 = __webpack_require__(/*! ./services/payroll-metrics.service */ "./src/modules/payroll-management/services/payroll-metrics.service.ts");
const payroll_processor_service_1 = __webpack_require__(/*! ./services/payroll-processor.service */ "./src/modules/payroll-management/services/payroll-processor.service.ts");
const payroll_state_machine_service_1 = __webpack_require__(/*! ./services/payroll-state-machine.service */ "./src/modules/payroll-management/services/payroll-state-machine.service.ts");
let PayrollManagementModule = class PayrollManagementModule {
};
exports.PayrollManagementModule = PayrollManagementModule;
exports.PayrollManagementModule = PayrollManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([payroll_entity_1.Payroll]),
            bull_1.BullModule.registerQueue({
                name: 'payroll-processing',
            }),
            core_1.RouterModule.register([
                {
                    path: 'payrolls',
                    module: PayrollManagementModule,
                    children: [
                        {
                            path: 'payroll-items',
                            module: payroll_items_module_1.PayrollItemsModule
                        },
                        {
                            path: 'payroll-item-types',
                            module: payroll_item_types_module_1.PayrollItemTypesModule
                        },
                        {
                            path: 'cutoffs',
                            module: cutoffs_module_1.CutoffsModule
                        }
                    ]
                }
            ]),
            payroll_items_module_1.PayrollItemsModule,
            payroll_item_types_module_1.PayrollItemTypesModule,
            cutoffs_module_1.CutoffsModule,
            employee_management_module_1.EmployeeManagementModule,
            (0, common_1.forwardRef)(() => final_work_hours_module_1.FinalWorkHoursModule),
            work_time_requests_module_1.WorkTimeRequestsModule,
        ],
        providers: [payrolls_service_1.PayrollsService, payroll_state_machine_service_1.PayrollStateMachine, payroll_processor_service_1.PayrollProcessorService, payroll_metrics_service_1.PayrollMetricsService],
        exports: [
            payrolls_service_1.PayrollsService,
            payroll_items_module_1.PayrollItemsModule,
            payroll_item_types_module_1.PayrollItemTypesModule,
            cutoffs_module_1.CutoffsModule,
        ],
        controllers: [payrolls_controller_1.PayrollsController],
    })
], PayrollManagementModule);


/***/ }),

/***/ "./src/modules/payroll-management/payrolls.controller.ts":
/*!***************************************************************!*\
  !*** ./src/modules/payroll-management/payrolls.controller.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollsController = void 0;
const authorize_decorator_1 = __webpack_require__(/*! @/common/decorators/authorize.decorator */ "./src/common/decorators/authorize.decorator.ts");
const current_user_decorator_1 = __webpack_require__(/*! @/common/decorators/current-user.decorator */ "./src/common/decorators/current-user.decorator.ts");
const generalresponse_dto_1 = __webpack_require__(/*! @/common/dtos/generalresponse.dto */ "./src/common/dtos/generalresponse.dto.ts");
const action_enum_1 = __webpack_require__(/*! @/common/enums/action.enum */ "./src/common/enums/action.enum.ts");
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const utility_helper_1 = __webpack_require__(/*! @/common/helpers/utility.helper */ "./src/common/helpers/utility.helper.ts");
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const bull_2 = __webpack_require__(/*! bull */ "bull");
const express_1 = __webpack_require__(/*! express */ "express");
const payroll_batch_process_dto_1 = __webpack_require__(/*! ./dtos/payroll-batch-process.dto */ "./src/modules/payroll-management/dtos/payroll-batch-process.dto.ts");
const payroll_dto_1 = __webpack_require__(/*! ./dtos/payroll.dto */ "./src/modules/payroll-management/dtos/payroll.dto.ts");
const recalculate_options_dto_1 = __webpack_require__(/*! ./dtos/recalculate-options.dto */ "./src/modules/payroll-management/dtos/recalculate-options.dto.ts");
const release_payroll_dto_1 = __webpack_require__(/*! ./dtos/release-payroll.dto */ "./src/modules/payroll-management/dtos/release-payroll.dto.ts");
const payroll_entity_1 = __webpack_require__(/*! ./entities/payroll.entity */ "./src/modules/payroll-management/entities/payroll.entity.ts");
const payrolls_service_1 = __webpack_require__(/*! ./payrolls.service */ "./src/modules/payroll-management/payrolls.service.ts");
const payslip_pdf_generator_1 = __webpack_require__(/*! ./utils/payslip-pdf-generator */ "./src/modules/payroll-management/utils/payslip-pdf-generator.ts");
let PayrollsController = class PayrollsController extends (0, create_controller_factory_1.createController)(payroll_entity_1.Payroll, payrolls_service_1.PayrollsService, payroll_dto_1.GetPayrollDto, payroll_dto_1.PayrollDto, payroll_dto_1.UpdatePayrollDto) {
    constructor(baseService, payrollQueue) {
        super(baseService);
        this.baseService = baseService;
        this.payrollQueue = payrollQueue;
    }
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async update(id, entityDto, updatedById) {
        return await this.baseService.update(id, entityDto, updatedById);
    }
    async delete(id) {
        return await super.delete(id);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    async findOne(fieldsString, relations, select) {
        return await super.findOne(fieldsString, relations, select);
    }
    async processPayrollForEmployee(employeeId, cutoffId, userId) {
        const payroll = await this.baseService.processPayrollForEmployee(employeeId, cutoffId, userId);
        return {
            message: `Payroll processed successfully for employee ${employeeId} in cutoff ${cutoffId}`,
        };
    }
    async archivePayroll(id) {
        const payroll = await this.baseService.findOneByOrFail({ id });
        const success = this.baseService.stateMachine.archive(payroll);
        if (!success) {
            throw new common_1.BadRequestException(`Cannot archive payroll ${id} in state: ${payroll.state}`);
        }
        await this.baseService.getRepository().save(payroll);
        return {
            message: `Payroll ${id} archived successfully`
        };
    }
    async voidPayroll(id, userId) {
        const payroll = await this.baseService.findOneByOrFail({ id });
        const success = this.baseService.stateMachine.void(payroll, userId);
        if (!success) {
            throw new common_1.BadRequestException(`Cannot void payroll ${id} in state: ${payroll.state}`);
        }
        await this.baseService.getRepository().save(payroll);
        return {
            message: `Payroll ${id} voided successfully`
        };
    }
    // @Put('process/cutoff/:cutoffId')
    // @Authorize({ endpointType: Action.CREATE })
    // @ApiOperation({
    //     summary: 'Process payroll for all employees in a cutoff',
    //     description: 'Batch process payrolls for all eligible employees in a specified cutoff period'
    // })
    // @ApiParam({
    //     name: 'cutoffId',
    //     description: 'ID of the cutoff period to process payrolls for',
    //     required: true
    // })
    // @ApiResponse({
    //     status: HttpStatus.CREATED,
    //     description: 'Payrolls successfully processed',
    //     type: [GetPayrollDto]
    // })
    // @ApiResponse({
    //     status: HttpStatus.BAD_REQUEST,
    //     description: 'Invalid request, cutoff not active, or no eligible employees'
    // })
    // async processPayrollForCutoff(
    //     @Param('cutoffId') cutoffId: string,
    //     @CurrentUser('sub') userId: string
    // ): Promise<GetPayrollDto[]> {
    //     const payrolls = await this.baseService.processPayrollForCutoff(cutoffId, userId);
    //     return payrolls as GetPayrollDto[];
    // }
    async generatePayslipData(id) {
        return await this.baseService.generatePayslipData(id);
    }
    async downloadPayslip(id, res) {
        const payroll = await this.baseService.findOneByOrFail({ id });
        const employee = payroll.employee;
        const payslipData = await this.baseService.generatePayslipData(id);
        // log
        // Generate PDF using the custom generator
        const pdfBuffer = await (0, payslip_pdf_generator_1.generatePayslipPdf)(payslipData);
        const fileName = `Payslip_${employee.employeeNumber}_${utility_helper_1.UtilityHelper.ensureDate(payroll.cutoff.startDate).toISOString().slice(0, 10)}.pdf`;
        // Set appropriate headers for PDF download
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename=${fileName}`);
        res.setHeader('Content-Length', pdfBuffer.length);
        // Send the PDF
        res.send(pdfBuffer);
    }
    async approvePayroll(id, userId) {
        // Get the full payroll entity
        const payroll = await this.baseService.findOneByOrFail({ id });
        // Use the state machine to perform transition with validation
        const success = this.baseService.stateMachine.approve(payroll, userId);
        if (!success) {
            throw new common_1.BadRequestException(`Cannot approve payroll ${id} in current state: ${payroll.state}`);
        }
        // Save the updated payroll with history
        await this.baseService.getRepository().save(payroll);
        return {
            message: `Payroll ${id} approved successfully`
        };
    }
    async releasePayroll(id, releaseData, userId) {
        const payroll = await this.baseService.findOneByOrFail({ id });
        // Use markPaid instead of direct update
        const success = this.baseService.stateMachine.markPaid(payroll, userId, {
            paymentMethod: releaseData.paymentMethod,
            paymentDate: releaseData.paymentDate || new Date(),
            bankReferenceNumber: releaseData.bankReferenceNumber,
            bankAccount: releaseData.bankAccount,
            checkNumber: releaseData.checkNumber
        });
        if (!success) {
            throw new common_1.BadRequestException(`Cannot release payroll ${id} in current state: ${payroll.state}`);
        }
        // Additional payment details
        payroll.paymentMethod = releaseData.paymentMethod;
        payroll.paymentDate = releaseData.paymentDate || new Date();
        payroll.bankReferenceNumber = releaseData.bankReferenceNumber;
        payroll.bankAccount = releaseData.bankAccount;
        payroll.checkNumber = releaseData.checkNumber;
        await this.baseService.getRepository().save(payroll);
        return {
            message: `Payroll ${id} released successfully`
        };
    }
    async rejectPayroll(id, reason, userId) {
        // Get the full payroll entity
        const payroll = await this.baseService.findOneByOrFail({ id });
        // Use the state machine to perform transition with validation
        const success = this.baseService.stateMachine.reject(payroll, userId, reason);
        if (!success) {
            throw new common_1.BadRequestException(`Cannot reject payroll ${id} in current state: ${payroll.state}`);
        }
        // Save the updated payroll with history
        await this.baseService.getRepository().save(payroll);
        return {
            message: `Payroll ${id} approved successfully`
        };
    }
    async processBatchPayroll(data, userId) {
        const batches = await this.baseService.createProcessingBatches(data.cutoffId, data.batchSize);
        // log
        this.logger.log(`Processing ${batches.length} batches for cutoff ${data.cutoffId}`);
        // Queue each batch for processing
        for (const batch of batches) {
            await this.payrollQueue.add('process-batch-payroll', {
                cutoffId: data.cutoffId,
                userId,
                batchId: batch.batchId
            });
        }
        // Estimate completion time (3 seconds per employee as a rough estimate)
        let estimatedCompletionTime;
        const totalEmployees = batches.reduce((sum, batch) => sum + batch.employeeCount, 0);
        try {
            // Prevent division by zero
            if (batches.length === 0) {
                estimatedCompletionTime = new Date().toISOString();
            }
            else {
                const estimatedSeconds = Math.ceil((totalEmployees * 2) / batches.length);
                // Add a safety limit to prevent extremely large values
                const safeSeconds = Math.min(estimatedSeconds, 86400); // Max 24 hours
                estimatedCompletionTime = new Date(Date.now() + safeSeconds * 1000).toISOString();
            }
        }
        catch (error) {
            // Fallback to current time if any calculation fails
            estimatedCompletionTime = new Date().toISOString();
        }
        return {
            cutoffId: data.cutoffId,
            batchSize: data.batchSize,
            message: `Processing started for ${totalEmployees} employees in ${batches.length} batches`,
            batchCount: batches.length,
            batches,
            estimatedCompletionTime
        };
    }
    async retryFailedPayrolls(data, userId) {
        const result = await this.baseService.retryFailedPayrolls(data.cutoffId, userId, {
            maxRetries: data.maxRetries,
            onlySpecificIds: data.specificIds
        });
        return {
            message: `Retry process completed`,
            successful: result.successful,
            failed: result.failed,
            skipped: result.skipped
        };
    }
    async getBatchProcessingStatus(cutoffId) {
        // Implement a method in your service to get batch processing statistics
        return this.baseService.getBatchProcessingStatus(cutoffId);
    }
    // @Get('audit/:payrollId')
    // @Authorize({ endpointType: Action.READ })
    // @ApiOperation({
    //   summary: 'Get payroll audit trail',
    //   description: 'Returns detailed audit information for a payroll record'
    // })
    // async getPayrollAudit(
    //   @Param('payrollId') payrollId: string
    // ): Promise<{
    //   payrollId: string,
    //   stateHistory: any[],
    //   calculations: any,
    //   changes: any[]
    // }> {
    //   return this.baseService.getPayrollAudit(payrollId);
    // }
    async recalculatePayroll(id, options, userId) {
        await this.baseService.recalculatePayroll(id, options, userId);
        return {
            message: `Payroll ${id} recalculated successfully`
        };
    }
};
exports.PayrollsController = PayrollsController;
__decorate([
    (0, common_1.Post)('process/employee/:employeeId/cutoff/:cutoffId'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.CREATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Process payroll for a specific employee and cutoff',
        description: 'Generates and calculates a complete payroll for an employee for a given cutoff period'
    }),
    (0, swagger_1.ApiParam)({
        name: 'employeeId',
        description: 'ID of the employee to process payroll for',
        required: true
    }),
    (0, swagger_1.ApiParam)({
        name: 'cutoffId',
        description: 'ID of the cutoff period to process',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payroll successfully processed',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid request or payroll already processed',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Employee or cutoff not found'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Param)('employeeId', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Param)('cutoffId', common_1.ParseUUIDPipe)),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], PayrollsController.prototype, "processPayrollForEmployee", null);
__decorate([
    (0, common_1.Patch)(':id/archive'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Archive a payroll',
        description: 'Moves payroll to archived state for long-term storage'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to archive',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payroll archived successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Payroll not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Payroll cannot be archived (invalid status)',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], PayrollsController.prototype, "archivePayroll", null);
__decorate([
    (0, common_1.Patch)(':id/void'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Void a payroll',
        description: 'Marks a payroll as voided, indicating it is no longer valid'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to void',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payroll voided successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Payroll not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Payroll cannot be voided (invalid status)',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], PayrollsController.prototype, "voidPayroll", null);
__decorate([
    (0, common_1.Get)(':id/payslip'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({
        summary: 'Get payslip data',
        description: 'Generates structured payslip data for an existing payroll'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to generate payslip for',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payslip data generated successfully',
        type: 'any'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Payroll not found'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], PayrollsController.prototype, "generatePayslipData", null);
__decorate([
    (0, common_1.Get)(':id/payslip/download'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({
        summary: 'Download payslip as PDF',
        description: 'Generates and downloads a PDF payslip for the specified payroll'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to generate PDF payslip for',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'PDF generated and downloaded successfully'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Payroll not found'
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_g = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _g : Object]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], PayrollsController.prototype, "downloadPayslip", null);
__decorate([
    (0, common_1.Patch)(':id/approve'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.MANAGE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Approve a payroll',
        description: 'Changes the status of a payroll to APPROVED'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to approve',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payroll approved successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Payroll not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Payroll cannot be approved (invalid status)',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], PayrollsController.prototype, "approvePayroll", null);
__decorate([
    (0, common_1.Patch)(':id/release'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Release a payroll',
        description: 'Marks a payroll as RELEASED, indicating it has been sent for payment'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to release',
        required: true
    }),
    (0, swagger_1.ApiBody)({
        type: release_payroll_dto_1.ReleasePayrollDto,
        description: 'Details for releasing the payroll'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payroll released successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Payroll not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Payroll cannot be released (invalid status)',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_k = typeof release_payroll_dto_1.ReleasePayrollDto !== "undefined" && release_payroll_dto_1.ReleasePayrollDto) === "function" ? _k : Object, String]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], PayrollsController.prototype, "releasePayroll", null);
__decorate([
    (0, common_1.Patch)(':id/reject'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Reject a payroll',
        description: 'Marks a payroll as REJECTED'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to reject',
        required: true
    }),
    (0, swagger_1.ApiQuery)({
        name: 'reason',
        required: true,
        description: 'Reason for rejection'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payroll rejected successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Payroll not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Payroll cannot be rejected (invalid status)',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Query)('reason')),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], PayrollsController.prototype, "rejectPayroll", null);
__decorate([
    (0, common_1.Post)('process/batch'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.CREATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Process payrolls in batch mode',
        description: 'Divides employees into batches and queues them for asynchronous processing'
    }),
    (0, swagger_1.ApiBody)({
        type: payroll_batch_process_dto_1.PayrollBatchProcessRequestDto,
        description: 'Request body for batch payroll processing'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Batch payroll processing initiated successfully',
        type: payroll_batch_process_dto_1.PayrollBatchProcessResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid request or cutoff not active',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Cutoff not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_o = typeof payroll_batch_process_dto_1.PayrollBatchProcessRequestDto !== "undefined" && payroll_batch_process_dto_1.PayrollBatchProcessRequestDto) === "function" ? _o : Object, String]),
    __metadata("design:returntype", typeof (_p = typeof Promise !== "undefined" && Promise) === "function" ? _p : Object)
], PayrollsController.prototype, "processBatchPayroll", null);
__decorate([
    (0, common_1.Put)('retry-failed'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Retry failed payroll processing',
        description: 'Attempts to reprocess failed payrolls with smart retry logic'
    }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_q = typeof Promise !== "undefined" && Promise) === "function" ? _q : Object)
], PayrollsController.prototype, "retryFailedPayrolls", null);
__decorate([
    (0, common_1.Get)('batch-status/:cutoffId'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({
        summary: 'Check batch processing status',
        description: 'Returns the current status of batch payroll processing'
    }),
    __param(0, (0, common_1.Param)('cutoffId', common_1.ParseUUIDPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_r = typeof Promise !== "undefined" && Promise) === "function" ? _r : Object)
], PayrollsController.prototype, "getBatchProcessingStatus", null);
__decorate([
    (0, common_1.Put)(':id/recalculate'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Recalculate a specific payroll',
        description: 'Forces recalculation of an existing payroll with option to preserve or reset state'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to recalculate',
        required: true
    }),
    (0, swagger_1.ApiBody)({
        type: recalculate_options_dto_1.RecalculateOptionsDto,
        description: 'Options for recalculation'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payroll recalculated successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Payroll not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Payroll cannot be recalculated (invalid status)',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'Unauthorized',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.FORBIDDEN,
        description: 'Forbidden',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_s = typeof recalculate_options_dto_1.RecalculateOptionsDto !== "undefined" && recalculate_options_dto_1.RecalculateOptionsDto) === "function" ? _s : Object, String]),
    __metadata("design:returntype", typeof (_t = typeof Promise !== "undefined" && Promise) === "function" ? _t : Object)
], PayrollsController.prototype, "recalculatePayroll", null);
exports.PayrollsController = PayrollsController = __decorate([
    __param(1, (0, bull_1.InjectQueue)('payroll-processing')),
    __metadata("design:paramtypes", [typeof (_a = typeof payrolls_service_1.PayrollsService !== "undefined" && payrolls_service_1.PayrollsService) === "function" ? _a : Object, typeof (_b = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _b : Object])
], PayrollsController);


/***/ }),

/***/ "./src/modules/payroll-management/payrolls.service.ts":
/*!************************************************************!*\
  !*** ./src/modules/payroll-management/payrolls.service.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PayrollsService_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollsService = void 0;
const occurrence_enum_1 = __webpack_require__(/*! @/common/enums/occurrence.enum */ "./src/common/enums/occurrence.enum.ts");
const cutoff_status_enum_1 = __webpack_require__(/*! @/common/enums/payroll/cutoff-status.enum */ "./src/common/enums/payroll/cutoff-status.enum.ts");
const cutoff_type_enum_1 = __webpack_require__(/*! @/common/enums/payroll/cutoff-type.enum */ "./src/common/enums/payroll/cutoff-type.enum.ts");
const government_contribution_type_enum_1 = __webpack_require__(/*! @/common/enums/payroll/government-contribution-type.enum */ "./src/common/enums/payroll/government-contribution-type.enum.ts");
const payroll_item_category_enum_1 = __webpack_require__(/*! @/common/enums/payroll/payroll-item-category.enum */ "./src/common/enums/payroll/payroll-item-category.enum.ts");
const payroll_state_enum_1 = __webpack_require__(/*! @/common/enums/payroll/payroll-state.enum */ "./src/common/enums/payroll/payroll-state.enum.ts");
const utility_helper_1 = __webpack_require__(/*! @/common/helpers/utility.helper */ "./src/common/helpers/utility.helper.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const transaction_service_1 = __webpack_require__(/*! @/common/services/transaction.service */ "./src/common/services/transaction.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const final_work_hours_service_1 = __webpack_require__(/*! @/modules/attendance-management/final-work-hours/final-work-hours.service */ "./src/modules/attendance-management/final-work-hours/final-work-hours.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const os_1 = __webpack_require__(/*! os */ "os");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const work_time_requests_service_1 = __webpack_require__(/*! ../attendance-management/work-time-requests/work-time-requests.service */ "./src/modules/attendance-management/work-time-requests/work-time-requests.service.ts");
const employee_payroll_item_types_service_1 = __webpack_require__(/*! ../employee-management/employee-payroll-item-types/employee-payroll-item-types.service */ "./src/modules/employee-management/employee-payroll-item-types/employee-payroll-item-types.service.ts");
const employees_service_1 = __webpack_require__(/*! ../employee-management/employees.service */ "./src/modules/employee-management/employees.service.ts");
const cutoffs_service_1 = __webpack_require__(/*! ./cutoffs/cutoffs.service */ "./src/modules/payroll-management/cutoffs/cutoffs.service.ts");
const payroll_entity_1 = __webpack_require__(/*! ./entities/payroll.entity */ "./src/modules/payroll-management/entities/payroll.entity.ts");
const payroll_item_types_service_1 = __webpack_require__(/*! ./payroll-item-types/payroll-item-types.service */ "./src/modules/payroll-management/payroll-item-types/payroll-item-types.service.ts");
const payroll_item_entity_1 = __webpack_require__(/*! ./payroll-items/entities/payroll-item.entity */ "./src/modules/payroll-management/payroll-items/entities/payroll-item.entity.ts");
const payroll_state_machine_service_1 = __webpack_require__(/*! ./services/payroll-state-machine.service */ "./src/modules/payroll-management/services/payroll-state-machine.service.ts");
let PayrollsService = PayrollsService_1 = class PayrollsService extends base_service_1.BaseService {
    constructor(payrollsRepository, employeesService, cutoffsService, finalWorkHoursService, employeePayrollItemTypesService, payrollItemTypesService, usersService, workTimeRequestsService, stateMachine, eventEmitter, transactionService) {
        super(payrollsRepository, usersService);
        this.payrollsRepository = payrollsRepository;
        this.employeesService = employeesService;
        this.cutoffsService = cutoffsService;
        this.finalWorkHoursService = finalWorkHoursService;
        this.employeePayrollItemTypesService = employeePayrollItemTypesService;
        this.payrollItemTypesService = payrollItemTypesService;
        this.usersService = usersService;
        this.workTimeRequestsService = workTimeRequestsService;
        this.stateMachine = stateMachine;
        this.eventEmitter = eventEmitter;
        this.transactionService = transactionService;
        this.logger = new common_1.Logger(PayrollsService_1.name);
        this.RestDayPayMultiplier = 1.3;
        this.HolidayPayMultiplier = 2.0;
        this.SpecialHolidayPayMultiplier = 1.3;
        this.OvertimePayMultiplier = 1.25;
        this.HolidayOvertimePayMultiplier = 2.3;
        this.SpecialHolidayOvertimePayMultiplier = 1.3;
        this.RestDayOvertimePayMultiplier = 1.69;
        this.NightDifferentialPayMultiplier = 1.1;
        this.NightDifferentialOvertimePayMultiplier = 1.35;
        this.BaseAmount = 'monthlyRate';
    }
    /**
     * Calculate rates based on employee's compensation type and cutoff period
     */
    async calculateRates(employeeId, cutoff) {
        const baseCompensation = await this.employeePayrollItemTypesService.getEmployeeBaseCompensation(employeeId);
        const { rateType, amount } = baseCompensation;
        const businessDaysInPeriod = utility_helper_1.UtilityHelper.getBusinessDays(cutoff.startDate, cutoff.endDate);
        const businessDaysInMonth = utility_helper_1.UtilityHelper.getBusinessDaysInMonth(cutoff.startDate);
        // Default values
        let monthlyRate = 0;
        let dailyRate = 0;
        let hourlyRate = 0;
        // Calculate rates based on compensation type
        switch (rateType) {
            case occurrence_enum_1.Occurrence.MONTHLY:
                monthlyRate = amount;
                // Calculate daily rate based on cutoff type
                switch (cutoff.cutoffType) {
                    case cutoff_type_enum_1.CutoffType.DAILY:
                        dailyRate = monthlyRate / businessDaysInMonth;
                        break;
                    case cutoff_type_enum_1.CutoffType.WEEKLY:
                        dailyRate = (monthlyRate / 4) / businessDaysInPeriod;
                        break;
                    case cutoff_type_enum_1.CutoffType.BI_WEEKLY:
                        dailyRate = (monthlyRate / 2) / businessDaysInPeriod;
                        break;
                    case cutoff_type_enum_1.CutoffType.MONTHLY:
                    default:
                        dailyRate = monthlyRate / businessDaysInMonth;
                        break;
                }
                // Standard 8-hour workday
                hourlyRate = dailyRate / 8;
                break;
            case occurrence_enum_1.Occurrence.DAILY:
                dailyRate = amount;
                monthlyRate = dailyRate * businessDaysInMonth;
                hourlyRate = dailyRate / 8;
                break;
            case occurrence_enum_1.Occurrence.HOURLY:
                hourlyRate = amount;
                dailyRate = hourlyRate * 8;
                monthlyRate = dailyRate * businessDaysInMonth;
                break;
            default:
                throw new common_1.BadRequestException(`Unknown compensation type: ${os_1.type}`);
        }
        return {
            monthlyRate,
            dailyRate,
            hourlyRate,
            baseCompensationType: rateType,
            baseCompensationAmount: amount
        };
    }
    /**
     * Calculate SSS contribution based on 2025 rules
     */
    calculateSSSContribution(itemType, baseAmount) {
        // SSS calculation based on 2025 rates
        const sssEmployeeRate = (itemType.percentage || 5) / 100;
        const sssEmployerRate = (itemType.employerPercentage || 10) / 100;
        const mscCeiling = itemType.maxAmount || 35000;
        const mscFloor = itemType.minAmount || 5000;
        // Apply MSC ceiling based on gross pay
        let msc = Math.max(baseAmount, mscFloor);
        msc = Math.min(msc, mscCeiling);
        // Calculate employee and employer shares
        const calculatedAmount = parseFloat((msc * sssEmployeeRate).toFixed(2));
        let employerAmount = parseFloat((msc * sssEmployerRate).toFixed(2));
        // Add EC contribution (employer only)
        const ecContribution = msc <= (itemType.minContribution || 14500) ? 10 : 30;
        employerAmount += ecContribution;
        const calculationDetail = {
            calculationType: 'SSS',
            baseAmount: baseAmount,
            msc: msc,
            employeeRate: `${sssEmployeeRate * 100}%`,
            employerRate: `${sssEmployerRate * 100}%`,
            employeeContribution: calculatedAmount,
            employerContribution: employerAmount,
            ecContribution: ecContribution,
            totalContribution: calculatedAmount + employerAmount
        };
        return { calculatedAmount, employerAmount, calculationDetail };
    }
    /**
     * Calculate withholding tax based on TRAIN Law
     */
    // Function to calculate withholding tax based on 2025 tax brackets
    calculateWithholdingTax(monthlyTaxableIncome) {
        // Convert monthly to annual taxable income
        const annualTaxableIncome = monthlyTaxableIncome * 12;
        // Apply 2025 TRAIN Law tax brackets (accurate rates and thresholds)
        let annualTax = 0;
        if (annualTaxableIncome <= 250000) {
            // First bracket: 0% for income up to ₱250,000
            annualTax = 0;
        }
        else if (annualTaxableIncome <= 400000) {
            // Second bracket: 15% of excess over ₱250,000
            annualTax = (annualTaxableIncome - 250000) * 0.15;
        }
        else if (annualTaxableIncome <= 800000) {
            // Third bracket: ₱22,500 + 20% of excess over ₱400,000
            annualTax = 22500 + (annualTaxableIncome - 400000) * 0.20;
        }
        else if (annualTaxableIncome <= 2000000) {
            // Fourth bracket: ₱102,500 + 25% of excess over ₱800,000
            annualTax = 102500 + (annualTaxableIncome - 800000) * 0.25;
        }
        else if (annualTaxableIncome <= 8000000) {
            // Fifth bracket: ₱402,500 + 30% of excess over ₱2,000,000
            annualTax = 402500 + (annualTaxableIncome - 2000000) * 0.30;
        }
        else {
            // Sixth bracket: ₱2,202,500 + 35% of excess over ₱8,000,000
            annualTax = 2202500 + (annualTaxableIncome - 8000000) * 0.35;
        }
        // Calculate monthly withholding tax
        // Round to 2 decimal places to avoid floating point precision issues
        const monthlyTax = Math.round((annualTax / 12) * 100) / 100;
        const calculationDetail = {
            calculationType: 'WITHHOLDING_TAX',
            monthlyTaxableIncome: monthlyTaxableIncome,
            annualTaxableIncome: annualTaxableIncome,
            annualTax: Math.round(annualTax * 100) / 100, // Round annual tax too
            monthlyTax: monthlyTax
        };
        return {
            calculatedAmount: monthlyTax,
            calculationDetail
        };
    }
    /**
     * Calculates PhilHealth contributions based on 2025 rates
     * @param baseAmount Employee's base salary amount
     * @param itemType Configuration object with rates and thresholds
     * @returns Object containing calculated amounts and detailed breakdown
     */
    calculatePhilHealthContribution(baseAmount, itemType) {
        // PhilHealth calculation based on 2025 rates
        const philHealthRate = (itemType.percentage || 2.5) / 100;
        const philHealthEmployerRate = (itemType.employerPercentage || 2.5) / 100;
        const floorSalary = itemType.minAmount || 10000;
        const ceilingSalary = itemType.maxAmount || 100000;
        // Apply floor and ceiling
        let philHealthBase = baseAmount;
        philHealthBase = Math.max(philHealthBase, floorSalary);
        philHealthBase = Math.min(philHealthBase, ceilingSalary);
        // Calculate contributions
        const calculatedAmount = parseFloat((philHealthBase * philHealthRate).toFixed(2));
        const employerAmount = parseFloat((philHealthBase * philHealthEmployerRate).toFixed(2));
        const calculationDetail = {
            calculationType: 'PHILHEALTH',
            baseAmount: baseAmount,
            computationBase: philHealthBase,
            employeeRate: `${philHealthRate * 100}%`,
            employerRate: `${philHealthEmployerRate * 100}%`,
            employeeContribution: calculatedAmount,
            employerContribution: employerAmount,
            totalContribution: calculatedAmount + employerAmount
        };
        return { calculatedAmount, employerAmount, calculationDetail };
    }
    /**
     * Calculates PAGIBIG contributions for both employee and employer
     * @param baseAmount The employee's base salary
     * @param itemType Configuration object containing rates and limits
     * @returns Object containing calculated amounts and detailed breakdown
     */
    calculatePagibigContribution(baseAmount, itemType) {
        // Pag-IBIG calculation based on 2025 rates
        const pagibigBaseSalary = Math.min(baseAmount, itemType.maxAmount || 10000);
        // Employee rate depends on salary (1% if ≤ 1500, 2% otherwise)
        const employeePagibigRate = baseAmount <= (itemType.minAmount || 1500) ?
            (itemType.minContribution || 1) / 100 :
            (itemType.maxContribution || 2) / 100;
        const employerPagibigRate = (itemType.employerPercentage || 2) / 100;
        const calculatedAmount = parseFloat((pagibigBaseSalary * employeePagibigRate).toFixed(2));
        const employerAmount = parseFloat((pagibigBaseSalary * employerPagibigRate).toFixed(2));
        const calculationDetail = {
            calculationType: 'PAGIBIG',
            baseAmount: baseAmount,
            computationBase: pagibigBaseSalary,
            employeeRate: `${employeePagibigRate * 100}%`,
            employerRate: `${employerPagibigRate * 100}%`,
            employeeContribution: calculatedAmount,
            employerContribution: employerAmount,
            totalContribution: calculatedAmount + employerAmount
        };
        return {
            calculatedAmount,
            employerAmount,
            calculationDetail
        };
    }
    /**
     * Calculate basic pay components from work hours
     */
    async calculateBasicPay(payroll, finalWorkHours) {
        // Get rates based on employee's compensation type
        const rates = await this.calculateRates(payroll.employee.id, payroll.cutoff);
        // Set rates
        payroll.monthlyRate = rates.monthlyRate;
        payroll.dailyRate = rates.dailyRate;
        payroll.hourlyRate = rates.hourlyRate;
        // Reset deduction hours
        payroll.totalNoTimeInHours = 0;
        payroll.totalNoTimeOutHours = 0;
        payroll.totalAbsentHours = 0;
        payroll.totalTardinessHours = 0;
        payroll.totalUndertimeHours = 0;
        // Reset hour totals
        payroll.totalRegularHours = 0;
        payroll.totalHolidayHours = 0;
        payroll.totalSpecialHolidayHours = 0;
        payroll.totalRestDayHours = 0;
        payroll.totalOvertimeHours = 0;
        payroll.totalHolidayOvertimeHours = 0;
        payroll.totalSpecialHolidayOvertimeHours = 0;
        payroll.totalRestDayOvertimeHours = 0;
        payroll.totalNightDifferentialHours = 0;
        payroll.totalNightDifferentialOvertimeHours = 0;
        // Reset pay components
        payroll.basicPay = 0;
        payroll.overtimePay = 0;
        payroll.holidayPay = 0;
        payroll.holidayOvertimePay = 0;
        payroll.specialHolidayPay = 0;
        payroll.specialHolidayOvertimePay = 0;
        payroll.restDayPay = 0;
        payroll.restDayOvertimePay = 0;
        payroll.nightDifferentialPay = 0;
        payroll.nightDifferentialOvertimePay = 0;
        // Reset deduction totals
        payroll.absences = 0;
        payroll.tardiness = 0;
        payroll.undertime = 0;
        payroll.noTimeIn = 0;
        payroll.noTimeOut = 0;
        payroll.totalBasicDeductions = 0;
        payroll.totalDeductions = 0;
        payroll.totalAllowances = 0;
        // Process each work hour record
        for (const workHour of finalWorkHours) {
            // Fix the hours mapping - you had these swapped
            payroll.totalRegularHours += +workHour.regularDayHours || 0;
            payroll.totalHolidayHours += +workHour.regularHolidayHours || 0;
            payroll.totalSpecialHolidayHours += +workHour.specialHolidayHours || 0;
            payroll.totalRestDayHours += +workHour.restDayHours || 0;
            // Aggregate overtime hours
            payroll.totalOvertimeHours += +workHour.overtimeRegularDayHours || 0;
            payroll.totalHolidayOvertimeHours += +workHour.overtimeRegularHolidayHours || 0;
            payroll.totalSpecialHolidayOvertimeHours += +workHour.overtimeSpecialHolidayHours || 0;
            payroll.totalRestDayOvertimeHours += +workHour.overtimeRestDayHours || 0;
            // Aggregate deductions
            payroll.totalNoTimeInHours += +workHour.noTimeInHours || 0;
            payroll.totalNoTimeOutHours += +workHour.noTimeOutHours || 0;
            payroll.totalAbsentHours += +workHour.absentHours || 0;
            payroll.totalTardinessHours += +workHour.tardinessHours || 0;
            payroll.totalUndertimeHours += +workHour.undertimeHours || 0;
            // Night differential
            payroll.totalNightDifferentialHours += +workHour.nightDifferentialHours || 0;
            payroll.totalNightDifferentialOvertimeHours += +workHour.overtimeNightDifferentialHours || 0;
        }
        // Calculate pay components with proper rate multipliers according to Philippine labor laws
        // 1. Basic regular day pay (1.0x)
        payroll.basicPay = payroll.totalRegularHours * payroll.hourlyRate;
        // 2. Rest day pay (1.3x)
        payroll.restDayPay = payroll.totalRestDayHours * payroll.hourlyRate * this.RestDayPayMultiplier;
        // 3. Holiday pay (2.0x)
        payroll.holidayPay = payroll.totalHolidayHours * payroll.hourlyRate * this.HolidayPayMultiplier;
        // 4. Special holiday pay (1.3x)
        payroll.specialHolidayPay = payroll.totalSpecialHolidayHours * payroll.hourlyRate * this.SpecialHolidayPayMultiplier;
        // 5. Overtime regular pay (1.25x)
        payroll.overtimePay = payroll.totalOvertimeHours * payroll.hourlyRate * this.OvertimePayMultiplier;
        // 6. Overtime holiday pay (2.6x)
        payroll.holidayOvertimePay = payroll.totalHolidayOvertimeHours * payroll.hourlyRate * this.HolidayOvertimePayMultiplier;
        // 7. Overtime special holiday pay (1.3x)
        payroll.specialHolidayOvertimePay = payroll.totalSpecialHolidayOvertimeHours * payroll.hourlyRate * this.SpecialHolidayOvertimePayMultiplier;
        // 8. Overtime rest day pay (1.69x)
        payroll.restDayOvertimePay = payroll.totalRestDayOvertimeHours * payroll.hourlyRate * this.RestDayOvertimePayMultiplier;
        // 9. Night differential (10% of hourly rate)
        payroll.nightDifferentialPay = payroll.totalNightDifferentialHours * payroll.hourlyRate * this.NightDifferentialPayMultiplier;
        // 9. Overtime night differential (1.35x)
        payroll.nightDifferentialOvertimePay = payroll.totalNightDifferentialOvertimeHours * payroll.hourlyRate * this.NightDifferentialOvertimePayMultiplier;
        // 10. Deduction hours
        payroll.absences = payroll.totalAbsentHours * payroll.hourlyRate;
        payroll.tardiness = payroll.totalTardinessHours * payroll.hourlyRate;
        payroll.undertime = payroll.totalUndertimeHours * payroll.hourlyRate;
        payroll.noTimeIn = payroll.totalNoTimeInHours * payroll.hourlyRate;
        payroll.noTimeOut = payroll.totalNoTimeOutHours * payroll.hourlyRate;
        payroll.totalBasicDeductions = payroll.absences + payroll.tardiness + payroll.undertime
            + payroll.noTimeIn + payroll.noTimeOut;
        payroll.totalDeductions = payroll.totalBasicDeductions;
        // 10. Initial gross pay from basic components
        payroll.grossPay = payroll.basicPay + payroll.restDayPay + payroll.holidayPay
            + payroll.specialHolidayPay + payroll.overtimePay
            + payroll.holidayOvertimePay + payroll.specialHolidayOvertimePay
            + payroll.restDayOvertimePay + payroll.nightDifferentialPay;
        // 11. Total hours worked
        payroll.totalHours = payroll.totalRegularHours + payroll.totalRestDayHours +
            payroll.totalHolidayHours + payroll.totalSpecialHolidayHours +
            payroll.totalOvertimeHours + payroll.totalRestDayOvertimeHours +
            payroll.totalHolidayOvertimeHours + payroll.totalSpecialHolidayOvertimeHours;
        // 12. Initial taxable income (will be adjusted for non-taxable items)
        payroll.taxableIncome = payroll.grossPay;
        // 13. Initial net pay
        payroll.netPay = payroll.grossPay - payroll.totalDeductions;
    }
    /**
     * Process all payroll items for an employee
     */
    async processPayrollItems(payroll, userId) {
        // check if cutoff is available
        const { cutoff } = payroll;
        if (!cutoff) {
            throw new common_1.NotFoundException(`Cutoff not found for payroll ID: ${payroll.id}`);
        }
        // Get all payroll item types
        const allPayrollItemTypes = await this.payrollItemTypesService.getRepository().find({
            where: { isActive: true, isDeleted: false, includeInPayrollItemsProcessing: true },
            order: { category: 'ASC', name: 'ASC' }
        });
        // Get employee specific payroll item configurations
        const employeePayrollItems = await this.employeePayrollItemTypesService.getRepository().find({
            where: {
                employee: { id: payroll.employee.id },
                isActive: true,
                isDeleted: false
            },
            relations: {
                payrollItemType: true,
                employee: true
            }
        });
        // For government mandated contributions on second cutoff, get combined income
        let combinedGrossPay = payroll.grossPay;
        let combinedTaxableIncome = payroll.taxableIncome;
        if (cutoff.cutoffPlace === 2) {
            // log 
            this.logger.log(`Processing second cutoff payroll for employee ${payroll.employee.id} with gross pay ${payroll.grossPay} and taxable income ${payroll.taxableIncome}`);
            // Find the first cutoff payroll in the same month
            const firstCutoffDate = new Date(cutoff.startDate);
            firstCutoffDate.setDate(1); // Set to first day of month
            const previousPayroll = await this.payrollsRepository.findOne({
                where: {
                    employee: { id: payroll.employee.id },
                    cutoff: {
                        cutoffNumber: cutoff.cutoffNumber - 1,
                    },
                    // status: PayrollStatus.RELEASED
                },
                relations: {
                    employee: true,
                    cutoff: true
                }
            });
            if (previousPayroll) {
                // Add the gross pay from the first cutoff
                combinedGrossPay += previousPayroll.grossPay;
                combinedTaxableIncome += previousPayroll.taxableIncome;
            }
        }
        // Check if employee has the required payroll item types
        const requiredPayrollItemTypes = allPayrollItemTypes.filter(item => item.isRequired);
        let missingRequiredItems = requiredPayrollItemTypes.filter(item => !employeePayrollItems.some(empItem => empItem.payrollItemType.id === item.id));
        if (missingRequiredItems.length > 0) {
            throw new common_1.BadRequestException(`Employee ${payroll.employee.id} is missing required payroll item types: ${missingRequiredItems.map(item => item.name).join(', ')}`);
        }
        // Map employee payroll items by payroll item type ID for quick lookup
        const employeePayrollItemMap = new Map(employeePayrollItems.map(item => [item.payrollItemType.id, item]));
        // Order for processing categories
        const processingOrder = [
            payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION,
            payroll_item_category_enum_1.PayrollItemCategory.ADJUSTMENT,
            payroll_item_category_enum_1.PayrollItemCategory.DEDUCTION,
            payroll_item_category_enum_1.PayrollItemCategory.ALLOWANCE,
        ];
        const newPayrollItems = [];
        const calculationLog = [];
        // First, track original values for reference
        const originalValues = {
            grossPay: payroll.grossPay,
            taxableIncome: payroll.taxableIncome
        };
        // Process each category in order
        for (const category of processingOrder) {
            // Get item types for this category
            const categoryItemTypes = allPayrollItemTypes.filter(type => type.category === category);
            for (const itemType of categoryItemTypes) {
                // Check if this employee has a specific configuration for this item type
                const employeeItemConfig = employeePayrollItemMap.get(itemType.id);
                // log
                this.logger.log(`Processing payroll item type: ${itemType.name} for employee ${payroll.employee.id} in category ${category}`);
                // Skip if not applicable for this employee
                // Only process required items or items that have employee-specific configuration
                if (!employeeItemConfig || !employeeItemConfig.isApplicable || (itemType.processEvery && cutoff.cutoffPlace !== itemType.processEvery)) {
                    // log
                    this.logger.log(`Skipping payroll item type: ${itemType.name} for employee ${payroll.employee.id} as it is not applicable or not configured.`);
                    continue;
                }
                // Create new payroll item
                const payrollItem = new payroll_item_entity_1.PayrollItem({});
                payrollItem.payrollItemType = itemType;
                payrollItem.employeePayrollItemType = employeeItemConfig;
                // Calculate item amount
                let calculatedAmount = employeeItemConfig.amount || itemType.defaultAmount || 0;
                let employerAmount;
                let calculationDetail;
                // the base amount for calculation gross or monthly rate
                const baseAmount = this.BaseAmount === 'grossPay' ? combinedGrossPay : payroll.monthlyRate;
                // Otherwise, calculate based on item type
                if (itemType.governmentMandatedType) {
                    // log type
                    this.logger.log(`Processing government mandated type: ${itemType.governmentMandatedType} for ${payroll.employee.id} for cutoff ${cutoff.cutoffNumber}`);
                    // Calculate government contributions based on 2025 rates from the item type properties
                    switch (itemType.governmentMandatedType) {
                        case government_contribution_type_enum_1.GovernmentMandatedType.SSS:
                            const sssResult = this.calculateSSSContribution(itemType, baseAmount);
                            calculatedAmount = sssResult.calculatedAmount;
                            employerAmount = sssResult.employerAmount;
                            calculationDetail = sssResult.calculationDetail;
                            break;
                        case government_contribution_type_enum_1.GovernmentMandatedType.PHILHEALTH:
                            const philHealthResult = this.calculatePhilHealthContribution(baseAmount, itemType);
                            calculatedAmount = philHealthResult.calculatedAmount;
                            employerAmount = philHealthResult.employerAmount;
                            calculationDetail = philHealthResult.calculationDetail;
                            break;
                        case government_contribution_type_enum_1.GovernmentMandatedType.PAGIBIG:
                            const pagibigResult = this.calculatePagibigContribution(baseAmount, itemType);
                            calculatedAmount = pagibigResult.calculatedAmount;
                            employerAmount = pagibigResult.employerAmount;
                            calculationDetail = pagibigResult.calculationDetail;
                            break;
                        case government_contribution_type_enum_1.GovernmentMandatedType.THIRTEENTH_MONTH_PAY:
                            // 13th month pay calculation
                            // Check if it is december and first cutoff
                            const isDecember = utility_helper_1.UtilityHelper.ensureDate(cutoff.startDate).getMonth() === 12;
                            const isFirstCutoff = cutoff.cutoffPlace === 1;
                            if (!isDecember || !isFirstCutoff) {
                                // log that 13th month pay is not applicable
                                this.logger.log(`13th month pay is not applicable for ${payroll.employee.id} for cutoff ${cutoff.cutoffNumber} as it is not the first cutoff of December.`);
                                continue;
                            }
                            // Get all payroll net pay of the employee for the year
                            const yearStartDate = new Date(cutoff.startDate.getFullYear(), 0, 1);
                            const yearEndDate = new Date(cutoff.startDate.getFullYear(), 11, 31);
                            const yearPayrolls = await this.payrollsRepository.find({
                                where: {
                                    employee: { id: payroll.employee.id },
                                    cutoff: {
                                        startDate: (0, typeorm_2.MoreThan)(yearStartDate),
                                        endDate: (0, typeorm_2.LessThan)(yearEndDate)
                                    },
                                    state: payroll_state_enum_1.PayrollState.PAID
                                },
                                relations: {
                                    employee: true,
                                    cutoff: true
                                }
                            });
                            // Calculate total net pay for the year
                            const totalNetPay = yearPayrolls.reduce((total, p) => total + p.netPay, 0);
                            // Calculate 13th month pay
                            calculatedAmount = parseFloat((totalNetPay / 12).toFixed(2));
                            calculationDetail = {
                                calculationType: 'THIRTEENTH_MONTH',
                                totalNetPay: totalNetPay,
                                thirteenthMonthPay: calculatedAmount
                            };
                            break;
                        case government_contribution_type_enum_1.GovernmentMandatedType.TAX:
                            // Withholding tax calculation based on 2025 Tax Brackets
                            const { calculatedAmount: taxAmount, calculationDetail: taxDetail } = this.calculateWithholdingTax(combinedTaxableIncome);
                            calculatedAmount = taxAmount;
                            calculationDetail = taxDetail;
                            break;
                    }
                }
                else if (itemType.type === 'fixed') {
                    // For fixed type items
                    calculatedAmount = employeeItemConfig.amount || itemType.defaultAmount || 0;
                    calculationDetail = {
                        calculationType: 'DEFAULT',
                        amount: calculatedAmount
                    };
                }
                else if (itemType.type === 'formula') {
                    // // For formula types without actual formula in entity, 
                    // // use percentage-based calculation on monthly rate
                    // if (itemType.percentage) {
                    //   calculatedAmount = parseFloat(((payroll.monthlyRate * itemType.percentage) / 100).toFixed(2));
                    //   calculationDetail = {
                    //     source: 'percentage_calculation',
                    //     baseAmount: payroll.monthlyRate,
                    //     percentage: `${itemType.percentage}%`,
                    //     result: calculatedAmount
                    //   };
                    //   // Calculate employer share if applicable
                    //   if (itemType.employerPercentage) {
                    //     employerAmount = parseFloat(((payroll.monthlyRate * itemType.employerPercentage) / 100).toFixed(2));
                    //     calculationDetail.employerCalculation = {
                    //       percentage: `${itemType.employerPercentage}%`,
                    //       baseAmount: payroll.monthlyRate,
                    //       result: employerAmount
                    //     };
                    //   }
                    // } else {
                    //   // Fallback to default amount if no percentage
                    //   calculatedAmount = itemType.defaultAmount || 0;
                    //   calculationDetail = {
                    //     source: 'default_amount',
                    //     amount: calculatedAmount
                    //   };
                    // }
                }
                // log calculated ammount
                this.logger.log(`Calculated amount for ${itemType.name}: ${calculatedAmount}`);
                if (itemType.category === payroll_item_category_enum_1.PayrollItemCategory.DEDUCTION) {
                    // Deduct from net pay
                    payroll.netPay -= Number(calculatedAmount);
                    payroll.totalDeductions = (Number(payroll.totalDeductions) || 0) + Number(calculatedAmount);
                }
                else if (itemType.category === payroll_item_category_enum_1.PayrollItemCategory.ALLOWANCE) {
                    // Add to net pay
                    payroll.netPay += Number(calculatedAmount);
                    payroll.totalAllowances = (Number(payroll.totalAllowances) || 0) + Number(calculatedAmount);
                }
                else if (itemType.category === payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION) {
                    // Add to gross pay
                    payroll.grossPay += Number(calculatedAmount);
                }
                if (itemType.isTaxable) {
                    // Add to taxable income
                    const taxExempt = Number(itemType.taxExemptionAmount) || 0;
                    payrollItem.taxableAmount = taxExempt <= calculatedAmount ?
                        Number(calculatedAmount) - taxExempt : 0;
                    payroll.taxableIncome += Number(payrollItem.taxableAmount);
                }
                if (itemType.isTaxDeductible) {
                    // Deduct from gross pay
                    payroll.taxableIncome -= Number(calculatedAmount);
                }
                // Set calculated amounts
                payrollItem.amount = calculatedAmount;
                payrollItem.employerAmount = employerAmount;
                payrollItem.calculationDetails = calculationDetail;
                // Save to log
                calculationLog.push({
                    id: itemType.id,
                    name: itemType.name,
                    category: itemType.category,
                    amount: calculatedAmount,
                    employerAmount,
                    details: calculationDetail
                });
                // Add to return array
                newPayrollItems.push(payrollItem);
            }
        }
        // Save calculated totals and details
        payroll.calculationDetails = {
            items: calculationLog,
            original: originalValues,
            final: {
                grossPay: payroll.grossPay,
                taxableIncome: payroll.taxableIncome,
                totalAllowances: payroll.totalAllowances,
                totalDeductions: payroll.totalDeductions,
                netPay: payroll.netPay
            }
        };
        return newPayrollItems;
    }
    /**
     * Process payroll for a single employee
     */
    async processPayrollForEmployee(employeeId, cutoffId, userId, batchId) {
        return this.transactionService.executeInTransaction(async (queryRunner) => {
            // Use queryRunner.manager instead of transactionManager
            const transactionManager = queryRunner.manager;
            // Check if payroll already exists for this employee and cutoff
            const existingPayroll = await transactionManager.findOne(payroll_entity_1.Payroll, {
                where: {
                    employee: { id: employeeId },
                    cutoff: { id: cutoffId },
                    state: (0, typeorm_2.Not)(payroll_state_enum_1.PayrollState.VOID)
                },
                relations: {
                    payrollItems: {
                        payrollItemType: true
                    }
                }
            });
            // If payroll already exist prevent re-processing
            if (existingPayroll) {
                throw new common_1.ConflictException(`Payroll already exists for employee ${employeeId} for cutoff ${cutoffId}`);
            }
            // Get employee and cutoff data
            const employee = await this.employeesService.findOneByOrFail({ id: employeeId });
            const cutoff = await this.cutoffsService.findOneByOrFail({ id: cutoffId });
            // Get final work hours for this employee and cutoff
            const finalWorkHours = await this.finalWorkHoursService.getRepository().findBy({
                employee: { id: employeeId },
                cutoff: { id: cutoffId },
                isApproved: true,
            });
            if (!finalWorkHours.length) {
                throw new common_1.BadRequestException(`No approved work hours found for employee ${employeeId} in cutoff ${cutoffId}`);
            }
            // Get base compensation
            const baseCompensation = await this.employeePayrollItemTypesService.getEmployeeBaseCompensation(employeeId);
            if (!baseCompensation) {
                throw new common_1.BadRequestException(`No base compensation defined for employee ${employeeId}. Please define employee's base compensation first.`);
            }
            // // Check if there is pending overtime work time requests for this employee
            // const pendingWorkTimeRequests = await this.workTimeRequestsService.getRepository().find({
            //   where: {
            //     employee: { id: employeeId },
            //     status: RequestStatus.PENDING,
            //     type: AttendanceStatus.OVERTIME,
            //     cutoff: { id: cutoffId }
            //   }
            // });
            // if (pendingWorkTimeRequests.length > 0) {
            //   // could prevent process or just change payroll status to error
            //   throw new BadRequestException(`There are pending overtime work time requests for employee ${employeeId}. Please approve or reject them first.`);
            // }
            // if (cutoff.status !== CutoffStatus.PROCESSING) {
            //   throw new BadRequestException('Cutoff is not in processing status');
            // }
            let payroll;
            // Create a new payroll if none exists
            payroll = new payroll_entity_1.Payroll({});
            payroll.employee = employee;
            payroll.cutoff = cutoff;
            payroll.batchId = batchId;
            payroll.state = payroll_state_enum_1.PayrollState.DRAFT;
            payroll.stateHistory = [];
            // Start calculation process
            const startSuccess = this.stateMachine.startCalculation(payroll);
            if (!startSuccess) {
                throw new common_1.BadRequestException(`Cannot start calculation for payroll in state ${payroll.state}`);
            }
            // Calculate basic pay from work hours
            await this.calculateBasicPay(payroll, finalWorkHours);
            // Save payroll to get an ID if new
            const savedPayroll = await transactionManager.save(payroll_entity_1.Payroll, payroll);
            // In processPayrollForEmployee
            const payrollItems = await this.processPayrollItems(savedPayroll, userId);
            // Set the relationship properly
            payrollItems.forEach(item => {
                item.payroll = savedPayroll;
            });
            // Save items first
            await transactionManager.save(payrollItems);
            // Then set on payroll
            savedPayroll.payrollItems = payrollItems;
            // Finalize payroll
            savedPayroll.processedAt = new Date();
            savedPayroll.processedBy = userId;
            // complete calculation
            const completeSuccess = this.stateMachine.completeCalculation(savedPayroll);
            if (!completeSuccess) {
                throw new common_1.BadRequestException(`Cannot complete calculation for payroll in state ${savedPayroll.state}`);
            }
            // Save the final payroll
            return await transactionManager.save(savedPayroll);
        });
    }
    /**
     * Process payroll for all eligible employees in a cutoff
     */
    async processPayrollForCutoff(cutoffId, userId) {
        const cutoff = await this.cutoffsService.findOneByOrFail({ id: cutoffId });
        if (cutoff.status !== cutoff_status_enum_1.CutoffStatus.PENDING) {
            throw new common_1.BadRequestException('Cutoff is not in pending status');
        }
        // Get all employees with approved work hours for this cutoff
        const workHours = await this.finalWorkHoursService.getRepository().findBy({
            cutoff: { id: cutoffId },
            isApproved: true,
            // isProcessed: false
        });
        if (!workHours.length) {
            throw new common_1.BadRequestException('No approved work hours found for this cutoff period');
        }
        // Get unique employee IDs
        const employeeIds = [...new Set(workHours.map(wh => wh.employee.id))];
        // Process payroll for each employee
        const payrolls = [];
        const errors = [];
        for (const employeeId of employeeIds) {
            try {
                const payroll = await this.processPayrollForEmployee(employeeId, cutoffId, userId);
                payrolls.push(payroll);
            }
            catch (error) {
                if (error instanceof Error) {
                    this.logger.error(`Error processing payroll for employee ${employeeId}: ${error.message}`, error.stack);
                    errors.push({ employeeId, error: error.message });
                }
                else {
                    this.logger.error(`Error processing payroll for employee ${employeeId}: ${String(error)}`);
                    errors.push({ employeeId, error: String(error) });
                }
            }
        }
        this.logger.log(`Processed ${payrolls.length} payrolls successfully. ${errors.length} errors.`);
        return payrolls;
    }
    /**
     * Generate payslip data for a specific payroll
     */
    async generatePayslipData(payrollId) {
        var _a, _b, _c, _d, _e, _f, _g;
        const payroll = await this.findOneByOrFail({ id: payrollId }, {
            relations: {
                employee: {
                    roles: {
                        organization: true,
                        department: true,
                        branch: true
                    },
                    user: {
                        profile: true
                    },
                },
                cutoff: true,
                payrollItems: {
                    payrollItemType: true
                }
            }
        });
        // check if state is not approve not archive
        if (![payroll_state_enum_1.PayrollState.APPROVED, payroll_state_enum_1.PayrollState.PAID, payroll_state_enum_1.PayrollState.ARCHIVED].includes(payroll.state)) {
            throw new common_1.BadRequestException('Payroll must be approved, released, paid or archived to generate payslips');
        }
        // log employee roles
        this.logger.log(`Generating payslip for employee ${payroll.employee.id} with roles: ${(_a = payroll.employee.roles) === null || _a === void 0 ? void 0 : _a.map(role => role.name).join(', ')}`);
        // Get the employee's highest scope role
        const highestRole = utility_helper_1.UtilityHelper.determineEffectiveScope(payroll.employee.roles || []);
        // log highest role
        this.logger.log(`Highest role for employee ${payroll.employee.id}: ${highestRole.name}`);
        // Group payroll items by category for organized display
        const itemsByCategory = {};
        for (const item of payroll.payrollItems || []) {
            const category = item.payrollItemType.category;
            if (!itemsByCategory[category]) {
                itemsByCategory[category] = [];
            }
            itemsByCategory[category].push({
                name: item.payrollItemType.name,
                amount: item.amount,
            });
        }
        // Format dates
        const startDate = utility_helper_1.UtilityHelper.ensureDate(payroll.cutoff.startDate).toLocaleDateString();
        const endDate = utility_helper_1.UtilityHelper.ensureDate(payroll.cutoff.endDate).toLocaleDateString();
        const name = ((_b = payroll.employee.user.profile) === null || _b === void 0 ? void 0 : _b.fullName) || payroll.employee.user.userName || payroll.employee.user.email;
        // Build payslip data
        return {
            employee: {
                name,
                employeeNumber: payroll.employee.employeeNumber,
                position: highestRole.name,
                department: ((_c = highestRole === null || highestRole === void 0 ? void 0 : highestRole.department) === null || _c === void 0 ? void 0 : _c.name) || 'N/A',
                branch: ((_d = highestRole === null || highestRole === void 0 ? void 0 : highestRole.branch) === null || _d === void 0 ? void 0 : _d.name) || 'N/A',
                organization: ((_e = highestRole === null || highestRole === void 0 ? void 0 : highestRole.organization) === null || _e === void 0 ? void 0 : _e.name) || 'N/A',
            },
            cutoffPeriod: `${startDate} - ${endDate}`,
            rates: {
                monthly: payroll.monthlyRate,
                daily: payroll.dailyRate,
                hourly: payroll.hourlyRate
            },
            workHours: {
                regular: payroll.totalRegularHours,
                overtime: payroll.totalOvertimeHours,
                holiday: payroll.totalHolidayHours,
                holidayOvertime: payroll.totalHolidayOvertimeHours,
                specialHoliday: payroll.totalSpecialHolidayHours,
                specialHolidayOvertime: payroll.totalSpecialHolidayOvertimeHours,
                restDay: payroll.totalRestDayHours,
                restDayOvertime: payroll.totalRestDayOvertimeHours,
                nightDifferential: payroll.totalNightDifferentialHours,
                nightDifferentialOvertime: payroll.totalNightDifferentialOvertimeHours,
            },
            compensation: {
                basicPay: payroll.basicPay,
                overtimePay: payroll.overtimePay,
                holidayPay: payroll.holidayPay,
                holidayOvertimePay: payroll.holidayOvertimePay,
                specialHolidayPay: payroll.specialHolidayPay,
                specialHolidayOvertimePay: payroll.specialHolidayOvertimePay,
                restDayPay: payroll.restDayPay,
                restDayOvertimePay: payroll.restDayOvertimePay,
                nightDifferentialPay: payroll.nightDifferentialPay,
                nightDifferentialOvertimePay: payroll.nightDifferentialOvertimePay,
                adjustments: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.ADJUSTMENT] || [],
                others: ((_f = itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION]) === null || _f === void 0 ? void 0 : _f.filter((item) => !item.includeInPayrollItemsProcessing)) || []
            },
            benefits: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.BENEFIT] || [],
            deductions: {
                basic: {
                    absences: payroll.absences,
                    tardiness: payroll.tardiness,
                    undertime: payroll.undertime,
                    noTimeIn: payroll.noTimeIn,
                    noTimeOut: payroll.noTimeOut,
                    total: payroll.totalBasicDeductions
                },
                governmentMandated: {
                    sss: payroll.sssContribution.employee,
                    philHealth: payroll.philHealthContribution.employee,
                    pagIbig: payroll.pagIbigContribution.employee,
                    withholdingTax: payroll.withholdingTax
                },
                others: ((_g = itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.DEDUCTION]) === null || _g === void 0 ? void 0 : _g.filter((item) => item.governmentMandatedType)) || []
            },
            allowances: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.ALLOWANCE] || [],
            totals: {
                grossPay: payroll.grossPay,
                totalDeductions: payroll.totalDeductions,
                totalAllowances: payroll.totalAllowances,
                taxableIncome: payroll.taxableIncome,
                netPay: payroll.netPay
            },
            year: new Date().getFullYear(),
            payrollDate: utility_helper_1.UtilityHelper.ensureDate(payroll.processedAt || new Date).toLocaleDateString()
        };
    }
    /**
     * Process payrolls in batches with optimized performance
     */
    async processPayrollBatch(cutoffId, userId, batchId, batchSize = 50) {
        this.logger.log(`Processing payroll batch ${batchId} for cutoff ${cutoffId}`);
        const cutoff = await this.cutoffsService.findOneByOrFail({ id: cutoffId });
        // Get employees in optimized batches with reduced relations
        const workHours = await this.finalWorkHoursService.getRepository().find({
            where: {
                cutoff: { id: cutoffId },
                isApproved: true,
                // isProcessed: false, // can be used to filter unprocessed work hours
                payrollBatchId: batchId // Process only employees in this specific batch
            },
            relations: { employee: true },
            take: batchSize
        });
        if (!workHours.length) {
            throw new common_1.BadRequestException(`No approved work hours found for batch ${batchId} in cutoff ${cutoffId}`);
        }
        // Group by employee to prevent duplicate processing
        const employeeMap = new Map();
        workHours.forEach(wh => employeeMap.set(wh.employee.id, wh.employee));
        const employees = Array.from(employeeMap.values());
        // Process with connection pooling and transaction management
        const payrolls = [];
        const failedEmployees = [];
        let processedCount = 0;
        for (const employee of employees) {
            try {
                const payroll = await this.processPayrollForEmployee(employee.id, cutoffId, userId);
                payrolls.push(payroll);
                processedCount++;
                // // Mark work hours as processed
                // await this.finalWorkHoursService.getRepository().update(
                //   { employee: { id: employee.id }, cutoff: { id: cutoffId } },
                //   { isProcessed: true, processedAt: new Date(), processedBy: userId }
                // );
            }
            catch (error) {
                this.logger.error(`Failed to process payroll for employee ${employee.id}`, error.message);
                failedEmployees.push({
                    id: employee.id,
                    reason: error.message || 'Unknown error'
                });
            }
        }
        // Record failure metrics for monitoring
        if (failedEmployees.length > employees.length * 0.5) {
            // this.eventEmitter.emit('payroll.batch.partialFailure', {
            //   batchId,
            //   cutoffId,
            //   failedCount: failedEmployees.length,
            //   totalCount: employees.length,
            //   failedEmployees
            // });
            throw new Error(`Batch ${batchId} had too many failures: ${failedEmployees.length}/${employees.length}`);
            // if (failedCount > attendanceIds.length * 0.5) { // If more than 50% failed
            // }
        }
        if (processedCount === employees.length) {
            this.logger.log(`Batch ${batchId} processing completed. Success: ${payrolls.length}, Failed: ${failedEmployees.length}`);
        }
        else {
            this.logger.warn(`Processed ${processedCount} out of ${employees.length} payrolls in batch ${batchId}`);
        }
        return payrolls;
    }
    /**
     * Divide employees into processing batches for parallel execution
     */
    async createProcessingBatches(cutoffId, batchSize = 200) {
        // Get all employees with work hours for this cutoff
        const result = await this.finalWorkHoursService.getRepository()
            .createQueryBuilder('workHour')
            .select('workHour.employeeId', 'employeeId')
            .addSelect('COUNT(*)', 'recordCount')
            .where('workHour.cutoffId = :cutoffId', { cutoffId })
            .andWhere('workHour.isApproved = :isApproved', { isApproved: true })
            // .andWhere('workHour.isProcessed = :isProcessed', { isProcessed: false })
            .groupBy('workHour.employeeId')
            .getRawMany();
        const totalEmployees = result.length;
        const batchCount = Math.ceil(totalEmployees / batchSize);
        const batches = [];
        // Create batch assignments
        for (let i = 0; i < batchCount; i++) {
            const start = i * batchSize;
            const end = Math.min((i + 1) * batchSize, totalEmployees);
            const batchEmployees = result.slice(start, end);
            const batchId = `${cutoffId}-batch-${i + 1}`;
            // Assign batch ID to these work hours
            await this.finalWorkHoursService.getRepository().createQueryBuilder()
                .update()
                .set({ payrollBatchId: batchId })
                .where('employeeId IN (:...employeeIds)', {
                employeeIds: batchEmployees.map(e => e.employeeId)
            })
                .andWhere('cutoffId = :cutoffId', { cutoffId })
                .andWhere('isApproved = :isApproved', { isApproved: true })
                // .andWhere('isProcessed = :isProcessed', { isProcessed: false })
                .execute();
            batches.push({
                batchId,
                employeeCount: batchEmployees.length
            });
        }
        return batches;
    }
    /**
   * Get batch processing status for a specific cutoff
   */
    async getBatchProcessingStatus(cutoffId) {
        this.logger.log(`Getting batch processing status for cutoff ${cutoffId}`);
        // Get all payrolls for this cutoff
        const payrolls = await this.repository.find({
            where: { cutoff: { id: cutoffId } },
            relations: ['employee']
        });
        // Get all work hours with batch IDs for this cutoff
        const workHours = await this.finalWorkHoursService.getRepository().find({
            where: {
                cutoff: { id: cutoffId },
                isApproved: true,
                batchId: (0, typeorm_2.Not)((0, typeorm_2.IsNull)())
            },
            relations: { employee: true }
        });
        // Extract unique batch IDs
        const batchIds = [...new Set(workHours
                .filter(wh => wh.batchId)
                .map(wh => wh.batchId))];
        // Count processing states
        const processed = payrolls.filter(p => [
            payroll_state_enum_1.PayrollState.PENDING_APPROVAL,
            payroll_state_enum_1.PayrollState.APPROVED,
            payroll_state_enum_1.PayrollState.PAID,
            payroll_state_enum_1.PayrollState.ARCHIVED
        ].includes(p.state)).length;
        const failed = payrolls.filter(p => p.state === payroll_state_enum_1.PayrollState.FAILED).length;
        // Calculate employees with work hours but no payroll yet
        const employeesWithWorkHours = [...new Set(workHours.map(wh => wh.employee.id))];
        const employeesWithPayrolls = [...new Set(payrolls.map(p => p.employee.id))];
        const pending = employeesWithWorkHours.length - employeesWithPayrolls.length +
            payrolls.filter(p => p.state === payroll_state_enum_1.PayrollState.DRAFT ||
                p.state === payroll_state_enum_1.PayrollState.CALCULATING).length;
        const total = Math.max(employeesWithWorkHours.length, employeesWithPayrolls.length);
        // Calculate batch statuses
        const batchStatuses = batchIds.map(batchId => {
            const batchWorkHours = workHours.filter(wh => wh.batchId === batchId);
            const employeeIdsInBatch = [...new Set(batchWorkHours.map(wh => wh.employee.id))];
            const batchPayrolls = payrolls.filter(p => employeeIdsInBatch.includes(p.employee.id));
            const processedCount = batchPayrolls.filter(p => [
                payroll_state_enum_1.PayrollState.PENDING_APPROVAL,
                payroll_state_enum_1.PayrollState.APPROVED,
                payroll_state_enum_1.PayrollState.PAID,
                payroll_state_enum_1.PayrollState.ARCHIVED
            ].includes(p.state)).length;
            const failedCount = batchPayrolls.filter(p => p.state === payroll_state_enum_1.PayrollState.FAILED).length;
            const pendingCount = employeeIdsInBatch.length - processedCount - failedCount;
            let status = 'Not Started';
            if (processedCount > 0 && processedCount < employeeIdsInBatch.length) {
                status = 'In Progress';
            }
            else if (processedCount === employeeIdsInBatch.length) {
                status = 'Completed';
            }
            else if (failedCount > 0) {
                status = 'Has Failures';
            }
            return {
                batchId,
                status,
                processedCount,
                pendingCount,
                failedCount
            };
        });
        // Calculate overall status
        let status = 'Not Started';
        if (processed > 0 && processed < total) {
            status = 'In Progress';
        }
        else if (processed === total && total > 0) {
            status = 'Completed';
        }
        else if (failed > 0) {
            status = 'Has Failures';
        }
        const percentComplete = total > 0 ? Math.round((processed / total) * 100) : 0;
        return {
            status,
            processed,
            pending,
            failed,
            total,
            percentComplete,
            batchStatuses
        };
    }
    /**
     * Get detailed audit trail for a payroll
     */
    async getPayrollAudit(payrollId) {
        this.logger.log(`Getting audit trail for payroll ${payrollId}`);
        const payroll = await this.findOneByOrFail({ id: payrollId }, {
            relations: {
                employee: true,
                cutoff: true,
                payrollItems: {
                    payrollItemType: true
                }
            }
        });
        // Get the previous payroll for comparison if available
        const previousPayrolls = await this.repository.find({
            where: {
                employee: { id: payroll.employee.id },
                cutoff: { endDate: (0, typeorm_2.LessThan)(payroll.cutoff.startDate) }
            },
            order: { cutoff: { endDate: 'DESC' } },
            take: 1
        });
        const previousPayroll = previousPayrolls.length > 0 ? previousPayrolls[0] : null;
        // Calculate changes if previous payroll exists
        const changes = [];
        if (previousPayroll) {
            const compareFields = [
                { field: 'grossPay', label: 'Gross Pay' },
                { field: 'netPay', label: 'Net Pay' },
                { field: 'basicPay', label: 'Basic Pay' },
                { field: 'totalDeductions', label: 'Total Deductions' },
                { field: 'totalAllowances', label: 'Total Allowances' }
            ];
            for (const { field, label } of compareFields) {
                const currentValue = Number(payroll[field]);
                const previousValue = Number(previousPayroll[field]);
                if (previousValue !== 0) {
                    const percentChange = ((currentValue - previousValue) / previousValue) * 100;
                    if (Math.abs(percentChange) > 5) { // Only record significant changes
                        changes.push({
                            field: label,
                            previousValue,
                            currentValue,
                            difference: currentValue - previousValue,
                            percentChange: Math.round(percentChange * 100) / 100
                        });
                    }
                }
            }
        }
        return {
            payrollId,
            stateHistory: payroll.stateHistory || [],
            calculations: payroll.calculationDetails || {},
            changes
        };
    }
    /**
     * Recalculate a payroll with options to preserve state and selectively update components
     */
    async recalculatePayroll(id, options, userId) {
        var _a, _b;
        this.logger.log(`Recalculating payroll ${id} with options:`, options);
        const payroll = await this.findOneByOrFail({ id }, {
            relations: {
                employee: true,
                cutoff: true,
                payrollItems: {
                    payrollItemType: true
                }
            }
        });
        // Save original state if we need to preserve it
        const originalState = payroll.state;
        // Use the state machine to reset if not preserving state
        if (!options.preserveState) {
            if (!this.stateMachine.resetToDraft(payroll, 'Recalculation requested')) {
                throw new common_1.BadRequestException(`Cannot recalculate payroll in state ${payroll.state}`);
            }
        }
        // Get work hours for recalculation
        const workHours = await this.finalWorkHoursService.getRepository().findBy({
            employee: { id: payroll.employee.id },
            cutoff: { id: payroll.cutoff.id },
            isApproved: true
        });
        if (!workHours.length) {
            throw new common_1.BadRequestException('No approved work hours found for recalculation');
        }
        // Recalculate basic pay components (hours, rates, basic pay)
        await this.calculateBasicPay(payroll, workHours);
        // Filter payroll items based on recalculation options
        if ((_a = payroll.payrollItems) === null || _a === void 0 ? void 0 : _a.length) {
            payroll.payrollItems = payroll.payrollItems.filter(item => {
                const category = item.payrollItemType.category;
                if (options.recalculateDeductions &&
                    category === payroll_item_category_enum_1.PayrollItemCategory.DEDUCTION) {
                    return false; // Remove to recalculate
                }
                if (options.recalculateAllowances &&
                    category === payroll_item_category_enum_1.PayrollItemCategory.ALLOWANCE) {
                    return false; // Remove to recalculate
                }
                return true; // Keep other items
            });
        }
        // Recalculate the payroll items
        const payrollItems = await this.processPayrollItems(payroll, userId);
        // Restore original state if preserving
        if (options.preserveState) {
            payroll.state = originalState;
        }
        else {
            // Mark as recalculated
            (_b = payroll.stateHistory) === null || _b === void 0 ? void 0 : _b.push({
                from: payroll_state_enum_1.PayrollState.DRAFT,
                to: payroll_state_enum_1.PayrollState.PENDING_APPROVAL,
                timestamp: new Date(),
                note: `Recalculated by ${userId}`
            });
            payroll.state = payroll_state_enum_1.PayrollState.PENDING_APPROVAL;
        }
        // Update processed information
        payroll.processedAt = new Date();
        payroll.processedBy = userId;
        payroll.payrollItems = payrollItems;
        payroll.organizationId = payroll.employee.organizationId;
        payroll.branchId = payroll.employee.branchId;
        payroll.departmentId = payroll.employee.departmentId;
        payroll.userId = payroll.employee.userId;
        // Save the updated payroll
        return await this.repository.save(payroll);
    }
    /**
     * Smart re-processing of failed payrolls with metadata tracking
     */
    async retryFailedPayrolls(cutoffId, userId, options) {
        var _a;
        const maxRetries = (options === null || options === void 0 ? void 0 : options.maxRetries) || 3;
        // Find payrolls that failed
        const failedPayrolls = await this.payrollsRepository.find({
            where: Object.assign({ cutoff: { id: cutoffId }, state: payroll_state_enum_1.PayrollState.FAILED }, ((options === null || options === void 0 ? void 0 : options.onlySpecificIds) ? { id: (0, typeorm_2.In)(options.onlySpecificIds) } : {})),
            relations: ['employee', 'cutoff'],
        });
        this.logger.log(`Found ${failedPayrolls.length} failed payrolls to retry`);
        const result = { successful: 0, failed: 0, skipped: 0, payrolls: [] };
        for (const payroll of failedPayrolls) {
            // Skip if exceeded max retries
            if ((((_a = payroll.stateHistory) === null || _a === void 0 ? void 0 : _a.filter(h => h.to === payroll_state_enum_1.PayrollState.FAILED).length) || 0) >= maxRetries) {
                this.logger.warn(`Skipping payroll ${payroll.id} - exceeded max retries (${maxRetries})`);
                result.skipped++;
                continue;
            }
            try {
                // Reset and reprocess
                await this.stateMachine.resetToDraft(payroll, `Retry attempt ${new Date().toISOString()}`);
                await this.repository.save(payroll);
                const reprocessed = await this.processPayrollForEmployee(payroll.employee.id, payroll.cutoff.id, userId);
                result.successful++;
                result.payrolls.push(reprocessed);
            }
            catch (error) {
                this.logger.error(`Failed to reprocess payroll ${payroll.id}`, error.stack);
                result.failed++;
            }
        }
        return result;
    }
};
exports.PayrollsService = PayrollsService;
exports.PayrollsService = PayrollsService = PayrollsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(payroll_entity_1.Payroll)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _b : Object, typeof (_c = typeof cutoffs_service_1.CutoffsService !== "undefined" && cutoffs_service_1.CutoffsService) === "function" ? _c : Object, typeof (_d = typeof final_work_hours_service_1.FinalWorkHoursService !== "undefined" && final_work_hours_service_1.FinalWorkHoursService) === "function" ? _d : Object, typeof (_e = typeof employee_payroll_item_types_service_1.EmployeePayrollItemTypesService !== "undefined" && employee_payroll_item_types_service_1.EmployeePayrollItemTypesService) === "function" ? _e : Object, typeof (_f = typeof payroll_item_types_service_1.PayrollItemTypesService !== "undefined" && payroll_item_types_service_1.PayrollItemTypesService) === "function" ? _f : Object, typeof (_g = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _g : Object, typeof (_h = typeof work_time_requests_service_1.WorkTimeRequestsService !== "undefined" && work_time_requests_service_1.WorkTimeRequestsService) === "function" ? _h : Object, typeof (_j = typeof payroll_state_machine_service_1.PayrollStateMachine !== "undefined" && payroll_state_machine_service_1.PayrollStateMachine) === "function" ? _j : Object, typeof (_k = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _k : Object, typeof (_l = typeof transaction_service_1.TransactionService !== "undefined" && transaction_service_1.TransactionService) === "function" ? _l : Object])
], PayrollsService);


/***/ }),

/***/ "./src/modules/payroll-management/services/payroll-metrics.service.ts":
/*!****************************************************************************!*\
  !*** ./src/modules/payroll-management/services/payroll-metrics.service.ts ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PayrollMetricsService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollMetricsService = void 0;
const payroll_state_enum_1 = __webpack_require__(/*! @/common/enums/payroll/payroll-state.enum */ "./src/common/enums/payroll/payroll-state.enum.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const schedule_1 = __webpack_require__(/*! @nestjs/schedule */ "@nestjs/schedule");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const prom_client_1 = __webpack_require__(/*! prom-client */ "prom-client");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const payroll_entity_1 = __webpack_require__(/*! ../entities/payroll.entity */ "./src/modules/payroll-management/entities/payroll.entity.ts");
let PayrollMetricsService = PayrollMetricsService_1 = class PayrollMetricsService {
    constructor(payrollRepository) {
        this.payrollRepository = payrollRepository;
        this.logger = new common_1.Logger(PayrollMetricsService_1.name);
        // Initialize metrics collectors with default values
        this.payrollProcessingTime = new prom_client_1.Histogram({
            name: 'payroll_processing_seconds',
            help: 'Time taken to process payrolls',
            labelNames: ['cutoff_type', 'status']
        });
        this.activePayrollJobs = new prom_client_1.Gauge({
            name: 'payroll_active_jobs',
            help: 'Number of currently active payroll jobs'
        });
        this.failedPayrollCounter = new prom_client_1.Counter({
            name: 'payroll_failures_total',
            help: 'Total number of payroll processing failures',
            labelNames: ['error_type']
        });
    }
    // Record processing time
    recordProcessingTime(cutoffType, status, seconds) {
        this.payrollProcessingTime.labels(cutoffType, status).observe(seconds);
    }
    // Increment active jobs
    incrementActiveJobs() {
        this.activePayrollJobs.inc();
    }
    // Decrement active jobs
    decrementActiveJobs() {
        this.activePayrollJobs.dec();
    }
    // Increment failure counter
    recordFailure(errorType) {
        this.failedPayrollCounter.labels(errorType).inc();
    }
    // Gather system metrics periodically
    async gatherPayrollMetrics() {
        try {
            const [processing, completed, failed] = await Promise.all([
                this.payrollRepository.count({ where: { state: payroll_state_enum_1.PayrollState.CALCULATING } }),
                this.payrollRepository.count({ where: { state: payroll_state_enum_1.PayrollState.PAID } }),
                this.payrollRepository.count({ where: { state: payroll_state_enum_1.PayrollState.FAILED } })
            ]);
            this.logger.log(`Metrics collected - Processing: ${processing}, Completed: ${completed}, Failed: ${failed}`);
        }
        catch (error) {
            this.logger.error('Failed to gather payroll metrics', error);
        }
    }
};
exports.PayrollMetricsService = PayrollMetricsService;
__decorate([
    (0, schedule_1.Cron)('0 */15 * * * *') // Every 15 minutes
    ,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], PayrollMetricsService.prototype, "gatherPayrollMetrics", null);
exports.PayrollMetricsService = PayrollMetricsService = PayrollMetricsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(payroll_entity_1.Payroll)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], PayrollMetricsService);


/***/ }),

/***/ "./src/modules/payroll-management/services/payroll-processor.service.ts":
/*!******************************************************************************!*\
  !*** ./src/modules/payroll-management/services/payroll-processor.service.ts ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var PayrollProcessorService_1;
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollProcessorService = void 0;
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const bull_2 = __webpack_require__(/*! bull */ "bull");
const payrolls_service_1 = __webpack_require__(/*! ../payrolls.service */ "./src/modules/payroll-management/payrolls.service.ts");
let PayrollProcessorService = PayrollProcessorService_1 = class PayrollProcessorService {
    constructor(payrollsService, eventEmitter) {
        this.payrollsService = payrollsService;
        this.eventEmitter = eventEmitter;
        this.logger = new common_1.Logger(PayrollProcessorService_1.name);
    }
    async processEmployeePayroll(job) {
        this.logger.log(`Processing payroll for employee ${job.data.employeeId} (${job.id})`);
        try {
            const payroll = await this.payrollsService.processPayrollForEmployee(job.data.employeeId, job.data.cutoffId, job.data.userId);
            return payroll;
        }
        catch (error) {
            this.logger.error(`Failed to process payroll for employee ${job.data.employeeId}`, error);
            throw error;
        }
    }
    async processBatchPayroll(job) {
        this.logger.log(`Processing batch payroll for cutoff ${job.data.cutoffId} (Batch: ${job.data.batchId})`);
        try {
            const payrolls = await this.payrollsService.processPayrollBatch(job.data.cutoffId, job.data.userId, job.data.batchId);
            return payrolls;
        }
        catch (error) {
            this.logger.error(`Failed to process batch payroll for cutoff ${job.data.cutoffId}`, error);
            throw error;
        }
    }
    onFailed(job, error) {
        this.logger.error(`Failed job ${job.id} of type ${job.name}: ${error.message}`, error.stack);
        this.eventEmitter.emit('payroll.processing.failed', {
            jobId: job.id,
            type: job.name,
            data: job.data,
            error: error.message,
        });
    }
    onCompleted(job, result) {
        this.logger.log(`Completed job ${job.id} of type ${job.name}`);
        this.eventEmitter.emit('payroll.processing.completed', {
            jobId: job.id,
            type: job.name,
            data: job.data,
            result,
        });
    }
};
exports.PayrollProcessorService = PayrollProcessorService;
__decorate([
    (0, bull_1.Process)('process-employee-payroll'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof bull_2.Job !== "undefined" && bull_2.Job) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], PayrollProcessorService.prototype, "processEmployeePayroll", null);
__decorate([
    (0, bull_1.Process)('process-batch-payroll'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof bull_2.Job !== "undefined" && bull_2.Job) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], PayrollProcessorService.prototype, "processBatchPayroll", null);
__decorate([
    (0, bull_1.OnQueueFailed)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_e = typeof bull_2.Job !== "undefined" && bull_2.Job) === "function" ? _e : Object, typeof (_f = typeof Error !== "undefined" && Error) === "function" ? _f : Object]),
    __metadata("design:returntype", void 0)
], PayrollProcessorService.prototype, "onFailed", null);
__decorate([
    (0, bull_1.OnQueueCompleted)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_g = typeof bull_2.Job !== "undefined" && bull_2.Job) === "function" ? _g : Object, Object]),
    __metadata("design:returntype", void 0)
], PayrollProcessorService.prototype, "onCompleted", null);
exports.PayrollProcessorService = PayrollProcessorService = PayrollProcessorService_1 = __decorate([
    (0, bull_1.Processor)('payroll-processing'),
    __metadata("design:paramtypes", [typeof (_a = typeof payrolls_service_1.PayrollsService !== "undefined" && payrolls_service_1.PayrollsService) === "function" ? _a : Object, typeof (_b = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _b : Object])
], PayrollProcessorService);


/***/ }),

/***/ "./src/modules/payroll-management/services/payroll-state-machine.service.ts":
/*!**********************************************************************************!*\
  !*** ./src/modules/payroll-management/services/payroll-state-machine.service.ts ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PayrollStateMachine_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollStateMachine = void 0;
const payroll_state_enum_1 = __webpack_require__(/*! @/common/enums/payroll/payroll-state.enum */ "./src/common/enums/payroll/payroll-state.enum.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
/**
 * Manages the state transitions for payroll processing to ensure
 * consistency and prevent invalid state transitions
 */
let PayrollStateMachine = PayrollStateMachine_1 = class PayrollStateMachine {
    constructor() {
        this.logger = new common_1.Logger(PayrollStateMachine_1.name);
    }
    /**
     * Start the calculation process for a payroll
     */
    startCalculation(payroll) {
        // Only draft payrolls can be calculated
        if (payroll.state !== payroll_state_enum_1.PayrollState.DRAFT) {
            this.logger.warn(`Cannot start calculation for payroll ${payroll.id} in state ${payroll.state}`);
            return false;
        }
        // Initialize state history if not exists
        if (!payroll.stateHistory) {
            payroll.stateHistory = [];
        }
        // Record state transition
        payroll.stateHistory.push({
            from: payroll_state_enum_1.PayrollState.DRAFT,
            to: payroll_state_enum_1.PayrollState.CALCULATING,
            timestamp: new Date(),
        });
        payroll.state = payroll_state_enum_1.PayrollState.CALCULATING;
        return true;
    }
    /**
     * Complete calculation and move to pending approval
     */
    completeCalculation(payroll) {
        var _a;
        if (payroll.state !== payroll_state_enum_1.PayrollState.CALCULATING) {
            this.logger.warn(`Cannot complete calculation for payroll ${payroll.id} in state ${payroll.state}`);
            return false;
        }
        // Record state transition
        (_a = payroll.stateHistory) === null || _a === void 0 ? void 0 : _a.push({
            from: payroll_state_enum_1.PayrollState.CALCULATING,
            to: payroll_state_enum_1.PayrollState.PENDING_APPROVAL,
            timestamp: new Date(),
        });
        payroll.state = payroll_state_enum_1.PayrollState.PENDING_APPROVAL;
        return true;
    }
    /**
     * Approve the payroll
     */
    approve(payroll, approvedBy) {
        var _a;
        if (payroll.state !== payroll_state_enum_1.PayrollState.PENDING_APPROVAL) {
            this.logger.warn(`Cannot approve payroll ${payroll.id} in state ${payroll.state}`);
            return false;
        }
        // Record state transition
        (_a = payroll.stateHistory) === null || _a === void 0 ? void 0 : _a.push({
            from: payroll_state_enum_1.PayrollState.PENDING_APPROVAL,
            to: payroll_state_enum_1.PayrollState.APPROVED,
            timestamp: new Date(),
            note: `Approved by ${approvedBy}`,
        });
        payroll.state = payroll_state_enum_1.PayrollState.APPROVED;
        payroll.approvedAt = new Date();
        payroll.approvedBy = approvedBy;
        return true;
    }
    /**
     * Reject the payroll
     */
    reject(payroll, rejectedBy, reason) {
        var _a;
        if (payroll.state !== payroll_state_enum_1.PayrollState.PENDING_APPROVAL) {
            this.logger.warn(`Cannot reject payroll ${payroll.id} in state ${payroll.state}`);
            return false;
        }
        // Record state transition
        (_a = payroll.stateHistory) === null || _a === void 0 ? void 0 : _a.push({
            from: payroll_state_enum_1.PayrollState.PENDING_APPROVAL,
            to: payroll_state_enum_1.PayrollState.REJECTED,
            timestamp: new Date(),
            note: `Rejected by ${rejectedBy}: ${reason}`,
        });
        payroll.state = payroll_state_enum_1.PayrollState.REJECTED;
        payroll.rejectedAt = new Date();
        payroll.rejectedBy = rejectedBy;
        payroll.rejectionReason = reason;
        return true;
    }
    /**
     * Void the payroll
     */
    void(payroll, voidedBy) {
        var _a;
        // Check if the payroll is already voided
        if (payroll.state === payroll_state_enum_1.PayrollState.VOID) {
            this.logger.warn(`Cannot void payroll ${payroll.id} as it is already voided`);
            return false;
        }
        // Record state transition
        (_a = payroll.stateHistory) === null || _a === void 0 ? void 0 : _a.push({
            from: payroll.state, // Use current state instead of hardcoded PAID
            to: payroll_state_enum_1.PayrollState.VOID,
            timestamp: new Date(),
            note: `Voided by ${voidedBy}`,
        });
        payroll.state = payroll_state_enum_1.PayrollState.VOID;
        payroll.voidedAt = new Date();
        payroll.voidedBy = voidedBy;
        return true;
    }
    /**
     * Mark the payroll as paid
     */
    markPaid(payroll, releasedBy, paymentDetails) {
        var _a;
        if (payroll.state !== payroll_state_enum_1.PayrollState.APPROVED) {
            this.logger.warn(`Cannot mark payroll ${payroll.id} as paid in state ${payroll.state}`);
            return false;
        }
        // Record state transition with payment details
        (_a = payroll.stateHistory) === null || _a === void 0 ? void 0 : _a.push({
            from: payroll_state_enum_1.PayrollState.APPROVED,
            to: payroll_state_enum_1.PayrollState.PAID,
            timestamp: new Date(),
            note: `Released by ${releasedBy}`,
            details: paymentDetails || {},
        });
        payroll.state = payroll_state_enum_1.PayrollState.PAID;
        payroll.releasedAt = new Date();
        payroll.releasedBy = releasedBy;
        return true;
    }
    /**
     * Archive the payroll
     */
    archive(payroll) {
        var _a;
        if (payroll.state !== payroll_state_enum_1.PayrollState.PAID) {
            this.logger.warn(`Cannot archive payroll ${payroll.id} in state ${payroll.state}`);
            return false;
        }
        // Record state transition
        (_a = payroll.stateHistory) === null || _a === void 0 ? void 0 : _a.push({
            from: payroll_state_enum_1.PayrollState.PAID,
            to: payroll_state_enum_1.PayrollState.ARCHIVED,
            timestamp: new Date(),
        });
        payroll.state = payroll_state_enum_1.PayrollState.ARCHIVED;
        return true;
    }
    /**
     * Mark the payroll as failed
     */
    markFailed(payroll, reason) {
        var _a;
        // Any state can fail
        (_a = payroll.stateHistory) === null || _a === void 0 ? void 0 : _a.push({
            from: payroll.state,
            to: payroll_state_enum_1.PayrollState.FAILED,
            timestamp: new Date(),
            note: reason,
        });
        payroll.state = payroll_state_enum_1.PayrollState.FAILED;
    }
    /**
     * Reset the payroll to draft state for reprocessing
     */
    resetToDraft(payroll, reason) {
        var _a;
        // Only failed or pending approval payrolls can be reset
        const allowedStates = [
            payroll_state_enum_1.PayrollState.FAILED,
            payroll_state_enum_1.PayrollState.PENDING_APPROVAL,
            payroll_state_enum_1.PayrollState.REJECTED
        ];
        if (!allowedStates.includes(payroll.state)) {
            this.logger.warn(`Cannot reset payroll ${payroll.id} in state ${payroll.state}`);
            return false;
        }
        // Record state transition
        (_a = payroll.stateHistory) === null || _a === void 0 ? void 0 : _a.push({
            from: payroll.state,
            to: payroll_state_enum_1.PayrollState.DRAFT,
            timestamp: new Date(),
            note: reason,
        });
        payroll.state = payroll_state_enum_1.PayrollState.DRAFT;
        payroll.reprocessedCount += 1;
        return true;
    }
};
exports.PayrollStateMachine = PayrollStateMachine;
exports.PayrollStateMachine = PayrollStateMachine = PayrollStateMachine_1 = __decorate([
    (0, common_1.Injectable)()
], PayrollStateMachine);


/***/ }),

/***/ "./src/modules/payroll-management/types/calculation-details.type.ts":
/*!**************************************************************************!*\
  !*** ./src/modules/payroll-management/types/calculation-details.type.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/modules/payroll-management/utils/payslip-pdf-generator.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/payroll-management/utils/payslip-pdf-generator.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generatePayslipPdf = generatePayslipPdf;
exports.generateMiniPayslipPdf = generateMiniPayslipPdf;
const pdfkit_1 = __importDefault(__webpack_require__(/*! pdfkit */ "pdfkit"));
async function generatePayslipPdf(payslipData) {
    return new Promise((resolve, reject) => {
        try {
            // Ensure all required nested objects exist to prevent undefined errors
            payslipData = Object.assign({ employee: payslipData.employee || {}, workHours: payslipData.workHours || {}, compensation: payslipData.compensation || {}, deductions: payslipData.deductions || {}, rates: payslipData.rates || {}, totals: payslipData.totals || {}, cutoffPeriod: payslipData.cutoffPeriod || 'N/A', payrollDate: payslipData.payrollDate || 'N/A', benefits: payslipData.benefits || [], allowances: payslipData.allowances || [] }, payslipData);
            // Ensure nested objects within deductions exist
            payslipData.deductions.governmentMandated = payslipData.deductions.governmentMandated || {};
            payslipData.deductions.basic = payslipData.deductions.basic || {};
            payslipData.deductions.others = payslipData.deductions.others || [];
            // Create default values for totals if they don't exist
            payslipData.totals.grossPay = payslipData.totals.grossPay || 0;
            payslipData.totals.totalDeductions = payslipData.totals.totalDeductions || 0;
            payslipData.totals.totalAllowances = payslipData.totals.totalAllowances || 0;
            payslipData.totals.netPay = payslipData.totals.netPay || 0;
            payslipData.totals.taxableIncome = payslipData.totals.taxableIncome || 0;
            const buffers = [];
            const doc = new pdfkit_1.default({
                margin: 50,
                size: 'A4',
                bufferPages: true
            });
            // Collect PDF data chunks
            doc.on('data', buffers.push.bind(buffers));
            doc.on('end', () => {
                resolve(Buffer.concat(buffers));
            });
            // A4 dimensions
            const A4Width = 595.28;
            const A4Height = 841.89;
            const margin = 50;
            // Available space after margins
            const availableWidth = A4Width - 2 * margin;
            const availableHeight = A4Height - 2 * margin;
            // Width of each rectangle (dividing available width by 3)
            const rectWidth = (availableWidth / 3) - 10;
            // Define consistent styling
            const styles = {
                header: { fontSize: 10, font: 'Helvetica-Bold', color: '#333333' },
                subheader: { fontSize: 12, font: 'Helvetica-Bold', color: '#333333' },
                title: { fontSize: 18, font: 'Helvetica-Bold', color: '#000000' },
                normal: { fontSize: 10, font: 'Helvetica', color: '#333333' },
                small: { fontSize: 8, font: 'Helvetica', color: '#666666' },
                highlight: { fontSize: 12, font: 'Helvetica-Bold', color: '#000000' },
                tableHeader: { fontSize: 9, font: 'Helvetica-Bold', color: '#333333' },
                tableCell: { fontSize: 9, font: 'Helvetica', color: '#333333' },
                money: { fontSize: 10, font: 'Helvetica-Bold', color: '#000000' }
            };
            // Try to load company logo if it exists (adapt path as needed)
            // try {
            //     const logoPath = path.resolve(process.cwd(), 'assets/company_logo.png');
            //     if (fs.existsSync(logoPath)) {
            //         doc.image(logoPath, 50, 45, { width: 100 });
            //     }
            // } catch (err) {
            //     // Logo loading failed - continue without it
            //     console.log('Company logo not found, continuing without it');
            // }
            const employee = payslipData.employee;
            // Document Header with Company Information
            // doc.font(styles.title.font)
            //      .fontSize(styles.title.fontSize)
            //      .fillColor(styles.title.color)
            //      .text(String(employee.organization).toUpperCase(), { align: 'center' });
            // doc.font(styles.small.font)
            //      .fontSize(styles.small.fontSize)
            //      .fillColor(styles.small.color)
            //      .text('123 Corporate Plaza, Business District', { align: 'center' })
            //      .text('City, State, ZIP | Phone: (123) 456-7890', { align: 'center' })
            //      .text('Email: hr@companyname.com | Web: www.companyname.com', { align: 'center' });
            const startY = 50;
            // Payslip Title Banner
            drawFilledRect(doc, margin, startY, doc.page.width - 100, 30, '#f1f1f1');
            doc.font(styles.title.font)
                .fontSize(styles.title.fontSize)
                .fillColor(styles.title.color)
                .text('EMPLOYEE PAYSLIP', margin, startY + 9, { align: 'center' });
            // Employee and Payroll Information Section
            const employeeInfoY = startY + 40;
            drawOutlinedRect(doc, 50, employeeInfoY, doc.page.width - 100, 120);
            // Left column - Employee Info
            doc.font(styles.header.font)
                .fontSize(styles.header.fontSize)
                .fillColor(styles.header.color)
                .text('EMPLOYEE INFORMATION', 60, employeeInfoY + 10);
            doc.font(styles.normal.font)
                .fontSize(styles.normal.fontSize)
                .fillColor(styles.normal.color)
                .text(`Employee #: ${employee.employeeNumber}`, 60, employeeInfoY + 30)
                .text(`Name: ${employee.name}`, 60, employeeInfoY + 45)
                .text(`Position: ${employee.position}`, 60, employeeInfoY + 60)
                .text(`Department: ${employee.department}`, 60, employeeInfoY + 75)
                .text(`Branch: ${employee.branch}`, 60, employeeInfoY + 90)
                .text(`Organization: ${employee.organization}`, 60, employeeInfoY + 105);
            // Right column - Payroll Info
            doc.font(styles.header.font)
                .fontSize(styles.header.fontSize)
                .fillColor(styles.header.color)
                .text('PAYROLL INFORMATION', 350, employeeInfoY + 10);
            doc.font(styles.normal.font)
                .fontSize(styles.normal.fontSize)
                .fillColor(styles.normal.color)
                .text(`Cutoff Period: ${payslipData.cutoffPeriod}`, 350, employeeInfoY + 30)
                .text(`Pay Date: ${payslipData.payrollDate}`, 350, employeeInfoY + 45)
                .text(`Payroll #: ${payslipData.payrollReferenceNumber || 'N/A'}`, 350, employeeInfoY + 60);
            // Rates section
            const ratesY = employeeInfoY + 130;
            drawFilledRect(doc, 50, ratesY, doc.page.width - 100, 25, '#f1f1f1');
            doc.font(styles.subheader.font)
                .fontSize(styles.subheader.fontSize)
                .fillColor(styles.subheader.color)
                .text('PAY RATE INFORMATION', 60, ratesY + 8);
            const ratesDetailY = ratesY + 35;
            doc.font(styles.normal.font)
                .fontSize(styles.normal.fontSize)
                .fillColor(styles.normal.color);
            // Draw rates in a 2x2 grid
            drawInfoBox(doc, 'Monthly Rate', formatCurrency(payslipData.rates.monthly), margin, ratesDetailY, rectWidth);
            drawInfoBox(doc, 'Daily Rate', formatCurrency(payslipData.rates.daily), margin + rectWidth + 15, ratesDetailY, rectWidth);
            drawInfoBox(doc, 'Hourly Rate', formatCurrency(payslipData.rates.hourly), margin + (2 * rectWidth) + 30, ratesDetailY, rectWidth);
            // Main columns layout - Earnings and Deductions side by side
            const columnsStartY = ratesDetailY + 50;
            const colWidth = (doc.page.width - 100) / 2 - 10;
            // Earnings Column
            drawFilledRect(doc, 50, columnsStartY, colWidth, 25, '#f1f1f1');
            doc.font(styles.subheader.font)
                .fontSize(styles.subheader.fontSize)
                .fillColor(styles.subheader.color)
                .text('EARNINGS', 60, columnsStartY + 8);
            // Draw earnings table
            let currentY = columnsStartY + 35;
            const earnings = payslipData.compensation;
            const regularEarnings = [
                { description: 'Basic Pay', hours: payslipData.workHours.regular || 0, amount: earnings.basicPay || 0 },
                { description: 'Overtime', hours: payslipData.workHours.overtime || 0, amount: earnings.overtimePay || 0 },
                { description: 'Regular Holiday', hours: payslipData.workHours.holiday || 0, amount: earnings.holidayPay || 0 },
                { description: 'Holiday Overtime', hours: payslipData.workHours.holidayOvertime || 0, amount: earnings.holidayOvertimePay || 0 },
                { description: 'Special Holiday', hours: payslipData.workHours.specialHoliday || 0, amount: earnings.specialHolidayPay || 0 },
                { description: 'Special Holiday OT', hours: payslipData.workHours.specialHolidayOvertime || 0, amount: earnings.specialHolidayOvertimePay || 0 },
                { description: 'Rest Day', hours: payslipData.workHours.restDay || 0, amount: earnings.restDayPay || 0 },
                { description: 'Rest Day OT', hours: payslipData.workHours.restDayOvertime || 0, amount: earnings.restDayOvertimePay || 0 },
                { description: 'Night Differential', hours: payslipData.workHours.nightDifferential || 0, amount: earnings.nightDifferentialPay || 0 },
                { description: 'Night Differential OT', hours: payslipData.workHours.nightDifferentialOvertime || 0, amount: earnings.nightDifferentialOvertimePay || 0 }
            ].filter(item => (item.amount || 0) > 0); // Add fallback for undefined amounts
            currentY = drawTable(doc, ['Description', 'Hours', 'Amount'], regularEarnings.map(e => [e.description, Number(e.hours).toFixed(2), formatCurrency(e.amount)]), [50, currentY, colWidth], styles, [0.45, 0.2, 0.35]);
            // Add adjustments if any
            if (earnings.adjustments && earnings.adjustments.length > 0) {
                currentY += 10;
                doc.font(styles.header.font)
                    .fontSize(styles.header.fontSize)
                    .fillColor(styles.header.color)
                    .text('Adjustments', 60, currentY);
                currentY += 15;
                currentY = drawTable(doc, ['Description', 'Amount'], earnings.adjustments.map((a) => [a.name, formatCurrency(a.amount)]), [50, currentY, colWidth], styles, [0.7, 0.3]);
            }
            // Add other earnings if any
            if (earnings.others && earnings.others.length > 0) {
                currentY += 10;
                doc.font(styles.header.font)
                    .fontSize(styles.header.fontSize)
                    .fillColor(styles.header.color)
                    .text('Other Earnings', 60, currentY);
                currentY += 15;
                currentY = drawTable(doc, ['Description', 'Amount'], earnings.others.map((a) => [a.name, formatCurrency(a.amount)]), [50, currentY, colWidth], styles, [0.7, 0.3]);
            }
            // Add allowances if any
            if (payslipData.allowances && payslipData.allowances.length > 0) {
                currentY += 10;
                doc.font(styles.header.font)
                    .fontSize(styles.header.fontSize)
                    .fillColor(styles.header.color)
                    .text('Allowances', 60, currentY);
                currentY += 15;
                currentY = drawTable(doc, ['Description', 'Amount'], payslipData.allowances.map((a) => [a.name, formatCurrency(a.amount)]), [50, currentY, colWidth], styles, [0.7, 0.3]);
            }
            // Add benefits if any
            if (payslipData.benefits && payslipData.benefits.length > 0) {
                currentY += 10;
                doc.font(styles.header.font)
                    .fontSize(styles.header.fontSize)
                    .fillColor(styles.header.color)
                    .text('Benefits', 60, currentY);
                currentY += 15;
                currentY = drawTable(doc, ['Description', 'Amount'], payslipData.benefits.map((b) => [b.name, formatCurrency(b.amount)]), [50, currentY, colWidth], styles, [0.6, 0.4]);
            }
            // Calculate total earnings
            currentY += 10;
            doc.font(styles.highlight.font)
                .fontSize(styles.highlight.fontSize)
                .fillColor(styles.highlight.color);
            doc.text('Total Earnings:', 60, currentY);
            doc.text(formatCurrency(payslipData.totals.grossPay), 20 + colWidth - 80, currentY, { width: 100, align: 'right' });
            // Deductions Column
            const deductionsX = 50 + colWidth + 20;
            drawFilledRect(doc, deductionsX, columnsStartY, colWidth, 25, '#f1f1f1');
            doc.font(styles.subheader.font)
                .fontSize(styles.subheader.fontSize)
                .fillColor(styles.subheader.color)
                .text('DEDUCTIONS', deductionsX + 10, columnsStartY + 8);
            // Draw deductions
            let deductionsY = columnsStartY + 30;
            const deductions = payslipData.deductions;
            // Basic deductions if any
            if (deductions.basic) {
                const basicDeductions = [
                    { description: 'Absences', amount: deductions.basic.absences || 0 },
                    { description: 'Tardiness', amount: deductions.basic.tardiness || 0 },
                    { description: 'Undertime', amount: deductions.basic.undertime || 0 },
                    { description: 'No Time In', amount: deductions.basic.noTimeIn || 0 },
                    { description: 'No Time Out', amount: deductions.basic.noTimeOut || 0 }
                ].filter(d => (d.amount || 0) > 0);
                if (basicDeductions.length > 0) {
                    // log basic deductions length
                    console.log('Basic deductions:', basicDeductions.length);
                    deductionsY += 10;
                    doc.font(styles.header.font)
                        .fontSize(styles.header.fontSize)
                        .fillColor(styles.header.color)
                        .text('Attendance Deductions', deductionsX + 10, deductionsY - 6);
                    deductionsY += 10;
                    deductionsY = drawTable(doc, ['Description', 'Amount'], basicDeductions.map(d => [d.description, formatCurrency(d.amount)]), [deductionsX, deductionsY, colWidth], styles, [0.6, 0.4]);
                    // Display basic deductions total
                    if (deductions.basic.total) {
                        deductionsY += 5;
                        doc.font(styles.tableCell.font)
                            .fontSize(styles.tableCell.fontSize)
                            .fillColor(styles.tableCell.color);
                        doc.text('Attendance Deductions Total:', deductionsX + 10, deductionsY);
                        doc.text(formatCurrency(deductions.basic.total), deductionsX + colWidth - 80, deductionsY, { width: 70, align: 'right' });
                        deductionsY += 15;
                    }
                }
            }
            // Government mandated deductions
            const governmentDeductions = [
                { description: 'SSS Contribution', amount: deductions.governmentMandated.sss || 0 },
                { description: 'PhilHealth', amount: deductions.governmentMandated.philHealth || 0 },
                { description: 'Pag-IBIG', amount: deductions.governmentMandated.pagIbig || 0 },
                { description: 'Withholding Tax', amount: deductions.governmentMandated.withholdingTax || 0 }
            ].filter(item => (item.amount || 0) > 0);
            deductionsY = drawTable(doc, ['Description', 'Amount'], governmentDeductions.map(d => [d.description, formatCurrency(d.amount)]), [deductionsX, deductionsY, colWidth], styles, [0.6, 0.4]);
            // Other deductions if any
            if (deductions.others && deductions.others.length > 0) {
                deductionsY += 10;
                doc.font(styles.header.font)
                    .fontSize(styles.header.fontSize)
                    .fillColor(styles.header.color)
                    .text('Other Deductions', deductionsX + 10, deductionsY);
                deductionsY += 15;
                deductionsY = drawTable(doc, ['Description', 'Amount'], deductions.others.map((d) => [d.name, formatCurrency(d.amount)]), [deductionsX, deductionsY, colWidth], styles, [0.6, 0.4]);
            }
            // Total deductions
            deductionsY += 10;
            doc.font(styles.highlight.font)
                .fontSize(styles.highlight.fontSize)
                .fillColor(styles.highlight.color);
            doc.text('Total Deductions:', deductionsX + 10, deductionsY);
            doc.text(formatCurrency(payslipData.totals.totalDeductions), deductionsX + colWidth - 100, deductionsY, { width: 90, align: 'right' });
            // Summary Section - Net Pay
            const summaryY = Math.max(currentY, deductionsY) + 20;
            drawFilledRect(doc, 50, summaryY, doc.page.width - 100, 25, '#e6e6e6');
            doc.font(styles.subheader.font)
                .fontSize(styles.subheader.fontSize)
                .fillColor(styles.subheader.color)
                .text('PAYMENT SUMMARY', 50, summaryY + 8, { align: 'center' });
            const summaryDetailY = summaryY + 25;
            const netPayBoxY = summaryDetailY;
            doc.font(styles.header.font)
                .fontSize(14)
                .fillColor('#000')
                .text('NET PAY', 50, netPayBoxY + 15, { align: 'center' });
            doc.font('Helvetica-Bold')
                .fontSize(18)
                .fillColor('#000')
                .text(formatCurrency(payslipData.totals.netPay), 50, netPayBoxY + 35, { align: 'center' });
            // Footer
            const footerY = netPayBoxY + 60;
            drawFilledRect(doc, 50, footerY, doc.page.width - 100, 1, '#cccccc');
            doc.font(styles.small.font)
                .fontSize(styles.small.fontSize)
                .fillColor(styles.small.color)
                .text('This is a computer-generated document. No signature is required.', 50, footerY + 10, { align: 'center' })
                .text(`Generated on: ${new Date().toLocaleString()}`, 50, footerY + 20, { align: 'center' });
            // // Add page numbers
            // const pageCount = doc.bufferedPageRange().count;
            // for (let i = 0; i < pageCount; i++) {
            //     doc.switchToPage(i);
            //     doc.font(styles.small.font)
            //          .fontSize(styles.small.fontSize)
            //          .text(
            //              `Page ${i + 1} of ${pageCount}`,
            //              50,
            //              doc.page.height - 50,
            //              { align: 'right', width: doc.page.width - 100 }
            //          );
            // }
            doc.end();
        }
        catch (error) {
            console.error('Error generating PDF:', error);
            reject(error);
        }
    });
}
async function generateMiniPayslipPdf(payslipData) {
    return new Promise((resolve, reject) => {
        var _a;
        try {
            // Normalize payslip data with defaults
            payslipData = Object.assign({ employee: payslipData.employee || {}, compensation: payslipData.compensation || {}, deductions: payslipData.deductions || {}, rates: payslipData.rates || {}, totals: payslipData.totals || {}, allowances: payslipData.allowances || [] }, payslipData);
            // Ensure nested objects within deductions exist
            payslipData.deductions.governmentMandated = payslipData.deductions.governmentMandated || {};
            payslipData.deductions.basic = payslipData.deductions.basic || {};
            payslipData.deductions.others = payslipData.deductions.others || [];
            const buffers = [];
            // Create mini payslip - similar to the image
            const miniWidth = 280;
            const miniHeight = 500; // Taller to fit all items
            const doc = new pdfkit_1.default({
                margin: 10,
                size: [miniWidth, miniHeight],
                bufferPages: true
            });
            // Collect PDF data chunks
            doc.on('data', buffers.push.bind(buffers));
            doc.on('end', () => {
                resolve(Buffer.concat(buffers));
            });
            const margin = 15;
            const x = margin;
            let y = margin;
            const availableWidth = miniWidth - (2 * margin);
            // Compact styling
            const styles = {
                title: { fontSize: 9, font: 'Helvetica-Bold', color: '#000000' },
                header: { fontSize: 8, font: 'Helvetica-Bold', color: '#000000' },
                normal: { fontSize: 8, font: 'Helvetica', color: '#000000' },
                small: { fontSize: 6, font: 'Helvetica', color: '#666666' }
            };
            // Company header (if needed)
            if ((_a = payslipData.employee) === null || _a === void 0 ? void 0 : _a.organization) {
                doc.font(styles.title.font)
                    .fontSize(styles.title.fontSize)
                    .text(String(payslipData.employee.organization).toUpperCase(), x, y, { align: 'center' });
                y += 15;
            }
            // Period information
            if (payslipData.cutoffPeriod) {
                doc.font(styles.normal.font)
                    .fontSize(styles.normal.fontSize)
                    .text(`Pay Period: ${payslipData.cutoffPeriod}`, x, y);
                y += 10;
            }
            if (payslipData.payrollDate) {
                doc.font(styles.normal.font)
                    .fontSize(styles.normal.fontSize)
                    .text(`Pay Date: ${payslipData.payrollDate}`, x, y);
                y += 15;
            }
            // Employee information
            const employee = payslipData.employee;
            if (employee) {
                doc.font(styles.normal.font)
                    .fontSize(styles.normal.fontSize);
                if (employee.name) {
                    doc.text(`Employee: ${employee.name}`, x, y);
                    y += 10;
                }
                if (employee.position) {
                    doc.text(`Position: ${employee.position}`, x, y);
                    y += 10;
                }
                if (employee.department) {
                    doc.text(`Department: ${employee.department}`, x, y);
                    y += 15;
                }
            }
            // Rate information
            doc.font(styles.header.font)
                .fontSize(styles.header.fontSize);
            if (payslipData.rates.monthly) {
                doc.text('MONTHLY RATE:', x, y);
                doc.text(formatCurrency(payslipData.rates.monthly).replace('PHP ', ''), availableWidth + x - 70, y, { align: 'right' });
                y += 10;
            }
            if (payslipData.rates.daily) {
                doc.text('DAILY RATE:', x, y);
                doc.text(formatCurrency(payslipData.rates.daily).replace('PHP ', ''), availableWidth + x - 70, y, { align: 'right' });
                y += 15;
            }
            // Earnings section
            doc.font(styles.header.font)
                .fontSize(styles.header.fontSize)
                .text('BASIC PAY', x, y);
            y += 10;
            // Add earnings items
            doc.font(styles.normal.font)
                .fontSize(styles.normal.fontSize);
            const earnings = payslipData.compensation;
            if (earnings.basicPay) {
                doc.text('ADD:', x, y);
                y += 10;
            }
            const earningsItems = [
                { name: 'REGULAR OVERTIME', amount: earnings.overtimePay },
                { name: 'REST DAY', amount: earnings.restDayPay },
                { name: 'REST DAY OVERTIME', amount: earnings.restDayOvertimePay },
                { name: 'HOLIDAY PAY', amount: earnings.holidayPay },
                { name: '13TH MONTH', amount: earnings.thirteenthMonthPay },
                { name: 'SPECIAL HOLIDAY PAY', amount: earnings.specialHolidayPay },
                { name: 'SPECIAL HOLIDAY OVERTIME', amount: earnings.specialHolidayOvertimePay },
                { name: 'NIGHT DIFFERENTIAL', amount: earnings.nightDifferentialPay }
            ];
            // Add adjustments as "PAYROLL ADJUSTMENT" if any
            if (earnings.adjustments && earnings.adjustments.length > 0) {
                const adjustmentTotal = earnings.adjustments.reduce((sum, adj) => sum + (adj.amount || 0), 0);
                earningsItems.push({ name: 'PAYROLL ADJUSTMENT', amount: adjustmentTotal });
            }
            // Add tip if applicable
            if (earnings.tip) {
                earningsItems.push({ name: 'TIP', amount: earnings.tip });
            }
            // Display attendance deductions as a negative earning under "ABSENCES/UNDERTIME/TARDINESS"
            if (payslipData.deductions.basic &&
                (payslipData.deductions.basic.absences ||
                    payslipData.deductions.basic.tardiness ||
                    payslipData.deductions.basic.undertime)) {
                const attendanceDeductions = (payslipData.deductions.basic.absences || 0) +
                    (payslipData.deductions.basic.tardiness || 0) +
                    (payslipData.deductions.basic.undertime || 0);
                if (attendanceDeductions > 0) {
                    earningsItems.push({ name: 'ABSENCES/UNDERTIME/TARDINESS', amount: -attendanceDeductions });
                }
            }
            // Print earnings items
            earningsItems.forEach(item => {
                if (item.amount) {
                    doc.text(item.name, x + 10, y);
                    if (item.amount < 0) {
                        // For negative amounts (like deductions), use parentheses
                        doc.text(`(${formatCurrency(Math.abs(item.amount)).replace('PHP ', '')})`, availableWidth + x - 70, y, { align: 'right' });
                    }
                    else {
                        doc.text(formatCurrency(item.amount).replace('PHP ', ''), availableWidth + x - 70, y, { align: 'right' });
                    }
                    y += 10;
                }
            });
            // Gross pay
            doc.font(styles.header.font)
                .fontSize(styles.header.fontSize);
            y += 5;
            doc.text('GROSS PAY', x, y);
            doc.text(formatCurrency(payslipData.totals.grossPay).replace('PHP ', ''), availableWidth + x - 70, y, { align: 'right' });
            y += 15;
            // Deductions section
            doc.font(styles.header.font)
                .fontSize(styles.header.fontSize)
                .text('LESS:', x, y);
            y += 10;
            doc.font(styles.normal.font)
                .fontSize(styles.normal.fontSize);
            // Government mandated deductions
            const deductionItems = [
                { name: 'WITHHOLDING TAX', amount: payslipData.deductions.governmentMandated.withholdingTax },
                { name: 'SSS PREMIUM', amount: payslipData.deductions.governmentMandated.sss },
                { name: 'PHIL. HEALTH', amount: payslipData.deductions.governmentMandated.philHealth },
                { name: 'PAG-IBIG', amount: payslipData.deductions.governmentMandated.pagIbig }
            ];
            // Add other deductions
            if (payslipData.deductions.others && payslipData.deductions.others.length > 0) {
                payslipData.deductions.others.forEach((deduction) => {
                    deductionItems.push({
                        name: deduction.name.toUpperCase(),
                        amount: deduction.amount
                    });
                });
            }
            // Print deduction items
            deductionItems.forEach(item => {
                if (item.amount) {
                    doc.text(item.name, x + 10, y);
                    doc.text(formatCurrency(item.amount).replace('PHP ', ''), availableWidth + x - 70, y, { align: 'right' });
                    y += 10;
                }
            });
            // Total deductions
            y += 5;
            doc.font(styles.header.font)
                .fontSize(styles.header.fontSize)
                .text('TOTAL DEDUCTIONS', x, y);
            doc.text(formatCurrency(payslipData.totals.totalDeductions).replace('PHP ', ''), availableWidth + x - 70, y, { align: 'right' });
            y += 15;
            // Allowances section if any
            if (payslipData.allowances && payslipData.allowances.length > 0) {
                const allowanceItems = payslipData.allowances.map((allowance) => ({
                    name: allowance.name.toUpperCase(),
                    amount: allowance.amount
                }));
                // Print allowance items
                allowanceItems.forEach((item) => {
                    doc.font(styles.normal.font)
                        .fontSize(styles.normal.fontSize)
                        .text(item.name, x + 10, y);
                    doc.text(formatCurrency(item.amount).replace('PHP ', ''), availableWidth + x - 70, y, { align: 'right' });
                    y += 10;
                });
                // Total allowances
                y += 5;
                doc.font(styles.header.font)
                    .fontSize(styles.header.fontSize)
                    .text('TOTAL ALLOWANCES', x, y);
                const totalAllowances = payslipData.totals.totalAllowances ||
                    payslipData.allowances.reduce((sum, item) => sum + (item.amount || 0), 0);
                doc.text(formatCurrency(totalAllowances).replace('PHP ', ''), availableWidth + x - 70, y, { align: 'right' });
                y += 15;
            }
            // Net pay
            doc.font(styles.header.font)
                .fontSize(styles.header.fontSize)
                .text('NET PAY', x, y);
            doc.text(formatCurrency(payslipData.totals.netPay).replace('PHP ', ''), availableWidth + x - 70, y, { align: 'right' });
            y += 20;
            // Received by
            doc.font(styles.header.font)
                .fontSize(styles.header.fontSize)
                .text('RECEIVED BY:', x, y);
            y += 20;
            // Signature line
            doc.lineWidth(0.5)
                .moveTo(x, y)
                .lineTo(x + 150, y)
                .stroke();
            // Accounting Copy
            y += 5;
            doc.font(styles.normal.font)
                .fontSize(styles.normal.fontSize)
                .text('Accounting Copy', x, y);
            doc.end();
        }
        catch (error) {
            console.error('Error generating mini payslip:', error);
            reject(error);
        }
    });
}
// Helper functions for drawing elements
function drawOutlinedRect(doc, x, y, width, height, lineWidth = 1) {
    doc.lineWidth(lineWidth)
        .rect(x, y, width, height)
        .stroke();
}
function drawFilledRect(doc, x, y, width, height, color) {
    doc.fillColor(color)
        .rect(x, y, width, height)
        .fill();
}
function drawInfoBox(doc, label, value, x, y, width) {
    drawOutlinedRect(doc, x, y, width, 40);
    doc.font('Helvetica')
        .fontSize(8)
        .fillColor('#666666')
        .text(label, x + 5, y + 5);
    doc.font('Helvetica-Bold')
        .fontSize(12)
        .fillColor('#000000')
        .text(value, x + 5, y + 20);
}
function drawTable(doc, headers, rows, position, // [x, y, width]
styles, columnRatios // Optional column width ratios
) {
    const [x, y, width] = position;
    const colWidths = columnRatios
        ? columnRatios.map(ratio => width * ratio)
        : calculateColumnWidths(width, headers.length);
    let startX = x;
    let startY = y;
    // Draw table header
    const headerHeight = 20;
    drawFilledRect(doc, x, y, width, headerHeight, '#e6e6e6');
    doc.font(styles.tableHeader.font)
        .fontSize(styles.tableHeader.fontSize)
        .fillColor(styles.tableHeader.color);
    headers.forEach((header, i) => {
        const align = i === headers.length - 1 ? 'right' : 'left';
        const padding = i === headers.length - 1 ? 10 : 10;
        doc.text(header, startX + padding, startY + 6, {
            width: colWidths[i] - (padding * 2),
            align
        });
        startX += colWidths[i];
    });
    // Draw horizontal line after header
    doc.lineWidth(0.5)
        .moveTo(x, y + headerHeight)
        .lineTo(x + width, y + headerHeight)
        .stroke();
    startY += headerHeight;
    // Draw rows with dynamic heights
    doc.font(styles.tableCell.font)
        .fontSize(styles.tableCell.fontSize)
        .fillColor(styles.tableCell.color);
    rows.forEach((row, rowIndex) => {
        // Calculate row height based on content
        let rowHeight = 20; // minimum height
        let cellHeights = [];
        // Calculate height needed for each cell in this row
        row.forEach((cell, i) => {
            const textOptions = {
                width: colWidths[i] - 20, // 10px padding on each side
                align: (i === row.length - 1 ? 'right' : 'left')
            };
            // Calculate height without actually rendering
            const textHeight = doc.heightOfString(cell, textOptions);
            cellHeights.push(Math.max(20, textHeight + 12)); // Add padding
        });
        // Row height is the maximum of all cell heights in this row
        rowHeight = Math.max(...cellHeights);
        // Draw row background
        startX = x;
        row.forEach((cell, i) => {
            const align = i === row.length - 1 ? 'right' : 'left';
            const padding = i === row.length - 1 ? 10 : 10;
            doc.text(cell, startX + padding, startY + 6, {
                width: colWidths[i] - (padding * 2),
                align
            });
            startX += colWidths[i];
        });
        startY += rowHeight;
    });
    // Draw bottom border
    doc.lineWidth(0.5)
        .moveTo(x, startY)
        .lineTo(x + width, startY)
        .stroke();
    return startY;
}
function calculateColumnWidths(totalWidth, columnCount) {
    if (columnCount === 2) {
        // For 2 columns, make first one wider (70%)
        return [
            totalWidth * 0.7,
            totalWidth * 0.3
        ];
    }
    else if (columnCount === 3) {
        // For 3 columns (e.g., description, hours, amount)
        return [
            totalWidth * 0.6,
            totalWidth * 0.2,
            totalWidth * 0.2
        ];
    }
    // Default: equal widths
    const width = totalWidth / columnCount;
    return new Array(columnCount).fill(width);
}
function formatCurrency(amount) {
    const value = amount || 0;
    // Format the number without currency symbol first
    const formatter = new Intl.NumberFormat('en-PH', {
        style: 'decimal',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    });
    // Then add the peso symbol manually
    return `₱${formatter.format(value)}`;
}


/***/ }),

/***/ "./src/modules/shift-management/dtos/shift-day.dto.ts":
/*!************************************************************!*\
  !*** ./src/modules/shift-management/dtos/shift-day.dto.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShiftDayDto = void 0;
const is_time_string_decorator_1 = __webpack_require__(/*! @/common/decorators/is-time-string.decorator */ "./src/common/decorators/is-time-string.decorator.ts");
const day_enum_1 = __webpack_require__(/*! @/common/enums/day.enum */ "./src/common/enums/day.enum.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class ShiftDayDto {
}
exports.ShiftDayDto = ShiftDayDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Day of the week',
        enum: day_enum_1.Day,
        example: day_enum_1.Day.MONDAY
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(day_enum_1.Day),
    __metadata("design:type", typeof (_a = typeof day_enum_1.Day !== "undefined" && day_enum_1.Day) === "function" ? _a : Object)
], ShiftDayDto.prototype, "day", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Start time of the shift',
        example: '09:00:00',
        type: String,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, is_time_string_decorator_1.IsTimeString)(),
    __metadata("design:type", String)
], ShiftDayDto.prototype, "startTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'End time of the shift',
        example: '18:00:00',
        type: String,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, is_time_string_decorator_1.IsTimeString)(),
    __metadata("design:type", String)
], ShiftDayDto.prototype, "endTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Break time in minutes',
        example: 60,
        required: false,
        type: Number
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], ShiftDayDto.prototype, "breakTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Duration of the shift in hours',
        example: 480,
        required: false,
        type: Number
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], ShiftDayDto.prototype, "duration", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Indicates if the shift runs overnight',
        example: false,
        default: false,
        required: false,
        type: Boolean,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ShiftDayDto.prototype, "isOvernight", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID of the associated shift',
        example: '123e4567-e89b-12d3-a456-426614174000'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ShiftDayDto.prototype, "shiftId", void 0);


/***/ }),

/***/ "./src/modules/shift-management/dtos/shift.dto.ts":
/*!********************************************************!*\
  !*** ./src/modules/shift-management/dtos/shift.dto.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetShiftDto = exports.UpdateShiftDto = exports.ShiftDto = void 0;
const is_time_string_decorator_1 = __webpack_require__(/*! @/common/decorators/is-time-string.decorator */ "./src/common/decorators/is-time-string.decorator.ts");
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const shift_day_dto_1 = __webpack_require__(/*! ./shift-day.dto */ "./src/modules/shift-management/dtos/shift-day.dto.ts");
class ShiftDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
    get defaultDuration() {
        if (!this.defaultStartTime || !this.defaultEndTime) {
            return 0;
        }
        // Parse times
        const [startHours, startMinutes] = this.defaultStartTime.split(':').map(Number);
        const [endHours, endMinutes] = this.defaultEndTime.split(':').map(Number);
        // Calculate duration in hours
        let durationHours = endHours - startHours;
        let durationMinutes = endMinutes - startMinutes;
        // Adjust for negative minutes
        if (durationMinutes < 0) {
            durationHours -= 1;
            durationMinutes += 60;
        }
        // Calculate break time in hours
        const breakHours = this.defaultBreakTime ? this.defaultBreakTime / 60 : 0;
        // Return duration minus break time
        return Math.max(0, durationHours + (durationMinutes / 60) - breakHours);
    }
}
exports.ShiftDto = ShiftDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the shift',
        example: 'Morning Shift',
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ShiftDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of the shift',
        example: 'Standard morning work schedule',
        required: false,
        type: String
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ShiftDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Default start time of the shift',
        example: '09:00:00',
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, is_time_string_decorator_1.IsTimeString)(),
    __metadata("design:type", String)
], ShiftDto.prototype, "defaultStartTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Default end time of the shift',
        example: '18:00:00',
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, is_time_string_decorator_1.IsTimeString)(),
    __metadata("design:type", String)
], ShiftDto.prototype, "defaultEndTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Default break time in minutes',
        example: 60,
        required: false,
        type: Number
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], ShiftDto.prototype, "defaultBreakTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Default duration of the shift in hours (computed from start/end times)',
        example: 8,
        readOnly: true,
        type: Number
    }),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], ShiftDto.prototype, "defaultDuration", null);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Shift details for specific days',
        type: [shift_day_dto_1.ShiftDayDto],
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => shift_day_dto_1.ShiftDayDto),
    __metadata("design:type", Array)
], ShiftDto.prototype, "days", void 0);
class UpdateShiftDto extends (0, swagger_1.PartialType)(ShiftDto) {
}
exports.UpdateShiftDto = UpdateShiftDto;
class GetShiftDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateShiftDto, 'shift') {
}
exports.GetShiftDto = GetShiftDto;


/***/ }),

/***/ "./src/modules/shift-management/entities/shift-day.entity.ts":
/*!*******************************************************************!*\
  !*** ./src/modules/shift-management/entities/shift-day.entity.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShiftDay = void 0;
const day_enum_1 = __webpack_require__(/*! @/common/enums/day.enum */ "./src/common/enums/day.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const shift_entity_1 = __webpack_require__(/*! @/modules/shift-management/entities/shift.entity */ "./src/modules/shift-management/entities/shift.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
let ShiftDay = class ShiftDay extends base_entity_1.BaseEntity {
};
exports.ShiftDay = ShiftDay;
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: day_enum_1.Day
    }),
    __metadata("design:type", typeof (_a = typeof day_enum_1.Day !== "undefined" && day_enum_1.Day) === "function" ? _a : Object)
], ShiftDay.prototype, "day", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time', nullable: true }),
    __metadata("design:type", String)
], ShiftDay.prototype, "startTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time', nullable: true }),
    __metadata("design:type", String)
], ShiftDay.prototype, "endTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], ShiftDay.prototype, "breakTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], ShiftDay.prototype, "duration", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], ShiftDay.prototype, "isOvernight", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => shift_entity_1.Shift, (shift) => shift.days),
    (0, typeorm_1.JoinColumn)({ name: 'shiftId' }),
    __metadata("design:type", typeof (_b = typeof shift_entity_1.Shift !== "undefined" && shift_entity_1.Shift) === "function" ? _b : Object)
], ShiftDay.prototype, "shift", void 0);
exports.ShiftDay = ShiftDay = __decorate([
    (0, typeorm_1.Entity)('shift-days')
], ShiftDay);


/***/ }),

/***/ "./src/modules/shift-management/entities/shift.entity.ts":
/*!***************************************************************!*\
  !*** ./src/modules/shift-management/entities/shift.entity.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shift = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const cutoff_entity_1 = __webpack_require__(/*! @/modules/payroll-management/cutoffs/entities/cutoff.entity */ "./src/modules/payroll-management/cutoffs/entities/cutoff.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const group_entity_1 = __webpack_require__(/*! ../groups/entities/group.entity */ "./src/modules/shift-management/groups/entities/group.entity.ts");
const schedule_entity_1 = __webpack_require__(/*! ../schedules/entities/schedule.entity */ "./src/modules/shift-management/schedules/entities/schedule.entity.ts");
const shift_day_entity_1 = __webpack_require__(/*! ./shift-day.entity */ "./src/modules/shift-management/entities/shift-day.entity.ts");
let Shift = class Shift extends base_entity_1.BaseEntity {
    // Getter methods to easily get shift details for a specific day
    getShiftDetailsForDay(day) {
        if (!this.days || this.days.length === 0) {
            return null;
        }
        return this.days.find(detail => detail.day === day) || null;
    }
    // Helper methods from your existing Shift entity
    getStartTimeForDay(day) {
        const dayDetail = this.getShiftDetailsForDay(day);
        return (dayDetail === null || dayDetail === void 0 ? void 0 : dayDetail.startTime) || this.defaultStartTime;
    }
    getEndTimeForDay(day) {
        const dayDetail = this.getShiftDetailsForDay(day);
        return (dayDetail === null || dayDetail === void 0 ? void 0 : dayDetail.endTime) || this.defaultEndTime;
    }
    getBreakTimeForDay(day) {
        const dayDetail = this.getShiftDetailsForDay(day);
        return (dayDetail === null || dayDetail === void 0 ? void 0 : dayDetail.breakTime) || this.defaultBreakTime;
    }
    getDurationForDay(day) {
        const dayDetail = this.getShiftDetailsForDay(day);
        return (dayDetail === null || dayDetail === void 0 ? void 0 : dayDetail.duration) || this.defaultDuration;
    }
    isActiveOnDay(day) {
        return !!this.getShiftDetailsForDay(day);
    }
    getActiveDays() {
        var _a;
        return ((_a = this.days) === null || _a === void 0 ? void 0 : _a.map(day => day.day)) || [];
    }
};
exports.Shift = Shift;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Shift.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Shift.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time' }),
    __metadata("design:type", String)
], Shift.prototype, "defaultStartTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time' }),
    __metadata("design:type", String)
], Shift.prototype, "defaultEndTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Shift.prototype, "defaultBreakTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Shift.prototype, "defaultDuration", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => shift_day_entity_1.ShiftDay, (day) => day.shift, {
        cascade: true, eager: true
    }),
    __metadata("design:type", Array)
], Shift.prototype, "days", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => cutoff_entity_1.Cutoff, (cutoff) => cutoff.shifts, { nullable: true, cascade: true }),
    (0, typeorm_1.JoinTable)({
        name: 'shift_cutoffs',
        joinColumn: { name: 'shift_id', referencedColumnName: 'id' },
        inverseJoinColumn: { name: 'cutoff_id', referencedColumnName: 'id' },
    }),
    __metadata("design:type", Array)
], Shift.prototype, "cutoffs", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => group_entity_1.Group, (group) => group.shift, { nullable: true }),
    __metadata("design:type", Array)
], Shift.prototype, "groups", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => schedule_entity_1.Schedule, (schedule) => schedule.shift, { nullable: true }),
    __metadata("design:type", Array)
], Shift.prototype, "schedules", void 0);
exports.Shift = Shift = __decorate([
    (0, typeorm_1.Entity)('shifts')
], Shift);


/***/ }),

/***/ "./src/modules/shift-management/groups/dtos/group.dto.ts":
/*!***************************************************************!*\
  !*** ./src/modules/shift-management/groups/dtos/group.dto.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetGroupDto = exports.UpdateGroupDto = exports.GroupDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const reference_dto_1 = __webpack_require__(/*! @/common/dtos/reference.dto */ "./src/common/dtos/reference.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class GroupDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.GroupDto = GroupDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the group',
        example: 'Morning Shift Team'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GroupDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of the group',
        example: 'Team responsible for morning operations',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GroupDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Shift assigned to this group',
        type: reference_dto_1.ReferenceDto,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_a = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _a : Object)
], GroupDto.prototype, "shift", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Employees assigned to this group',
        type: [reference_dto_1.ReferenceDto]
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], GroupDto.prototype, "employees", void 0);
class UpdateGroupDto extends (0, swagger_1.PartialType)(GroupDto) {
}
exports.UpdateGroupDto = UpdateGroupDto;
class GetGroupDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateGroupDto, "group") {
}
exports.GetGroupDto = GetGroupDto;


/***/ }),

/***/ "./src/modules/shift-management/groups/entities/group.entity.ts":
/*!**********************************************************************!*\
  !*** ./src/modules/shift-management/groups/entities/group.entity.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Group = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const shift_entity_1 = __webpack_require__(/*! ../../entities/shift.entity */ "./src/modules/shift-management/entities/shift.entity.ts");
let Group = class Group extends base_entity_1.BaseEntity {
};
exports.Group = Group;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Group.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Group.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => employee_entity_1.Employee, (employee) => employee.group, { cascade: true, nullable: true }),
    __metadata("design:type", Array)
], Group.prototype, "employees", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => shift_entity_1.Shift, (shift) => shift.groups, { nullable: true, cascade: true, eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'shiftId' }),
    __metadata("design:type", typeof (_a = typeof shift_entity_1.Shift !== "undefined" && shift_entity_1.Shift) === "function" ? _a : Object)
], Group.prototype, "shift", void 0);
exports.Group = Group = __decorate([
    (0, typeorm_1.Entity)('groups')
], Group);


/***/ }),

/***/ "./src/modules/shift-management/groups/groups.controller.ts":
/*!******************************************************************!*\
  !*** ./src/modules/shift-management/groups/groups.controller.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const group_dto_1 = __webpack_require__(/*! ./dtos/group.dto */ "./src/modules/shift-management/groups/dtos/group.dto.ts");
const group_entity_1 = __webpack_require__(/*! ./entities/group.entity */ "./src/modules/shift-management/groups/entities/group.entity.ts");
const groups_service_1 = __webpack_require__(/*! ./groups.service */ "./src/modules/shift-management/groups/groups.service.ts");
class GroupsController extends (0, create_controller_factory_1.createController)(group_entity_1.Group, groups_service_1.GroupsService, group_dto_1.GetGroupDto, group_dto_1.GroupDto, group_dto_1.UpdateGroupDto) {
}
exports.GroupsController = GroupsController;


/***/ }),

/***/ "./src/modules/shift-management/groups/groups.module.ts":
/*!**************************************************************!*\
  !*** ./src/modules/shift-management/groups/groups.module.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupsModule = void 0;
const employee_management_module_1 = __webpack_require__(/*! @/modules/employee-management/employee-management.module */ "./src/modules/employee-management/employee-management.module.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const group_entity_1 = __webpack_require__(/*! ./entities/group.entity */ "./src/modules/shift-management/groups/entities/group.entity.ts");
const groups_controller_1 = __webpack_require__(/*! ./groups.controller */ "./src/modules/shift-management/groups/groups.controller.ts");
const groups_service_1 = __webpack_require__(/*! ./groups.service */ "./src/modules/shift-management/groups/groups.service.ts");
let GroupsModule = class GroupsModule {
};
exports.GroupsModule = GroupsModule;
exports.GroupsModule = GroupsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([group_entity_1.Group]),
            employee_management_module_1.EmployeeManagementModule,
        ],
        providers: [groups_service_1.GroupsService],
        exports: [groups_service_1.GroupsService],
        controllers: [groups_controller_1.GroupsController],
    })
], GroupsModule);


/***/ }),

/***/ "./src/modules/shift-management/groups/groups.service.ts":
/*!***************************************************************!*\
  !*** ./src/modules/shift-management/groups/groups.service.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var GroupsService_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupsService = void 0;
const employee_assigned_event_1 = __webpack_require__(/*! @/common/events/employee-assigned.event */ "./src/common/events/employee-assigned.event.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const employees_service_1 = __webpack_require__(/*! @/modules/employee-management/employees.service */ "./src/modules/employee-management/employees.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const group_entity_1 = __webpack_require__(/*! ./entities/group.entity */ "./src/modules/shift-management/groups/entities/group.entity.ts");
let GroupsService = GroupsService_1 = class GroupsService extends base_service_1.BaseService {
    constructor(groupsRepository, usersService, employeesService, eventEmitter) {
        super(groupsRepository, usersService);
        this.groupsRepository = groupsRepository;
        this.usersService = usersService;
        this.employeesService = employeesService;
        this.eventEmitter = eventEmitter;
        this.logger = new common_1.Logger(GroupsService_1.name);
    }
    async create(createDto, createdBy) {
        // Extract employee references before creating the group
        const employeeRefs = createDto.employees;
        const employeeRefsIds = employeeRefs ? employeeRefs.map(ref => ref.id).filter((id) => id !== undefined) : [];
        const employees = await this.employeesService.getEmployeesByIds(employeeRefsIds);
        // Create the group first (without employees)
        const group = await super.create(createDto, createdBy);
        // Emit event for employee assignment to group
        this.eventEmitter.emit(employee_assigned_event_1.GROUP_EVENTS.EMPLOYEE_ASSIGNED, new employee_assigned_event_1.EmployeeAssignedEvent(group, employees, createdBy));
        return group;
    }
    async update(id, updateDto, updatedBy) {
        // Extract employee references before updating the group
        const employeeRefs = updateDto.employees;
        const employeeRefsIds = employeeRefs ? employeeRefs.map(ref => ref.id).filter((id) => id !== undefined) : [];
        await this.employeesService.getEmployeesByIds(employeeRefsIds);
        const currentEmployees = await this.employeesService.getRepository().findBy({
            group: { id }
        });
        const currentEmployeeIds = currentEmployees ? currentEmployees.map(emp => emp.id).filter((id) => id !== undefined) : [];
        // Update the group first (without employees)
        const group = await super.update(id, updateDto, updatedBy);
        const employeesToRemove = currentEmployeeIds.filter(id => !employeeRefsIds.includes(id));
        const employeesToAdd = employeeRefsIds.filter(id => !currentEmployeeIds.includes(id));
        // Remove employees from the group
        if (employeesToRemove.length > 0) {
            const removedEmployees = await this.employeesService.getRepository().findBy({
                id: (0, typeorm_2.In)(employeesToRemove)
            });
            this.eventEmitter.emit(employee_assigned_event_1.GROUP_EVENTS.EMPLOYEE_REMOVED, new employee_assigned_event_1.EmployeeAssignedEvent(group, removedEmployees, updatedBy));
        }
        // Add new employees to the group
        if (employeesToAdd.length > 0) {
            const employees = await this.employeesService.getRepository().findBy({
                id: (0, typeorm_2.In)(employeesToAdd)
            });
            this.eventEmitter.emit(employee_assigned_event_1.GROUP_EVENTS.EMPLOYEE_ASSIGNED, new employee_assigned_event_1.EmployeeAssignedEvent(group, employees, updatedBy));
        }
        return group;
    }
};
exports.GroupsService = GroupsService;
exports.GroupsService = GroupsService = GroupsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(group_entity_1.Group)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _c : Object, typeof (_d = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _d : Object])
], GroupsService);


/***/ }),

/***/ "./src/modules/shift-management/holidays/dtos/holiday.dto.ts":
/*!*******************************************************************!*\
  !*** ./src/modules/shift-management/holidays/dtos/holiday.dto.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetHolidayDto = exports.UpdateHolidayDto = exports.HolidayDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const day_enum_1 = __webpack_require__(/*! @/common/enums/day.enum */ "./src/common/enums/day.enum.ts");
const holiday_type_enum_1 = __webpack_require__(/*! @/common/enums/holiday-type.enum */ "./src/common/enums/holiday-type.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class HolidayDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.HolidayDto = HolidayDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the holiday',
        example: 'Christmas Day'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], HolidayDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of the holiday',
        example: 'Annual celebration on December 25th',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], HolidayDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of holiday',
        enum: holiday_type_enum_1.HolidayType,
        enumName: 'HolidayType',
        example: Object.values(holiday_type_enum_1.HolidayType)[0]
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(holiday_type_enum_1.HolidayType, { message: 'Type must be a valid holiday type' }),
    __metadata("design:type", typeof (_a = typeof holiday_type_enum_1.HolidayType !== "undefined" && holiday_type_enum_1.HolidayType) === "function" ? _a : Object)
], HolidayDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date of the holiday',
        example: '2023-12-25'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], HolidayDto.prototype, "date", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Day of the week for the holiday',
        enum: day_enum_1.Day,
        enumName: 'Day',
        example: Object.values(day_enum_1.Day)[0]
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(day_enum_1.Day, { message: 'Day must be a valid day of the week' }),
    __metadata("design:type", typeof (_c = typeof day_enum_1.Day !== "undefined" && day_enum_1.Day) === "function" ? _c : Object)
], HolidayDto.prototype, "day", void 0);
class UpdateHolidayDto extends (0, swagger_1.PartialType)(HolidayDto) {
}
exports.UpdateHolidayDto = UpdateHolidayDto;
class GetHolidayDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateHolidayDto, 'holiday') {
}
exports.GetHolidayDto = GetHolidayDto;


/***/ }),

/***/ "./src/modules/shift-management/holidays/entities/holiday.entity.ts":
/*!**************************************************************************!*\
  !*** ./src/modules/shift-management/holidays/entities/holiday.entity.ts ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Holiday = void 0;
const day_enum_1 = __webpack_require__(/*! @/common/enums/day.enum */ "./src/common/enums/day.enum.ts");
const holiday_type_enum_1 = __webpack_require__(/*! @/common/enums/holiday-type.enum */ "./src/common/enums/holiday-type.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const schedule_entity_1 = __webpack_require__(/*! ../../schedules/entities/schedule.entity */ "./src/modules/shift-management/schedules/entities/schedule.entity.ts");
let Holiday = class Holiday extends base_entity_1.BaseEntity {
};
exports.Holiday = Holiday;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Holiday.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Holiday.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: holiday_type_enum_1.HolidayType }),
    __metadata("design:type", typeof (_a = typeof holiday_type_enum_1.HolidayType !== "undefined" && holiday_type_enum_1.HolidayType) === "function" ? _a : Object)
], Holiday.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Holiday.prototype, "date", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: day_enum_1.Day }),
    __metadata("design:type", typeof (_c = typeof day_enum_1.Day !== "undefined" && day_enum_1.Day) === "function" ? _c : Object)
], Holiday.prototype, "day", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => schedule_entity_1.Schedule, (schedule) => schedule.holiday, { nullable: true, onDelete: 'SET NULL' }),
    __metadata("design:type", Array)
], Holiday.prototype, "schedules", void 0);
exports.Holiday = Holiday = __decorate([
    (0, typeorm_1.Entity)('holidays')
], Holiday);


/***/ }),

/***/ "./src/modules/shift-management/holidays/holidays.controller.ts":
/*!**********************************************************************!*\
  !*** ./src/modules/shift-management/holidays/holidays.controller.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HolidaysController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const holiday_dto_1 = __webpack_require__(/*! ./dtos/holiday.dto */ "./src/modules/shift-management/holidays/dtos/holiday.dto.ts");
const holiday_entity_1 = __webpack_require__(/*! ./entities/holiday.entity */ "./src/modules/shift-management/holidays/entities/holiday.entity.ts");
const holidays_service_1 = __webpack_require__(/*! ./holidays.service */ "./src/modules/shift-management/holidays/holidays.service.ts");
class HolidaysController extends (0, create_controller_factory_1.createController)(holiday_entity_1.Holiday, holidays_service_1.HolidaysService, holiday_dto_1.GetHolidayDto, holiday_dto_1.HolidayDto, holiday_dto_1.UpdateHolidayDto) {
}
exports.HolidaysController = HolidaysController;


/***/ }),

/***/ "./src/modules/shift-management/holidays/holidays.module.ts":
/*!******************************************************************!*\
  !*** ./src/modules/shift-management/holidays/holidays.module.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HolidaysModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const schedules_module_1 = __webpack_require__(/*! ../schedules/schedules.module */ "./src/modules/shift-management/schedules/schedules.module.ts");
const holiday_entity_1 = __webpack_require__(/*! ./entities/holiday.entity */ "./src/modules/shift-management/holidays/entities/holiday.entity.ts");
const holidays_controller_1 = __webpack_require__(/*! ./holidays.controller */ "./src/modules/shift-management/holidays/holidays.controller.ts");
const holidays_service_1 = __webpack_require__(/*! ./holidays.service */ "./src/modules/shift-management/holidays/holidays.service.ts");
let HolidaysModule = class HolidaysModule {
};
exports.HolidaysModule = HolidaysModule;
exports.HolidaysModule = HolidaysModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([holiday_entity_1.Holiday]),
            (0, common_1.forwardRef)(() => schedules_module_1.SchedulesModule),
        ],
        providers: [holidays_service_1.HolidaysService],
        exports: [holidays_service_1.HolidaysService],
        controllers: [holidays_controller_1.HolidaysController],
    })
], HolidaysModule);


/***/ }),

/***/ "./src/modules/shift-management/holidays/holidays.service.ts":
/*!*******************************************************************!*\
  !*** ./src/modules/shift-management/holidays/holidays.service.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HolidaysService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const schedules_service_1 = __webpack_require__(/*! ../schedules/schedules.service */ "./src/modules/shift-management/schedules/schedules.service.ts");
const holiday_entity_1 = __webpack_require__(/*! ./entities/holiday.entity */ "./src/modules/shift-management/holidays/entities/holiday.entity.ts");
let HolidaysService = class HolidaysService extends base_service_1.BaseService {
    constructor(holidaysRepository, usersService, schedulesService) {
        super(holidaysRepository, usersService);
        this.holidaysRepository = holidaysRepository;
        this.usersService = usersService;
        this.schedulesService = schedulesService;
    }
    async create(createDto, createdBy) {
        // Check if holiday already exists for the same date
        const existingHoliday = await this.holidaysRepository.findOne({
            where: { date: createDto.date }
        });
        if (existingHoliday) {
            throw new common_1.ConflictException(`A holiday already exists on ${createDto.date}`);
        }
        // Call the base class create method
        const holiday = await super.create(createDto, createdBy);
        // Find all schedules on this date and link them to the holiday
        await this.linkHolidayToSchedules(holiday);
        return holiday;
    }
    async update(id, updateDto, updatedBy) {
        // Get existing holiday
        const existingHoliday = await this.findOneByOrFail({ id });
        // If date is being updated, check if another holiday exists on the new date
        if (updateDto.date && updateDto.date !== existingHoliday.date) {
            const conflictingHoliday = await this.holidaysRepository.findOne({
                where: { date: updateDto.date }
            });
            if (conflictingHoliday && conflictingHoliday.id !== id) {
                throw new common_1.ConflictException(`A holiday already exists on ${updateDto.date}`);
            }
        }
        // Call the base class update method
        const updatedHoliday = await super.update(id, updateDto, updatedBy);
        // If the date was changed, update all schedules for the new date
        if (updateDto.date && updateDto.date !== existingHoliday.date) {
            // Unlink schedules from the old date
            await this.schedulesService.getRepository().update({ holiday: { id } }, { holiday: undefined });
            // Link schedules to the new date
            await this.linkHolidayToSchedules(updatedHoliday);
        }
        return updatedHoliday;
    }
    /**
     * Links a holiday to all schedules on the same date
     */
    async linkHolidayToSchedules(holiday) {
        // Create a date range for the entire day
        const startDate = new Date(holiday.date);
        startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(holiday.date);
        endDate.setHours(23, 59, 59, 999);
        // Find all schedules on this date
        const schedules = await this.schedulesService.getRepository().find({
            where: {
                date: (0, typeorm_2.Between)(startDate, endDate)
            }
        });
        // Link the holiday to all schedules
        if (schedules.length > 0) {
            await Promise.all(schedules.map(schedule => this.schedulesService.getRepository().update(schedule.id, { holiday: { id: holiday.id } })));
        }
    }
};
exports.HolidaysService = HolidaysService;
exports.HolidaysService = HolidaysService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(holiday_entity_1.Holiday)),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => schedules_service_1.SchedulesService))),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _c : Object])
], HolidaysService);


/***/ }),

/***/ "./src/modules/shift-management/schedules/dtos/schedule.dto.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/shift-management/schedules/dtos/schedule.dto.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetScheduleDto = exports.UpdateScheduleDto = exports.ScheduleDto = void 0;
const is_time_string_decorator_1 = __webpack_require__(/*! @/common/decorators/is-time-string.decorator */ "./src/common/decorators/is-time-string.decorator.ts");
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const reference_dto_1 = __webpack_require__(/*! @/common/dtos/reference.dto */ "./src/common/dtos/reference.dto.ts");
const schedule_status_1 = __webpack_require__(/*! @/common/enums/schedule-status */ "./src/common/enums/schedule-status.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class ScheduleDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.ScheduleDto = ScheduleDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date of the schedule',
        example: '2023-01-01',
        type: String,
        format: 'date'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], ScheduleDto.prototype, "date", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Notes about the schedule',
        example: 'Special schedule for holiday season'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ScheduleDto.prototype, "notes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Color of the schedule',
        example: '#000000'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ScheduleDto.prototype, "color", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Indicates if this is a rest day',
        default: false,
        example: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ScheduleDto.prototype, "restDay", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Start time of the schedule',
        example: '09:00:00',
        format: 'time'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, is_time_string_decorator_1.IsTimeString)(),
    __metadata("design:type", String)
], ScheduleDto.prototype, "startTime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'End time of the schedule',
        example: '17:00:00',
        format: 'time'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, is_time_string_decorator_1.IsTimeString)(),
    __metadata("design:type", String)
], ScheduleDto.prototype, "endTime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Break time in minutes',
        example: 60,
        minimum: 0
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], ScheduleDto.prototype, "breakTime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Employee owns this schedule',
        type: reference_dto_1.ReferenceDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_b = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _b : Object)
], ScheduleDto.prototype, "employee", void 0);
class UpdateScheduleDto extends (0, swagger_1.PartialType)(ScheduleDto) {
}
exports.UpdateScheduleDto = UpdateScheduleDto;
class GetScheduleDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateScheduleDto, 'schedule') {
}
exports.GetScheduleDto = GetScheduleDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Cutoff this schedule belongs to',
        type: reference_dto_1.ReferenceDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_c = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _c : Object)
], GetScheduleDto.prototype, "cutoff", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Shift this schedule is based',
        type: reference_dto_1.ReferenceDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_d = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _d : Object)
], GetScheduleDto.prototype, "shift", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Associated holiday reference',
        type: reference_dto_1.ReferenceDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_e = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _e : Object)
], GetScheduleDto.prototype, "holiday", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Status of the schedule',
        enum: schedule_status_1.ScheduleStatus,
        default: schedule_status_1.ScheduleStatus.DEFAULT,
        example: schedule_status_1.ScheduleStatus.DEFAULT
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(schedule_status_1.ScheduleStatus),
    __metadata("design:type", typeof (_f = typeof schedule_status_1.ScheduleStatus !== "undefined" && schedule_status_1.ScheduleStatus) === "function" ? _f : Object)
], GetScheduleDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Duration in hours',
        example: 8,
        minimum: 0
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], GetScheduleDto.prototype, "duration", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Attendance for this schedule',
        type: reference_dto_1.ReferenceDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_g = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _g : Object)
], GetScheduleDto.prototype, "attendance", void 0);


/***/ }),

/***/ "./src/modules/shift-management/schedules/entities/schedule.entity.ts":
/*!****************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/entities/schedule.entity.ts ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Schedule = void 0;
const schedule_status_1 = __webpack_require__(/*! @/common/enums/schedule-status */ "./src/common/enums/schedule-status.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const attendance_entity_1 = __webpack_require__(/*! @/modules/attendance-management/entities/attendance.entity */ "./src/modules/attendance-management/entities/attendance.entity.ts");
const employee_entity_1 = __webpack_require__(/*! @/modules/employee-management/entities/employee.entity */ "./src/modules/employee-management/entities/employee.entity.ts");
const cutoff_entity_1 = __webpack_require__(/*! @/modules/payroll-management/cutoffs/entities/cutoff.entity */ "./src/modules/payroll-management/cutoffs/entities/cutoff.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const shift_entity_1 = __webpack_require__(/*! ../../entities/shift.entity */ "./src/modules/shift-management/entities/shift.entity.ts");
const holiday_entity_1 = __webpack_require__(/*! ../../holidays/entities/holiday.entity */ "./src/modules/shift-management/holidays/entities/holiday.entity.ts");
const schedule_change_request_entity_1 = __webpack_require__(/*! ../schedule-change-requests/entities/schedule-change-request.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/entities/schedule-change-request.entity.ts");
let Schedule = class Schedule extends base_entity_1.BaseEntity {
};
exports.Schedule = Schedule;
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Schedule.prototype, "date", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Schedule.prototype, "notes", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: schedule_status_1.ScheduleStatus, default: schedule_status_1.ScheduleStatus.DEFAULT }),
    __metadata("design:type", typeof (_b = typeof schedule_status_1.ScheduleStatus !== "undefined" && schedule_status_1.ScheduleStatus) === "function" ? _b : Object)
], Schedule.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => attendance_entity_1.Attendance, (attendance) => attendance.schedule, { nullable: true }),
    __metadata("design:type", typeof (_c = typeof attendance_entity_1.Attendance !== "undefined" && attendance_entity_1.Attendance) === "function" ? _c : Object)
], Schedule.prototype, "attendance", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Schedule.prototype, "color", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time', nullable: true }),
    __metadata("design:type", String)
], Schedule.prototype, "startTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time', nullable: true }),
    __metadata("design:type", String)
], Schedule.prototype, "endTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Schedule.prototype, "breakTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Schedule.prototype, "duration", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], Schedule.prototype, "allowEarlyCheckIn", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => shift_entity_1.Shift, (shift) => shift.schedules),
    (0, typeorm_1.JoinColumn)({ name: 'shiftId' }),
    __metadata("design:type", typeof (_d = typeof shift_entity_1.Shift !== "undefined" && shift_entity_1.Shift) === "function" ? _d : Object)
], Schedule.prototype, "shift", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => holiday_entity_1.Holiday, (holiday) => holiday.schedules, { nullable: true, eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'holidayId' }),
    __metadata("design:type", typeof (_e = typeof holiday_entity_1.Holiday !== "undefined" && holiday_entity_1.Holiday) === "function" ? _e : Object)
], Schedule.prototype, "holiday", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], Schedule.prototype, "restDay", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.schedules),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_f = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _f : Object)
], Schedule.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => schedule_change_request_entity_1.ScheduleChangeRequest, (scheduleChangeRequest) => scheduleChangeRequest.originalSchedules, { nullable: true }),
    __metadata("design:type", Array)
], Schedule.prototype, "scheduleChangeRequests", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => cutoff_entity_1.Cutoff, (cutoff) => cutoff.schedules, { eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'cutoffId' }),
    __metadata("design:type", typeof (_g = typeof cutoff_entity_1.Cutoff !== "undefined" && cutoff_entity_1.Cutoff) === "function" ? _g : Object)
], Schedule.prototype, "cutoff", void 0);
exports.Schedule = Schedule = __decorate([
    (0, typeorm_1.Entity)('schedules')
], Schedule);


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedule-change-requests/dtos/schedule-change-request.dto.ts":
/*!*************************************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedule-change-requests/dtos/schedule-change-request.dto.ts ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetScheduleChangeRequestDto = exports.UpdateScheduleChangeRequestDto = exports.ScheduleChangeRequestDto = exports.AlternativeScheduleDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const reference_dto_1 = __webpack_require__(/*! @/common/dtos/reference.dto */ "./src/common/dtos/reference.dto.ts");
const request_status_enum_1 = __webpack_require__(/*! @/common/enums/request-status.enum */ "./src/common/enums/request-status.enum.ts");
const schedule_change_request_type_enum_1 = __webpack_require__(/*! @/common/enums/schedule-change-request-type.enum */ "./src/common/enums/schedule-change-request-type.enum.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class AlternativeScheduleDto {
}
exports.AlternativeScheduleDto = AlternativeScheduleDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date of the alternative schedule',
        example: '2023-06-15',
        type: String,
        format: 'date'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], AlternativeScheduleDto.prototype, "date", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Start time of the alternative schedule',
        example: '09:00:00',
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], AlternativeScheduleDto.prototype, "startTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'End time of the alternative schedule',
        example: '17:00:00',
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], AlternativeScheduleDto.prototype, "endTime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Break time in minutes for the alternative schedule',
        example: 60
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AlternativeScheduleDto.prototype, "breakTime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Notes for this alternative schedule',
        example: 'Working from home this day'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], AlternativeScheduleDto.prototype, "notes", void 0);
class ScheduleChangeRequestDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.ScheduleChangeRequestDto = ScheduleChangeRequestDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Reason for the schedule change request',
        example: 'Medical appointment'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ScheduleChangeRequestDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of schedule change request',
        enum: schedule_change_request_type_enum_1.ScheduleChangeRequestType,
        example: schedule_change_request_type_enum_1.ScheduleChangeRequestType.SICK_LEAVE
    }),
    (0, class_validator_1.IsEnum)(schedule_change_request_type_enum_1.ScheduleChangeRequestType),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof schedule_change_request_type_enum_1.ScheduleChangeRequestType !== "undefined" && schedule_change_request_type_enum_1.ScheduleChangeRequestType) === "function" ? _a : Object)
], ScheduleChangeRequestDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Original schedules that need to be changed',
        type: [reference_dto_1.ReferenceDto],
        example: [
            { id: '123e4567-e89b-12d3-a456-426614174000' },
            { id: '123e4567-e89b-12d3-a456-426614174001' }
        ]
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], ScheduleChangeRequestDto.prototype, "originalSchedules", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Alternative schedules to replace the originals',
        type: [AlternativeScheduleDto]
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => AlternativeScheduleDto),
    __metadata("design:type", Array)
], ScheduleChangeRequestDto.prototype, "alternativeSchedules", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Documents associated with the schedule change request',
        type: [reference_dto_1.ReferenceDto],
        example: [
            { id: '123e4567-e89b-12d3-a456-426614174000' }
        ]
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], ScheduleChangeRequestDto.prototype, "documents", void 0);
class UpdateScheduleChangeRequestDto extends (0, swagger_1.PartialType)(ScheduleChangeRequestDto) {
}
exports.UpdateScheduleChangeRequestDto = UpdateScheduleChangeRequestDto;
class GetScheduleChangeRequestDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateScheduleChangeRequestDto, 'schedule change request') {
}
exports.GetScheduleChangeRequestDto = GetScheduleChangeRequestDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Status of the request',
        enum: request_status_enum_1.RequestStatus,
        default: request_status_enum_1.RequestStatus.PENDING,
        example: request_status_enum_1.RequestStatus.PENDING
    }),
    (0, class_validator_1.IsEnum)(request_status_enum_1.RequestStatus),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_b = typeof request_status_enum_1.RequestStatus !== "undefined" && request_status_enum_1.RequestStatus) === "function" ? _b : Object)
], GetScheduleChangeRequestDto.prototype, "status", void 0);


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedule-change-requests/entities/alternative-schedule.entity.ts":
/*!*****************************************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedule-change-requests/entities/alternative-schedule.entity.ts ***!
  \*****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlternativeSchedule = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const schedule_entity_1 = __webpack_require__(/*! ../../entities/schedule.entity */ "./src/modules/shift-management/schedules/entities/schedule.entity.ts");
const schedule_change_request_entity_1 = __webpack_require__(/*! ./schedule-change-request.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/entities/schedule-change-request.entity.ts");
let AlternativeSchedule = class AlternativeSchedule extends base_entity_1.BaseEntity {
};
exports.AlternativeSchedule = AlternativeSchedule;
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], AlternativeSchedule.prototype, "date", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time' }),
    __metadata("design:type", String)
], AlternativeSchedule.prototype, "startTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time' }),
    __metadata("design:type", String)
], AlternativeSchedule.prototype, "endTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], AlternativeSchedule.prototype, "breakTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], AlternativeSchedule.prototype, "notes", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => schedule_change_request_entity_1.ScheduleChangeRequest, scheduleChangeRequest => scheduleChangeRequest.alternativeSchedules),
    (0, typeorm_1.JoinColumn)({ name: 'scheduleChangeRequestId' }),
    __metadata("design:type", typeof (_b = typeof schedule_change_request_entity_1.ScheduleChangeRequest !== "undefined" && schedule_change_request_entity_1.ScheduleChangeRequest) === "function" ? _b : Object)
], AlternativeSchedule.prototype, "scheduleChangeRequest", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => schedule_entity_1.Schedule, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'resultingScheduleId' }),
    __metadata("design:type", typeof (_c = typeof schedule_entity_1.Schedule !== "undefined" && schedule_entity_1.Schedule) === "function" ? _c : Object)
], AlternativeSchedule.prototype, "resultingSchedule", void 0);
exports.AlternativeSchedule = AlternativeSchedule = __decorate([
    (0, typeorm_1.Entity)('alternative-schedules')
], AlternativeSchedule);


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedule-change-requests/entities/schedule-change-request.entity.ts":
/*!********************************************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedule-change-requests/entities/schedule-change-request.entity.ts ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeRequest = void 0;
const request_status_enum_1 = __webpack_require__(/*! @/common/enums/request-status.enum */ "./src/common/enums/request-status.enum.ts");
const schedule_change_request_type_enum_1 = __webpack_require__(/*! @/common/enums/schedule-change-request-type.enum */ "./src/common/enums/schedule-change-request-type.enum.ts");
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const document_entity_1 = __webpack_require__(/*! @/modules/documents/entities/document.entity */ "./src/modules/documents/entities/document.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const schedule_entity_1 = __webpack_require__(/*! ../../entities/schedule.entity */ "./src/modules/shift-management/schedules/entities/schedule.entity.ts");
const schedule_change_response_entity_1 = __webpack_require__(/*! ../schedule-change-responses/entities/schedule-change-response.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/entities/schedule-change-response.entity.ts");
const alternative_schedule_entity_1 = __webpack_require__(/*! ./alternative-schedule.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/entities/alternative-schedule.entity.ts");
let ScheduleChangeRequest = class ScheduleChangeRequest extends base_entity_1.BaseEntity {
};
exports.ScheduleChangeRequest = ScheduleChangeRequest;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], ScheduleChangeRequest.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: request_status_enum_1.RequestStatus, default: request_status_enum_1.RequestStatus.PENDING }),
    __metadata("design:type", typeof (_a = typeof request_status_enum_1.RequestStatus !== "undefined" && request_status_enum_1.RequestStatus) === "function" ? _a : Object)
], ScheduleChangeRequest.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: schedule_change_request_type_enum_1.ScheduleChangeRequestType }),
    __metadata("design:type", typeof (_b = typeof schedule_change_request_type_enum_1.ScheduleChangeRequestType !== "undefined" && schedule_change_request_type_enum_1.ScheduleChangeRequestType) === "function" ? _b : Object)
], ScheduleChangeRequest.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => schedule_entity_1.Schedule, { cascade: false }),
    (0, typeorm_1.JoinTable)({
        name: 'schedule_change_request_originals',
        joinColumn: { name: 'scheduleChangeRequestId', referencedColumnName: 'id' },
        inverseJoinColumn: { name: 'scheduleId', referencedColumnName: 'id' },
    }),
    __metadata("design:type", Array)
], ScheduleChangeRequest.prototype, "originalSchedules", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => alternative_schedule_entity_1.AlternativeSchedule, alternativeSchedule => alternativeSchedule.scheduleChangeRequest, { cascade: true }),
    __metadata("design:type", Array)
], ScheduleChangeRequest.prototype, "alternativeSchedules", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => document_entity_1.Document, (document) => document.scheduleChangeRequest, { nullable: true, cascade: true }),
    __metadata("design:type", Array)
], ScheduleChangeRequest.prototype, "documents", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => schedule_change_response_entity_1.ScheduleChangeResponse, (scheduleChangeResponse) => scheduleChangeResponse.scheduleChangeRequest, { eager: true, nullable: true }),
    __metadata("design:type", typeof (_c = typeof schedule_change_response_entity_1.ScheduleChangeResponse !== "undefined" && schedule_change_response_entity_1.ScheduleChangeResponse) === "function" ? _c : Object)
], ScheduleChangeRequest.prototype, "scheduleChangeResponse", void 0);
exports.ScheduleChangeRequest = ScheduleChangeRequest = __decorate([
    (0, typeorm_1.Entity)('schedule-change-requests')
], ScheduleChangeRequest);


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedule-change-requests/listener/schedule-change.listener.ts":
/*!**************************************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedule-change-requests/listener/schedule-change.listener.ts ***!
  \**************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ScheduleChangeListener_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeListener = void 0;
const request_status_enum_1 = __webpack_require__(/*! @/common/enums/request-status.enum */ "./src/common/enums/request-status.enum.ts");
const schedule_change_event_1 = __webpack_require__(/*! @/common/events/schedule-change.event */ "./src/common/events/schedule-change.event.ts");
const work_time_event_1 = __webpack_require__(/*! @/common/events/work-time.event */ "./src/common/events/work-time.event.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const schedule_change_requests_service_1 = __webpack_require__(/*! ../schedule-change-requests.service */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.service.ts");
let ScheduleChangeListener = ScheduleChangeListener_1 = class ScheduleChangeListener {
    constructor(scheduleChangeRequestsService) {
        this.scheduleChangeRequestsService = scheduleChangeRequestsService;
        this.logger = new common_1.Logger(ScheduleChangeListener_1.name);
    }
    async handleScheduleChangeResponded(event) {
        this.logger.log(`Schedule change request responded: ${event.scheduleChangeRequestId}, approved: ${event.isApproved}`);
        if (!event.scheduleChangeRequestId) {
            this.logger.warn('Schedule change request ID is missing');
            return;
        }
        // Update the request status
        const newStatus = event.isApproved === true
            ? request_status_enum_1.RequestStatus.APPROVED
            : (event.isApproved === false ? request_status_enum_1.RequestStatus.REJECTED : request_status_enum_1.RequestStatus.PENDING);
        await this.scheduleChangeRequestsService.update(event.scheduleChangeRequestId, { status: newStatus }, event.respondedBy);
        // If approved, apply the schedule changes
        if (event.isApproved === true) {
            try {
                await this.scheduleChangeRequestsService.applyScheduleChanges(event.scheduleChangeRequestId, event.respondedBy);
                this.logger.log(`Successfully applied schedule changes for request ${event.scheduleChangeRequestId}`);
            }
            catch (error) {
                this.logger.error(`Failed to apply schedule changes: ${error.message}`, error.stack);
                // Consider creating a notification for the failure
            }
        }
    }
};
exports.ScheduleChangeListener = ScheduleChangeListener;
__decorate([
    (0, event_emitter_1.OnEvent)(work_time_event_1.WORK_TIME_EVENTS.WORK_TIME_RESPONDED),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof schedule_change_event_1.ScheduleChangeRespondedEvent !== "undefined" && schedule_change_event_1.ScheduleChangeRespondedEvent) === "function" ? _b : Object]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], ScheduleChangeListener.prototype, "handleScheduleChangeResponded", null);
exports.ScheduleChangeListener = ScheduleChangeListener = ScheduleChangeListener_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof schedule_change_requests_service_1.ScheduleChangeRequestsService !== "undefined" && schedule_change_requests_service_1.ScheduleChangeRequestsService) === "function" ? _a : Object])
], ScheduleChangeListener);


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.controller.ts":
/*!****************************************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.controller.ts ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeRequestsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const schedule_change_request_dto_1 = __webpack_require__(/*! ./dtos/schedule-change-request.dto */ "./src/modules/shift-management/schedules/schedule-change-requests/dtos/schedule-change-request.dto.ts");
const schedule_change_request_entity_1 = __webpack_require__(/*! ./entities/schedule-change-request.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/entities/schedule-change-request.entity.ts");
const schedule_change_requests_service_1 = __webpack_require__(/*! ./schedule-change-requests.service */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.service.ts");
class ScheduleChangeRequestsController extends (0, create_controller_factory_1.createController)(schedule_change_request_entity_1.ScheduleChangeRequest, schedule_change_requests_service_1.ScheduleChangeRequestsService, schedule_change_request_dto_1.GetScheduleChangeRequestDto, schedule_change_request_dto_1.ScheduleChangeRequestDto, schedule_change_request_dto_1.UpdateScheduleChangeRequestDto) {
    async delete(id) {
        return await super.delete(id);
    }
}
exports.ScheduleChangeRequestsController = ScheduleChangeRequestsController;


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.module.ts":
/*!************************************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.module.ts ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeRequestsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const schedules_module_1 = __webpack_require__(/*! ../schedules.module */ "./src/modules/shift-management/schedules/schedules.module.ts");
const alternative_schedule_entity_1 = __webpack_require__(/*! ./entities/alternative-schedule.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/entities/alternative-schedule.entity.ts");
const schedule_change_request_entity_1 = __webpack_require__(/*! ./entities/schedule-change-request.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/entities/schedule-change-request.entity.ts");
const schedule_change_listener_1 = __webpack_require__(/*! ./listener/schedule-change.listener */ "./src/modules/shift-management/schedules/schedule-change-requests/listener/schedule-change.listener.ts");
const schedule_change_requests_controller_1 = __webpack_require__(/*! ./schedule-change-requests.controller */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.controller.ts");
const schedule_change_requests_service_1 = __webpack_require__(/*! ./schedule-change-requests.service */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.service.ts");
let ScheduleChangeRequestsModule = class ScheduleChangeRequestsModule {
};
exports.ScheduleChangeRequestsModule = ScheduleChangeRequestsModule;
exports.ScheduleChangeRequestsModule = ScheduleChangeRequestsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([schedule_change_request_entity_1.ScheduleChangeRequest, alternative_schedule_entity_1.AlternativeSchedule]),
            (0, common_1.forwardRef)(() => schedules_module_1.SchedulesModule),
        ],
        providers: [schedule_change_requests_service_1.ScheduleChangeRequestsService, schedule_change_listener_1.ScheduleChangeListener],
        exports: [
            schedule_change_requests_service_1.ScheduleChangeRequestsService,
        ],
        controllers: [schedule_change_requests_controller_1.ScheduleChangeRequestsController],
    })
], ScheduleChangeRequestsModule);


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.service.ts":
/*!*************************************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.service.ts ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ScheduleChangeRequestsService_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeRequestsService = void 0;
const request_status_enum_1 = __webpack_require__(/*! @/common/enums/request-status.enum */ "./src/common/enums/request-status.enum.ts");
const schedule_status_1 = __webpack_require__(/*! @/common/enums/schedule-status */ "./src/common/enums/schedule-status.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const schedule_entity_1 = __webpack_require__(/*! ../entities/schedule.entity */ "./src/modules/shift-management/schedules/entities/schedule.entity.ts");
const schedules_service_1 = __webpack_require__(/*! ../schedules.service */ "./src/modules/shift-management/schedules/schedules.service.ts");
const alternative_schedule_entity_1 = __webpack_require__(/*! ./entities/alternative-schedule.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/entities/alternative-schedule.entity.ts");
const schedule_change_request_entity_1 = __webpack_require__(/*! ./entities/schedule-change-request.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/entities/schedule-change-request.entity.ts");
let ScheduleChangeRequestsService = ScheduleChangeRequestsService_1 = class ScheduleChangeRequestsService extends base_service_1.BaseService {
    constructor(scheduleChangeRequestsRepository, alternativeSchedulesRepository, schedulesService, usersService) {
        super(scheduleChangeRequestsRepository, usersService);
        this.scheduleChangeRequestsRepository = scheduleChangeRequestsRepository;
        this.alternativeSchedulesRepository = alternativeSchedulesRepository;
        this.schedulesService = schedulesService;
        this.usersService = usersService;
        this.logger = new common_1.Logger(ScheduleChangeRequestsService_1.name);
    }
    async validateScheduleChangeRequest(dto) {
        if (!dto.originalSchedules || dto.originalSchedules.length === 0) {
            throw new common_1.BadRequestException('Original schedules must be specified');
        }
        if (!dto.alternativeSchedules || dto.alternativeSchedules.length === 0) {
            throw new common_1.BadRequestException('Alternative schedules must be specified');
        }
        // Fetch the original schedules to validate
        const scheduleIds = dto.originalSchedules.map(s => s.id).filter(Boolean);
        const schedules = await this.schedulesService.getRepository().find({
            where: { id: (0, typeorm_2.In)(scheduleIds) },
            relations: ['attendance']
        });
        if (schedules.length !== scheduleIds.length) {
            throw new common_1.BadRequestException('One or more schedules do not exist');
        }
        // Check schedules are in the future
        const now = new Date();
        now.setHours(0, 0, 0, 0); // Start of today
        for (const schedule of schedules) {
            // Check schedule is in the future
            const scheduleDate = new Date(schedule.date);
            if (scheduleDate <= now) {
                throw new common_1.BadRequestException(`Cannot change schedules from the past or today (${schedule.date})`);
            }
            // Check for attendance
            if (schedule.attendance) {
                throw new common_1.BadRequestException(`Cannot change schedule (${schedule.date}) that already has attendance records`);
            }
        }
    }
    async create(createDto, createdBy) {
        await this.validateScheduleChangeRequest(createDto);
        return super.create(createDto, createdBy);
    }
    async update(id, updateDto, updatedBy) {
        if (updateDto.originalSchedules || updateDto.alternativeSchedules) {
            // Get existing request to check status
            const existingRequest = await this.findOneByOrFail({ id });
            if (existingRequest.status !== request_status_enum_1.RequestStatus.PENDING) {
                throw new common_1.BadRequestException(`Cannot modify schedules for a request that is ${existingRequest.status}`);
            }
            await this.validateScheduleChangeRequest(Object.assign(Object.assign({}, existingRequest), updateDto));
        }
        return super.update(id, updateDto, updatedBy);
    }
    async applyScheduleChanges(scheduleChangeRequestId, userId) {
        const request = await this.scheduleChangeRequestsRepository.findOne({
            where: { id: scheduleChangeRequestId },
            relations: ['originalSchedules', 'alternativeSchedules']
        });
        if (!request) {
            throw new common_1.NotFoundException('Schedule change request not found');
        }
        if (request.status !== request_status_enum_1.RequestStatus.APPROVED) {
            throw new common_1.BadRequestException('Cannot apply changes for a request that is not approved');
        }
        // Start a transaction
        await this.schedulesService.getRepository().manager.transaction(async (transactionalEntityManager) => {
            try {
                // Get the employee ID and other details from the first original schedule
                const firstSchedule = request.originalSchedules[0];
                const employeeData = await this.schedulesService.getRepository().findOne({
                    where: { id: firstSchedule.id },
                    relations: ['employee', 'shift', 'cutoff']
                });
                if (!employeeData || !employeeData.employee) {
                    throw new common_1.BadRequestException('Cannot find employee data for the schedules');
                }
                // Soft delete original schedules
                for (const schedule of request.originalSchedules) {
                    await transactionalEntityManager.update(schedule_entity_1.Schedule, schedule.id, {
                        deletedAt: new Date(),
                        deletedBy: userId,
                        status: schedule_status_1.ScheduleStatus.CANCELLED
                    });
                    this.logger.log(`Removed original schedule ${schedule.id}`);
                }
                // Create new schedules from alternatives
                for (const alternative of request.alternativeSchedules) {
                    const newSchedule = transactionalEntityManager.create(schedule_entity_1.Schedule, {
                        date: alternative.date,
                        startTime: alternative.startTime,
                        endTime: alternative.endTime,
                        breakTime: alternative.breakTime,
                        notes: alternative.notes || `Created from change request ${request.id}`,
                        status: schedule_status_1.ScheduleStatus.MODIFIED,
                        employee: employeeData.employee,
                        shift: employeeData.shift,
                        cutoff: employeeData.cutoff,
                        createdBy: userId
                    });
                    const savedSchedule = await transactionalEntityManager.save(schedule_entity_1.Schedule, newSchedule);
                    this.logger.log(`Created alternative schedule ${savedSchedule.id}`);
                    // Link the alternative to the resulting schedule
                    await transactionalEntityManager.update(alternative_schedule_entity_1.AlternativeSchedule, alternative.id, {
                        resultingSchedule: savedSchedule
                    });
                }
                this.logger.log(`Successfully applied schedule changes for request ${scheduleChangeRequestId}`);
            }
            catch (error) {
                this.logger.error(`Failed to apply schedule changes: ${error.message}`, error.stack);
                throw error;
            }
        });
    }
};
exports.ScheduleChangeRequestsService = ScheduleChangeRequestsService;
exports.ScheduleChangeRequestsService = ScheduleChangeRequestsService = ScheduleChangeRequestsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(schedule_change_request_entity_1.ScheduleChangeRequest)),
    __param(1, (0, typeorm_1.InjectRepository)(alternative_schedule_entity_1.AlternativeSchedule)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _c : Object, typeof (_d = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _d : Object])
], ScheduleChangeRequestsService);


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/dtos/schedule-change-response.dto.ts":
/*!****************************************************************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/dtos/schedule-change-response.dto.ts ***!
  \****************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetScheduleChangeResponseDto = exports.UpdateScheduleChangeResponseDto = exports.ScheduleChangeResponseDto = void 0;
const base_dto_1 = __webpack_require__(/*! @/common/dtos/base.dto */ "./src/common/dtos/base.dto.ts");
const reference_dto_1 = __webpack_require__(/*! @/common/dtos/reference.dto */ "./src/common/dtos/reference.dto.ts");
const create_get_dto_factory_1 = __webpack_require__(/*! @/common/factories/create-get-dto.factory */ "./src/common/factories/create-get-dto.factory.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class ScheduleChangeResponseDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.ScheduleChangeResponseDto = ScheduleChangeResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the schedule change request is approved',
        example: true
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ScheduleChangeResponseDto.prototype, "approved", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Response message for the schedule change request',
        example: 'Your schedule change has been approved.'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ScheduleChangeResponseDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID of the associated schedule change request',
        type: reference_dto_1.ReferenceDto,
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_a = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _a : Object)
], ScheduleChangeResponseDto.prototype, "scheduleChangeRequest", void 0);
class UpdateScheduleChangeResponseDto extends (0, swagger_1.PartialType)(ScheduleChangeResponseDto) {
}
exports.UpdateScheduleChangeResponseDto = UpdateScheduleChangeResponseDto;
class GetScheduleChangeResponseDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateScheduleChangeResponseDto, 'schedule change response') {
}
exports.GetScheduleChangeResponseDto = GetScheduleChangeResponseDto;


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/entities/schedule-change-response.entity.ts":
/*!***********************************************************************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/entities/schedule-change-response.entity.ts ***!
  \***********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeResponse = void 0;
const base_entity_1 = __webpack_require__(/*! @/database/entities/base.entity */ "./src/database/entities/base.entity.ts");
const typeorm_1 = __webpack_require__(/*! typeorm */ "typeorm");
const schedule_change_request_entity_1 = __webpack_require__(/*! ../../entities/schedule-change-request.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/entities/schedule-change-request.entity.ts");
let ScheduleChangeResponse = class ScheduleChangeResponse extends base_entity_1.BaseEntity {
};
exports.ScheduleChangeResponse = ScheduleChangeResponse;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Boolean)
], ScheduleChangeResponse.prototype, "approved", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], ScheduleChangeResponse.prototype, "message", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => schedule_change_request_entity_1.ScheduleChangeRequest, (scheduleChangeRequest) => scheduleChangeRequest.scheduleChangeResponse, { cascade: true }),
    (0, typeorm_1.JoinColumn)({ name: 'scheduleChangeRequestId' }),
    __metadata("design:type", typeof (_a = typeof schedule_change_request_entity_1.ScheduleChangeRequest !== "undefined" && schedule_change_request_entity_1.ScheduleChangeRequest) === "function" ? _a : Object)
], ScheduleChangeResponse.prototype, "scheduleChangeRequest", void 0);
exports.ScheduleChangeResponse = ScheduleChangeResponse = __decorate([
    (0, typeorm_1.Entity)('schedule-change-responses')
], ScheduleChangeResponse);


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/schedule-change-responses.controller.ts":
/*!*******************************************************************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/schedule-change-responses.controller.ts ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeResponsesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const schedule_change_response_dto_1 = __webpack_require__(/*! ./dtos/schedule-change-response.dto */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/dtos/schedule-change-response.dto.ts");
const schedule_change_response_entity_1 = __webpack_require__(/*! ./entities/schedule-change-response.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/entities/schedule-change-response.entity.ts");
const schedule_change_responses_service_1 = __webpack_require__(/*! ./schedule-change-responses.service */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/schedule-change-responses.service.ts");
class ScheduleChangeResponsesController extends (0, create_controller_factory_1.createController)(schedule_change_response_entity_1.ScheduleChangeResponse, schedule_change_responses_service_1.ScheduleChangeResponsesService, schedule_change_response_dto_1.GetScheduleChangeResponseDto, schedule_change_response_dto_1.ScheduleChangeResponseDto, schedule_change_response_dto_1.UpdateScheduleChangeResponseDto) {
    async delete(id) {
        return await super.delete(id);
    }
    async deleteMany(ids, hardDelete) {
        return await super.deleteMany(ids, hardDelete);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    async findOne(fieldsString, relations, select) {
        return await super.findOne(fieldsString, relations, select);
    }
}
exports.ScheduleChangeResponsesController = ScheduleChangeResponsesController;


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/schedule-change-responses.module.ts":
/*!***************************************************************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/schedule-change-responses.module.ts ***!
  \***************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeResponsesModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const schedule_change_response_entity_1 = __webpack_require__(/*! ./entities/schedule-change-response.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/entities/schedule-change-response.entity.ts");
const schedule_change_responses_controller_1 = __webpack_require__(/*! ./schedule-change-responses.controller */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/schedule-change-responses.controller.ts");
const schedule_change_responses_service_1 = __webpack_require__(/*! ./schedule-change-responses.service */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/schedule-change-responses.service.ts");
const schedule_change_requests_module_1 = __webpack_require__(/*! ../schedule-change-requests.module */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.module.ts");
let ScheduleChangeResponsesModule = class ScheduleChangeResponsesModule {
};
exports.ScheduleChangeResponsesModule = ScheduleChangeResponsesModule;
exports.ScheduleChangeResponsesModule = ScheduleChangeResponsesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([schedule_change_response_entity_1.ScheduleChangeResponse]),
            schedule_change_requests_module_1.ScheduleChangeRequestsModule,
        ],
        providers: [schedule_change_responses_service_1.ScheduleChangeResponsesService],
        exports: [schedule_change_responses_service_1.ScheduleChangeResponsesService],
        controllers: [schedule_change_responses_controller_1.ScheduleChangeResponsesController],
    })
], ScheduleChangeResponsesModule);


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/schedule-change-responses.service.ts":
/*!****************************************************************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/schedule-change-responses.service.ts ***!
  \****************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeResponsesService = void 0;
const schedule_change_event_1 = __webpack_require__(/*! @/common/events/schedule-change.event */ "./src/common/events/schedule-change.event.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const schedule_change_requests_service_1 = __webpack_require__(/*! ../schedule-change-requests.service */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.service.ts");
const schedule_change_response_entity_1 = __webpack_require__(/*! ./entities/schedule-change-response.entity */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/entities/schedule-change-response.entity.ts");
let ScheduleChangeResponsesService = class ScheduleChangeResponsesService extends base_service_1.BaseService {
    constructor(scheduleChangeResponsesRepository, usersService, scheduleChangeRequestsService, eventEmitter) {
        super(scheduleChangeResponsesRepository, usersService);
        this.scheduleChangeResponsesRepository = scheduleChangeResponsesRepository;
        this.usersService = usersService;
        this.scheduleChangeRequestsService = scheduleChangeRequestsService;
        this.eventEmitter = eventEmitter;
    }
    async validateBefore(dto) {
        dto = await this.validateReferences(dto, [
            {
                field: 'scheduleChangeRequest',
                service: this.scheduleChangeRequestsService,
                required: true
            }
        ]);
    }
    async create(createDto, createdBy) {
        var _a;
        const scheduleChangeResponse = await super.create(createDto, createdBy);
        this.eventEmitter.emit(schedule_change_event_1.SCHEDULE_CHANGE_EVENTS.SCHEDULE_CHANGE_RESPONDED, new schedule_change_event_1.ScheduleChangeRespondedEvent((_a = createDto.scheduleChangeRequest) === null || _a === void 0 ? void 0 : _a.id, createDto.approved, createdBy));
        return scheduleChangeResponse;
    }
    async update(id, updateDto, updatedBy) {
        var _a;
        const scheduleChangeResponse = await super.update(id, updateDto, updatedBy);
        this.eventEmitter.emit(schedule_change_event_1.SCHEDULE_CHANGE_EVENTS.SCHEDULE_CHANGE_RESPONDED, new schedule_change_event_1.ScheduleChangeRespondedEvent((_a = updateDto.scheduleChangeRequest) === null || _a === void 0 ? void 0 : _a.id, updateDto.approved, updatedBy));
        return scheduleChangeResponse;
    }
};
exports.ScheduleChangeResponsesService = ScheduleChangeResponsesService;
exports.ScheduleChangeResponsesService = ScheduleChangeResponsesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(schedule_change_response_entity_1.ScheduleChangeResponse)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof schedule_change_requests_service_1.ScheduleChangeRequestsService !== "undefined" && schedule_change_requests_service_1.ScheduleChangeRequestsService) === "function" ? _c : Object, typeof (_d = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _d : Object])
], ScheduleChangeResponsesService);


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedules.controller.ts":
/*!************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedules.controller.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SchedulesController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const schedule_dto_1 = __webpack_require__(/*! ./dtos/schedule.dto */ "./src/modules/shift-management/schedules/dtos/schedule.dto.ts");
const schedule_entity_1 = __webpack_require__(/*! ./entities/schedule.entity */ "./src/modules/shift-management/schedules/entities/schedule.entity.ts");
const schedules_service_1 = __webpack_require__(/*! ./schedules.service */ "./src/modules/shift-management/schedules/schedules.service.ts");
class SchedulesController extends (0, create_controller_factory_1.createController)(schedule_entity_1.Schedule, schedules_service_1.SchedulesService, schedule_dto_1.GetScheduleDto, schedule_dto_1.ScheduleDto, schedule_dto_1.UpdateScheduleDto) {
    async create(entityDto, createdById) {
        return super.create(entityDto, createdById);
    }
    async update(id, entityDto, updatedById) {
        return super.update(id, entityDto, updatedById);
    }
    async findOne(fieldsString, relations, select) {
        return super.findOne(fieldsString, relations, select);
    }
    async delete(id) {
        return super.delete(id);
    }
}
exports.SchedulesController = SchedulesController;


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedules.module.ts":
/*!********************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedules.module.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SchedulesModule = void 0;
const cutoffs_module_1 = __webpack_require__(/*! @/modules/payroll-management/cutoffs/cutoffs.module */ "./src/modules/payroll-management/cutoffs/cutoffs.module.ts");
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const employee_management_module_1 = __webpack_require__(/*! ../../employee-management/employee-management.module */ "./src/modules/employee-management/employee-management.module.ts");
const groups_module_1 = __webpack_require__(/*! ../groups/groups.module */ "./src/modules/shift-management/groups/groups.module.ts");
const holidays_module_1 = __webpack_require__(/*! ../holidays/holidays.module */ "./src/modules/shift-management/holidays/holidays.module.ts");
const schedule_entity_1 = __webpack_require__(/*! ./entities/schedule.entity */ "./src/modules/shift-management/schedules/entities/schedule.entity.ts");
const schedule_change_requests_module_1 = __webpack_require__(/*! ./schedule-change-requests/schedule-change-requests.module */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.module.ts");
const schedule_change_responses_module_1 = __webpack_require__(/*! ./schedule-change-requests/schedule-change-responses/schedule-change-responses.module */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/schedule-change-responses.module.ts");
const schedules_controller_1 = __webpack_require__(/*! ./schedules.controller */ "./src/modules/shift-management/schedules/schedules.controller.ts");
const schedules_service_1 = __webpack_require__(/*! ./schedules.service */ "./src/modules/shift-management/schedules/schedules.service.ts");
const schedule_generation_service_1 = __webpack_require__(/*! ./services/schedule-generation.service */ "./src/modules/shift-management/schedules/services/schedule-generation.service.ts");
let SchedulesModule = class SchedulesModule {
};
exports.SchedulesModule = SchedulesModule;
exports.SchedulesModule = SchedulesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([schedule_entity_1.Schedule]),
            bull_1.BullModule.registerQueue({
                name: 'schedule-generation',
            }),
            schedule_change_requests_module_1.ScheduleChangeRequestsModule,
            schedule_change_responses_module_1.ScheduleChangeResponsesModule,
            cutoffs_module_1.CutoffsModule,
            employee_management_module_1.EmployeeManagementModule,
            groups_module_1.GroupsModule,
            (0, common_1.forwardRef)(() => holidays_module_1.HolidaysModule),
        ],
        providers: [schedules_service_1.SchedulesService, schedule_generation_service_1.ScheduleGenerationProcessor, schedule_generation_service_1.ScheduleGenerationService],
        exports: [
            schedules_service_1.SchedulesService,
            schedule_change_requests_module_1.ScheduleChangeRequestsModule,
            schedule_change_responses_module_1.ScheduleChangeResponsesModule,
            schedule_generation_service_1.ScheduleGenerationProcessor,
            schedule_generation_service_1.ScheduleGenerationService,
        ],
        controllers: [schedules_controller_1.SchedulesController],
    })
], SchedulesModule);


/***/ }),

/***/ "./src/modules/shift-management/schedules/schedules.service.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/shift-management/schedules/schedules.service.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SchedulesService = void 0;
const schedule_status_1 = __webpack_require__(/*! @/common/enums/schedule-status */ "./src/common/enums/schedule-status.ts");
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const day_util_1 = __webpack_require__(/*! @/common/utils/day.util */ "./src/common/utils/day.util.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const date_fns_1 = __webpack_require__(/*! date-fns */ "date-fns");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const employees_service_1 = __webpack_require__(/*! ../../employee-management/employees.service */ "./src/modules/employee-management/employees.service.ts");
const cutoffs_service_1 = __webpack_require__(/*! ../../payroll-management/cutoffs/cutoffs.service */ "./src/modules/payroll-management/cutoffs/cutoffs.service.ts");
const groups_service_1 = __webpack_require__(/*! ../groups/groups.service */ "./src/modules/shift-management/groups/groups.service.ts");
const holidays_service_1 = __webpack_require__(/*! ../holidays/holidays.service */ "./src/modules/shift-management/holidays/holidays.service.ts");
const schedule_entity_1 = __webpack_require__(/*! ./entities/schedule.entity */ "./src/modules/shift-management/schedules/entities/schedule.entity.ts");
let SchedulesService = class SchedulesService extends base_service_1.BaseService {
    constructor(schedulesRepository, usersService, groupsService, cutoffsService, holidaysService, employeesService) {
        super(schedulesRepository, usersService);
        this.schedulesRepository = schedulesRepository;
        this.usersService = usersService;
        this.groupsService = groupsService;
        this.cutoffsService = cutoffsService;
        this.holidaysService = holidaysService;
        this.employeesService = employeesService;
    }
    async validateBefore(dto) {
        // Validate that the employee exists
        dto = await this.validateReferences(dto, [
            {
                field: 'employee',
                service: this.employeesService,
                required: true
            }
        ]);
    }
    async getEmployeeScheduleToday(employeeId) {
        return await this.schedulesRepository.findOne({
            where: {
                employee: { id: employeeId },
                date: (0, date_fns_1.parseISO)((0, date_fns_1.format)(new Date(), 'yyyy-MM-dd'))
            },
            relations: { shift: { days: true }, cutoff: true, holiday: true, employee: true }
        });
    }
    /**
     * Delete future schedules (starting from tomorrow) for employees in a specific group and cutoff
     * Uses hard delete to permanently remove the records
     */
    async deleteSchedules(params) {
        const { employeeIds, groupId, cutoffId } = params;
        // Get tomorrow's date
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(0, 0, 0, 0); // Set to beginning of day
        try {
            // Delete schedules matching our criteria, but only from tomorrow onwards
            const result = await this.schedulesRepository.delete({
                employee: { id: (0, typeorm_2.In)(employeeIds) },
                cutoff: { id: cutoffId },
                date: (0, typeorm_2.MoreThanOrEqual)(tomorrow)
            });
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Failed to delete future schedules: ${error.message}`, error.stack);
            }
            else {
                this.logger.error(`Failed to delete future schedules: Unknown error`);
            }
            throw error;
        }
    }
    async generateSchedulesForEmployees(employeeIds, groupId, cutoffId) {
        this.logger.log(`Generating schedules for ${employeeIds.length} employees in group ${groupId}`);
        // Get the group with shift
        const group = await this.groupsService.findOneByOrFail({ id: groupId }, { relations: { shift: true } });
        if (!group.shift) {
            throw new common_1.NotFoundException(`${group.name} has no shift assigned`);
        }
        // Get cutoff
        const cutoff = await this.cutoffsService.findOneByOrFail({ id: cutoffId });
        // Get employees
        const employees = await this.employeesService.getRepository().findBy({
            id: (0, typeorm_2.In)(employeeIds)
        });
        // Generate schedules for each employee
        const generatedSchedules = [];
        for (const employee of employees) {
            const schedules = await this.generateSchedulesForEmployee(employee, group.shift, cutoff);
            generatedSchedules.push(...schedules);
        }
        // Save all generated schedules
        return this.schedulesRepository.save(generatedSchedules);
    }
    async generateSchedulesForEmployee(employee, shift, cutoff) {
        const { startDate, endDate } = cutoff;
        const { commencementDate } = employee;
        const schedules = [];
        // Delete existing schedules for this employee and cutoff
        await this.deleteSchedules({
            employeeIds: [employee.id],
            groupId: employee.group.id,
            cutoffId: cutoff.id,
        });
        // Get today and tomorrow dates
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);
        // Parse dates
        const parsedCommencementDate = (0, date_fns_1.parseISO)(commencementDate.toString());
        const parsedCutoffStartDate = (0, date_fns_1.parseISO)(startDate.toString());
        // Determine effective start date based on the new logic:
        // - If cutoff start date is in the future, use it
        // - Otherwise use tomorrow
        let baseStartDate;
        if (parsedCutoffStartDate > today) {
            this.logger.log(`Using future cutoff start date: ${(0, date_fns_1.format)(parsedCutoffStartDate, 'yyyy-MM-dd')}`);
            baseStartDate = parsedCutoffStartDate;
        }
        else {
            this.logger.log(`Cutoff already started, using tomorrow: ${(0, date_fns_1.format)(tomorrow, 'yyyy-MM-dd')}`);
            baseStartDate = tomorrow;
        }
        // Still respect employee's commencement date
        let effectiveStartDate = new Date(Math.max(baseStartDate.getTime(), parsedCommencementDate.getTime()));
        this.logger.log(`Effective schedule start date: ${(0, date_fns_1.format)(effectiveStartDate, 'yyyy-MM-dd')}`);
        // Generate schedule for each day in the cutoff period
        let currentDate = new Date(effectiveStartDate);
        const cutoffEndDate = new Date(endDate);
        while ((0, date_fns_1.isBefore)(currentDate, cutoffEndDate) || (0, date_fns_1.isSameDay)(currentDate, cutoffEndDate)) {
            const dayOfWeek = day_util_1.DayUtils.fromDate(currentDate);
            // Find if this day is in the shift's schedule
            const shiftDay = shift.days.find(day => day.day === dayOfWeek);
            if (shiftDay) {
                // Check if the current date is a holiday
                const holiday = await this.holidaysService.findOneBy({
                    date: currentDate
                });
                // Create a schedule entry with specific shift details for this day
                const scheduleEntry = {
                    date: new Date(currentDate),
                    status: schedule_status_1.ScheduleStatus.DEFAULT,
                    employee: { id: employee.id },
                    shift: { id: shift.id },
                    cutoff: { id: cutoff.id },
                    startTime: shiftDay.startTime || shift.defaultStartTime,
                    endTime: shiftDay.endTime || shift.defaultEndTime,
                    breakTime: shiftDay.breakTime || shift.defaultBreakTime,
                    duration: shiftDay.duration || shift.defaultDuration,
                    organizationId: employee.organizationId,
                    userId: employee.userId,
                    departmentId: employee.departmentId,
                    branchId: employee.branchId,
                };
                // If it's a holiday, associate it with the schedule
                if (holiday) {
                    scheduleEntry.holiday = holiday;
                }
                schedules.push(scheduleEntry);
            }
            // Move to the next day
            currentDate = (0, date_fns_1.addDays)(currentDate, 1);
        }
        return schedules;
    }
    // Check if a schedule already exists
    async findExistingSchedules(employeeId, cutoffId, startDate, endDate) {
        return this.schedulesRepository.find({
            where: {
                employee: { id: employeeId },
                cutoff: { id: cutoffId },
                date: (0, typeorm_2.Between)(startDate, endDate),
            },
        });
    }
};
exports.SchedulesService = SchedulesService;
exports.SchedulesService = SchedulesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(schedule_entity_1.Schedule)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof groups_service_1.GroupsService !== "undefined" && groups_service_1.GroupsService) === "function" ? _c : Object, typeof (_d = typeof cutoffs_service_1.CutoffsService !== "undefined" && cutoffs_service_1.CutoffsService) === "function" ? _d : Object, typeof (_e = typeof holidays_service_1.HolidaysService !== "undefined" && holidays_service_1.HolidaysService) === "function" ? _e : Object, typeof (_f = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _f : Object])
], SchedulesService);


/***/ }),

/***/ "./src/modules/shift-management/schedules/services/schedule-generation.service.ts":
/*!****************************************************************************************!*\
  !*** ./src/modules/shift-management/schedules/services/schedule-generation.service.ts ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ScheduleGenerationService_1, ScheduleGenerationProcessor_1;
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleGenerationProcessor = exports.ScheduleGenerationService = void 0;
const employee_assigned_event_1 = __webpack_require__(/*! @/common/events/employee-assigned.event */ "./src/common/events/employee-assigned.event.ts");
const bull_1 = __webpack_require__(/*! @nestjs/bull */ "@nestjs/bull");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const event_emitter_1 = __webpack_require__(/*! @nestjs/event-emitter */ "@nestjs/event-emitter");
const bull_2 = __webpack_require__(/*! bull */ "bull");
const schedules_service_1 = __webpack_require__(/*! ../schedules.service */ "./src/modules/shift-management/schedules/schedules.service.ts");
let ScheduleGenerationService = ScheduleGenerationService_1 = class ScheduleGenerationService {
    constructor(scheduleQueue) {
        this.scheduleQueue = scheduleQueue;
        this.logger = new common_1.Logger(ScheduleGenerationService_1.name);
    }
    async addGenerationJob(data) {
        this.logger.log(`Adding schedule generation job for ${data.employeeIds.length} employees in group ${data.groupId}`);
        return this.scheduleQueue.add('generate', data);
    }
};
exports.ScheduleGenerationService = ScheduleGenerationService;
exports.ScheduleGenerationService = ScheduleGenerationService = ScheduleGenerationService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, bull_1.InjectQueue)('schedule-generation')),
    __metadata("design:paramtypes", [typeof (_a = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _a : Object])
], ScheduleGenerationService);
let ScheduleGenerationProcessor = ScheduleGenerationProcessor_1 = class ScheduleGenerationProcessor {
    constructor(schedulesService, eventEmitter) {
        this.schedulesService = schedulesService;
        this.eventEmitter = eventEmitter;
        this.logger = new common_1.Logger(ScheduleGenerationProcessor_1.name);
    }
    async processScheduleGeneration(job) {
        this.logger.log(`Processing schedule generation job ${job.id}`);
        const { employeeIds, groupId, cutoffId, requestedBy } = job.data;
        try {
            const result = await this.schedulesService.generateSchedulesForEmployees(employeeIds, groupId, cutoffId);
            this.eventEmitter.emit(employee_assigned_event_1.SCHEDULE_EVENTS.GENERATION_COMPLETED, {
                jobId: job.id,
                employeeIds,
                groupId,
                cutoffId,
                schedulesGenerated: result.length,
                requestedBy,
            });
            this.logger.log(`Generated ${result.length} schedules for job ${job.id}`);
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Schedule generation failed for job ${job.id}: ${error.message}`, error.stack);
                this.eventEmitter.emit(employee_assigned_event_1.SCHEDULE_EVENTS.GENERATION_FAILED, {
                    jobId: job.id,
                    employeeIds,
                    groupId,
                    cutoffId,
                    error: error.message,
                    requestedBy,
                });
            }
            else {
                this.logger.error(`Schedule generation failed for job ${job.id}: Unknown error`);
                this.eventEmitter.emit(employee_assigned_event_1.SCHEDULE_EVENTS.GENERATION_FAILED, {
                    jobId: job.id,
                    employeeIds,
                    groupId,
                    cutoffId,
                    error: 'Unknown error',
                    requestedBy,
                });
            }
            throw error;
        }
    }
};
exports.ScheduleGenerationProcessor = ScheduleGenerationProcessor;
__decorate([
    (0, bull_1.Process)('generate'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof bull_2.Job !== "undefined" && bull_2.Job) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], ScheduleGenerationProcessor.prototype, "processScheduleGeneration", null);
exports.ScheduleGenerationProcessor = ScheduleGenerationProcessor = ScheduleGenerationProcessor_1 = __decorate([
    (0, bull_1.Processor)('schedule-generation'),
    __metadata("design:paramtypes", [typeof (_b = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _b : Object, typeof (_c = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _c : Object])
], ScheduleGenerationProcessor);


/***/ }),

/***/ "./src/modules/shift-management/services/default-shift-seeder.service.ts":
/*!*******************************************************************************!*\
  !*** ./src/modules/shift-management/services/default-shift-seeder.service.ts ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var DefaultShiftsSeeder_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultShiftsSeeder = void 0;
const day_enum_1 = __webpack_require__(/*! @/common/enums/day.enum */ "./src/common/enums/day.enum.ts");
const cutoff_status_enum_1 = __webpack_require__(/*! @/common/enums/payroll/cutoff-status.enum */ "./src/common/enums/payroll/cutoff-status.enum.ts");
const cutoffs_service_1 = __webpack_require__(/*! @/modules/payroll-management/cutoffs/cutoffs.service */ "./src/modules/payroll-management/cutoffs/cutoffs.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const groups_service_1 = __webpack_require__(/*! ../groups/groups.service */ "./src/modules/shift-management/groups/groups.service.ts");
const shifts_service_1 = __webpack_require__(/*! ../shifts.service */ "./src/modules/shift-management/shifts.service.ts");
let DefaultShiftsSeeder = DefaultShiftsSeeder_1 = class DefaultShiftsSeeder {
    constructor(shiftsService, groupsService, cutoffsService) {
        this.shiftsService = shiftsService;
        this.groupsService = groupsService;
        this.cutoffsService = cutoffsService;
        this.logger = new common_1.Logger(DefaultShiftsSeeder_1.name);
    }
    async onModuleInit() {
        await this.seed();
    }
    async seed() {
        // this.logger.log('Seeding default shifts and groups...');
        // Check if default shift already exists
        const existingShifts = await this.shiftsService.getRepository().count();
        if (existingShifts > 0) {
            // this.logger.log('Shifts already exist, skipping seeder');
            return;
        }
        // Find or create a default cutoff to associate with shifts
        let defaultCutoff = await this.cutoffsService.findOneBy({
            status: cutoff_status_enum_1.CutoffStatus.PENDING
        }) || await this.cutoffsService.getActiveCutoff();
        if (!defaultCutoff) {
            throw new Error('No active cutoff found. Please create a cutoff first.');
        }
        // Common reference for cutoff
        const cutoffRef = { id: defaultCutoff.id };
        const weekdays = [day_enum_1.Day.MONDAY, day_enum_1.Day.TUESDAY, day_enum_1.Day.WEDNESDAY, day_enum_1.Day.THURSDAY, day_enum_1.Day.FRIDAY];
        // 1. Create standard day shift
        await this.createDayShift(weekdays, cutoffRef);
        // 2. Create night shift with overnight flag
        await this.createNightShift(weekdays, cutoffRef);
        // 3. Create graveyard shift
        await this.createGraveyardShift(weekdays, cutoffRef);
        // 4. Create weekend shift
        await this.createWeekendShift(cutoffRef);
        // 5. Create flexible shift
        await this.createFlexibleShift(cutoffRef);
        this.logger.log('Successfully seeded all default shifts and groups');
    }
    async createDayShift(weekdays, cutoffRef) {
        // Create shift days array for cascade insertion
        const dayShifts = weekdays.map(day => ({
            day,
            startTime: '09:00:00',
            endTime: '18:00:00',
            breakTime: 60,
            duration: 8,
            isOvernight: false,
        }));
        // Create shift with days using cascade
        const dayShift = await this.shiftsService.create({
            name: 'Standard Day Shift',
            description: 'Regular 9-6 workday with 1 hour break',
            defaultStartTime: '09:00:00',
            defaultEndTime: '18:00:00',
            defaultBreakTime: 60,
            defaultDuration: 8,
            days: dayShifts,
            cutoffs: [cutoffRef]
        });
        this.logger.log(`Created day shift: ${dayShift.id}`);
        // Create default group for day shift
        const dayGroup = await this.groupsService.create({
            name: 'Standard Day Shift Group',
            description: 'Default group working standard office hours',
            shift: { id: dayShift.id },
        });
        this.logger.log(`Created day shift group: ${dayGroup.id}`);
        return dayShift;
    }
    async createNightShift(weekdays, cutoffRef) {
        // Create shift days array for cascade insertion
        const nightShiftDays = weekdays.map(day => ({
            day,
            startTime: '16:00:00',
            endTime: '00:00:00',
            breakTime: 45,
            duration: 7.25,
            isOvernight: true, // This shift crosses midnight
        }));
        // Create shift with days using cascade
        const nightShift = await this.shiftsService.create({
            name: 'Night Shift',
            description: 'Evening to midnight shift',
            defaultStartTime: '16:00:00',
            defaultEndTime: '00:00:00',
            defaultBreakTime: 45,
            defaultDuration: 7.25,
            days: nightShiftDays,
            cutoffs: [cutoffRef]
        });
        this.logger.log(`Created night shift: ${nightShift.id}`);
        // Create night shift group
        const nightGroup = await this.groupsService.create({
            name: 'Night Shift Group',
            description: 'Group working evening to midnight hours',
            shift: { id: nightShift.id },
        });
        this.logger.log(`Created night shift group: ${nightGroup.id}`);
        return nightShift;
    }
    async createGraveyardShift(weekdays, cutoffRef) {
        // Create shift days array for cascade insertion
        const graveyardShiftDays = weekdays.map(day => ({
            day,
            startTime: '00:00:00',
            endTime: '08:00:00',
            breakTime: 30,
            duration: 7.5,
            isOvernight: false,
        }));
        // Create shift with days using cascade
        const graveyardShift = await this.shiftsService.create({
            name: 'Graveyard Shift',
            description: 'Midnight to morning shift',
            defaultStartTime: '00:00:00',
            defaultEndTime: '08:00:00',
            defaultBreakTime: 30,
            defaultDuration: 7.5,
            days: graveyardShiftDays,
            cutoffs: [cutoffRef]
        });
        this.logger.log(`Created graveyard shift: ${graveyardShift.id}`);
        // Create graveyard shift group
        const graveyardGroup = await this.groupsService.create({
            name: 'Graveyard Shift Group',
            description: 'Group working overnight hours',
            shift: { id: graveyardShift.id },
        });
        this.logger.log(`Created graveyard shift group: ${graveyardGroup.id}`);
        return graveyardShift;
    }
    async createWeekendShift(cutoffRef) {
        // Create shift days array for cascade insertion
        const weekendShiftDays = [day_enum_1.Day.SATURDAY, day_enum_1.Day.SUNDAY].map(day => ({
            day,
            startTime: '10:00:00',
            endTime: '16:00:00',
            breakTime: 30,
            duration: 5.5,
            isOvernight: false,
        }));
        // Create shift with days using cascade
        const weekendShift = await this.shiftsService.create({
            name: 'Weekend Shift',
            description: 'Weekend coverage with different hours',
            defaultStartTime: '10:00:00',
            defaultEndTime: '16:00:00',
            defaultBreakTime: 30,
            defaultDuration: 5.5,
            days: weekendShiftDays,
            cutoffs: [cutoffRef]
        });
        this.logger.log(`Created weekend shift: ${weekendShift.id}`);
        // Create weekend shift group
        const weekendGroup = await this.groupsService.create({
            name: 'Weekend Shift Group',
            description: 'Group working weekend hours',
            shift: { id: weekendShift.id },
        });
        this.logger.log(`Created weekend shift group: ${weekendGroup.id}`);
        return weekendShift;
    }
    async createFlexibleShift(cutoffRef) {
        // Define different schedules for each day
        const flexSchedules = [
            { day: day_enum_1.Day.MONDAY, start: '08:00:00', end: '16:00:00', break: 60, duration: 7 },
            { day: day_enum_1.Day.TUESDAY, start: '09:00:00', end: '17:00:00', break: 45, duration: 7.25 },
            { day: day_enum_1.Day.WEDNESDAY, start: '10:00:00', end: '18:00:00', break: 45, duration: 7.25 },
            { day: day_enum_1.Day.THURSDAY, start: '09:00:00', end: '17:00:00', break: 45, duration: 7.25 },
            { day: day_enum_1.Day.FRIDAY, start: '08:00:00', end: '14:00:00', break: 30, duration: 5.5 },
        ];
        // Create shift days array for cascade insertion
        const flexShiftDays = flexSchedules.map(schedule => ({
            day: schedule.day,
            startTime: schedule.start,
            endTime: schedule.end,
            breakTime: schedule.break,
            duration: schedule.duration,
            isOvernight: false,
        }));
        // Create shift with days using cascade
        const flexShift = await this.shiftsService.create({
            name: 'Flexible Shift',
            description: 'Different hours each day of the week',
            defaultStartTime: '09:00:00',
            defaultEndTime: '17:00:00',
            defaultBreakTime: 45,
            defaultDuration: 7.25,
            days: flexShiftDays,
            cutoffs: [cutoffRef]
        });
        this.logger.log(`Created flexible shift: ${flexShift.id}`);
        // Create flexible shift group
        const flexGroup = await this.groupsService.create({
            name: 'Flexible Shift Group',
            description: 'Group with different hours each day',
            shift: { id: flexShift.id },
        });
        this.logger.log(`Created flexible shift group: ${flexGroup.id}`);
        return flexShift;
    }
};
exports.DefaultShiftsSeeder = DefaultShiftsSeeder;
exports.DefaultShiftsSeeder = DefaultShiftsSeeder = DefaultShiftsSeeder_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof shifts_service_1.ShiftsService !== "undefined" && shifts_service_1.ShiftsService) === "function" ? _a : Object, typeof (_b = typeof groups_service_1.GroupsService !== "undefined" && groups_service_1.GroupsService) === "function" ? _b : Object, typeof (_c = typeof cutoffs_service_1.CutoffsService !== "undefined" && cutoffs_service_1.CutoffsService) === "function" ? _c : Object])
], DefaultShiftsSeeder);


/***/ }),

/***/ "./src/modules/shift-management/shift-management.module.ts":
/*!*****************************************************************!*\
  !*** ./src/modules/shift-management/shift-management.module.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShiftManagementModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const cutoffs_module_1 = __webpack_require__(/*! ../payroll-management/cutoffs/cutoffs.module */ "./src/modules/payroll-management/cutoffs/cutoffs.module.ts");
const shift_day_entity_1 = __webpack_require__(/*! ./entities/shift-day.entity */ "./src/modules/shift-management/entities/shift-day.entity.ts");
const shift_entity_1 = __webpack_require__(/*! ./entities/shift.entity */ "./src/modules/shift-management/entities/shift.entity.ts");
const groups_module_1 = __webpack_require__(/*! ./groups/groups.module */ "./src/modules/shift-management/groups/groups.module.ts");
const holidays_module_1 = __webpack_require__(/*! ./holidays/holidays.module */ "./src/modules/shift-management/holidays/holidays.module.ts");
const schedule_change_requests_module_1 = __webpack_require__(/*! ./schedules/schedule-change-requests/schedule-change-requests.module */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-requests.module.ts");
const schedule_change_responses_module_1 = __webpack_require__(/*! ./schedules/schedule-change-requests/schedule-change-responses/schedule-change-responses.module */ "./src/modules/shift-management/schedules/schedule-change-requests/schedule-change-responses/schedule-change-responses.module.ts");
const schedules_module_1 = __webpack_require__(/*! ./schedules/schedules.module */ "./src/modules/shift-management/schedules/schedules.module.ts");
const default_shift_seeder_service_1 = __webpack_require__(/*! ./services/default-shift-seeder.service */ "./src/modules/shift-management/services/default-shift-seeder.service.ts");
const shifts_controller_1 = __webpack_require__(/*! ./shifts.controller */ "./src/modules/shift-management/shifts.controller.ts");
const shifts_service_1 = __webpack_require__(/*! ./shifts.service */ "./src/modules/shift-management/shifts.service.ts");
let ShiftManagementModule = class ShiftManagementModule {
};
exports.ShiftManagementModule = ShiftManagementModule;
exports.ShiftManagementModule = ShiftManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([shift_entity_1.Shift, shift_day_entity_1.ShiftDay]),
            core_1.RouterModule.register([
                {
                    path: 'shifts',
                    module: ShiftManagementModule,
                    children: [
                        {
                            path: 'schedules',
                            module: schedules_module_1.SchedulesModule,
                            children: [
                                {
                                    path: 'requests',
                                    module: schedule_change_requests_module_1.ScheduleChangeRequestsModule,
                                    children: [
                                        {
                                            path: 'responses',
                                            module: schedule_change_responses_module_1.ScheduleChangeResponsesModule,
                                        }
                                    ]
                                },
                            ]
                        },
                        {
                            path: 'groups',
                            module: groups_module_1.GroupsModule
                        },
                    ]
                },
                {
                    path: 'holiday',
                    module: holidays_module_1.HolidaysModule,
                }
            ]),
            holidays_module_1.HolidaysModule,
            schedules_module_1.SchedulesModule,
            groups_module_1.GroupsModule,
            cutoffs_module_1.CutoffsModule,
        ],
        providers: [shifts_service_1.ShiftsService, default_shift_seeder_service_1.DefaultShiftsSeeder],
        exports: [
            shifts_service_1.ShiftsService,
            holidays_module_1.HolidaysModule,
            schedules_module_1.SchedulesModule,
            groups_module_1.GroupsModule,
        ],
        controllers: [shifts_controller_1.ShiftsController],
    })
], ShiftManagementModule);


/***/ }),

/***/ "./src/modules/shift-management/shifts.controller.ts":
/*!***********************************************************!*\
  !*** ./src/modules/shift-management/shifts.controller.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShiftsController = void 0;
const create_controller_factory_1 = __webpack_require__(/*! @/common/factories/create-controller.factory */ "./src/common/factories/create-controller.factory.ts");
const shift_dto_1 = __webpack_require__(/*! ./dtos/shift.dto */ "./src/modules/shift-management/dtos/shift.dto.ts");
const shift_entity_1 = __webpack_require__(/*! ./entities/shift.entity */ "./src/modules/shift-management/entities/shift.entity.ts");
const shifts_service_1 = __webpack_require__(/*! ./shifts.service */ "./src/modules/shift-management/shifts.service.ts");
class ShiftsController extends (0, create_controller_factory_1.createController)(shift_entity_1.Shift, shifts_service_1.ShiftsService, shift_dto_1.GetShiftDto, shift_dto_1.ShiftDto, shift_dto_1.UpdateShiftDto) {
}
exports.ShiftsController = ShiftsController;


/***/ }),

/***/ "./src/modules/shift-management/shifts.service.ts":
/*!********************************************************!*\
  !*** ./src/modules/shift-management/shifts.service.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShiftsService = void 0;
const base_service_1 = __webpack_require__(/*! @/common/services/base.service */ "./src/common/services/base.service.ts");
const users_service_1 = __webpack_require__(/*! @/modules/account-management/users/users.service */ "./src/modules/account-management/users/users.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const typeorm_1 = __webpack_require__(/*! @nestjs/typeorm */ "@nestjs/typeorm");
const typeorm_2 = __webpack_require__(/*! typeorm */ "typeorm");
const shift_entity_1 = __webpack_require__(/*! ./entities/shift.entity */ "./src/modules/shift-management/entities/shift.entity.ts");
let ShiftsService = class ShiftsService extends base_service_1.BaseService {
    constructor(shiftsRepository, usersService) {
        super(shiftsRepository, usersService);
        this.shiftsRepository = shiftsRepository;
        this.usersService = usersService;
    }
};
exports.ShiftsService = ShiftsService;
exports.ShiftsService = ShiftsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(shift_entity_1.Shift)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], ShiftsService);


/***/ }),

/***/ "@bull-board/api":
/*!**********************************!*\
  !*** external "@bull-board/api" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@bull-board/api");

/***/ }),

/***/ "@bull-board/api/bullAdapter":
/*!**********************************************!*\
  !*** external "@bull-board/api/bullAdapter" ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@bull-board/api/bullAdapter");

/***/ }),

/***/ "@bull-board/express":
/*!**************************************!*\
  !*** external "@bull-board/express" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@bull-board/express");

/***/ }),

/***/ "@nestjs-modules/mailer":
/*!*****************************************!*\
  !*** external "@nestjs-modules/mailer" ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs-modules/mailer");

/***/ }),

/***/ "@nestjs-modules/mailer/dist/adapters/handlebars.adapter":
/*!**************************************************************************!*\
  !*** external "@nestjs-modules/mailer/dist/adapters/handlebars.adapter" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs-modules/mailer/dist/adapters/handlebars.adapter");

/***/ }),

/***/ "@nestjs/bull":
/*!*******************************!*\
  !*** external "@nestjs/bull" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/bull");

/***/ }),

/***/ "@nestjs/common":
/*!*********************************!*\
  !*** external "@nestjs/common" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/common");

/***/ }),

/***/ "@nestjs/config":
/*!*********************************!*\
  !*** external "@nestjs/config" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/config");

/***/ }),

/***/ "@nestjs/core":
/*!*******************************!*\
  !*** external "@nestjs/core" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/core");

/***/ }),

/***/ "@nestjs/event-emitter":
/*!****************************************!*\
  !*** external "@nestjs/event-emitter" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/event-emitter");

/***/ }),

/***/ "@nestjs/jwt":
/*!******************************!*\
  !*** external "@nestjs/jwt" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/jwt");

/***/ }),

/***/ "@nestjs/passport":
/*!***********************************!*\
  !*** external "@nestjs/passport" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/passport");

/***/ }),

/***/ "@nestjs/platform-express":
/*!*******************************************!*\
  !*** external "@nestjs/platform-express" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/platform-express");

/***/ }),

/***/ "@nestjs/schedule":
/*!***********************************!*\
  !*** external "@nestjs/schedule" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/schedule");

/***/ }),

/***/ "@nestjs/swagger":
/*!**********************************!*\
  !*** external "@nestjs/swagger" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/swagger");

/***/ }),

/***/ "@nestjs/typeorm":
/*!**********************************!*\
  !*** external "@nestjs/typeorm" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/typeorm");

/***/ }),

/***/ "@nestjs/websockets":
/*!*************************************!*\
  !*** external "@nestjs/websockets" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/websockets");

/***/ }),

/***/ "@scalar/nestjs-api-reference":
/*!***********************************************!*\
  !*** external "@scalar/nestjs-api-reference" ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@scalar/nestjs-api-reference");

/***/ }),

/***/ "bcrypt":
/*!*************************!*\
  !*** external "bcrypt" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("bcrypt");

/***/ }),

/***/ "bcryptjs":
/*!***************************!*\
  !*** external "bcryptjs" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("bcryptjs");

/***/ }),

/***/ "bull":
/*!***********************!*\
  !*** external "bull" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("bull");

/***/ }),

/***/ "class-transformer":
/*!************************************!*\
  !*** external "class-transformer" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("class-transformer");

/***/ }),

/***/ "class-validator":
/*!**********************************!*\
  !*** external "class-validator" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("class-validator");

/***/ }),

/***/ "compression":
/*!******************************!*\
  !*** external "compression" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("compression");

/***/ }),

/***/ "csv-writer":
/*!*****************************!*\
  !*** external "csv-writer" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("csv-writer");

/***/ }),

/***/ "date-fns":
/*!***************************!*\
  !*** external "date-fns" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("date-fns");

/***/ }),

/***/ "dotenv":
/*!*************************!*\
  !*** external "dotenv" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("dotenv");

/***/ }),

/***/ "exceljs":
/*!**************************!*\
  !*** external "exceljs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("exceljs");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("express");

/***/ }),

/***/ "express-rate-limit":
/*!*************************************!*\
  !*** external "express-rate-limit" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("express-rate-limit");

/***/ }),

/***/ "glob":
/*!***********************!*\
  !*** external "glob" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("glob");

/***/ }),

/***/ "handlebars":
/*!*****************************!*\
  !*** external "handlebars" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("handlebars");

/***/ }),

/***/ "helmet":
/*!*************************!*\
  !*** external "helmet" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("helmet");

/***/ }),

/***/ "joi":
/*!**********************!*\
  !*** external "joi" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("joi");

/***/ }),

/***/ "mime-types":
/*!*****************************!*\
  !*** external "mime-types" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("mime-types");

/***/ }),

/***/ "nodemailer":
/*!*****************************!*\
  !*** external "nodemailer" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("nodemailer");

/***/ }),

/***/ "passport-google-oauth20":
/*!******************************************!*\
  !*** external "passport-google-oauth20" ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("passport-google-oauth20");

/***/ }),

/***/ "passport-jwt":
/*!*******************************!*\
  !*** external "passport-jwt" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("passport-jwt");

/***/ }),

/***/ "pdfkit":
/*!*************************!*\
  !*** external "pdfkit" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("pdfkit");

/***/ }),

/***/ "pluralize":
/*!****************************!*\
  !*** external "pluralize" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("pluralize");

/***/ }),

/***/ "prom-client":
/*!******************************!*\
  !*** external "prom-client" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("prom-client");

/***/ }),

/***/ "reflect-metadata":
/*!***********************************!*\
  !*** external "reflect-metadata" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("reflect-metadata");

/***/ }),

/***/ "rxjs":
/*!***********************!*\
  !*** external "rxjs" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("rxjs");

/***/ }),

/***/ "rxjs/operators":
/*!*********************************!*\
  !*** external "rxjs/operators" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("rxjs/operators");

/***/ }),

/***/ "socket.io":
/*!****************************!*\
  !*** external "socket.io" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("socket.io");

/***/ }),

/***/ "typeorm":
/*!**************************!*\
  !*** external "typeorm" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("typeorm");

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("uuid");

/***/ }),

/***/ "web-push":
/*!***************************!*\
  !*** external "web-push" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("web-push");

/***/ }),

/***/ "zkteco-js":
/*!****************************!*\
  !*** external "zkteco-js" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("zkteco-js");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;