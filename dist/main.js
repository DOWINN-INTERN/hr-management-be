/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const api_1 = __webpack_require__(1);
const bullAdapter_1 = __webpack_require__(2); // Correct import
const express_1 = __webpack_require__(3); // Correct import
const bull_1 = __webpack_require__(4);
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const core_1 = __webpack_require__(7);
const swagger_1 = __webpack_require__(8);
const nestjs_api_reference_1 = __webpack_require__(9);
const compression_1 = __importDefault(__webpack_require__(10));
const express_rate_limit_1 = __importDefault(__webpack_require__(11));
const helmet_1 = __importDefault(__webpack_require__(12));
const app_module_1 = __webpack_require__(13);
const http_exception_filter_1 = __webpack_require__(348);
const transform_interceptor_1 = __webpack_require__(349);
const day_util_1 = __webpack_require__(154);
const swagger_config_1 = __webpack_require__(350);
const system_logger_service_1 = __webpack_require__(308);
// process.env.TZ = 'UTC';
async function bootstrap() {
    const isDevelopment = process.env.NODE_ENV !== 'production';
    // Create the app with our custom logger
    const app = await core_1.NestFactory.create(app_module_1.AppModule, {
        logger: (0, day_util_1.getLogLevels)(isDevelopment),
        bufferLogs: true, // Buffer logs until logger is set up
    });
    // Get the SystemLogger from our module
    const logger = await app.resolve(system_logger_service_1.SystemLogger);
    app.useLogger(logger);
    const configService = app.get(config_1.ConfigService);
    // Dynamically get all queues from the queues.config.ts
    const { queues } = await Promise.resolve().then(() => __importStar(__webpack_require__(170)));
    // Set up Bull Board
    const serverAdapter = new express_1.ExpressAdapter();
    const bullAdapters = queues.map(queue => new bullAdapter_1.BullAdapter(app.get((0, bull_1.getQueueToken)(queue.name))));
    (0, api_1.createBullBoard)({
        queues: bullAdapters,
        serverAdapter,
    });
    // Define the base path for Bull Board UI
    serverAdapter.setBasePath('/api/admin/queues');
    const port = configService.getOrThrow('PORT');
    const appUrl = configService.getOrThrow('APP_URL');
    const corsOrigins = configService.getOrThrow('CORS_ORIGINS');
    // Rate Limit Settings
    const rateLimitWindowMs = configService.getOrThrow('RATE_LIMIT_WINDOW_MS');
    const rateLimitMax = configService.getOrThrow('RATE_LIMIT_MAX');
    // Set global prefix for all routes in the application
    app.setGlobalPrefix('/api');
    // Add Bull Board UI routes - place this AFTER helmet and BEFORE other routes
    app.use('/api/admin/queues', serverAdapter.getRouter());
    // Global validation pipe
    app.useGlobalPipes(new common_1.ValidationPipe({
        whitelist: true, // Strip properties that do not have any decorators
        forbidNonWhitelisted: true, // Throw an error if non-whitelisted properties are present
        transform: true, // Automatically transform payloads to be objects typed according to their DTO classes
        transformOptions: {
            enableImplicitConversion: true, // Allow implicit type conversion
        },
    }));
    // Global exception filter
    app.useGlobalFilters(new http_exception_filter_1.HttpExceptionFilter());
    // Global logging interceptor (using our new logging interceptor)
    // app.useGlobalInterceptors(new LoggingInterceptor());
    // Global transform interceptor
    app.useGlobalInterceptors(new transform_interceptor_1.TransformInterceptor());
    // Enable CORS with more secure settings
    app.enableCors({
        origin: true, // specify allowed origins
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE', // specify allowed HTTP methods
        credentials: true, // allow sending cookies from the frontend to the backend (for session cookies)
    });
    // Use Helmet for security with best practices
    app.use((0, helmet_1.default)()); // Sets appropriate HTTP headers for security
    app.use(helmet_1.default.referrerPolicy({ policy: 'no-referrer' })); // when following a link, do not send the Referer header to other sites (privacy)
    // Rate limiting
    app.use((0, express_rate_limit_1.default)({
        windowMs: rateLimitWindowMs, // 15 * 60 * 1000, // 15 minutes
        max: rateLimitMax, // limit each IP to 100 requests per windowMs
        message: 'Too many requests from this IP, please try again later.',
        headers: true,
    }));
    app.use((req, res, next) => {
        res.removeHeader('Cross-Origin-Opener-Policy');
        res.removeHeader('Origin-Agent-Cluster');
        res.removeHeader('Content-Security-Policy');
        next();
    });
    // Compression middleware
    app.use((0, compression_1.default)()); // Compress all responses to reduce the size of the response body and increase the speed of a web application
    // HTTP request logger
    // app.use(morgan('combined')); // Log HTTP requests with the Apache combined format (combined is the most common format) to the console
    // Swagger Setup
    const document = swagger_1.SwaggerModule.createDocument(app, swagger_config_1.swaggerConfig); // Create a Swagger document
    swagger_1.SwaggerModule.setup('api', app, document, swagger_config_1.swaggerCustomOptions); // Set up the Swagger module
    // Scalar Setup
    app.use('/reference', (0, nestjs_api_reference_1.apiReference)({
        content: document,
    }));
    await app.listen(port, '0.0.0.0'); // Listen on all network interfaces (LAN)
    logger.log(`Application is running on: ${appUrl}/api`, 'Main');
    logger.log(`API Reference available at: ${appUrl}/reference`, 'Main');
    logger.log(`Queue monitoring available at: ${appUrl}/api/admin/queues`, 'Main');
}
bootstrap();


/***/ }),
/* 1 */
/***/ ((module) => {

"use strict";
module.exports = require("@bull-board/api");

/***/ }),
/* 2 */
/***/ ((module) => {

"use strict";
module.exports = require("@bull-board/api/bullAdapter");

/***/ }),
/* 3 */
/***/ ((module) => {

"use strict";
module.exports = require("@bull-board/express");

/***/ }),
/* 4 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/bull");

/***/ }),
/* 5 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/common");

/***/ }),
/* 6 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/config");

/***/ }),
/* 7 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/core");

/***/ }),
/* 8 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/swagger");

/***/ }),
/* 9 */
/***/ ((module) => {

"use strict";
module.exports = require("@scalar/nestjs-api-reference");

/***/ }),
/* 10 */
/***/ ((module) => {

"use strict";
module.exports = require("compression");

/***/ }),
/* 11 */
/***/ ((module) => {

"use strict";
module.exports = require("express-rate-limit");

/***/ }),
/* 12 */
/***/ ((module) => {

"use strict";
module.exports = require("helmet");

/***/ }),
/* 13 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AppModule = void 0;
const common_1 = __webpack_require__(5);
const common_module_1 = __webpack_require__(14);
const config_module_1 = __webpack_require__(168);
const database_module_1 = __webpack_require__(174);
const account_management_module_1 = __webpack_require__(175);
const addresses_module_1 = __webpack_require__(218);
const attendance_management_module_1 = __webpack_require__(220);
const biometrics_module_1 = __webpack_require__(221);
const documents_module_1 = __webpack_require__(278);
const emails_module_1 = __webpack_require__(177);
const employee_management_module_1 = __webpack_require__(15);
const files_module_1 = __webpack_require__(286);
const logs_module_1 = __webpack_require__(302);
const notifications_module_1 = __webpack_require__(312);
const organization_management_module_1 = __webpack_require__(324);
const payroll_management_module_1 = __webpack_require__(336);
const shift_management_module_1 = __webpack_require__(133);
let AppModule = class AppModule {
};
exports.AppModule = AppModule;
exports.AppModule = AppModule = __decorate([
    (0, common_1.Module)({
        imports: [
            config_module_1.ConfigModule,
            database_module_1.DatabaseModule,
            common_module_1.CommonModule,
            logs_module_1.LogsModule,
            files_module_1.FilesModule,
            notifications_module_1.NotificationsModule,
            documents_module_1.DocumentsModule,
            employee_management_module_1.EmployeeManagementModule,
            account_management_module_1.AccountManagementModule,
            organization_management_module_1.OrganizationManagementModule,
            attendance_management_module_1.AttendanceManagementModule,
            shift_management_module_1.ShiftManagementModule,
            addresses_module_1.AddressesModule,
            documents_module_1.DocumentsModule,
            biometrics_module_1.BiometricsModule,
            payroll_management_module_1.PayrollManagementModule,
            emails_module_1.EmailsModule,
        ],
        controllers: [],
    })
], AppModule);


/***/ }),
/* 14 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonModule = void 0;
const employee_management_module_1 = __webpack_require__(15);
const cutoffs_module_1 = __webpack_require__(128);
const shift_management_module_1 = __webpack_require__(133);
const common_1 = __webpack_require__(5);
const employee_group_assignement_listener_1 = __webpack_require__(166);
const common_service_1 = __webpack_require__(167);
const transaction_service_1 = __webpack_require__(88);
let CommonModule = class CommonModule {
};
exports.CommonModule = CommonModule;
exports.CommonModule = CommonModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [cutoffs_module_1.CutoffsModule, shift_management_module_1.ShiftManagementModule, employee_management_module_1.EmployeeManagementModule],
        providers: [
            common_service_1.CommonService, transaction_service_1.TransactionService,
            employee_group_assignement_listener_1.EmployeeGroupAssignmentListener,
        ],
        exports: [common_service_1.CommonService, transaction_service_1.TransactionService, employee_group_assignement_listener_1.EmployeeGroupAssignmentListener],
    })
], CommonModule);


/***/ }),
/* 15 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeeManagementModule = void 0;
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const typeorm_1 = __webpack_require__(16);
const employees_controller_1 = __webpack_require__(17);
const employees_service_1 = __webpack_require__(104);
const employee_entity_1 = __webpack_require__(43);
const permissions_module_1 = __webpack_require__(105);
const roles_module_1 = __webpack_require__(106);
let EmployeeManagementModule = class EmployeeManagementModule {
};
exports.EmployeeManagementModule = EmployeeManagementModule;
exports.EmployeeManagementModule = EmployeeManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([employee_entity_1.Employee]),
            roles_module_1.RolesModule,
            core_1.RouterModule.register([
                {
                    path: 'employees',
                    module: EmployeeManagementModule,
                    children: [
                        {
                            path: 'roles',
                            module: roles_module_1.RolesModule,
                            children: [
                                {
                                    path: 'permissions',
                                    module: permissions_module_1.PermissionsModule,
                                }
                            ]
                        },
                    ],
                },
            ]),
        ],
        providers: [employees_service_1.EmployeesService],
        exports: [
            roles_module_1.RolesModule,
            employees_service_1.EmployeesService,
        ],
        controllers: [employees_controller_1.EmployeesController],
    })
], EmployeeManagementModule);


/***/ }),
/* 16 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/typeorm");

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeesController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const employee_dto_1 = __webpack_require__(100);
const employees_service_1 = __webpack_require__(104);
const employee_entity_1 = __webpack_require__(43);
class EmployeesController extends (0, create_controller_factory_1.createController)(employee_entity_1.Employee, employees_service_1.EmployeesService, employee_dto_1.GetEmployeeDto, employee_dto_1.EmployeeDto, employee_dto_1.UpdateEmployeeDto) {
}
exports.EmployeesController = EmployeesController;


/***/ }),
/* 18 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createController = createController;
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const pluralize_1 = __importStar(__webpack_require__(19));
const base_controller_1 = __webpack_require__(20);
const current_user_decorator_1 = __webpack_require__(97);
const override_decorator_1 = __webpack_require__(98);
const generalresponse_dto_1 = __webpack_require__(86);
const pagination_dto_1 = __webpack_require__(22);
function createController(EntityClass, ServiceClass, getDtoClass, createDtoClass, updateDtoClass) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    // Extract entity name from class (removing "Entity" suffix if present)
    const entityName = EntityClass.name.replace(/Entity$/, '');
    // Add spaces before capital letters (except the first letter)
    const spacedEntityName = entityName.replace(/([A-Z])/g, ' $1').trim();
    // For the first character, ensure it's capitalized without a preceding space
    const formattedEntityName = spacedEntityName.charAt(0).toUpperCase() + spacedEntityName.slice(1);
    // Determine plural name for controller routes (used in swagger docs)
    const pluralName = (0, pluralize_1.default)(formattedEntityName);
    let DynamicController = class DynamicController extends base_controller_1.BaseController {
        constructor(baseService) {
            super(baseService, getDtoClass, formattedEntityName);
        }
        async create(entityDto, createdById) {
            return await super.create(entityDto, createdById);
        }
        async update(id, entityDto, updatedById) {
            return await super.update(id, entityDto, updatedById);
        }
        async delete(id) {
            return await super.delete(id);
        }
        async softDelete(id, deletedBy) {
            return await super.softDelete(id, deletedBy);
        }
        async findById(id, relations, select) {
            return await super.findById(id, relations, select);
        }
        async findOne(fieldsString, relations, select) {
            return await super.findOne(fieldsString, relations, select);
        }
        findAllAdvanced(paginationDto) {
            return super.findAllAdvanced(paginationDto);
        }
    };
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Create a New ${(0, pluralize_1.singular)(formattedEntityName)}`,
            description: `Creates a new ${(0, pluralize_1.singular)(formattedEntityName.toLowerCase())} record in the database with the provided data.`
        }),
        (0, swagger_1.ApiBody)({
            type: createDtoClass,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} creation data`,
            required: true
        }),
        (0, swagger_1.ApiResponse)({
            status: common_1.HttpStatus.CREATED,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} has been successfully created.`,
            type: getDtoClass
        }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Invalid input data.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.UNPROCESSABLE_ENTITY, description: 'Unprocessable entity.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.UNAUTHORIZED, description: 'Unauthorized.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.CONFLICT, description: `${(0, pluralize_1.singular)(formattedEntityName)} already exists.`, type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.INTERNAL_SERVER_ERROR, description: 'Internal server error.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: 'Related entity not found.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.FORBIDDEN, description: 'Forbidden.', type: generalresponse_dto_1.GeneralResponseDto }),
        __param(0, (0, common_1.Body)()),
        __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, String]),
        __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
    ], DynamicController.prototype, "create", null);
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Update an Existing ${(0, pluralize_1.singular)(formattedEntityName)}`,
            description: `Updates an existing ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} record in the database with the provided data.`
        }),
        (0, swagger_1.ApiParam)({
            name: 'id',
            description: `The unique identifier of the ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} to update`,
            required: true
        }),
        (0, swagger_1.ApiBody)({
            type: updateDtoClass,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} update data`,
            required: true
        }),
        (0, swagger_1.ApiResponse)({
            status: common_1.HttpStatus.OK,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} has been successfully updated.`,
            type: getDtoClass
        }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Invalid input data.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.UNPROCESSABLE_ENTITY, description: 'Unprocessable entity.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.UNAUTHORIZED, description: 'Unauthorized.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: `${(0, pluralize_1.singular)(formattedEntityName)} not found.`, type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.INTERNAL_SERVER_ERROR, description: 'Internal server error.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.FORBIDDEN, description: 'Forbidden.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.CONFLICT, description: 'Data conflict during update.', type: generalresponse_dto_1.GeneralResponseDto }),
        __param(0, (0, common_1.Param)('id')),
        __param(1, (0, common_1.Body)()),
        __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String, Object, String]),
        __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
    ], DynamicController.prototype, "update", null);
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Hard Delete a Specific ${(0, pluralize_1.singular)(formattedEntityName)}`,
            description: `Removes a ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} record from the database by its unique identifier.`
        }),
        (0, swagger_1.ApiParam)({
            name: 'id',
            description: `The unique identifier of the ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} to delete`,
            required: true
        }),
        (0, swagger_1.ApiResponse)({
            status: common_1.HttpStatus.NO_CONTENT,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} has been successfully deleted.`,
            type: generalresponse_dto_1.GeneralResponseDto
        }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Invalid ID format.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.UNAUTHORIZED, description: 'Unauthorized.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: `${(0, pluralize_1.singular)(formattedEntityName)} not found.`, type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.INTERNAL_SERVER_ERROR, description: 'Internal server error.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.FORBIDDEN, description: 'Forbidden.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.CONFLICT, description: 'Cannot delete due to existing references.', type: generalresponse_dto_1.GeneralResponseDto }),
        __param(0, (0, common_1.Param)('id')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
    ], DynamicController.prototype, "delete", null);
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Soft Delete a Specific ${(0, pluralize_1.singular)(formattedEntityName)}`,
            description: `Marks a ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} record as deleted without removing it from the database.`
        }),
        (0, swagger_1.ApiParam)({
            name: 'id',
            description: `The unique identifier of the ${(0, pluralize_1.singular)(formattedEntityName.toLowerCase())} to soft delete`,
            required: true
        }),
        (0, swagger_1.ApiResponse)({
            status: common_1.HttpStatus.NO_CONTENT,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} has been successfully soft-deleted.`,
            type: generalresponse_dto_1.GeneralResponseDto
        }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Invalid ID format.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.UNAUTHORIZED, description: 'Unauthorized.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: `${(0, pluralize_1.singular)(formattedEntityName)} not found.`, type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.INTERNAL_SERVER_ERROR, description: 'Internal server error.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.FORBIDDEN, description: 'Forbidden.', type: generalresponse_dto_1.GeneralResponseDto }),
        __param(0, (0, common_1.Param)('id')),
        __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String, String]),
        __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
    ], DynamicController.prototype, "softDelete", null);
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Find a Specific ${(0, pluralize_1.singular)(formattedEntityName)} by ID`,
            description: `Retrieve a single ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} from the database using its unique identifier.`
        }),
        (0, swagger_1.ApiParam)({
            name: 'id',
            description: `The unique identifier of the ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} to retrieve`,
            required: true
        }),
        (0, swagger_1.ApiQuery)({
            name: 'relations',
            required: false,
            type: String,
            description: 'Relations to include (comma-separated)',
            example: 'user,profile,permissions'
        }),
        (0, swagger_1.ApiQuery)({
            name: 'select',
            required: false,
            type: String,
            description: 'Fields to select (comma-separated)',
            example: 'id,name,email,createdAt'
        }),
        (0, swagger_1.ApiResponse)({
            status: common_1.HttpStatus.OK,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} was successfully retrieved.`,
            type: getDtoClass
        }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Invalid ID format.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.UNAUTHORIZED, description: 'Unauthorized.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: `${(0, pluralize_1.singular)(formattedEntityName)} not found.`, type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.INTERNAL_SERVER_ERROR, description: 'Internal server error.', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.FORBIDDEN, description: 'Forbidden.', type: generalresponse_dto_1.GeneralResponseDto }),
        __param(0, (0, common_1.Param)('id')),
        __param(1, (0, common_1.Query)('relations')),
        __param(2, (0, common_1.Query)('select')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String, String, String]),
        __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
    ], DynamicController.prototype, "findById", null);
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Find ${(0, pluralize_1.singular)(formattedEntityName)} by Any Field`,
            description: `Search for ${(0, pluralize_1.singular)(formattedEntityName).toLowerCase()} using field-value pairs. Multiple criteria can be combined.`
        }),
        (0, swagger_1.ApiQuery)({
            name: 'fields',
            required: true,
            type: String,
            description: 'Search fields in format field:value (comma-separated)',
            example: `id:123,name:example${(0, pluralize_1.singular)(entityName).toLowerCase()}`
        }),
        (0, swagger_1.ApiQuery)({
            name: 'relations',
            required: false,
            type: String,
            description: 'Relations to include in the response (comma-separated)',
            example: 'user,category,tags'
        }),
        (0, swagger_1.ApiQuery)({
            name: 'select',
            required: false,
            type: String,
            description: 'Fields to select in the response (comma-separated). Only these fields will be returned.',
            example: 'id,name,createdAt'
        }),
        (0, swagger_1.ApiResponse)({
            status: common_1.HttpStatus.OK,
            description: `${(0, pluralize_1.singular)(formattedEntityName)} found successfully`,
            type: getDtoClass
        }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: `${(0, pluralize_1.singular)(formattedEntityName)} not found with the specified criteria`, type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.FORBIDDEN, description: 'Forbidden. User does not have permission to access this resource', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.UNAUTHORIZED, description: 'Unauthorized. Authentication is required', type: generalresponse_dto_1.GeneralResponseDto }),
        (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.INTERNAL_SERVER_ERROR, description: 'Internal server error', type: generalresponse_dto_1.GeneralResponseDto }),
        __param(0, (0, common_1.Query)('fields')),
        __param(1, (0, common_1.Query)('relations')),
        __param(2, (0, common_1.Query)('select')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String, String, String]),
        __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
    ], DynamicController.prototype, "findOne", null);
    __decorate([
        (0, override_decorator_1.Override)(),
        (0, swagger_1.ApiOperation)({
            summary: `Find all ${(0, pluralize_1.singular)(formattedEntityName)} with Advanced Filtering`,
            description: `
        # Advanced Filtering Guide
        
        This endpoint supports complex filtering using JSON objects in the filter parameter.
        
        ## Basic Filters
        Simple equality: \`?filter={"status":"active"}\`
        
        ## Advanced Operators
        - Equal: \`?filter={"name":{"eq":"John"}}\`
        - Not equal: \`?filter={"status":{"ne":"deleted"}}\`
        - Greater than: \`?filter={"age":{"gt":18}}\`
        - Greater than or equal: \`?filter={"age":{"gte":21}}\`
        - Less than: \`?filter={"age":{"lt":65}}\`
        - Less than or equal: \`?filter={"price":{"lte":100}}\`
        - Like (contains): \`?filter={"name":{"like":"oh"}}\`
        - Case-insensitive like: \`?filter={"name":{"ilike":"john"}}\`
        - Between: \`?filter={"price":{"between":[10,50]}}\`
        - In array: \`?filter={"status":{"in":["active","pending"]}}\`
        - Not in array: \`?filter={"status":{"nin":["deleted","archived"]}}\`
        - Is null: \`?filter={"deletedAt":{"isNull":true}}\`
        
        ## Logical Operators
        
        ### AND (Default)
        Multiple conditions combined with AND logic (all must match):
        \`?filter={"status":"active","age":{"gte":21}}\`
        
        ### OR
        Any condition can match (using the special OR property):
        \`?filter={"OR":[{"status":"active"},{"featured":true}]}\`
        
        ## Relational Filtering
        
        ### Basic relation filtering:
        \`?filter={"user.email":"example@email.com"}\`
        
        ### Advanced relation filtering with operators:
        \`?filter={"user.profile.firstName":{"ilike":"jo"}}\`
        
        ### Complex nested relation filtering:
        \`?filter={"user.profile.address.city":{"eq":"New York"}}\`
        
        ### Combining relation filters with logical operators:
        \`?filter={"OR":[{"user.profile.firstName":{"ilike":"jo"}},{"user.email":{"like":"gmail"}}]}\`
        
        ## Field Selection
        Select specific fields: \`?select=["id","name","email"]\`
        Select fields from relations: \`?select=["id","name","user.id","user.email","category.name"]\`
        
        ## Sorting
        Sort by field: \`?sort={"createdAt":"DESC"}\`
        Multiple fields: \`?sort={"status":"ASC","createdAt":"DESC"}\`
        Sort by relation field: \`?sort={"user.name":"ASC"}\`
        
        ## Pagination
        Page size: \`?take=10\`
        Skip records: \`?skip=10\` (for page 2 with size 10)
        
        ## Relations
        Include related entities: \`?relations=["user","category"]\`
        Include nested relations: \`?relations=["user","user.profile","user.profile.address"]\`
        Alternative format: \`?relations={"user":true,"category":{"subcategories":true}}\`
        `,
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [typeof (_g = typeof pagination_dto_1.PaginationDto !== "undefined" && pagination_dto_1.PaginationDto) === "function" ? _g : Object]),
        __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
    ], DynamicController.prototype, "findAllAdvanced", null);
    DynamicController = __decorate([
        (0, swagger_1.ApiTags)(pluralName),
        (0, common_1.Controller)(),
        __param(0, (0, common_1.Inject)(ServiceClass)),
        __metadata("design:paramtypes", [void 0])
    ], DynamicController);
    return DynamicController;
}


/***/ }),
/* 19 */
/***/ ((module) => {

"use strict";
module.exports = require("pluralize");

/***/ }),
/* 20 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseController = void 0;
const paginated_response_dto_1 = __webpack_require__(21);
const pagination_dto_1 = __webpack_require__(22);
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const authorize_decorator_1 = __webpack_require__(26);
const current_user_decorator_1 = __webpack_require__(97);
const action_enum_1 = __webpack_require__(40);
const utility_helper_1 = __webpack_require__(87);
class BaseController {
    constructor(baseService, getDtoClass, entityName) {
        this.baseService = baseService;
        this.getDtoClass = getDtoClass;
        this.entityName = entityName;
        // Static permissions map that all instances share
        this.permissions = { Create: [], Read: [], Update: [], Delete: [] };
        this.logger = new common_1.Logger(this.constructor.name);
    }
    async create(entityDto, createdById) {
        const entity = await this.baseService.create(entityDto, createdById);
        return (0, class_transformer_1.plainToInstance)(this.getDtoClass, entity);
    }
    async update(id, entityDto, updatedById) {
        const updatedEntity = await this.baseService.update(id, entityDto, updatedById);
        return (0, class_transformer_1.plainToInstance)(this.getDtoClass, updatedEntity);
    }
    async findAllAdvanced(paginationDto) {
        const entityResult = await this.baseService.findAllComplex(paginationDto);
        // Transform using class-transformer
        const dtoResult = {
            data: (0, class_transformer_1.plainToInstance)(this.getDtoClass, entityResult.data, {
                enableCircularCheck: true,
                exposeUnsetFields: false,
            }),
            totalCount: entityResult.totalCount,
            meta: entityResult.meta
        };
        return dtoResult;
    }
    async findOne(fieldsString, relations, select) {
        // Create options object for the service
        const options = {};
        // Parse search criteria from query string (format: field1:value1,field2:value2)
        const criteria = {};
        if (fieldsString) {
            const fieldPairs = fieldsString.split(',');
            for (const pair of fieldPairs) {
                const [key, value] = pair.trim().split(':');
                if (key && value !== undefined) {
                    // Convert value types appropriately
                    if (value === 'true') {
                        criteria[key] = true;
                    }
                    else if (value === 'false') {
                        criteria[key] = false;
                    }
                    else if (value === 'null') {
                        criteria[key] = null;
                    }
                    else if (!isNaN(Number(value))) {
                        criteria[key] = Number(value);
                    }
                    else {
                        criteria[key] = value;
                    }
                }
            }
        }
        // Parse relations if provided
        if (relations) {
            options.relations = utility_helper_1.UtilityHelper.parseRelations(relations);
        }
        // Parse select fields if provided
        if (select) {
            options.select = utility_helper_1.UtilityHelper.parseSelect(select);
        }
        try {
            // Use the service with proper typing and options
            const entity = await this.baseService.findOneByOrFail(criteria, options);
            return (0, class_transformer_1.plainToInstance)(this.getDtoClass, entity);
        }
        catch (error) {
            if (error instanceof common_1.NotFoundException) {
                throw error;
            }
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            throw new common_1.InternalServerErrorException(`Error retrieving ${this.entityName.toLowerCase()} with criteria ${JSON.stringify(criteria)}: ${errorMessage}`);
        }
    }
    async findById(id, relations, select) {
        return this.findOne(`id:${id}`, relations, select);
    }
    // @Get()
    // @ApiOperation({ summary: 'Get all entities' })
    // @ApiResponse({ status: 200, description: 'Return all entities with pagination.' })
    // @ApiQuery({ name: 'skip', required: false, type: Number, description: 'Number of items to skip' })
    // @ApiQuery({ name: 'take', required: false, type: Number, description: 'Number of items to take' })
    // @ApiQuery({ name: 'filter', required: false, type: String, description: 'Filter criteria in JSON format' })
    // @ApiQuery({ name: 'sort', required: false, type: String, description: 'Sort criteria in JSON format' })
    // async findAll(@Query() paginationDto: PaginationDto<T>): Promise<PaginatedResponseDto<T>> {
    //     return await this.baseService.findAll(paginationDto);
    // }
    async softDelete(id, deletedBy) {
        return await this.baseService.softDelete(id, deletedBy);
    }
    async delete(id) {
        return await this.baseService.delete(id);
    }
    // @Delete()
    async deleteMany(ids, hardDelete = false) {
        await this.baseService.deleteMany(ids, hardDelete);
    }
}
exports.BaseController = BaseController;
__decorate([
    (0, common_1.Post)(),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.CREATE }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], BaseController.prototype, "create", null);
__decorate([
    (0, common_1.Put)(':id'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, String]),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], BaseController.prototype, "update", null);
__decorate([
    (0, common_1.Get)(),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiQuery)({
        name: 'filter',
        required: false,
        type: String,
        examples: {
            basic: {
                summary: 'Basic Equality Filter',
                value: '{"status":"active"}',
            },
            textSearch: {
                summary: 'Case-insensitive Text Search',
                value: '{"name":{"ilike":"john"}}',
            },
            numeric: {
                summary: 'Numeric Range Filter',
                value: '{"age":{"gte":18,"lt":65}}',
            },
            dates: {
                summary: 'Date Range Filter',
                value: '{"createdAt":{"between":["2023-01-01","2023-12-31"]}}',
            },
            relation: {
                summary: 'Relation Filter',
                value: '{"user.profile.firstName":{"ilike":"jo"}}',
            },
            logicalOr: {
                summary: 'Logical OR',
                value: '{"OR":[{"status":"active"},{"featured":true}]}',
            },
            complex: {
                summary: 'Complex Combined Filter',
                value: '{"status":{"in":["active","pending"]},"age":{"gte":21},"user.profile.firstName":{"ilike":"jo"}}',
            },
        },
    }),
    (0, swagger_1.ApiQuery)({
        name: 'sort',
        required: false,
        type: String,
        examples: {
            single: {
                summary: 'Sort by one field',
                value: '{"createdAt":"DESC"}',
            },
            multiple: {
                summary: 'Sort by multiple fields',
                value: '{"status":"ASC","createdAt":"DESC"}',
            },
            relation: {
                summary: 'Sort by relation field',
                value: '{"user.firstName":"ASC"}',
            },
        },
    }),
    (0, swagger_1.ApiQuery)({
        name: 'relations',
        required: false,
        type: String,
        examples: {
            simple: {
                summary: 'Simple relations',
                value: '["user","roles"]',
            },
            nested: {
                summary: 'Nested relations',
                value: '["user","user.profile","user.profile.address"]',
            },
        },
    }),
    (0, swagger_1.ApiQuery)({
        name: 'select',
        required: false,
        type: String,
        examples: {
            basic: {
                summary: 'Basic field selection',
                value: '["id","name","email"]',
            },
            withRelations: {
                summary: 'Fields with relations',
                value: '["id","employeeNumber","user.id","user.email","user.profile.firstName"]',
            },
        },
    }),
    (0, swagger_1.ApiQuery)({ name: 'skip', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'take', required: false, type: Number }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Successfully retrieved entities',
        type: (paginated_response_dto_1.PaginatedResponseDto),
    }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof pagination_dto_1.PaginationDto !== "undefined" && pagination_dto_1.PaginationDto) === "function" ? _c : Object]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], BaseController.prototype, "findAllAdvanced", null);
__decorate([
    (0, common_1.Get)('find'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    __param(0, (0, common_1.Query)('fields')),
    __param(1, (0, common_1.Query)('relations')),
    __param(2, (0, common_1.Query)('select')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], BaseController.prototype, "findOne", null);
__decorate([
    (0, common_1.Get)('find/:id'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Query)('relations')),
    __param(2, (0, common_1.Query)('select')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], BaseController.prototype, "findById", null);
__decorate([
    (0, common_1.Delete)('delete/soft/:id'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.DELETE }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], BaseController.prototype, "softDelete", null);
__decorate([
    (0, common_1.Delete)('delete/:id'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.DELETE }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], BaseController.prototype, "delete", null);
__decorate([
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.DELETE }),
    (0, swagger_1.ApiOperation)({ summary: 'Delete multiple entities' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                ids: {
                    type: 'array',
                    items: {
                        type: 'string',
                        format: 'uuid',
                    },
                },
                hardDelete: {
                    type: 'boolean',
                    default: false,
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NO_CONTENT, description: 'The entities have been successfully deleted.' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.BAD_REQUEST, description: 'Invalid input data.' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.UNAUTHORIZED, description: 'Unauthorized.' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.INTERNAL_SERVER_ERROR, description: 'Internal' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.FORBIDDEN, description: 'Forbidden.' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.NOT_FOUND, description: 'Entity not found.' }),
    __param(0, (0, common_1.Body)('ids')),
    __param(1, (0, common_1.Body)('hardDelete')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Boolean]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], BaseController.prototype, "deleteMany", null);


/***/ }),
/* 21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaginatedResponseDto = void 0;
const swagger_1 = __webpack_require__(8);
const pagination_dto_1 = __webpack_require__(22);
class PaginatedResponseDto {
    constructor() {
        this.data = [];
        this.totalCount = 0;
        this.meta = new pagination_dto_1.PaginationDto();
    }
}
exports.PaginatedResponseDto = PaginatedResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({ isArray: true, description: 'Array of items' }),
    __metadata("design:type", Array)
], PaginatedResponseDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total number of items', example: 100 }),
    __metadata("design:type", Number)
], PaginatedResponseDto.prototype, "totalCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Pagination metadata' }),
    __metadata("design:type", typeof (_a = typeof pagination_dto_1.PaginationDto !== "undefined" && pagination_dto_1.PaginationDto) === "function" ? _a : Object)
], PaginatedResponseDto.prototype, "meta", void 0);


/***/ }),
/* 22 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaginationDto = void 0;
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
const typeorm_1 = __webpack_require__(25);
/**
 * Data Transfer Object for pagination, filtering, sorting, and relation loading in API requests.
 *
 * This class provides a standardized way to handle common database query parameters
 * such as pagination (skip/take), filtering with advanced operators, sorting,
 * relation loading, and field selection. It's designed to work with TypeORM's
 * FindManyOptions interface.
 *
 * @example
 * // Basic usage in a controller
 * @Get()
 * async findAll(@Query() paginationDto: PaginationDto<User>) {
 *   return this.userService.findAll(paginationDto.toFindManyOptions());
 * }
 *
 * @example
 * Query example
 * GET /users?skip=0&take=10&filter={"name":{"like":"John"}}&sort={"createdAt":"DESC"}
 *
 * @template T The entity type this pagination will be applied to
 */
class PaginationDto {
    constructor() {
        this.skip = 0;
        this.take = 10;
    }
    toFindManyOptions(baseWhere = {}) {
        const filterObj = this.parseStringInput(this.filter);
        const sortObj = this.parseStringInput(this.sort);
        // Process where conditions with advanced operators
        let filterWhere = this.applyFilterOperators(filterObj);
        // Simplify the deleted logic
        if (!filterWhere.hasOwnProperty('isDeleted')) {
            filterWhere = Object.assign(Object.assign({}, filterWhere), { isDeleted: false });
        }
        // Process relations
        let relations = undefined;
        if (this.relations) {
            if (typeof this.relations === 'string') {
                try {
                    relations = JSON.parse(this.relations);
                }
                catch (e) {
                    relations = undefined;
                }
            }
            else {
                relations = this.relations;
            }
        }
        // Process select
        let select = undefined;
        if (this.select) {
            if (typeof this.select === 'string') {
                try {
                    const selectArray = JSON.parse(this.select);
                    if (Array.isArray(selectArray)) {
                        select = selectArray.reduce((acc, field) => {
                            acc[field] = true;
                            return acc;
                        }, {});
                    }
                }
                catch (e) {
                    select = undefined;
                }
            }
            else if (Array.isArray(this.select)) {
                select = this.select.reduce((acc, field) => {
                    acc[field] = true;
                    return acc;
                }, {});
            }
        }
        const options = {
            skip: this.skip,
            take: this.take,
            where: Object.assign(Object.assign({}, baseWhere), filterWhere),
            order: sortObj || undefined,
            relations,
            select,
        };
        return options;
    }
    // Parse string inputs to proper objects
    parseStringInput(input) {
        if (typeof input === 'string') {
            try {
                return JSON.parse(input);
            }
            catch (error) {
                return {};
            }
        }
        return input || {};
    }
    // Apply advanced filter operators
    applyFilterOperators(filterObj) {
        const result = {};
        Object.entries(filterObj).forEach(([key, value]) => {
            // Skip null/undefined values
            if (value === null || value === undefined)
                return;
            // Handle special logical operators
            if (key === 'or' && Array.isArray(value)) {
                // For OR, TypeORM accepts an array of conditions
                return value.map(condition => this.applyFilterOperators(condition));
            }
            if (key === 'and' && Array.isArray(value)) {
                // Process each condition in the AND array and merge them
                const andConditions = value.reduce((acc, condition) => {
                    return Object.assign(Object.assign({}, acc), this.applyFilterOperators(condition));
                }, {});
                // Merge with the current result
                Object.assign(result, andConditions);
                return;
            }
            // Handle nested objects (potential operators)
            if (typeof value === 'object' && !Array.isArray(value)) {
                const operators = value;
                // Equal
                if (operators.eq !== undefined) {
                    result[key] = operators.eq;
                }
                // Not Equal
                if (operators.ne !== undefined) {
                    result[key] = (0, typeorm_1.Not)(operators.ne);
                }
                // Greater Than
                if (operators.gt !== undefined) {
                    result[key] = (0, typeorm_1.MoreThan)(operators.gt);
                }
                // Greater Than or Equal
                if (operators.gte !== undefined) {
                    result[key] = (0, typeorm_1.MoreThanOrEqual)(operators.gte);
                }
                // Less Than
                if (operators.lt !== undefined) {
                    result[key] = (0, typeorm_1.LessThan)(operators.lt);
                }
                // Less Than or Equal
                if (operators.lte !== undefined) {
                    result[key] = (0, typeorm_1.LessThanOrEqual)(operators.lte);
                }
                // Between
                if (operators.between && Array.isArray(operators.between) && operators.between.length === 2) {
                    result[key] = (0, typeorm_1.Between)(operators.between[0], operators.between[1]);
                }
                // Like (case sensitive)
                if (operators.like !== undefined) {
                    result[key] = (0, typeorm_1.Like)(`%${operators.like}%`);
                }
                // ILike (case insensitive)
                if (operators.ilike !== undefined) {
                    result[key] = (0, typeorm_1.ILike)(`%${operators.ilike}%`);
                }
                // In
                if (operators.in && Array.isArray(operators.in)) {
                    result[key] = (0, typeorm_1.In)(operators.in);
                }
                // Not In
                if (operators.nin && Array.isArray(operators.nin)) {
                    result[key] = (0, typeorm_1.Not)((0, typeorm_1.In)(operators.nin));
                }
                // Is Null
                if (operators.isNull !== undefined) {
                    result[key] = (operators.isNull ? null : (0, typeorm_1.Not)(null));
                }
            }
            else {
                // Simple equality match
                result[key] = value;
            }
        });
        return result;
    }
}
exports.PaginationDto = PaginationDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Number of items to skip',
        required: false,
        minimum: 0,
        default: 0,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], PaginationDto.prototype, "skip", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Number of items to take',
        required: false,
        minimum: 1,
        default: 10,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], PaginationDto.prototype, "take", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Filter criteria in JSON string format or object',
        required: false,
        example: '{"name":{"like":"%John%"},"age":{"gte":18}}',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => {
        try {
            return typeof value === 'string' ? JSON.parse(value) : value;
        }
        catch (e) {
            const errorMessage = e instanceof Error ? e.message : String(e);
            throw new common_1.BadRequestException(`Invalid JSON in filter: ${errorMessage}`);
        }
    }),
    __metadata("design:type", Object)
], PaginationDto.prototype, "filter", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Sort criteria in JSON string format or object',
        required: false,
        example: '{"createdAt":"DESC"}',
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], PaginationDto.prototype, "sort", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Relations to include in the query',
        required: false,
        example: '["user","category"]',
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], PaginationDto.prototype, "relations", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Fields to select',
        required: false,
        example: '["id","name","email"]',
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], PaginationDto.prototype, "select", void 0);


/***/ }),
/* 23 */
/***/ ((module) => {

"use strict";
module.exports = require("class-transformer");

/***/ }),
/* 24 */
/***/ ((module) => {

"use strict";
module.exports = require("class-validator");

/***/ }),
/* 25 */
/***/ ((module) => {

"use strict";
module.exports = require("typeorm");

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PERMISSION_ENDPOINT_TYPE = exports.PERMISSIONS_FUNCTION_KEY = void 0;
exports.Authorize = Authorize;
const jwt_auth_guard_1 = __webpack_require__(27);
const permissions_guard_1 = __webpack_require__(29);
const roles_guard_1 = __webpack_require__(95);
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const permissions_decorator_1 = __webpack_require__(93);
const roles_decorator_1 = __webpack_require__(96);
exports.PERMISSIONS_FUNCTION_KEY = 'permissions_function';
exports.PERMISSION_ENDPOINT_TYPE = 'permission_endpoint_type';
function Authorize(options) {
    const decorators = [
        // UseInterceptors(ScopeInterceptor),
        (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard, permissions_guard_1.PermissionsGuard),
        (0, roles_decorator_1.Roles)(options === null || options === void 0 ? void 0 : options.roles),
        (0, swagger_1.ApiBearerAuth)('access-token'),
    ];
    // Only add ScopeGuard for endpoints that need scope checking
    if (options === null || options === void 0 ? void 0 : options.endpointType) {
        decorators.push((0, common_1.SetMetadata)(exports.PERMISSION_ENDPOINT_TYPE, options.endpointType));
    }
    else {
        // For regular array-based permissions
        decorators.push((0, permissions_decorator_1.Permissions)(options === null || options === void 0 ? void 0 : options.permissions));
    }
    return (0, common_1.applyDecorators)(...decorators);
}


/***/ }),
/* 27 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JwtAuthGuard = void 0;
// jwt-auth.guard.ts
const common_1 = __webpack_require__(5);
const passport_1 = __webpack_require__(28);
let JwtAuthGuard = class JwtAuthGuard extends (0, passport_1.AuthGuard)('jwt') {
};
exports.JwtAuthGuard = JwtAuthGuard;
exports.JwtAuthGuard = JwtAuthGuard = __decorate([
    (0, common_1.Injectable)()
], JwtAuthGuard);


/***/ }),
/* 28 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/passport");

/***/ }),
/* 29 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var PermissionsGuard_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionsGuard = void 0;
const users_service_1 = __webpack_require__(30);
const permissions_service_1 = __webpack_require__(90);
const activity_logs_service_1 = __webpack_require__(92);
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const pluralize_1 = __webpack_require__(19);
const authorize_decorator_1 = __webpack_require__(26);
const permissions_decorator_1 = __webpack_require__(93);
const action_enum_1 = __webpack_require__(40);
const role_enum_1 = __webpack_require__(94);
let PermissionsGuard = PermissionsGuard_1 = class PermissionsGuard {
    constructor(reflector, usersService, permissionsService, activityLogsService) {
        this.reflector = reflector;
        this.usersService = usersService;
        this.permissionsService = permissionsService;
        this.activityLogsService = activityLogsService;
        this.logger = new common_1.Logger(PermissionsGuard_1.name);
    }
    async canActivate(context) {
        var _a, _b, _c, _d;
        try {
            // First check for endpoint type
            const endpointType = this.reflector.getAllAndOverride(authorize_decorator_1.PERMISSION_ENDPOINT_TYPE, [context.getHandler(), context.getClass()]);
            let requiredPermissions = [];
            const controllerClass = context.getClass();
            const controllerName = controllerClass.name;
            const baseName = (0, pluralize_1.singular)(controllerName.replace(/controller$/i, ''));
            if (endpointType) {
                // get the permissions for the controller in the database
                const permissions = await this.permissionsService.getPermissionsByControllerName(baseName);
                // Filter permissions based on the endpoint type action
                if (permissions && permissions.length > 0) {
                    // Filter permissions that match the endpoint type action
                    requiredPermissions = permissions.filter(permission => {
                        // For CREATE endpoints, match against CREATE or MANAGE actions
                        if (endpointType === action_enum_1.Action.CREATE) {
                            return permission.action === action_enum_1.Action.CREATE || permission.action === action_enum_1.Action.MANAGE;
                        }
                        // For READ endpoints, match against READ or MANAGE actions
                        else if (endpointType === action_enum_1.Action.READ) {
                            return permission.action === action_enum_1.Action.READ || permission.action === action_enum_1.Action.MANAGE;
                        }
                        // For UPDATE endpoints, match against UPDATE or MANAGE actions
                        else if (endpointType === action_enum_1.Action.UPDATE) {
                            return permission.action === action_enum_1.Action.UPDATE || permission.action === action_enum_1.Action.MANAGE;
                        }
                        // For DELETE endpoints, match against DELETE or MANAGE actions
                        else if (endpointType === action_enum_1.Action.DELETE) {
                            return permission.action === action_enum_1.Action.DELETE || permission.action === action_enum_1.Action.MANAGE;
                        }
                        return false;
                    });
                }
            }
            else {
                // Fall back to standard permissions check
                requiredPermissions = this.reflector.getAllAndOverride(permissions_decorator_1.PERMISSIONS_KEY, [context.getHandler(), context.getClass()]) || [];
            }
            // If no permissions are required, allow access
            if (!requiredPermissions || requiredPermissions.length === 0) {
                return true;
            }
            // Get the user payload from the request
            const request = context.switchToHttp().getRequest();
            const userClaims = request.user;
            const resourceId = this.getResourceInfo(request);
            // get user with their role and role permissions
            let user;
            try {
                user = await this.usersService.findOneByOrFail({ id: userClaims.sub }, { relations: { employee: { roles: { permissions: true } } } });
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error(`Error fetching user permissions: ${errorMessage}`);
                // Log failed permission check due to user lookup error
                await this.logUserActivity(userClaims, endpointType, baseName, false, 'Permission check failed - User not found', resourceId);
                throw new common_1.ForbiddenException('Error processing permissions');
            }
            // check if user is an employee if user is not an employee only allow access to their own resource
            if (!user.employee) {
                this.logger.warn(`User is not an employee`);
                // Check if the user is trying to access their own resource
                // const userId = request.params.userId || request.query.userId || request.body.userId;
                // if (userId !== userClaims.sub) {
                //   this.logger.warn(`User is trying to access another user's resource: ${userId}`);
                //   // Log unauthorized access attempt
                //   await this.logUserActivity(
                //     userClaims, endpointType, baseName, false,
                //     `Attempted to access another user's resource: ${userId}`,
                //     resourceId, userClaims.sub
                //   );
                //   throw new ForbiddenException('You do not have the permission to access or manage this resource.');
                // }
                // // Log successful access to own resource
                // await this.logUserActivity(
                //   userClaims, endpointType, baseName, true,
                //   `Accessed own resource`,
                //   resourceId, userClaims.sub
                // );
                return true;
            }
            // If user has the super admin role, allow access
            const hasSuperAdminRole = (_b = (_a = user.employee) === null || _a === void 0 ? void 0 : _a.roles) === null || _b === void 0 ? void 0 : _b.some(role => role.name === role_enum_1.Role.SUPERADMIN);
            if (hasSuperAdminRole) {
                // Log successful access with super admin privileges
                await this.logUserActivity(userClaims, endpointType, baseName, true, `Access granted with SUPERADMIN role`, resourceId, userClaims.sub);
                return true;
            }
            // Check if the user has every required permissions for some role
            const userPermissions = [
                ...new Set(((_d = (_c = user.employee) === null || _c === void 0 ? void 0 : _c.roles) === null || _d === void 0 ? void 0 : _d.flatMap(role => role.permissions).filter(Boolean)) || [])
            ];
            const hasRequiredPermissions = requiredPermissions.every(requiredPermission => {
                return userPermissions === null || userPermissions === void 0 ? void 0 : userPermissions.some(userPermission => {
                    // Direct permission match
                    const exactMatch = userPermission &&
                        userPermission.action === requiredPermission.action &&
                        userPermission.subject === requiredPermission.subject;
                    // Check if user has MANAGE permission for the same subject
                    // MANAGE is equivalent to having all other permissions
                    const hasManagePermission = userPermission &&
                        userPermission.action === action_enum_1.Action.MANAGE &&
                        userPermission.subject === requiredPermission.subject;
                    return exactMatch || hasManagePermission;
                });
            });
            if (!hasRequiredPermissions) {
                // Log failed permission check
                await this.logUserActivity(userClaims, endpointType, baseName, false, `Missing required permissions: ${JSON.stringify(requiredPermissions.map(p => `${p.action} ${p.subject}`))}`, resourceId, userClaims.sub);
                return true;
                throw new common_1.ForbiddenException('You do not have the permissions to access or manage this resource.');
            }
            // Log successful permission check
            await this.logUserActivity(userClaims, endpointType, baseName, true, `Successfully performed action`, resourceId, userClaims.sub);
            return true;
        }
        catch (error) {
            if (error instanceof common_1.ForbiddenException) {
                throw error;
            }
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Unexpected error in permissions guard: ${errorMessage}`);
            throw new common_1.ForbiddenException('Permission check failed');
        }
    }
    /**
     * Extract resource information from the request
     */
    getResourceInfo(request) {
        var _a, _b;
        return ((_a = request.params) === null || _a === void 0 ? void 0 : _a.id) || ((_b = request.body) === null || _b === void 0 ? void 0 : _b.id);
    }
    /**
     * Log user activity with detailed information
     */
    async logUserActivity(userClaims, endpointType, subject, successful, message, resourceId, userId) {
        try {
            const userEmail = userClaims.email || 'Unknown User';
            const action = endpointType || action_enum_1.Action.READ;
            const logMessage = successful
                ? `${userEmail} ${action} ${subject}${resourceId ? ` (ID: ${resourceId})` : ''}. ${message}`
                : `${userEmail} tried to ${action} ${subject}${resourceId ? ` (ID: ${resourceId})` : ''} but was denied. ${message}`;
            await this.activityLogsService.create({
                action,
                subject,
                user: { id: userId },
                message: logMessage
            });
        }
        catch (error) {
            // Don't let logging errors affect the app's operation
            this.logger.error(`Failed to log user activity: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
};
exports.PermissionsGuard = PermissionsGuard;
exports.PermissionsGuard = PermissionsGuard = PermissionsGuard_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof core_1.Reflector !== "undefined" && core_1.Reflector) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof permissions_service_1.PermissionsService !== "undefined" && permissions_service_1.PermissionsService) === "function" ? _c : Object, typeof (_d = typeof activity_logs_service_1.ActivityLogsService !== "undefined" && activity_logs_service_1.ActivityLogsService) === "function" ? _d : Object])
], PermissionsGuard);


/***/ }),
/* 30 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersService = void 0;
const base_service_1 = __webpack_require__(31);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const bcrypt = __importStar(__webpack_require__(89));
const typeorm_2 = __webpack_require__(25);
const user_entity_1 = __webpack_require__(47);
let UsersService = class UsersService extends base_service_1.BaseService {
    constructor(userRepository) {
        super(userRepository, null);
        this.userRepository = userRepository;
    }
    async signUpUser(model) {
        const hashedPassword = await bcrypt.hash(model.password, 10);
        const user = this.create(Object.assign(Object.assign({}, model), { password: hashedPassword, emailVerified: false, userName: model.userName.toLowerCase().trim(), email: model.email.toLowerCase().trim() }));
        return user;
    }
};
exports.UsersService = UsersService;
exports.UsersService = UsersService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(user_entity_1.User)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], UsersService);


/***/ }),
/* 31 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseService = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(25);
const data_source_1 = __importDefault(__webpack_require__(32));
const generalresponse_dto_1 = __webpack_require__(86);
const pagination_dto_1 = __webpack_require__(22);
const utility_helper_1 = __webpack_require__(87);
const transaction_service_1 = __webpack_require__(88);
let BaseService = class BaseService {
    constructor(repository, usersService) {
        this.repository = repository;
        this.usersService = usersService;
        this.logger = new common_1.Logger(this.constructor.name);
        this.transactionService = new transaction_service_1.TransactionService(data_source_1.default);
        this.entityName = this.repository.target instanceof Function ? this.repository.target.name : 'Entity';
        this.entityType = this.repository.target instanceof Function ? this.repository.target : Object;
        // State for query building
        this.queryState = {
            includes: new Map(),
            whereConditions: [],
            parameters: {},
            orderByClauses: [],
            skipValue: 0,
            takeValue: 0,
            isTracking: true,
            queryBuilder: null,
            parentPath: '',
            paramCounter: 0
        };
    }
    getRepository() {
        return this.repository;
    }
    async findAllComplex(paginationDto) {
        try {
            const findOptions = paginationDto.toFindManyOptions();
            const alias = this.entityName.toLowerCase();
            // Debug the incoming filter
            // console.log('Raw filter from client:', JSON.stringify(paginationDto.filter));
            // console.log('Converted findOptions where:', JSON.stringify(findOptions.where));
            // this.logger.debug(`Processing query with filters: ${JSON.stringify(findOptions.where)}`);
            // For complex filtering that requires JOIN operations or nested relations
            if (Object.keys(findOptions.where || {}).length > 0 ||
                (findOptions.relations && Object.keys(findOptions.relations).length > 0)) {
                // Use QueryBuilder for more complex queries
                const queryBuilder = this.repository.createQueryBuilder(alias);
                // Add soft delete condition - using proper parameter binding
                queryBuilder.where(`${alias}.deletedAt IS NULL`);
                // Track joined relations to avoid duplicates
                const joinedRelations = new Set();
                // Apply where conditions from findOptions
                if (findOptions.where) {
                    // Initialize arrays/objects for OR conditions
                    const orClauses = [];
                    const orParams = {};
                    // Check if OR condition exists first to avoid TypeScript errors
                    if (findOptions.where['OR'] && Array.isArray(findOptions.where['OR'])) {
                        try {
                            // Process each condition in the OR array
                            findOptions.where['OR'].forEach((condition, index) => {
                                // Create condition clauses for this OR branch
                                const conditionClauses = [];
                                const conditionParams = {};
                                // Process each field in this condition
                                Object.entries(condition).forEach(([key, value]) => {
                                    // Handle nested properties (relations.field)
                                    if (key.includes('.')) {
                                        const parts = key.split('.');
                                        const field = parts.pop();
                                        // Join each relation path to the main query builder
                                        let currentAlias = alias;
                                        let fullPath = '';
                                        // Process each part of the path for joins
                                        for (let i = 0; i < parts.length; i++) {
                                            const relationName = parts[i];
                                            const prevPath = fullPath;
                                            // Build the cumulative path
                                            fullPath = prevPath ? `${prevPath}.${relationName}` : relationName;
                                            const joinAlias = `${fullPath.replace(/\./g, '_')}_or_${index}_filter_${this.queryState.paramCounter++}`;
                                            const joinPath = `${currentAlias}.${relationName}`;
                                            // Only join if not already joined
                                            if (!joinedRelations.has(joinAlias)) {
                                                queryBuilder.leftJoin(joinPath, joinAlias);
                                                joinedRelations.add(joinAlias);
                                                this.logger.debug(`Joined relation for OR filter: ${joinPath} as ${joinAlias}`);
                                            }
                                            // Update the current alias for next iteration
                                            currentAlias = joinAlias;
                                        }
                                        // Apply the condition to the innermost relation
                                        if (typeof value === 'object' && value !== null && !(value instanceof Date)) {
                                            // Handle operators like ilike, gt, lt, etc.
                                            const paramBaseName = `${currentAlias}_${field}_or_${index}`;
                                            if ('ilike' in value) {
                                                const paramName = `${paramBaseName}_ilike_${this.queryState.paramCounter++}`;
                                                conditionClauses.push(`LOWER(${currentAlias}.${field}) LIKE LOWER(:${paramName})`);
                                                conditionParams[paramName] = `%${value.ilike}%`;
                                            }
                                            else if ('like' in value) {
                                                const paramName = `${paramBaseName}_like_${this.queryState.paramCounter++}`;
                                                conditionClauses.push(`${currentAlias}.${field} LIKE :${paramName}`);
                                                conditionParams[paramName] = `%${value.like}%`;
                                            }
                                            else {
                                                // Fall back to custom operator handling
                                                Object.entries(value).forEach(([op, opValue]) => {
                                                    const paramName = `${paramBaseName}_${op}_${this.queryState.paramCounter++}`;
                                                    switch (op) {
                                                        case 'eq':
                                                            conditionClauses.push(`${currentAlias}.${field} = :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'ne':
                                                            conditionClauses.push(`${currentAlias}.${field} != :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'gt':
                                                            conditionClauses.push(`${currentAlias}.${field} > :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'gte':
                                                            conditionClauses.push(`${currentAlias}.${field} >= :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'lt':
                                                            conditionClauses.push(`${currentAlias}.${field} < :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'lte':
                                                            conditionClauses.push(`${currentAlias}.${field} <= :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'in':
                                                            if (Array.isArray(opValue)) {
                                                                conditionClauses.push(`${currentAlias}.${field} IN (:...${paramName})`);
                                                                conditionParams[paramName] = opValue;
                                                            }
                                                            break;
                                                        case 'between':
                                                            if (Array.isArray(opValue) && opValue.length === 2) {
                                                                const minParam = `${paramName}_min`;
                                                                const maxParam = `${paramName}_max`;
                                                                conditionClauses.push(`${currentAlias}.${field} BETWEEN :${minParam} AND :${maxParam}`);
                                                                conditionParams[minParam] = opValue[0];
                                                                conditionParams[maxParam] = opValue[1];
                                                            }
                                                            break;
                                                        case 'isNull':
                                                            if (opValue === true) {
                                                                conditionClauses.push(`${currentAlias}.${field} IS NULL`);
                                                            }
                                                            else {
                                                                conditionClauses.push(`${currentAlias}.${field} IS NOT NULL`);
                                                            }
                                                            break;
                                                    }
                                                });
                                            }
                                        }
                                        else {
                                            // Simple equality for non-object values
                                            const paramName = `${currentAlias}_${field}_or_${index}_${this.queryState.paramCounter++}`;
                                            conditionClauses.push(`${currentAlias}.${field} = :${paramName}`);
                                            conditionParams[paramName] = value;
                                        }
                                    }
                                    else {
                                        // Handle direct properties (non-relational)
                                        if (typeof value === 'object' && value !== null && !(value instanceof Date)) {
                                            // Handle operators like ilike, gt, lt, etc.
                                            const paramBaseName = `${alias}_${key}_or_${index}`;
                                            if ('ilike' in value) {
                                                const paramName = `${paramBaseName}_ilike_${this.queryState.paramCounter++}`;
                                                conditionClauses.push(`LOWER(${alias}.${key}) LIKE LOWER(:${paramName})`);
                                                conditionParams[paramName] = `%${value.ilike}%`;
                                            }
                                            else if ('like' in value) {
                                                const paramName = `${paramBaseName}_like_${this.queryState.paramCounter++}`;
                                                conditionClauses.push(`${alias}.${key} LIKE :${paramName}`);
                                                conditionParams[paramName] = `%${value.like}%`;
                                            }
                                            else {
                                                // Fall back to other operators
                                                Object.entries(value).forEach(([op, opValue]) => {
                                                    const paramName = `${paramBaseName}_${op}_${this.queryState.paramCounter++}`;
                                                    switch (op) {
                                                        case 'eq':
                                                            conditionClauses.push(`${alias}.${key} = :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'ne':
                                                            conditionClauses.push(`${alias}.${key} != :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'gt':
                                                            conditionClauses.push(`${alias}.${key} > :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'gte':
                                                            conditionClauses.push(`${alias}.${key} >= :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'lt':
                                                            conditionClauses.push(`${alias}.${key} < :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'lte':
                                                            conditionClauses.push(`${alias}.${key} <= :${paramName}`);
                                                            conditionParams[paramName] = opValue;
                                                            break;
                                                        case 'in':
                                                            if (Array.isArray(opValue)) {
                                                                conditionClauses.push(`${alias}.${key} IN (:...${paramName})`);
                                                                conditionParams[paramName] = opValue;
                                                            }
                                                            break;
                                                        case 'between':
                                                            if (Array.isArray(opValue) && opValue.length === 2) {
                                                                const minParam = `${paramName}_min`;
                                                                const maxParam = `${paramName}_max`;
                                                                conditionClauses.push(`${alias}.${key} BETWEEN :${minParam} AND :${maxParam}`);
                                                                conditionParams[minParam] = opValue[0];
                                                                conditionParams[maxParam] = opValue[1];
                                                            }
                                                            break;
                                                        case 'isNull':
                                                            if (opValue === true) {
                                                                conditionClauses.push(`${alias}.${key} IS NULL`);
                                                            }
                                                            else {
                                                                conditionClauses.push(`${alias}.${key} IS NOT NULL`);
                                                            }
                                                            break;
                                                    }
                                                });
                                            }
                                        }
                                        else {
                                            // Simple equality for non-object values
                                            const paramName = `${alias}_${key}_or_${index}_${this.queryState.paramCounter++}`;
                                            conditionClauses.push(`${alias}.${key} = :${paramName}`);
                                            conditionParams[paramName] = value;
                                        }
                                    }
                                });
                                // Add this branch to the OR clauses if any conditions were added
                                if (conditionClauses.length > 0) {
                                    orClauses.push(`(${conditionClauses.join(' AND ')})`);
                                    Object.assign(orParams, conditionParams);
                                }
                            });
                            // Apply all OR conditions to the main query
                            if (orClauses.length > 0) {
                                queryBuilder.andWhere(`(${orClauses.join(' OR ')})`, orParams);
                                // this.logger.debug(`Applied OR conditions: ${orClauses.join(' OR ')}`);
                            }
                            // Remove OR from where to prevent double processing
                            delete findOptions.where['OR'];
                        }
                        catch (error) {
                            if (error instanceof Error) {
                                this.logger.error(`Error processing OR conditions: ${error.message}`, error.stack);
                            }
                            else {
                                this.logger.error(`Error processing OR conditions: ${String(error)}`);
                            }
                        }
                    }
                    Object.entries(findOptions.where).forEach(([key, value]) => {
                        // Skip isDeleted as we'll handle it separately
                        if (key === 'isDeleted')
                            return;
                        // Handle nested properties (relations.field)
                        if (key.includes('.')) {
                            const pathParts = key.split('.');
                            // Check if path is valid before proceeding
                            if (pathParts.length === 0) {
                                this.logger.warn(`Invalid path format: ${key}`);
                                return; // Skip this iteration of the forEach
                            }
                            const fieldName = pathParts.pop(); // Use non-null assertion since we checked length
                            let currentAlias = alias;
                            let fullPath = '';
                            // Process each part of the path for joins
                            for (let i = 0; i < pathParts.length; i++) {
                                const relationName = pathParts[i];
                                const prevPath = fullPath;
                                // Build the cumulative path
                                fullPath = prevPath ? `${prevPath}.${relationName}` : relationName;
                                const joinAlias = `${fullPath.replace(/\./g, '_')}_filter_${this.queryState.paramCounter++}`;
                                const joinPath = `${currentAlias}.${relationName}`;
                                // Only join if not already joined
                                if (!joinedRelations.has(joinAlias)) {
                                    // FIX: Actually perform the join operation!
                                    queryBuilder.innerJoin(joinPath, joinAlias);
                                    joinedRelations.add(joinAlias);
                                    this.logger.debug(`Joined relation for filter: ${joinPath} as ${joinAlias}`);
                                }
                                // Update the current alias for next iteration
                                currentAlias = joinAlias;
                            }
                            // Apply condition to final field
                            if (typeof value === 'object' && value !== null && !(value instanceof Date)) {
                                this.applyOperatorToQueryBuilder(queryBuilder, currentAlias, fieldName, value);
                                this.logger.debug(`Applied operator filter to ${currentAlias}.${fieldName}: ${JSON.stringify(value)}`);
                            }
                            else {
                                // Generate a truly unique parameter name
                                const paramName = `${currentAlias}_${fieldName}_${this.queryState.paramCounter++}`;
                                queryBuilder.andWhere(`${currentAlias}.${fieldName} = :${paramName}`, {
                                    [paramName]: value
                                });
                                this.logger.debug(`Applied equality filter to ${currentAlias}.${fieldName} = ${value}`);
                            }
                        }
                        else {
                            // Handle regular fields on main entity
                            if (typeof value === 'object' && value !== null && !(value instanceof Date)) {
                                this.applyOperatorToQueryBuilder(queryBuilder, alias, key, value);
                                this.logger.debug(`Applied operator filter to ${alias}.${key}: ${JSON.stringify(value)}`);
                            }
                            else {
                                // Generate a truly unique parameter name
                                const paramName = `${alias}_${key}_${this.queryState.paramCounter++}`;
                                queryBuilder.andWhere(`${alias}.${key} = :${paramName}`, {
                                    [paramName]: value
                                });
                                this.logger.debug(`Applied equality filter to ${alias}.${key} = ${value}`);
                            }
                        }
                    });
                }
                // Apply ordering
                if (findOptions.order) {
                    Object.entries(findOptions.order).forEach(([key, direction]) => {
                        // Handle nested ordering
                        if (key.includes('.')) {
                            const pathParts = key.split('.');
                            if (pathParts.length !== 2) {
                                this.logger.warn(`Complex nested ordering with more than one level is not supported: ${key}`);
                                return;
                            }
                            const [relation, field] = pathParts;
                            const relationAlias = `${relation}_order`;
                            // Join the relation if not already joined
                            if (!joinedRelations.has(relationAlias)) {
                                queryBuilder.leftJoin(`${alias}.${relation}`, relationAlias);
                                joinedRelations.add(relationAlias);
                                this.logger.debug(`Joined relation for ordering: ${relation} as ${relationAlias}`);
                            }
                            queryBuilder.addOrderBy(`${relationAlias}.${field}`, direction);
                            this.logger.debug(`Added order by ${relationAlias}.${field} ${direction}`);
                        }
                        else {
                            queryBuilder.addOrderBy(`${alias}.${key}`, direction);
                            this.logger.debug(`Added order by ${alias}.${key} ${direction}`);
                        }
                    });
                }
                // Handle field selection with relations
                if (findOptions.select && Array.isArray(findOptions.select) && findOptions.select.length > 0) {
                    // Clear any previous automatic selections
                    queryBuilder.select([]);
                    // Always include primary key for relational integrity
                    queryBuilder.addSelect(`${alias}.id`);
                    // Add requested fields for the main entity
                    findOptions.select.forEach(field => {
                        if (typeof field === 'string' && !field.includes('.')) {
                            queryBuilder.addSelect(`${alias}.${field}`);
                        }
                    });
                    this.logger.debug(`Applied field selection: ${JSON.stringify(findOptions.select)}`);
                }
                // Handle relations and field selection
                if (findOptions.relations) {
                    // Apply relations with any nested field selection
                    this.applyRelationsWithFieldSelection(queryBuilder, alias, findOptions.relations, findOptions.select, joinedRelations);
                    // this.logger.debug(`Applied relations: ${JSON.stringify(findOptions.relations)}`);
                    // ADDED: Apply field selection to the main entity when relations are present
                    if (findOptions.select) {
                        // Clear any previous selection to avoid selecting all fields
                        queryBuilder.select([]);
                        // Make sure we always select the ID field for relational integrity
                        queryBuilder.addSelect(`${alias}.id`);
                        // Handle array format
                        if (Array.isArray(findOptions.select)) {
                            findOptions.select.forEach(fieldName => {
                                if (typeof fieldName === 'string' && !fieldName.includes('.')) {
                                    queryBuilder.addSelect(`${alias}.${fieldName}`);
                                }
                            });
                        }
                        // Handle object format
                        else {
                            Object.entries(findOptions.select).forEach(([field, included]) => {
                                if (included && !field.includes('.')) {
                                    queryBuilder.addSelect(`${alias}.${field}`);
                                }
                            });
                        }
                        this.logger.debug(`Applied field selection to main entity: ${JSON.stringify(findOptions.select)}`);
                    }
                }
                // If no relations but we have select fields
                else if (findOptions.select) {
                    // Add ID to selection if not already included
                    if (!Object.keys(findOptions.select).includes('id')) {
                        queryBuilder.addSelect(`${alias}.id`);
                    }
                    // Add selected fields
                    Object.entries(findOptions.select).forEach(([field, included]) => {
                        if (included) {
                            queryBuilder.addSelect(`${alias}.${field}`);
                        }
                    });
                    this.logger.debug(`Applied field selection: ${JSON.stringify(findOptions.select)}`);
                }
                // Apply pagination
                queryBuilder.skip(findOptions.skip).take(findOptions.take);
                try {
                    // Execute the query with count
                    const [data, totalCount] = await queryBuilder.getManyAndCount();
                    // // Log the SQL for debugging purposes in development
                    // if (process.env.NODE_ENV !== 'production') {
                    //   console.log('Generated SQL:', queryBuilder.getSql());
                    //   console.log('Query parameters:', queryBuilder.getParameters());
                    // }
                    // this.logger.debug(`Found ${totalCount} items using QueryBuilder with relations and field selection`);
                    // Create a new pagination DTO to maintain all methods
                    const updatedPaginationDto = new pagination_dto_1.PaginationDto();
                    Object.assign(updatedPaginationDto, paginationDto, {
                        skip: findOptions.skip,
                        take: findOptions.take
                    });
                    return {
                        data,
                        totalCount,
                        meta: updatedPaginationDto,
                    };
                }
                catch (queryError) {
                    // Log and rethrow specific query errors with more context
                    if (queryError instanceof Error) {
                        this.logger.error(`Query execution error: ${queryError.message}`, queryError.stack);
                        this.logger.error(`Failed SQL: ${queryBuilder.getSql()}`);
                        this.logger.error(`Query parameters: ${JSON.stringify(queryBuilder.getParameters())}`);
                        throw new common_1.InternalServerErrorException(`Database query failed: ${queryError.message}`);
                    }
                    else {
                        this.logger.error(`Query execution error: ${String(queryError)}`);
                        this.logger.error(`Failed SQL: ${queryBuilder.getSql()}`);
                        this.logger.error(`Query parameters: ${JSON.stringify(queryBuilder.getParameters())}`);
                        throw new common_1.InternalServerErrorException(`Database query failed: ${String(queryError)}`);
                    }
                }
            }
            else {
                // For simple queries, use repository's findAndCount
                this.logger.debug('Using simple findAndCount for basic query');
                const [data, totalCount] = await this.repository.findAndCount(findOptions);
                // Create a new pagination DTO to maintain all methods
                const updatedPaginationDto = new pagination_dto_1.PaginationDto();
                Object.assign(updatedPaginationDto, paginationDto, {
                    skip: findOptions.skip,
                    take: findOptions.take,
                });
                return {
                    data,
                    totalCount,
                    meta: updatedPaginationDto,
                };
            }
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error in findAllComplex method: ${error.message}`, error.stack);
                throw new common_1.InternalServerErrorException(`Failed to retrieve ${this.entityName} records: ${error.message}`);
            }
            else {
                this.logger.error(`Error in findAllComplex method: ${String(error)}`);
                throw new common_1.InternalServerErrorException(`Failed to retrieve ${this.entityName} records: ${String(error)}`);
            }
        }
    }
    // Helper method to apply operators to QueryBuilder
    applyOperatorToQueryBuilder(queryBuilder, alias, field, valueObj) {
        // Create unique parameter name base
        const paramBaseName = `${alias}_${field}_${this.queryState.paramCounter++}`;
        // Debug the incoming value object
        // console.log(`Applying operator to ${alias}.${field}:`, JSON.stringify(valueObj, null, 2));
        // Handle TypeORM's internal operator objects (ILike, etc.)
        if (valueObj && valueObj._type && valueObj._value !== undefined) {
            const paramName = `${paramBaseName}_typeorm`;
            switch (valueObj._type) {
                case 'ilike':
                    // For ilike, TypeORM may have already added wildcards, so check the value
                    const ilikeValue = valueObj._value.includes('%') ? valueObj._value : `%${valueObj._value}%`;
                    queryBuilder.andWhere(`LOWER(${alias}.${field}) LIKE LOWER(:${paramName})`, {
                        [paramName]: ilikeValue
                    });
                    console.log(`Applied TypeORM ILIKE: ${alias}.${field} LIKE '${ilikeValue}'`);
                    break;
                case 'like':
                    const likeValue = valueObj._value.includes('%') ? valueObj._value : `%${valueObj._value}%`;
                    queryBuilder.andWhere(`${alias}.${field} LIKE :${paramName}`, {
                        [paramName]: likeValue
                    });
                    console.log(`Applied TypeORM LIKE: ${alias}.${field} LIKE '${likeValue}'`);
                    break;
                case 'equal':
                case 'eq':
                    queryBuilder.andWhere(`${alias}.${field} = :${paramName}`, {
                        [paramName]: valueObj._value
                    });
                    console.log(`Applied TypeORM equals: ${alias}.${field} = '${valueObj._value}'`);
                    break;
                case 'not':
                    queryBuilder.andWhere(`${alias}.${field} != :${paramName}`, {
                        [paramName]: valueObj._value
                    });
                    console.log(`Applied TypeORM not equals: ${alias}.${field} != '${valueObj._value}'`);
                    break;
                case 'gt':
                    queryBuilder.andWhere(`${alias}.${field} > :${paramName}`, {
                        [paramName]: valueObj._value
                    });
                    console.log(`Applied TypeORM greater than: ${alias}.${field} > ${valueObj._value}`);
                    break;
                case 'gte':
                    queryBuilder.andWhere(`${alias}.${field} >= :${paramName}`, {
                        [paramName]: valueObj._value
                    });
                    console.log(`Applied TypeORM greater than or equal: ${alias}.${field} >= ${valueObj._value}`);
                    break;
                case 'lt':
                    queryBuilder.andWhere(`${alias}.${field} < :${paramName}`, {
                        [paramName]: valueObj._value
                    });
                    console.log(`Applied TypeORM less than: ${alias}.${field} < ${valueObj._value}`);
                    break;
                case 'lte':
                    queryBuilder.andWhere(`${alias}.${field} <= :${paramName}`, {
                        [paramName]: valueObj._value
                    });
                    console.log(`Applied TypeORM less than or equal: ${alias}.${field} <= ${valueObj._value}`);
                    break;
                case 'in':
                    if (Array.isArray(valueObj._value)) {
                        queryBuilder.andWhere(`${alias}.${field} IN (:...${paramName})`, {
                            [paramName]: valueObj._value
                        });
                        console.log(`Applied TypeORM IN: ${alias}.${field} IN (${valueObj._value.join(', ')})`);
                    }
                    break;
                case 'any':
                    if (Array.isArray(valueObj._value)) {
                        queryBuilder.andWhere(`${alias}.${field} = ANY(:${paramName})`, {
                            [paramName]: valueObj._value
                        });
                        console.log(`Applied TypeORM ANY: ${alias}.${field} = ANY(${valueObj._value.join(', ')})`);
                    }
                    break;
                case 'between':
                    if (Array.isArray(valueObj._value) && valueObj._value.length === 2) {
                        queryBuilder.andWhere(`${alias}.${field} BETWEEN :${paramName}Min AND :${paramName}Max`, {
                            [`${paramName}Min`]: valueObj._value[0],
                            [`${paramName}Max`]: valueObj._value[1]
                        });
                        console.log(`Applied TypeORM BETWEEN: ${alias}.${field} BETWEEN ${valueObj._value[0]} AND ${valueObj._value[1]}`);
                    }
                    break;
                case 'isNull':
                    queryBuilder.andWhere(`${alias}.${field} IS NULL`);
                    console.log(`Applied TypeORM IS NULL: ${alias}.${field} IS NULL`);
                    break;
                case 'isNotNull':
                    queryBuilder.andWhere(`${alias}.${field} IS NOT NULL`);
                    console.log(`Applied TypeORM IS NOT NULL: ${alias}.${field} IS NOT NULL`);
                    break;
                default:
                // this.logger.warn(`Unsupported TypeORM operator type: ${valueObj._type}`);
            }
            return;
        }
        // Handle custom operator format
        try {
            if ('eq' in valueObj) {
                const paramName = `${paramBaseName}_eq`;
                queryBuilder.andWhere(`${alias}.${field} = :${paramName}`, { [paramName]: valueObj.eq });
                console.log(`Applied custom equals: ${alias}.${field} = '${valueObj.eq}'`);
            }
            else if ('ne' in valueObj) {
                const paramName = `${paramBaseName}_ne`;
                queryBuilder.andWhere(`${alias}.${field} != :${paramName}`, { [paramName]: valueObj.ne });
                console.log(`Applied custom not equals: ${alias}.${field} != '${valueObj.ne}'`);
            }
            else if ('gt' in valueObj) {
                const paramName = `${paramBaseName}_gt`;
                queryBuilder.andWhere(`${alias}.${field} > :${paramName}`, { [paramName]: valueObj.gt });
                console.log(`Applied custom greater than: ${alias}.${field} > ${valueObj.gt}`);
            }
            else if ('gte' in valueObj) {
                const paramName = `${paramBaseName}_gte`;
                queryBuilder.andWhere(`${alias}.${field} >= :${paramName}`, { [paramName]: valueObj.gte });
                console.log(`Applied custom greater than or equal: ${alias}.${field} >= ${valueObj.gte}`);
            }
            else if ('lt' in valueObj) {
                const paramName = `${paramBaseName}_lt`;
                queryBuilder.andWhere(`${alias}.${field} < :${paramName}`, { [paramName]: valueObj.lt });
                console.log(`Applied custom less than: ${alias}.${field} < ${valueObj.lt}`);
            }
            else if ('lte' in valueObj) {
                const paramName = `${paramBaseName}_lte`;
                queryBuilder.andWhere(`${alias}.${field} <= :${paramName}`, { [paramName]: valueObj.lte });
                console.log(`Applied custom less than or equal: ${alias}.${field} <= ${valueObj.lte}`);
            }
            else if ('like' in valueObj) {
                const paramName = `${paramBaseName}_like`;
                queryBuilder.andWhere(`${alias}.${field} LIKE :${paramName}`, {
                    [paramName]: `%${valueObj.like}%`
                });
                console.log(`Applied custom LIKE: ${alias}.${field} LIKE '%${valueObj.like}%'`);
            }
            else if ('ilike' in valueObj) {
                const paramName = `${paramBaseName}_ilike`;
                queryBuilder.andWhere(`LOWER(${alias}.${field}) LIKE LOWER(:${paramName})`, {
                    [paramName]: `%${valueObj.ilike}%`
                });
                console.log(`Applied custom ILIKE: ${alias}.${field} ILIKE '%${valueObj.ilike}%'`);
            }
            else if ('in' in valueObj && Array.isArray(valueObj.in)) {
                const paramName = `${paramBaseName}_in`;
                queryBuilder.andWhere(`${alias}.${field} IN (:...${paramName})`, { [paramName]: valueObj.in });
                console.log(`Applied custom IN: ${alias}.${field} IN (${valueObj.in.join(', ')})`);
            }
            else if ('between' in valueObj && Array.isArray(valueObj.between) && valueObj.between.length === 2) {
                const paramMinName = `${paramBaseName}_between_min`;
                const paramMaxName = `${paramBaseName}_between_max`;
                queryBuilder.andWhere(`${alias}.${field} BETWEEN :${paramMinName} AND :${paramMaxName}`, {
                    [paramMinName]: valueObj.between[0],
                    [paramMaxName]: valueObj.between[1]
                });
                console.log(`Applied custom BETWEEN: ${alias}.${field} BETWEEN ${valueObj.between[0]} AND ${valueObj.between[1]}`);
            }
            else if ('isNull' in valueObj) {
                if (valueObj.isNull) {
                    queryBuilder.andWhere(`${alias}.${field} IS NULL`);
                    console.log(`Applied custom IS NULL: ${alias}.${field} IS NULL`);
                }
                else {
                    queryBuilder.andWhere(`${alias}.${field} IS NOT NULL`);
                    console.log(`Applied custom IS NOT NULL: ${alias}.${field} IS NOT NULL`);
                }
            }
            else {
                console.warn(`Unknown operator in filter object: ${JSON.stringify(valueObj)}`);
                this.logger.warn(`Unknown operator in filter object: ${JSON.stringify(valueObj)}`);
            }
        }
        catch (error) {
            console.error(`Error applying operator for ${alias}.${field}:`, error);
            if (error instanceof Error) {
                this.logger.error(`Error applying operator for ${alias}.${field}: ${error.message}`, error.stack);
            }
            else {
                this.logger.error(`Error applying operator for ${alias}.${field}: ${String(error)}`);
            }
        }
        // After applying any operator, log query parameters for debugging
        console.log('Current query parameters:', queryBuilder.getParameters());
    }
    // Helper method to recursively apply relations with field selection
    applyRelationsWithFieldSelection(queryBuilder, parentAlias, relations, select, joinedRelations = new Set()) {
        // Handle string array format for relations
        if (Array.isArray(relations)) {
            // Sort relations to ensure parent relations are joined before their children
            const sortedRelations = [...relations].sort((a, b) => {
                // Put non-nested relations first, then sort by nesting depth
                const aNestCount = (a.match(/\./g) || []).length;
                const bNestCount = (b.match(/\./g) || []).length;
                return aNestCount - bNestCount;
            });
            // Process each relation path
            sortedRelations.forEach(relationPath => {
                // Handle nested paths (e.g., "user.profile")
                if (relationPath.includes('.')) {
                    const relationParts = relationPath.split('.');
                    let currentAlias = parentAlias;
                    let currentPath = '';
                    // Process each part of the path
                    relationParts.forEach((part, index) => {
                        const isLastPart = index === relationParts.length - 1;
                        const prevPath = currentPath;
                        // Build the cumulative path
                        currentPath = prevPath ? `${prevPath}.${part}` : part;
                        const fullRelationPath = `${currentAlias}.${part}`;
                        const newAlias = `${currentPath.replace(/\./g, '_')}_rel`;
                        // Skip if this relation segment is already joined
                        if (joinedRelations.has(newAlias)) {
                            currentAlias = newAlias;
                            return;
                        }
                        joinedRelations.add(newAlias);
                        // Join with or without selecting all fields
                        if (isLastPart) {
                            queryBuilder.leftJoinAndSelect(fullRelationPath, newAlias);
                        }
                        else {
                            // For intermediate relations, just join without selecting fields
                            queryBuilder.leftJoin(fullRelationPath, newAlias);
                        }
                        // Update current alias for the next iteration
                        currentAlias = newAlias;
                    });
                }
                else {
                    // Handle simple non-nested relations
                    const relationAlias = `${relationPath}_rel`;
                    // Skip if already joined
                    if (joinedRelations.has(relationAlias)) {
                        return;
                    }
                    joinedRelations.add(relationAlias);
                    queryBuilder.leftJoinAndSelect(`${parentAlias}.${relationPath}`, relationAlias);
                }
            });
            return;
        }
        // Rest of the method for object-format relations stays the same
        Object.entries(relations).forEach(([relationName, relationValue]) => {
            if (!relationValue)
                return;
            const relationAlias = `${relationName}_rel`;
            // Skip if already joined
            if (joinedRelations.has(relationAlias)) {
                return;
            }
            joinedRelations.add(relationAlias);
            // Handle nested relations
            if (typeof relationValue === 'object') {
                // Join the parent relation
                queryBuilder.leftJoinAndSelect(`${parentAlias}.${relationName}`, relationAlias);
                // Apply nested relations recursively
                this.applyRelationsWithFieldSelection(queryBuilder, relationAlias, relationValue, select, joinedRelations);
            }
            else {
                // Apply field selection for this relation if specified
                const relationSelect = this.extractNestedSelect(relationName, select);
                if (relationSelect && Object.keys(relationSelect).length > 0) {
                    // Join without selecting all fields
                    queryBuilder.leftJoin(`${parentAlias}.${relationName}`, relationAlias);
                    // Add ID field to ensure proper relation loading
                    queryBuilder.addSelect(`${relationAlias}.id`);
                    // Add each selected field
                    Object.entries(relationSelect).forEach(([field, included]) => {
                        if (included) {
                            queryBuilder.addSelect(`${relationAlias}.${field}`);
                        }
                    });
                }
                else {
                    // No specific field selection, select all fields
                    queryBuilder.leftJoinAndSelect(`${parentAlias}.${relationName}`, relationAlias);
                }
            }
        });
    }
    // Extract nested select fields for a specific relation
    extractNestedSelect(relationName, select) {
        if (!select)
            return undefined;
        const nestedSelect = {};
        let hasNestedFields = false;
        // Handle array format for select
        if (Array.isArray(select)) {
            // For array format, check if any items start with the relation name
            select.forEach(fieldPath => {
                if (typeof fieldPath === 'string' && fieldPath.startsWith(`${relationName}.`)) {
                    const nestedField = fieldPath.substring(relationName.length + 1);
                    nestedSelect[nestedField] = true;
                    hasNestedFields = true;
                }
            });
        }
        else {
            // Handle object format
            Object.entries(select).forEach(([field, included]) => {
                if (field.startsWith(`${relationName}.`)) {
                    const nestedField = field.substring(relationName.length + 1);
                    nestedSelect[nestedField] = included;
                    hasNestedFields = true;
                }
            });
        }
        return hasNestedFields ? nestedSelect : undefined;
    }
    /**
     * Finds a single entity matching the specified criteria.
     *
     * @param criteria - Fields to search by (partial entity)
     * @param options - Additional query options
     * @param options.relations - Relations to eager load with the entity
     * @param options.select - Fields to select from the entity
     * @param options.order - Sort order for the query results
     * @param options.withDeleted - Whether to include soft-deleted entities (default: false)
     * @param options.cache - Enable result caching (boolean, TTL in ms, or cache options object)
     * @param options.loadEagerRelations - Whether to load eager relations (default: true)
     * @param options.transaction - Whether the query should use an existing transaction
     *
     * @returns A Promise resolving to the matched entity or null if not found
     *
     * @example
     * // Find a user by email
     * const user = await userService.findOneBy({ email: 'example@domain.com' });
     *
     * // Find a user with related posts
     * const userWithPosts = await userService.findOneBy(
     *   { id: 123 },
     *   { relations: { posts: true } }
     * );
     */
    async findOneBy(criteria, options) {
        const findOptions = Object.assign({ where: Object.assign(Object.assign({}, (!(options === null || options === void 0 ? void 0 : options.withDeleted) && 'isDeleted' in criteria ? {} : { isDeleted: false })), criteria) }, options);
        return await this.repository.findOne(findOptions);
    }
    async findOneByOrFail(criteria, options) {
        const entity = await this.findOneBy(criteria, options);
        if (!entity) {
            throw new common_1.NotFoundException(`${this.entityName} with ${utility_helper_1.UtilityHelper.formatCriteria(criteria)} not found`);
        }
        return entity;
    }
    // DONE
    async create(createDto, createdBy) {
        const entity = this.repository.create(Object.assign(Object.assign({}, createDto), { createdBy }));
        try {
            return await this.repository.save(entity);
        }
        catch (error) {
            console.log('Full error object:', JSON.stringify(error, null, 2));
            throw error;
        }
    }
    // DONE
    async update(id, updateDto, updatedBy) {
        const entity = await this.findOneByOrFail({ id });
        const updatedEntity = await this.repository.save(Object.assign(Object.assign(Object.assign({}, entity), updateDto), { updatedBy }));
        return updatedEntity;
    }
    // DONE
    async softDelete(id, deletedBy) {
        if (deletedBy) {
            await this.repository.update(id, { deletedBy });
        }
        await this.repository.softDelete(id);
        const response = new generalresponse_dto_1.GeneralResponseDto();
        response.statusCode = common_1.HttpStatus.NO_CONTENT;
        response.timestamp = new Date().toISOString();
        response.detail = 'Deletion Successful';
        response.message = `${this.entityName} with id ${id} was deleted successfully`;
        return response;
    }
    async save(entity) {
        return await this.repository.save(entity);
    }
    // DONE
    async delete(id) {
        const result = await this.repository.delete(id);
        if (result.affected === 0) {
            throw new common_1.NotFoundException(`${this.entityName} with id ${id} not found`);
        }
        const response = new generalresponse_dto_1.GeneralResponseDto();
        response.statusCode = common_1.HttpStatus.NO_CONTENT;
        response.timestamp = new Date().toISOString();
        response.detail = 'Deletion Successful';
        response.message = `${this.entityName} with id ${id} was deleted successfully`;
        return response;
    }
    // DONE
    async deleteMany(ids, hardDelete = false) {
        if (ids.length === 0) {
            throw new common_1.BadRequestException('No ids provided for deletion.');
        }
        const existingEntities = await this.repository.findBy({
            id: (0, typeorm_1.In)(ids),
        });
        if (existingEntities.length !== ids.length) {
            const foundIds = existingEntities.map(entity => entity.id);
            const missingIds = ids.filter(id => !foundIds.includes(id));
            throw new common_1.NotFoundException(`${this.entityName}s with ids ${missingIds.join(', ')} not found.`);
        }
        await this.transactionService.executeInTransaction(async (queryRunner) => {
            try {
                if (!hardDelete) {
                    // Perform soft delete by updating isDeleted flag
                    await queryRunner.manager.update(this.entityType, { id: (0, typeorm_1.In)(ids) }, { isDeleted: true, deletedAt: new Date() });
                }
                else {
                    // Perform hard delete (physically remove records)
                    await queryRunner.manager.delete(this.entityType, ids);
                }
            }
            catch (error) {
                throw new common_1.InternalServerErrorException(`Failed to delete ${this.entityName}s.`);
            }
        });
    }
    createQueryBuilder(options) {
        const { alias = 'entity', filters = {}, relations = {}, orderBy = {}, select = [] } = options;
        const queryBuilder = this.repository.createQueryBuilder(alias);
        // Apply WHERE conditions
        Object.entries(filters).forEach(([key, value]) => {
            if (key.includes('.')) {
                // Handle nested filters (relations)
                const [relationPath, field] = key.split('.');
                queryBuilder.andWhere(`${relationPath}.${field} = :${key.replace('.', '_')}`, {
                    [key.replace('.', '_')]: value
                });
            }
            else if (Array.isArray(value)) {
                // Handle array values like roles
                if (key.endsWith('s') && typeof value[0] === 'object') {
                    // Many-to-many or one-to-many relation array (like "roles")
                    const relationName = key;
                    const relationAlias = `${relationName}_filtered`;
                    queryBuilder.innerJoinAndSelect(`${alias}.${relationName}`, relationAlias);
                    queryBuilder.andWhere(`${relationAlias}.id IN (:...${key}Ids)`, {
                        [`${key}Ids`]: value.map(item => item.id || item)
                    });
                }
                else {
                    // Simple array values
                    queryBuilder.andWhere(`${alias}.${key} IN (:...${key})`, { [key]: value });
                }
            }
            else if (typeof value === 'object' && value !== null && !(value instanceof Date)) {
                // Handle TypeORM operators
                Object.entries(value).forEach(([operator, operatorValue]) => {
                    switch (operator) {
                        case 'like':
                            queryBuilder.andWhere(`${alias}.${key} LIKE :${key}_like`, {
                                [`${key}_like`]: `%${operatorValue}%`
                            });
                            break;
                        case 'gt':
                            queryBuilder.andWhere(`${alias}.${key} > :${key}_gt`, { [`${key}_gt`]: operatorValue });
                            break;
                        case 'gte':
                            queryBuilder.andWhere(`${alias}.${key} >= :${key}_gte`, { [`${key}_gte`]: operatorValue });
                            break;
                        case 'lt':
                            queryBuilder.andWhere(`${alias}.${key} < :${key}_lt`, { [`${key}_lt`]: operatorValue });
                            break;
                        case 'lte':
                            queryBuilder.andWhere(`${alias}.${key} <= :${key}_lte`, { [`${key}_lte`]: operatorValue });
                            break;
                        default:
                            queryBuilder.andWhere(`${alias}.${key} = :${key}`, { [key]: value });
                    }
                });
            }
            else {
                // Simple equality
                queryBuilder.andWhere(`${alias}.${key} = :${key}`, { [key]: value });
            }
        });
        // Apply relations
        Object.entries(relations).forEach(([relationName, relationOptions]) => {
            if (relationOptions === true) {
                queryBuilder.leftJoinAndSelect(`${alias}.${relationName}`, relationName);
            }
            else if (typeof relationOptions === 'object') {
                const relationAlias = relationName;
                queryBuilder.leftJoinAndSelect(`${alias}.${relationName}`, relationAlias);
                // Apply filters to the relation if needed
                if (relationOptions.where) {
                    Object.entries(relationOptions.where).forEach(([field, value]) => {
                        queryBuilder.andWhere(`${relationAlias}.${field} = :${relationAlias}_${field}`, {
                            [`${relationAlias}_${field}`]: value
                        });
                    });
                }
            }
        });
        // Apply ordering
        Object.entries(orderBy).forEach(([key, direction]) => {
            queryBuilder.addOrderBy(`${alias}.${key}`, direction);
        });
        // Apply select fields if specified
        if (select.length > 0) {
            queryBuilder.select(select.map(field => `${alias}.${field}`));
        }
        return queryBuilder;
    }
    /**
     * Include a related entity (similar to EF Include)
     */
    include(navigationPropertyPath) {
        const propertyName = this.getPropertyName(navigationPropertyPath);
        const joinAlias = propertyName;
        const joinPath = `${this.repository.metadata.name.toLowerCase()}.${propertyName}`;
        this.queryState.includes.set(propertyName, joinPath);
        this.queryState.parentPath = propertyName;
        return this;
    }
    /**
     * Include a nested related entity (similar to EF ThenInclude)
     */
    thenInclude(navigationPropertyPath) {
        const propertyName = this.getPropertyName(navigationPropertyPath);
        const parentPath = this.queryState.parentPath;
        const joinPath = `${parentPath}.${propertyName}`;
        this.queryState.includes.set(joinPath, joinPath);
        this.queryState.parentPath = joinPath;
        return this;
    }
    /**
     * Filter entities based on a predicate
     */
    where(predicate) {
        const condition = this.parseExpression(predicate);
        this.queryState.whereConditions.push(condition.query);
        Object.assign(this.queryState.parameters, condition.parameters);
        return this;
    }
    /**
     * Order entities by a property ascending
     */
    orderBy(keySelector) {
        const propertyName = this.getPropertyName(keySelector);
        const alias = this.repository.metadata.name.toLowerCase();
        this.queryState.orderByClauses.push(`${alias}.${propertyName} ASC`);
        return this;
    }
    /**
     * Order entities by a property descending
     */
    orderByDescending(keySelector) {
        const propertyName = this.getPropertyName(keySelector);
        const alias = this.repository.metadata.name.toLowerCase();
        this.queryState.orderByClauses.push(`${alias}.${propertyName} DESC`);
        return this;
    }
    /**
     * Add a secondary ordering by a property ascending
     */
    thenBy(keySelector) {
        const propertyName = this.getPropertyName(keySelector);
        const alias = this.repository.metadata.name.toLowerCase();
        this.queryState.orderByClauses.push(`${alias}.${propertyName} ASC`);
        return this;
    }
    /**
     * Add a secondary ordering by a property descending
     */
    thenByDescending(keySelector) {
        const propertyName = this.getPropertyName(keySelector);
        const alias = this.repository.metadata.name.toLowerCase();
        this.queryState.orderByClauses.push(`${alias}.${propertyName} DESC`);
        return this;
    }
    /**
     * Skip a number of entities (for pagination)
     */
    skip(count) {
        this.queryState.skipValue = count;
        return this;
    }
    /**
     * Take a number of entities (for pagination)
     */
    take(count) {
        this.queryState.takeValue = count;
        return this;
    }
    /**
     * Execute the query with no tracking (better performance)
     */
    asNoTracking() {
        this.queryState.isTracking = false;
        return this;
    }
    /**
     * Execute the query and return all entities as a list
     */
    async toList() {
        try {
            const query = this.buildQuery();
            if (this.queryState.skipValue > 0) {
                query.skip(this.queryState.skipValue);
            }
            if (this.queryState.takeValue > 0) {
                query.take(this.queryState.takeValue);
            }
            const result = await query.getMany();
            this.resetQueryState();
            return result;
        }
        catch (error) {
            this.resetQueryState();
            throw error;
        }
    }
    /**
     * Execute the query and return a paginated response
     */
    async toPagedList(skip = 0, take = 10) {
        try {
            const query = this.buildQuery();
            // Use provided values or those set by skip()/take() methods
            const skipValue = this.queryState.skipValue > 0 ? this.queryState.skipValue : skip;
            const takeValue = this.queryState.takeValue > 0 ? this.queryState.takeValue : take;
            query.skip(skipValue).take(takeValue);
            const [data, totalCount] = await Promise.all([
                query.getMany(),
                query.getCount()
            ]);
            const paginationDto = new pagination_dto_1.PaginationDto();
            Object.assign(paginationDto, {
                skip: skipValue,
                take: takeValue
            });
            this.resetQueryState();
            return {
                data,
                totalCount,
                meta: paginationDto
            };
        }
        catch (error) {
            this.resetQueryState();
            throw error;
        }
    }
    /**
     * Execute the query and return the first entity or null
     */
    async firstOrDefault() {
        try {
            const query = this.buildQuery();
            query.take(1);
            const result = await query.getOne();
            this.resetQueryState();
            return result;
        }
        catch (error) {
            this.resetQueryState();
            throw error;
        }
    }
    /**
     * Execute the query and return the first entity or throw if not found
     */
    async first() {
        const result = await this.firstOrDefault();
        if (!result) {
            throw new common_1.NotFoundException(`${this.entityName} not found`);
        }
        return result;
    }
    /**
     * Execute the query and return a single entity or null
     * Throws if more than one entity is found
     */
    async singleOrDefault() {
        try {
            const query = this.buildQuery();
            const entities = await query.getMany();
            if (entities.length > 1) {
                throw new common_1.BadRequestException(`Expected a single ${this.entityName}, but found multiple`);
            }
            this.resetQueryState();
            return entities.length === 1 ? entities[0] : null;
        }
        catch (error) {
            this.resetQueryState();
            throw error;
        }
    }
    /**
     * Execute the query and return a single entity
     * Throws if no entity is found or more than one entity is found
     */
    async single() {
        const result = await this.singleOrDefault();
        if (!result) {
            throw new common_1.NotFoundException(`${this.entityName} not found`);
        }
        return result;
    }
    /**
     * Count the number of entities that match the query
     */
    async count() {
        try {
            const query = this.buildQuery();
            const count = await query.getCount();
            this.resetQueryState();
            return count;
        }
        catch (error) {
            this.resetQueryState();
            throw error;
        }
    }
    /**
     * Check if any entities match the query
     */
    async any() {
        const count = await this.count();
        return count > 0;
    }
    // Private helper methods
    /**
     * Build the TypeORM query from the state
     */
    buildQuery() {
        const alias = this.repository.metadata.name.toLowerCase();
        const query = this.repository.createQueryBuilder(alias);
        // Add includes (relations)
        this.queryState.includes.forEach((joinPath, key) => {
            const relationAlias = key.replace(/\./g, '_');
            query.leftJoinAndSelect(joinPath, relationAlias);
        });
        // Add where conditions
        this.queryState.whereConditions.forEach(condition => {
            query.andWhere(condition);
        });
        // Add parameters
        if (Object.keys(this.queryState.parameters).length > 0) {
            query.setParameters(this.queryState.parameters);
        }
        // Add order by
        this.queryState.orderByClauses.forEach(orderBy => {
            const [path, direction] = orderBy.split(' ');
            query.addOrderBy(path, direction);
        });
        // Filter out soft-deleted entities by default
        query.andWhere(`${alias}.isDeleted = :isDeleted`, { isDeleted: false });
        return query;
    }
    /**
     * Extract property name from an expression
     */
    getPropertyName(expression) {
        const funcStr = expression.toString();
        // Extract property name after the arrow function parameter
        const regex = /=>.*?\.([a-zA-Z0-9_]+)(?:\s|$|\)|\.|\[)/;
        const match = funcStr.match(regex);
        if (!match) {
            throw new Error(`Could not extract property name from expression: ${funcStr}`);
        }
        return match[1];
    }
    /**
     * Parse an expression into a SQL condition
     */
    parseExpression(expression) {
        const funcStr = expression.toString();
        const parameters = {};
        const alias = this.repository.metadata.name.toLowerCase();
        // Check for logical operators (AND, OR)
        if (funcStr.includes('&&') || funcStr.includes('||')) {
            return this.parseLogicalExpression(funcStr, alias);
        }
        // Handle basic comparison operations
        const comparisonRegex = /=>.*?\.([a-zA-Z0-9_]+)\s*(===|==|!==|!=|>=|<=|>|<)\s*([^;)]+)/;
        const comparisonMatch = funcStr.match(comparisonRegex);
        if (comparisonMatch) {
            const [_, property, operator, value] = comparisonMatch;
            const paramName = `param${++this.queryState.paramCounter}`;
            // Parse the value
            let parsedValue;
            if (value.trim() === 'true')
                parsedValue = true;
            else if (value.trim() === 'false')
                parsedValue = false;
            else if (value.trim() === 'null')
                parsedValue = null;
            else if (/^['"].*['"]$/.test(value.trim()))
                parsedValue = value.trim().slice(1, -1);
            else if (!isNaN(Number(value.trim())))
                parsedValue = Number(value.trim());
            else
                parsedValue = value.trim();
            parameters[paramName] = parsedValue;
            // Map JS operator to SQL operator
            const sqlOperator = this.mapOperator(operator);
            return {
                query: `${alias}.${property} ${sqlOperator} :${paramName}`,
                parameters
            };
        }
        // Handle method calls (includes, startsWith, endsWith)
        const methodRegex = /=>.*?\.([a-zA-Z0-9_]+)\.([a-zA-Z0-9_]+)\(([^)]*)\)/;
        const methodMatch = funcStr.match(methodRegex);
        if (methodMatch) {
            const [_, property, method, args] = methodMatch;
            const paramName = `param${++this.queryState.paramCounter}`;
            // Parse the arguments
            const parsedArgs = args.trim().split(',').map(arg => {
                const trimmedArg = arg.trim();
                if (trimmedArg.startsWith("'") || trimmedArg.startsWith('"')) {
                    return trimmedArg.slice(1, -1);
                }
                return trimmedArg;
            });
            // Handle common string methods
            switch (method) {
                case 'includes':
                    return {
                        query: `${alias}.${property} LIKE :${paramName}`,
                        parameters: { [paramName]: `%${parsedArgs[0]}%` }
                    };
                case 'startsWith':
                    return {
                        query: `${alias}.${property} LIKE :${paramName}`,
                        parameters: { [paramName]: `${parsedArgs[0]}%` }
                    };
                case 'endsWith':
                    return {
                        query: `${alias}.${property} LIKE :${paramName}`,
                        parameters: { [paramName]: `%${parsedArgs[0]}` }
                    };
                case 'indexOf':
                    return {
                        query: `${alias}.${property} LIKE :${paramName}`,
                        parameters: { [paramName]: `%${parsedArgs[0]}%` }
                    };
                case 'toLowerCase':
                    return {
                        query: `LOWER(${alias}.${property}) = LOWER(:${paramName})`,
                        parameters: { [paramName]: parsedArgs[0] || '' }
                    };
                case 'toUpperCase':
                    return {
                        query: `UPPER(${alias}.${property}) = UPPER(:${paramName})`,
                        parameters: { [paramName]: parsedArgs[0] || '' }
                    };
                case 'trim':
                    return {
                        query: `TRIM(${alias}.${property}) = :${paramName}`,
                        parameters: { [paramName]: parsedArgs[0] || '' }
                    };
                default:
                    throw new Error(`Unsupported method: ${method}`);
            }
        }
        // Handle null/undefined checks
        const nullCheckRegex = /=>.*?\.([a-zA-Z0-9_]+)\s*===?\s*(null|undefined)/;
        const nullCheckMatch = funcStr.match(nullCheckRegex);
        if (nullCheckMatch) {
            const [_, property] = nullCheckMatch;
            return {
                query: `${alias}.${property} IS NULL`,
                parameters: {}
            };
        }
        const notNullCheckRegex = /=>.*?\.([a-zA-Z0-9_]+)\s*!==?\s*(null|undefined)/;
        const notNullCheckMatch = funcStr.match(notNullCheckRegex);
        if (notNullCheckMatch) {
            const [_, property] = notNullCheckMatch;
            return {
                query: `${alias}.${property} IS NOT NULL`,
                parameters: {}
            };
        }
        // Fallback for unrecognized expressions
        this.logger.warn(`Could not parse expression: ${funcStr}. Using default true condition.`);
        return {
            query: '1=1', // Always true
            parameters: {}
        };
    }
    /**
     * Parse logical expressions with AND (&&) or OR (||)
     */
    parseLogicalExpression(funcStr, alias) {
        let parameters = {};
        // Function to create a dummy Expression
        const createDummyExpression = (expressionStr) => {
            return new Function(`return ${expressionStr}`)();
        };
        // Split by OR first (lower precedence)
        if (funcStr.includes('||')) {
            const orParts = funcStr.split('||').map(part => {
                // Extract just the lambda function part for each condition
                const lambdaMatch = part.match(/(?:^\s*|[|&]{2}\s*)(\([^=]*=>\s*[^|&]*)/);
                if (lambdaMatch && lambdaMatch[1]) {
                    const fixedExpression = `${lambdaMatch[1]})`;
                    const result = this.parseExpression(createDummyExpression(fixedExpression));
                    parameters = Object.assign(Object.assign({}, parameters), result.parameters);
                    return `(${result.query})`;
                }
                return '1=1'; // Default to true for parts we can't parse
            });
            return {
                query: orParts.join(' OR '),
                parameters
            };
        }
        // Split by AND
        if (funcStr.includes('&&')) {
            const andParts = funcStr.split('&&').map(part => {
                // Extract just the lambda function part for each condition
                const lambdaMatch = part.match(/(?:^\s*|[|&]{2}\s*)(\([^=]*=>\s*[^|&]*)/);
                if (lambdaMatch && lambdaMatch[1]) {
                    const fixedExpression = `${lambdaMatch[1]})`;
                    const result = this.parseExpression(createDummyExpression(fixedExpression));
                    parameters = Object.assign(Object.assign({}, parameters), result.parameters);
                    return `(${result.query})`;
                }
                return '1=1'; // Default to true for parts we can't parse
            });
            return {
                query: andParts.join(' AND '),
                parameters
            };
        }
        // Should not reach here
        return {
            query: '1=1',
            parameters: {}
        };
    }
    /**
     * Map JavaScript operators to SQL operators
     */
    mapOperator(operator) {
        switch (operator) {
            case '===':
            case '==': return '=';
            case '!==':
            case '!=': return '!=';
            case '>': return '>';
            case '>=': return '>=';
            case '<': return '<';
            case '<=': return '<=';
            default: return '=';
        }
    }
    /**
     * Reset the query state after execution
     */
    resetQueryState() {
        this.queryState = {
            includes: new Map(),
            whereConditions: [],
            parameters: {},
            orderByClauses: [],
            skipValue: 0,
            takeValue: 0,
            isTracking: true,
            queryBuilder: null,
            parentPath: '',
            paramCounter: 0
        };
    }
};
exports.BaseService = BaseService;
exports.BaseService = BaseService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_1.Repository !== "undefined" && typeorm_1.Repository) === "function" ? _a : Object, Object])
], BaseService);


/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dataSourceOptions = void 0;
const profile_entity_1 = __webpack_require__(33);
const address_entity_1 = __webpack_require__(35);
const document_type_entity_1 = __webpack_require__(79);
const config_1 = __webpack_require__(6);
const dotenv_1 = __webpack_require__(85);
const typeorm_1 = __webpack_require__(25);
(0, dotenv_1.config)();
const configService = new config_1.ConfigService();
const isProduction = configService.get('NODE_ENV') === 'production';
exports.dataSourceOptions = {
    type: 'mysql',
    host: configService.get('DB_HOST'),
    port: parseInt(configService.get('DB_PORT') || '3306', 10),
    username: configService.get('DB_USERNAME'),
    password: configService.get('DB_PASSWORD'),
    database: configService.get('DB_DATABASE'),
    entities: ['dist/**/*.entity{.ts,.js}', address_entity_1.Address, profile_entity_1.Profile, document_type_entity_1.DocumentType],
    migrations: ['dist/database/migrations/*{.ts,.js}'],
    synchronize: !isProduction,
    logging: false,
    ssl: isProduction,
    extra: {
        ssl: isProduction ? { rejectUnauthorized: false } : null,
    },
};
exports["default"] = new typeorm_1.DataSource(exports.dataSourceOptions);


/***/ }),
/* 33 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Profile = void 0;
const base_entity_1 = __webpack_require__(34);
const typeorm_1 = __webpack_require__(25);
const address_entity_1 = __webpack_require__(35);
const user_entity_1 = __webpack_require__(47);
let Profile = class Profile extends base_entity_1.BaseEntity {
};
exports.Profile = Profile;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Profile.prototype, "firstName", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "middleName", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Profile.prototype, "lastName", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Profile.prototype, "fullName", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "suffix", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "gender", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "sex", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "profilePicture", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Profile.prototype, "birthDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "civilStatus", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "citizenship", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "nationality", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Profile.prototype, "religion", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => user_entity_1.User, (user) => user.profile),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_b = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _b : Object)
], Profile.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Profile.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => address_entity_1.Address, (address) => address.profile, {
        cascade: true
    }),
    __metadata("design:type", typeof (_c = typeof address_entity_1.Address !== "undefined" && address_entity_1.Address) === "function" ? _c : Object)
], Profile.prototype, "address", void 0);
exports.Profile = Profile = __decorate([
    (0, typeorm_1.Entity)('profiles')
], Profile);


/***/ }),
/* 34 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseEntity = void 0;
const typeorm_1 = __webpack_require__(25);
class BaseEntity extends typeorm_1.BaseEntity {
    constructor(item) {
        super();
        Object.assign(this, item);
    }
}
exports.BaseEntity = BaseEntity;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)('uuid'),
    __metadata("design:type", String)
], BaseEntity.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({ type: 'timestamp' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], BaseEntity.prototype, "createdAt", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], BaseEntity.prototype, "updatedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BaseEntity.prototype, "createdBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BaseEntity.prototype, "updatedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], BaseEntity.prototype, "isDeleted", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BaseEntity.prototype, "deletedBy", void 0);
__decorate([
    (0, typeorm_1.DeleteDateColumn)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], BaseEntity.prototype, "deletedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    (0, typeorm_1.Index)("idx_organization"),
    __metadata("design:type", String)
], BaseEntity.prototype, "organizationId", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    (0, typeorm_1.Index)("idx_branch"),
    __metadata("design:type", String)
], BaseEntity.prototype, "branchId", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    (0, typeorm_1.Index)("idx_department"),
    __metadata("design:type", String)
], BaseEntity.prototype, "departmentId", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    (0, typeorm_1.Index)("idx_user"),
    __metadata("design:type", String)
], BaseEntity.prototype, "userId", void 0);


/***/ }),
/* 35 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Address = void 0;
const base_entity_1 = __webpack_require__(34);
const department_entity_1 = __webpack_require__(36);
const branch_entity_1 = __webpack_require__(41);
const organization_entity_1 = __webpack_require__(42);
const typeorm_1 = __webpack_require__(25);
const profile_entity_1 = __webpack_require__(33);
let Address = class Address extends base_entity_1.BaseEntity {
};
exports.Address = Address;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Address.prototype, "streetNameBuildingHouseNumber", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Address.prototype, "barangay", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Address.prototype, "cityOrMunicipality", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Address.prototype, "province", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Address.prototype, "region", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Number)
], Address.prototype, "postalCode", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => profile_entity_1.Profile, (profile) => profile.address, {
        onDelete: 'CASCADE', nullable: true
    }),
    (0, typeorm_1.JoinColumn)(),
    __metadata("design:type", typeof (_a = typeof profile_entity_1.Profile !== "undefined" && profile_entity_1.Profile) === "function" ? _a : Object)
], Address.prototype, "profile", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => organization_entity_1.Organization, (organization) => organization.address, {
        nullable: true
    }),
    (0, typeorm_1.JoinColumn)(),
    __metadata("design:type", typeof (_b = typeof organization_entity_1.Organization !== "undefined" && organization_entity_1.Organization) === "function" ? _b : Object)
], Address.prototype, "organization", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => branch_entity_1.Branch, (branch) => branch.address, {
        onDelete: 'CASCADE', nullable: true
    }),
    (0, typeorm_1.JoinColumn)(),
    __metadata("design:type", typeof (_c = typeof branch_entity_1.Branch !== "undefined" && branch_entity_1.Branch) === "function" ? _c : Object)
], Address.prototype, "branch", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => department_entity_1.Department, (department) => department.address, {
        onDelete: 'CASCADE', nullable: true
    }),
    (0, typeorm_1.JoinColumn)(),
    __metadata("design:type", typeof (_d = typeof department_entity_1.Department !== "undefined" && department_entity_1.Department) === "function" ? _d : Object)
], Address.prototype, "department", void 0);
exports.Address = Address = __decorate([
    (0, typeorm_1.Entity)('addresses')
], Address);


/***/ }),
/* 36 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Department = void 0;
const base_entity_1 = __webpack_require__(34);
const address_entity_1 = __webpack_require__(35);
const role_entity_1 = __webpack_require__(37);
const typeorm_1 = __webpack_require__(25);
const branch_entity_1 = __webpack_require__(41);
let Department = class Department extends base_entity_1.BaseEntity {
};
exports.Department = Department;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Department.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Department.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Department.prototype, "logo", void 0);
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Department.prototype, "alias", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Department.prototype, "email", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Department.prototype, "phoneNumber", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => address_entity_1.Address, (address) => address.department, {
        cascade: true
    }),
    __metadata("design:type", typeof (_a = typeof address_entity_1.Address !== "undefined" && address_entity_1.Address) === "function" ? _a : Object)
], Department.prototype, "address", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => branch_entity_1.Branch, (branch) => branch.departments, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'branchId' }),
    __metadata("design:type", typeof (_b = typeof branch_entity_1.Branch !== "undefined" && branch_entity_1.Branch) === "function" ? _b : Object)
], Department.prototype, "branch", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => role_entity_1.Role, (role) => role.department, { nullable: true, cascade: true }),
    __metadata("design:type", Array)
], Department.prototype, "roles", void 0);
exports.Department = Department = __decorate([
    (0, typeorm_1.Entity)('departments')
], Department);


/***/ }),
/* 37 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Role = void 0;
const role_scope_type_enum_1 = __webpack_require__(38);
const base_entity_1 = __webpack_require__(34);
const permission_entity_1 = __webpack_require__(39);
const department_entity_1 = __webpack_require__(36);
const branch_entity_1 = __webpack_require__(41);
const organization_entity_1 = __webpack_require__(42);
const typeorm_1 = __webpack_require__(25);
const employee_entity_1 = __webpack_require__(43);
let Role = class Role extends base_entity_1.BaseEntity {
};
exports.Role = Role;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Role.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Role.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: role_scope_type_enum_1.RoleScopeType,
        default: role_scope_type_enum_1.RoleScopeType.OWNED,
    }),
    __metadata("design:type", typeof (_a = typeof role_scope_type_enum_1.RoleScopeType !== "undefined" && role_scope_type_enum_1.RoleScopeType) === "function" ? _a : Object)
], Role.prototype, "scope", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => permission_entity_1.Permission, (permission) => permission.roles, { nullable: true, cascade: true }),
    (0, typeorm_1.JoinTable)({
        name: 'role_permissions',
        joinColumn: { name: 'role_id', referencedColumnName: 'id' },
        inverseJoinColumn: { name: 'permission_id', referencedColumnName: 'id' },
    }),
    __metadata("design:type", Array)
], Role.prototype, "permissions", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => employee_entity_1.Employee, (employee) => employee.roles, { nullable: true }),
    __metadata("design:type", Array)
], Role.prototype, "employees", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => organization_entity_1.Organization, (organization) => organization.roles, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'organizationId' }),
    __metadata("design:type", typeof (_b = typeof organization_entity_1.Organization !== "undefined" && organization_entity_1.Organization) === "function" ? _b : Object)
], Role.prototype, "organization", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => branch_entity_1.Branch, (branch) => branch.roles, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'branchId' }),
    __metadata("design:type", typeof (_c = typeof branch_entity_1.Branch !== "undefined" && branch_entity_1.Branch) === "function" ? _c : Object)
], Role.prototype, "branch", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => department_entity_1.Department, (department) => department.roles, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'departmentId' }),
    __metadata("design:type", typeof (_d = typeof department_entity_1.Department !== "undefined" && department_entity_1.Department) === "function" ? _d : Object)
], Role.prototype, "department", void 0);
exports.Role = Role = __decorate([
    (0, typeorm_1.Entity)('roles')
], Role);


/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleScopeType = void 0;
var RoleScopeType;
(function (RoleScopeType) {
    RoleScopeType["GLOBAL"] = "global";
    RoleScopeType["ORGANIZATION"] = "organization";
    RoleScopeType["BRANCH"] = "branch";
    RoleScopeType["DEPARTMENT"] = "department";
    RoleScopeType["OWNED"] = "owned";
})(RoleScopeType || (exports.RoleScopeType = RoleScopeType = {}));


/***/ }),
/* 39 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Permission = void 0;
const typeorm_1 = __webpack_require__(25);
const action_enum_1 = __webpack_require__(40);
const base_entity_1 = __webpack_require__(34);
const role_entity_1 = __webpack_require__(37);
let Permission = class Permission extends base_entity_1.BaseEntity {
};
exports.Permission = Permission;
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Permission.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Permission.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: action_enum_1.Action,
    }),
    __metadata("design:type", typeof (_a = typeof action_enum_1.Action !== "undefined" && action_enum_1.Action) === "function" ? _a : Object)
], Permission.prototype, "action", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Permission.prototype, "subject", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => role_entity_1.Role, Role => Role.permissions, { nullable: true }),
    __metadata("design:type", Array)
], Permission.prototype, "roles", void 0);
exports.Permission = Permission = __decorate([
    (0, typeorm_1.Entity)('permissions')
], Permission);


/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Action = void 0;
var Action;
(function (Action) {
    Action["MANAGE"] = "manage";
    Action["CREATE"] = "create";
    Action["READ"] = "read";
    Action["UPDATE"] = "update";
    Action["DELETE"] = "delete";
})(Action || (exports.Action = Action = {}));


/***/ }),
/* 41 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Branch = void 0;
const base_entity_1 = __webpack_require__(34);
const address_entity_1 = __webpack_require__(35);
const role_entity_1 = __webpack_require__(37);
const typeorm_1 = __webpack_require__(25);
const organization_entity_1 = __webpack_require__(42);
const department_entity_1 = __webpack_require__(36);
let Branch = class Branch extends base_entity_1.BaseEntity {
};
exports.Branch = Branch;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Branch.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Branch.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Branch.prototype, "logo", void 0);
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Branch.prototype, "alias", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Branch.prototype, "email", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Branch.prototype, "phoneNumber", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => address_entity_1.Address, (address) => address.branch, {
        cascade: true
    }),
    __metadata("design:type", typeof (_a = typeof address_entity_1.Address !== "undefined" && address_entity_1.Address) === "function" ? _a : Object)
], Branch.prototype, "address", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => organization_entity_1.Organization, (organization) => organization.branches, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'organizationId' }),
    __metadata("design:type", typeof (_b = typeof organization_entity_1.Organization !== "undefined" && organization_entity_1.Organization) === "function" ? _b : Object)
], Branch.prototype, "organization", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => department_entity_1.Department, (department) => department.branch, { cascade: true }),
    __metadata("design:type", Array)
], Branch.prototype, "departments", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => role_entity_1.Role, (role) => role.branch, { nullable: true, cascade: true }),
    __metadata("design:type", Array)
], Branch.prototype, "roles", void 0);
exports.Branch = Branch = __decorate([
    (0, typeorm_1.Entity)('branches')
], Branch);


/***/ }),
/* 42 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Organization = void 0;
const address_entity_1 = __webpack_require__(35);
const role_entity_1 = __webpack_require__(37);
const typeorm_1 = __webpack_require__(25);
const base_entity_1 = __webpack_require__(34);
const branch_entity_1 = __webpack_require__(41);
let Organization = class Organization extends base_entity_1.BaseEntity {
};
exports.Organization = Organization;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Organization.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Organization.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Organization.prototype, "logo", void 0);
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Organization.prototype, "alias", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Organization.prototype, "email", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Organization.prototype, "phoneNumber", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => address_entity_1.Address, (address) => address.organization, {
        cascade: true
    }),
    __metadata("design:type", typeof (_a = typeof address_entity_1.Address !== "undefined" && address_entity_1.Address) === "function" ? _a : Object)
], Organization.prototype, "address", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => branch_entity_1.Branch, (branch) => branch.organization, { cascade: true }),
    __metadata("design:type", Array)
], Organization.prototype, "branches", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => role_entity_1.Role, (role) => role.organization, { nullable: true, cascade: true }),
    __metadata("design:type", Array)
], Organization.prototype, "roles", void 0);
exports.Organization = Organization = __decorate([
    (0, typeorm_1.Entity)('organizations')
], Organization);


/***/ }),
/* 43 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Employee = void 0;
const employment_condition_enum_1 = __webpack_require__(44);
const employment_status_enum_1 = __webpack_require__(45);
const employment_type_enum_1 = __webpack_require__(46);
const base_entity_1 = __webpack_require__(34);
const user_entity_1 = __webpack_require__(47);
const attendance_entity_1 = __webpack_require__(52);
const final_work_hour_entity_1 = __webpack_require__(58);
const work_time_request_entity_1 = __webpack_require__(49);
const role_entity_1 = __webpack_require__(37);
const payroll_entity_1 = __webpack_require__(63);
const payroll_item_entity_1 = __webpack_require__(65);
const group_entity_1 = __webpack_require__(60);
const schedule_entity_1 = __webpack_require__(53);
const typeorm_1 = __webpack_require__(25);
let Employee = class Employee extends base_entity_1.BaseEntity {
};
exports.Employee = Employee;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", Number)
], Employee.prototype, "employeeNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: employment_status_enum_1.EmploymentStatus,
        default: employment_status_enum_1.EmploymentStatus.PENDING
    }),
    __metadata("design:type", typeof (_a = typeof employment_status_enum_1.EmploymentStatus !== "undefined" && employment_status_enum_1.EmploymentStatus) === "function" ? _a : Object)
], Employee.prototype, "employmentStatus", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: employment_condition_enum_1.EmploymentCondition,
        default: employment_condition_enum_1.EmploymentCondition.PROBATIONARY
    }),
    __metadata("design:type", typeof (_b = typeof employment_condition_enum_1.EmploymentCondition !== "undefined" && employment_condition_enum_1.EmploymentCondition) === "function" ? _b : Object)
], Employee.prototype, "employmentCondition", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Employee.prototype, "biometricsPassword", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", Number)
], Employee.prototype, "biometricsRole", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Employee.prototype, "cardNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: employment_type_enum_1.EmploymentType,
        default: employment_type_enum_1.EmploymentType.FULL_TIME
    }),
    __metadata("design:type", typeof (_c = typeof employment_type_enum_1.EmploymentType !== "undefined" && employment_type_enum_1.EmploymentType) === "function" ? _c : Object)
], Employee.prototype, "employmentType", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], Employee.prototype, "commencementDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 0 }),
    __metadata("design:type", Number)
], Employee.prototype, "leaveCredits", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 0 }),
    __metadata("design:type", Number)
], Employee.prototype, "offsetLeaveCredits", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => user_entity_1.User, (user) => user.employee),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_e = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _e : Object)
], Employee.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => role_entity_1.Role, (role) => role.employees, { nullable: true }),
    (0, typeorm_1.JoinTable)({
        name: 'employee_roles',
        joinColumn: { name: 'employee_id', referencedColumnName: 'id' },
        inverseJoinColumn: { name: 'role_id', referencedColumnName: 'id' },
    }),
    __metadata("design:type", Array)
], Employee.prototype, "roles", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => payroll_item_entity_1.PayrollItem, (payrollItem) => payrollItem.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "payrollItems", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => group_entity_1.Group, (group) => group.employees, { nullable: true, eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'groupId' }),
    __metadata("design:type", typeof (_f = typeof group_entity_1.Group !== "undefined" && group_entity_1.Group) === "function" ? _f : Object)
], Employee.prototype, "group", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Employee.prototype, "monthlyRate", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => schedule_entity_1.Schedule, (schedule) => schedule.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "schedules", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => attendance_entity_1.Attendance, (attendance) => attendance.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "attendances", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => final_work_hour_entity_1.FinalWorkHour, (finalWorkHour) => finalWorkHour.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "finalWorkHours", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => payroll_entity_1.Payroll, (payroll) => payroll.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "payrolls", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => work_time_request_entity_1.WorkTimeRequest, (workTimeRequest) => workTimeRequest.employee, { nullable: true }),
    __metadata("design:type", Array)
], Employee.prototype, "workTimeRequests", void 0);
exports.Employee = Employee = __decorate([
    (0, typeorm_1.Entity)('employees')
], Employee);


/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmploymentCondition = void 0;
var EmploymentCondition;
(function (EmploymentCondition) {
    EmploymentCondition["PROBATIONARY"] = "probationary";
    EmploymentCondition["REGULAR"] = "regular";
})(EmploymentCondition || (exports.EmploymentCondition = EmploymentCondition = {}));


/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmploymentStatus = void 0;
var EmploymentStatus;
(function (EmploymentStatus) {
    EmploymentStatus["ACTIVE"] = "active";
    EmploymentStatus["INACTIVE"] = "inactive";
    EmploymentStatus["PENDING"] = "pending";
    EmploymentStatus["SUSPENDED"] = "suspended";
    EmploymentStatus["ON_LEAVE"] = "on_leave";
    EmploymentStatus["RESIGNED"] = "resigned";
    EmploymentStatus["TERMINATED"] = "terminated";
    EmploymentStatus["RETIRED"] = "retired";
    EmploymentStatus["DECEASED"] = "deceased";
})(EmploymentStatus || (exports.EmploymentStatus = EmploymentStatus = {}));


/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmploymentType = void 0;
var EmploymentType;
(function (EmploymentType) {
    EmploymentType["FULL_TIME"] = "full_time";
    EmploymentType["PART_TIME"] = "part_time";
    EmploymentType["CONTRACTUAL"] = "contractual";
    EmploymentType["TEMPORARY"] = "temporary";
    EmploymentType["FREELANCE"] = "freelance";
    EmploymentType["INTERNSHIP"] = "internship";
    EmploymentType["TRAINEE"] = "trainee";
    EmploymentType["CONSULTANT"] = "consultant";
    EmploymentType["VOLUNTEER"] = "volunteer";
    EmploymentType["OTHER"] = "other";
})(EmploymentType || (exports.EmploymentType = EmploymentType = {}));


/***/ }),
/* 47 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.User = void 0;
const document_entity_1 = __webpack_require__(48);
const employee_entity_1 = __webpack_require__(43);
const activity_log_entity_1 = __webpack_require__(80);
const notification_entity_1 = __webpack_require__(82);
const typeorm_1 = __webpack_require__(25);
const base_entity_1 = __webpack_require__(34);
const profile_entity_1 = __webpack_require__(33);
const session_entity_1 = __webpack_require__(84);
let User = class User extends base_entity_1.BaseEntity {
    constructor() {
        super(...arguments);
        this.lockedOut = false;
        // @OneToMany(() => SocialLogin, (socialLogin) => socialLogin.user)
        // socialLogins?: SocialLogin[];
    }
};
exports.User = User;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], User.prototype, "email", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], User.prototype, "password", void 0);
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], User.prototype, "userName", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => profile_entity_1.Profile, (profile) => profile.user, { cascade: true, eager: true }),
    __metadata("design:type", typeof (_a = typeof profile_entity_1.Profile !== "undefined" && profile_entity_1.Profile) === "function" ? _a : Object)
], User.prototype, "profile", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], User.prototype, "lastLogin", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], User.prototype, "phoneNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], User.prototype, "emailVerified", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], User.prototype, "phoneNumberVerified", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 0 }),
    __metadata("design:type", Number)
], User.prototype, "accessFailedCount", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], User.prototype, "lockoutEnabled", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Boolean)
], User.prototype, "lockedOut", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], User.prototype, "lockOutStart", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], User.prototype, "lockOutEnd", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], User.prototype, "verificationToken", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], User.prototype, "verificationTokenExpires", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => session_entity_1.Session, (session) => session.user, { nullable: true }),
    __metadata("design:type", Array)
], User.prototype, "sessions", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => activity_log_entity_1.ActivityLog, (activityLog) => activityLog.user, { nullable: true }),
    __metadata("design:type", Array)
], User.prototype, "activityLogs", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => document_entity_1.Document, (document) => document.user, { nullable: true }),
    __metadata("design:type", Array)
], User.prototype, "documents", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => notification_entity_1.Notification, (notification) => notification.user, { nullable: true }),
    __metadata("design:type", Array)
], User.prototype, "notifications", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => employee_entity_1.Employee, (employee) => employee.user, { nullable: true }),
    __metadata("design:type", typeof (_f = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _f : Object)
], User.prototype, "employee", void 0);
exports.User = User = __decorate([
    (0, typeorm_1.Entity)('users')
], User);


/***/ }),
/* 48 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Document = void 0;
const base_entity_1 = __webpack_require__(34);
const user_entity_1 = __webpack_require__(47);
const work_time_request_entity_1 = __webpack_require__(49);
const schedule_change_request_entity_1 = __webpack_require__(70);
const typeorm_1 = __webpack_require__(25);
const document_type_entity_1 = __webpack_require__(79);
let Document = class Document extends base_entity_1.BaseEntity {
};
exports.Document = Document;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Document.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Document.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Document.prototype, "fileKey", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Number)
], Document.prototype, "size", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Document.prototype, "mimeType", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, (user) => user.documents, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_a = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _a : Object)
], Document.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => document_type_entity_1.DocumentType, (doctype) => doctype.documents),
    (0, typeorm_1.JoinColumn)({ name: 'documentTypeId' }),
    __metadata("design:type", typeof (_b = typeof document_type_entity_1.DocumentType !== "undefined" && document_type_entity_1.DocumentType) === "function" ? _b : Object)
], Document.prototype, "documentType", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => schedule_change_request_entity_1.ScheduleChangeRequest, (scheduleChangeRequest) => scheduleChangeRequest.documents, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'scheduleChangeRequestId' }),
    __metadata("design:type", typeof (_c = typeof schedule_change_request_entity_1.ScheduleChangeRequest !== "undefined" && schedule_change_request_entity_1.ScheduleChangeRequest) === "function" ? _c : Object)
], Document.prototype, "scheduleChangeRequest", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => work_time_request_entity_1.WorkTimeRequest, (workTimeRequest) => workTimeRequest.documents, { nullable: true }),
    __metadata("design:type", typeof (_d = typeof work_time_request_entity_1.WorkTimeRequest !== "undefined" && work_time_request_entity_1.WorkTimeRequest) === "function" ? _d : Object)
], Document.prototype, "workTimeRequest", void 0);
exports.Document = Document = __decorate([
    (0, typeorm_1.Entity)('documents')
], Document);


/***/ }),
/* 49 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeRequest = void 0;
const attendance_status_enum_1 = __webpack_require__(50);
const request_status_enum_1 = __webpack_require__(51);
const base_entity_1 = __webpack_require__(34);
const document_entity_1 = __webpack_require__(48);
const employee_entity_1 = __webpack_require__(43);
const typeorm_1 = __webpack_require__(25);
const attendance_entity_1 = __webpack_require__(52);
const final_work_hour_entity_1 = __webpack_require__(58);
const work_time_response_entity_1 = __webpack_require__(78);
let WorkTimeRequest = class WorkTimeRequest extends base_entity_1.BaseEntity {
};
exports.WorkTimeRequest = WorkTimeRequest;
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.workTimeRequests),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_a = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _a : Object)
], WorkTimeRequest.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: request_status_enum_1.RequestStatus, default: request_status_enum_1.RequestStatus.PENDING }),
    __metadata("design:type", typeof (_b = typeof request_status_enum_1.RequestStatus !== "undefined" && request_status_enum_1.RequestStatus) === "function" ? _b : Object)
], WorkTimeRequest.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: attendance_status_enum_1.AttendanceStatus }),
    __metadata("design:type", typeof (_c = typeof attendance_status_enum_1.AttendanceStatus !== "undefined" && attendance_status_enum_1.AttendanceStatus) === "function" ? _c : Object)
], WorkTimeRequest.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'decimal', precision: 10, scale: 2, nullable: true }),
    __metadata("design:type", Number)
], WorkTimeRequest.prototype, "duration", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: final_work_hour_entity_1.DayType,
        default: final_work_hour_entity_1.DayType.REGULAR_DAY
    }),
    __metadata("design:type", typeof (_d = typeof final_work_hour_entity_1.DayType !== "undefined" && final_work_hour_entity_1.DayType) === "function" ? _d : Object)
], WorkTimeRequest.prototype, "dayType", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => attendance_entity_1.Attendance, (attendance) => attendance.workTimeRequests),
    (0, typeorm_1.JoinColumn)({ name: 'attendanceId' }),
    __metadata("design:type", typeof (_e = typeof attendance_entity_1.Attendance !== "undefined" && attendance_entity_1.Attendance) === "function" ? _e : Object)
], WorkTimeRequest.prototype, "attendance", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => document_entity_1.Document, (document) => document.workTimeRequest, { nullable: true }),
    __metadata("design:type", Array)
], WorkTimeRequest.prototype, "documents", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], WorkTimeRequest.prototype, "reason", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => work_time_response_entity_1.WorkTimeResponse, (workTimeResponse) => workTimeResponse.workTimeRequest, { eager: true, nullable: true, cascade: true }),
    (0, typeorm_1.JoinColumn)({ name: 'workTimeResponseId' }),
    __metadata("design:type", typeof (_f = typeof work_time_response_entity_1.WorkTimeResponse !== "undefined" && work_time_response_entity_1.WorkTimeResponse) === "function" ? _f : Object)
], WorkTimeRequest.prototype, "workTimeResponse", void 0);
exports.WorkTimeRequest = WorkTimeRequest = __decorate([
    (0, typeorm_1.Entity)('work-time-requests')
], WorkTimeRequest);


/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendanceStatus = void 0;
var AttendanceStatus;
(function (AttendanceStatus) {
    AttendanceStatus["NO_CHECKED_IN"] = "NO_CHECKED_IN";
    AttendanceStatus["NO_CHECKED_OUT"] = "NO_CHECKED_OUT";
    AttendanceStatus["CHECKED_IN"] = "CHECKED_IN";
    AttendanceStatus["CHECKED_OUT"] = "CHECKED_OUT";
    AttendanceStatus["OVERTIME"] = "OVER_TIME";
    AttendanceStatus["UNDER_TIME"] = "UNDER_TIME";
    AttendanceStatus["LATE"] = "LATE";
    AttendanceStatus["ABSENT"] = "ABSENT";
    AttendanceStatus["REST_DAY"] = "REST_DAY";
    AttendanceStatus["HOLIDAY"] = "HOLIDAY";
    AttendanceStatus["LEAVE"] = "LEAVE";
    AttendanceStatus["OFFSET"] = "OFFSET";
})(AttendanceStatus || (exports.AttendanceStatus = AttendanceStatus = {}));


/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestStatus = void 0;
var RequestStatus;
(function (RequestStatus) {
    RequestStatus["PENDING"] = "PENDING";
    RequestStatus["APPROVED"] = "APPROVED";
    RequestStatus["REJECTED"] = "REJECTED";
})(RequestStatus || (exports.RequestStatus = RequestStatus = {}));


/***/ }),
/* 52 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Attendance = void 0;
const base_entity_1 = __webpack_require__(34);
const employee_entity_1 = __webpack_require__(43);
const schedule_entity_1 = __webpack_require__(53);
const typeorm_1 = __webpack_require__(25);
const attendance_punch_entity_1 = __webpack_require__(73);
const final_work_hour_entity_1 = __webpack_require__(58);
const work_time_request_entity_1 = __webpack_require__(49);
let Attendance = class Attendance extends base_entity_1.BaseEntity {
};
exports.Attendance = Attendance;
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.attendances, { eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_a = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _a : Object)
], Attendance.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'simple-array',
        nullable: true,
    }),
    __metadata("design:type", Array)
], Attendance.prototype, "statuses", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Attendance.prototype, "timeIn", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], Attendance.prototype, "timeOut", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], Attendance.prototype, "isProcessed", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: final_work_hour_entity_1.DayType }),
    __metadata("design:type", typeof (_d = typeof final_work_hour_entity_1.DayType !== "undefined" && final_work_hour_entity_1.DayType) === "function" ? _d : Object)
], Attendance.prototype, "dayType", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => schedule_entity_1.Schedule, (schedule) => schedule.attendance, { eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'scheduleId' }),
    __metadata("design:type", typeof (_e = typeof schedule_entity_1.Schedule !== "undefined" && schedule_entity_1.Schedule) === "function" ? _e : Object)
], Attendance.prototype, "schedule", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => attendance_punch_entity_1.AttendancePunch, (attendancePunches) => attendancePunches.attendance, { cascade: true }),
    __metadata("design:type", Array)
], Attendance.prototype, "attendancePunches", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => work_time_request_entity_1.WorkTimeRequest, (workTimeRequest) => workTimeRequest.attendance, { cascade: true, nullable: true }),
    __metadata("design:type", Array)
], Attendance.prototype, "workTimeRequests", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => final_work_hour_entity_1.FinalWorkHour, (finalWorkHour) => finalWorkHour.attendance, { cascade: true, nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'finalWorkHourId' }),
    __metadata("design:type", typeof (_f = typeof final_work_hour_entity_1.FinalWorkHour !== "undefined" && final_work_hour_entity_1.FinalWorkHour) === "function" ? _f : Object)
], Attendance.prototype, "finalWorkHour", void 0);
exports.Attendance = Attendance = __decorate([
    (0, typeorm_1.Entity)('attendances')
], Attendance);


/***/ }),
/* 53 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Schedule = void 0;
const schedule_status_1 = __webpack_require__(54);
const base_entity_1 = __webpack_require__(34);
const attendance_entity_1 = __webpack_require__(52);
const employee_entity_1 = __webpack_require__(43);
const cutoff_entity_1 = __webpack_require__(55);
const typeorm_1 = __webpack_require__(25);
const shift_entity_1 = __webpack_require__(59);
const holiday_entity_1 = __webpack_require__(68);
const schedule_change_request_entity_1 = __webpack_require__(70);
let Schedule = class Schedule extends base_entity_1.BaseEntity {
};
exports.Schedule = Schedule;
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Schedule.prototype, "date", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Schedule.prototype, "notes", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: schedule_status_1.ScheduleStatus, default: schedule_status_1.ScheduleStatus.DEFAULT }),
    __metadata("design:type", typeof (_b = typeof schedule_status_1.ScheduleStatus !== "undefined" && schedule_status_1.ScheduleStatus) === "function" ? _b : Object)
], Schedule.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => attendance_entity_1.Attendance, (attendance) => attendance.schedule, { nullable: true }),
    (0, typeorm_1.JoinColumn)({ name: 'attendanceId' }),
    __metadata("design:type", typeof (_c = typeof attendance_entity_1.Attendance !== "undefined" && attendance_entity_1.Attendance) === "function" ? _c : Object)
], Schedule.prototype, "attendance", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time', nullable: true }),
    __metadata("design:type", String)
], Schedule.prototype, "startTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time', nullable: true }),
    __metadata("design:type", String)
], Schedule.prototype, "endTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Schedule.prototype, "breakTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Schedule.prototype, "duration", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => shift_entity_1.Shift, (shift) => shift.schedules),
    (0, typeorm_1.JoinColumn)({ name: 'shiftId' }),
    __metadata("design:type", typeof (_d = typeof shift_entity_1.Shift !== "undefined" && shift_entity_1.Shift) === "function" ? _d : Object)
], Schedule.prototype, "shift", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => holiday_entity_1.Holiday, (holiday) => holiday.schedules, { nullable: true, eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'holidayId' }),
    __metadata("design:type", typeof (_e = typeof holiday_entity_1.Holiday !== "undefined" && holiday_entity_1.Holiday) === "function" ? _e : Object)
], Schedule.prototype, "holiday", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'boolean', default: false }),
    __metadata("design:type", Boolean)
], Schedule.prototype, "restDay", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.schedules),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_f = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _f : Object)
], Schedule.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => schedule_change_request_entity_1.ScheduleChangeRequest, (scheduleChangeRequest) => scheduleChangeRequest.schedule),
    __metadata("design:type", Array)
], Schedule.prototype, "scheduleChangeRequests", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => cutoff_entity_1.Cutoff, (cutoff) => cutoff.schedules),
    (0, typeorm_1.JoinColumn)({ name: 'cutoffId' }),
    __metadata("design:type", typeof (_g = typeof cutoff_entity_1.Cutoff !== "undefined" && cutoff_entity_1.Cutoff) === "function" ? _g : Object)
], Schedule.prototype, "cutoff", void 0);
exports.Schedule = Schedule = __decorate([
    (0, typeorm_1.Entity)('schedules')
], Schedule);


/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleStatus = void 0;
var ScheduleStatus;
(function (ScheduleStatus) {
    ScheduleStatus["DEFAULT"] = "DEFAULT";
    ScheduleStatus["MODIFIED"] = "MODIFIED";
    ScheduleStatus["SWAPPED"] = "SWAPPED";
    ScheduleStatus["LEAVE"] = "LEAVE";
})(ScheduleStatus || (exports.ScheduleStatus = ScheduleStatus = {}));


/***/ }),
/* 55 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Cutoff = void 0;
const cutoff_status_enum_1 = __webpack_require__(56);
const cutoff_type_enum_1 = __webpack_require__(57);
const base_entity_1 = __webpack_require__(34);
const final_work_hour_entity_1 = __webpack_require__(58);
const shift_entity_1 = __webpack_require__(59);
const schedule_entity_1 = __webpack_require__(53);
const typeorm_1 = __webpack_require__(25);
const payroll_entity_1 = __webpack_require__(63);
let Cutoff = class Cutoff extends base_entity_1.BaseEntity {
};
exports.Cutoff = Cutoff;
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Cutoff.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Cutoff.prototype, "startDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Cutoff.prototype, "endDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: cutoff_status_enum_1.CutoffStatus, default: cutoff_status_enum_1.CutoffStatus.ACTIVE }),
    __metadata("design:type", typeof (_c = typeof cutoff_status_enum_1.CutoffStatus !== "undefined" && cutoff_status_enum_1.CutoffStatus) === "function" ? _c : Object)
], Cutoff.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: cutoff_type_enum_1.CutoffType, default: cutoff_type_enum_1.CutoffType.BI_WEEKLY }),
    __metadata("design:type", typeof (_d = typeof cutoff_type_enum_1.CutoffType !== "undefined" && cutoff_type_enum_1.CutoffType) === "function" ? _d : Object)
], Cutoff.prototype, "cutoffType", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => payroll_entity_1.Payroll, (payroll) => payroll.cutoff, { nullable: true }),
    __metadata("design:type", Array)
], Cutoff.prototype, "payrolls", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => schedule_entity_1.Schedule, (schedule) => schedule.cutoff, { nullable: true }),
    __metadata("design:type", Array)
], Cutoff.prototype, "schedules", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => final_work_hour_entity_1.FinalWorkHour, (finalWorkHour) => finalWorkHour.cutoff, { nullable: true }),
    __metadata("design:type", Array)
], Cutoff.prototype, "finalWorkHours", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => shift_entity_1.Shift, (shift) => shift.cutoffs, { nullable: true }),
    __metadata("design:type", Array)
], Cutoff.prototype, "shifts", void 0);
exports.Cutoff = Cutoff = __decorate([
    (0, typeorm_1.Entity)('cutoffs')
], Cutoff);


/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CutoffStatus = void 0;
var CutoffStatus;
(function (CutoffStatus) {
    CutoffStatus["ACTIVE"] = "ACTIVE";
    CutoffStatus["INACTIVE"] = "INACTIVE";
    CutoffStatus["COMPLETED"] = "COMPLETED";
    CutoffStatus["PENDING"] = "PENDING";
    CutoffStatus["CANCELLED"] = "CANCELLED";
})(CutoffStatus || (exports.CutoffStatus = CutoffStatus = {}));


/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CutoffType = void 0;
var CutoffType;
(function (CutoffType) {
    CutoffType["BI_WEEKLY"] = "BI_WEEKLY";
    CutoffType["MONTHLY"] = "MONTHLY";
    CutoffType["WEEKLY"] = "WEEKLY";
    CutoffType["DAILY"] = "DAILY";
    CutoffType["ANNUAL"] = "ANNUAL";
    CutoffType["QUARTERLY"] = "QUARTERLY";
    CutoffType["SEMI_ANNUAL"] = "SEMI_ANNUAL";
    CutoffType["BI_ANNUAL"] = "BI_ANNUAL";
})(CutoffType || (exports.CutoffType = CutoffType = {}));


/***/ }),
/* 58 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FinalWorkHour = exports.DayType = void 0;
const base_entity_1 = __webpack_require__(34);
const employee_entity_1 = __webpack_require__(43);
const cutoff_entity_1 = __webpack_require__(55);
const typeorm_1 = __webpack_require__(25);
const attendance_entity_1 = __webpack_require__(52);
// Define day type enum for better type safety
var DayType;
(function (DayType) {
    DayType["REGULAR_DAY"] = "REGULAR_DAY";
    DayType["REST_DAY"] = "REST_DAY";
    DayType["SPECIAL_HOLIDAY"] = "SPECIAL_HOLIDAY";
    DayType["REGULAR_HOLIDAY"] = "REGULAR_HOLIDAY";
    DayType["SPECIAL_HOLIDAY_REST_DAY"] = "SPECIAL_HOLIDAY_REST_DAY";
    DayType["REGULAR_HOLIDAY_REST_DAY"] = "REGULAR_HOLIDAY_REST_DAY";
})(DayType || (exports.DayType = DayType = {}));
let FinalWorkHour = class FinalWorkHour extends base_entity_1.BaseEntity {
    // Calculate derived values after loading from database
    calculateDerivedFields() {
        // Calculate totals if not already set
        if (this.totalRegularHours === 0) {
            this.totalRegularHours = +this.regularDayHours + +this.restDayHours +
                +this.specialHolidayHours + +this.regularHolidayHours;
        }
        if (this.totalOvertimeHours === 0) {
            this.totalOvertimeHours = +this.overtimeRegularDayHours + +this.overtimeRestDayHours +
                +this.overtimeSpecialHolidayHours + +this.overtimeRegularHolidayHours;
        }
        if (this.totalHours === 0) {
            this.totalHours = +this.totalRegularHours + +this.totalOvertimeHours;
        }
    }
};
exports.FinalWorkHour = FinalWorkHour;
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.finalWorkHours),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_a = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _a : Object)
], FinalWorkHour.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => attendance_entity_1.Attendance, (attendance) => attendance.finalWorkHour),
    (0, typeorm_1.JoinColumn)({ name: 'attendanceId' }),
    __metadata("design:type", typeof (_b = typeof attendance_entity_1.Attendance !== "undefined" && attendance_entity_1.Attendance) === "function" ? _b : Object)
], FinalWorkHour.prototype, "attendance", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => cutoff_entity_1.Cutoff, (cutoff) => cutoff.finalWorkHours),
    (0, typeorm_1.JoinColumn)({ name: 'cutoffId' }),
    __metadata("design:type", typeof (_c = typeof cutoff_entity_1.Cutoff !== "undefined" && cutoff_entity_1.Cutoff) === "function" ? _c : Object)
], FinalWorkHour.prototype, "cutoff", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp' }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], FinalWorkHour.prototype, "timeIn", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp' }),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], FinalWorkHour.prototype, "timeOut", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_f = typeof Date !== "undefined" && Date) === "function" ? _f : Object)
], FinalWorkHour.prototype, "overTimeOut", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "regularDayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "restDayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "specialHolidayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "regularHolidayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "overtimeRegularDayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "overtimeRestDayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "overtimeSpecialHolidayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "overtimeRegularHolidayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "nightDifferentialHours", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: DayType,
        default: DayType.REGULAR_DAY
    }),
    __metadata("design:type", String)
], FinalWorkHour.prototype, "dayType", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "totalRegularHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "totalOvertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], FinalWorkHour.prototype, "totalHours", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], FinalWorkHour.prototype, "isApproved", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], FinalWorkHour.prototype, "isProcessed", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_g = typeof Date !== "undefined" && Date) === "function" ? _g : Object)
], FinalWorkHour.prototype, "workDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], FinalWorkHour.prototype, "notes", void 0);
__decorate([
    (0, typeorm_1.AfterLoad)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], FinalWorkHour.prototype, "calculateDerivedFields", null);
exports.FinalWorkHour = FinalWorkHour = __decorate([
    (0, typeorm_1.Entity)('final-work-hours')
], FinalWorkHour);


/***/ }),
/* 59 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shift = void 0;
const base_entity_1 = __webpack_require__(34);
const cutoff_entity_1 = __webpack_require__(55);
const typeorm_1 = __webpack_require__(25);
const group_entity_1 = __webpack_require__(60);
const schedule_entity_1 = __webpack_require__(53);
const shift_day_entity_1 = __webpack_require__(61);
let Shift = class Shift extends base_entity_1.BaseEntity {
    // Getter methods to easily get shift details for a specific day
    getShiftDetailsForDay(day) {
        if (!this.days || this.days.length === 0) {
            return null;
        }
        return this.days.find(detail => detail.day === day) || null;
    }
    // Helper methods from your existing Shift entity
    getStartTimeForDay(day) {
        const dayDetail = this.getShiftDetailsForDay(day);
        return (dayDetail === null || dayDetail === void 0 ? void 0 : dayDetail.startTime) || this.defaultStartTime;
    }
    getEndTimeForDay(day) {
        const dayDetail = this.getShiftDetailsForDay(day);
        return (dayDetail === null || dayDetail === void 0 ? void 0 : dayDetail.endTime) || this.defaultEndTime;
    }
    getBreakTimeForDay(day) {
        const dayDetail = this.getShiftDetailsForDay(day);
        return (dayDetail === null || dayDetail === void 0 ? void 0 : dayDetail.breakTime) || this.defaultBreakTime;
    }
    getDurationForDay(day) {
        const dayDetail = this.getShiftDetailsForDay(day);
        return (dayDetail === null || dayDetail === void 0 ? void 0 : dayDetail.duration) || this.defaultDuration;
    }
    isActiveOnDay(day) {
        return !!this.getShiftDetailsForDay(day);
    }
    getActiveDays() {
        var _a;
        return ((_a = this.days) === null || _a === void 0 ? void 0 : _a.map(day => day.day)) || [];
    }
};
exports.Shift = Shift;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Shift.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Shift.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time' }),
    __metadata("design:type", String)
], Shift.prototype, "defaultStartTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time' }),
    __metadata("design:type", String)
], Shift.prototype, "defaultEndTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Shift.prototype, "defaultBreakTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], Shift.prototype, "defaultDuration", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => shift_day_entity_1.ShiftDay, (day) => day.shift, {
        cascade: true, eager: true
    }),
    __metadata("design:type", Array)
], Shift.prototype, "days", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)(() => cutoff_entity_1.Cutoff, (cutoff) => cutoff.shifts, { nullable: true, cascade: true }),
    (0, typeorm_1.JoinTable)({
        name: 'shift_cutoffs',
        joinColumn: { name: 'shift_id', referencedColumnName: 'id' },
        inverseJoinColumn: { name: 'cutoff_id', referencedColumnName: 'id' },
    }),
    __metadata("design:type", Array)
], Shift.prototype, "cutoffs", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => group_entity_1.Group, (group) => group.shift, { nullable: true }),
    __metadata("design:type", Array)
], Shift.prototype, "groups", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => schedule_entity_1.Schedule, (schedule) => schedule.shift, { nullable: true }),
    __metadata("design:type", Array)
], Shift.prototype, "schedules", void 0);
exports.Shift = Shift = __decorate([
    (0, typeorm_1.Entity)('shifts')
], Shift);


/***/ }),
/* 60 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Group = void 0;
const base_entity_1 = __webpack_require__(34);
const employee_entity_1 = __webpack_require__(43);
const typeorm_1 = __webpack_require__(25);
const shift_entity_1 = __webpack_require__(59);
let Group = class Group extends base_entity_1.BaseEntity {
};
exports.Group = Group;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Group.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Group.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => employee_entity_1.Employee, (employee) => employee.group, { cascade: true, nullable: true }),
    __metadata("design:type", Array)
], Group.prototype, "employees", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => shift_entity_1.Shift, (shift) => shift.groups, { nullable: true, cascade: true, eager: true }),
    (0, typeorm_1.JoinColumn)({ name: 'shiftId' }),
    __metadata("design:type", typeof (_a = typeof shift_entity_1.Shift !== "undefined" && shift_entity_1.Shift) === "function" ? _a : Object)
], Group.prototype, "shift", void 0);
exports.Group = Group = __decorate([
    (0, typeorm_1.Entity)('groups')
], Group);


/***/ }),
/* 61 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShiftDay = void 0;
const day_enum_1 = __webpack_require__(62);
const base_entity_1 = __webpack_require__(34);
const shift_entity_1 = __webpack_require__(59);
const typeorm_1 = __webpack_require__(25);
let ShiftDay = class ShiftDay extends base_entity_1.BaseEntity {
};
exports.ShiftDay = ShiftDay;
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: day_enum_1.Day
    }),
    __metadata("design:type", typeof (_a = typeof day_enum_1.Day !== "undefined" && day_enum_1.Day) === "function" ? _a : Object)
], ShiftDay.prototype, "day", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time', nullable: true }),
    __metadata("design:type", String)
], ShiftDay.prototype, "startTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'time', nullable: true }),
    __metadata("design:type", String)
], ShiftDay.prototype, "endTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], ShiftDay.prototype, "breakTime", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int', nullable: true }),
    __metadata("design:type", Number)
], ShiftDay.prototype, "duration", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], ShiftDay.prototype, "isOvernight", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => shift_entity_1.Shift, (shift) => shift.days),
    (0, typeorm_1.JoinColumn)({ name: 'shiftId' }),
    __metadata("design:type", typeof (_b = typeof shift_entity_1.Shift !== "undefined" && shift_entity_1.Shift) === "function" ? _b : Object)
], ShiftDay.prototype, "shift", void 0);
exports.ShiftDay = ShiftDay = __decorate([
    (0, typeorm_1.Entity)('shift-days')
], ShiftDay);


/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Day = void 0;
var Day;
(function (Day) {
    Day["MONDAY"] = "MONDAY";
    Day["TUESDAY"] = "TUESDAY";
    Day["WEDNESDAY"] = "WEDNESDAY";
    Day["THURSDAY"] = "THURSDAY";
    Day["FRIDAY"] = "FRIDAY";
    Day["SATURDAY"] = "SATURDAY";
    Day["SUNDAY"] = "SUNDAY";
})(Day || (exports.Day = Day = {}));


/***/ }),
/* 63 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g, _h;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Payroll = void 0;
const payroll_status_enum_1 = __webpack_require__(64);
const base_entity_1 = __webpack_require__(34);
const employee_entity_1 = __webpack_require__(43);
const typeorm_1 = __webpack_require__(25);
const cutoff_entity_1 = __webpack_require__(55);
const payroll_item_entity_1 = __webpack_require__(65);
let Payroll = class Payroll extends base_entity_1.BaseEntity {
    calculateTotals() {
        if (!this.payrollItems)
            return;
        // Reset totals
        this.totalAllowances = 0;
        this.totalBonuses = 0;
        this.totalBenefits = 0;
        this.totalDeductions = 0;
        this.totalGovernmentContributions = 0;
        this.totalTaxes = 0;
        // Calculate based on payroll items
        this.payrollItems.forEach(item => {
            const category = item.payrollItemType.category.toLowerCase();
            // Sum by category
            if (category.includes('allowance')) {
                this.totalAllowances += +item.amount;
            }
            else if (category.includes('bonus')) {
                this.totalBonuses += +item.amount;
            }
            else if (category.includes('benefit')) {
                this.totalBenefits += +item.amount;
            }
            else if (category.includes('deduction')) {
                this.totalDeductions += +item.amount;
            }
            else if (category.includes('government')) {
                this.totalGovernmentContributions += +item.amount;
            }
            else if (category.includes('tax')) {
                this.totalTaxes += +item.amount;
            }
        });
    }
    // Helper methods to get government contributions by type
    getContributionByType(type) {
        const result = { employee: 0, employer: 0, total: 0 };
        if (!this.payrollItems)
            return result;
        this.payrollItems.forEach(item => {
            var _a;
            if (((_a = item.payrollItemType.governmentContributionType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === type.toLowerCase()) {
                result.employee += +item.amount;
                result.employer += +(item.employerAmount || 0);
            }
        });
        result.total = result.employee + result.employer;
        return result;
    }
    get sssContribution() {
        return this.getContributionByType('sss');
    }
    get philHealthContribution() {
        return this.getContributionByType('philhealth');
    }
    get pagIbigContribution() {
        return this.getContributionByType('pagibig');
    }
    get withHoldingTax() {
        return this.getContributionByType('tax').employee;
    }
};
exports.Payroll = Payroll;
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.payrolls),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_a = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _a : Object)
], Payroll.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => cutoff_entity_1.Cutoff, (cutoff) => cutoff.payrolls),
    (0, typeorm_1.JoinColumn)({ name: 'cutoffId' }),
    __metadata("design:type", typeof (_b = typeof cutoff_entity_1.Cutoff !== "undefined" && cutoff_entity_1.Cutoff) === "function" ? _b : Object)
], Payroll.prototype, "cutoff", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => payroll_item_entity_1.PayrollItem, (payrollItem) => payrollItem.payroll, {
        cascade: true,
        eager: true
    }),
    __metadata("design:type", Array)
], Payroll.prototype, "payrollItems", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "monthlyRate", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "dailyRate", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "hourlyRate", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalRegularHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalOvertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalHolidayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalHolidayOvertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalSpecialHolidayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalSpecialHolidayOvertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalRestDayHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalRestDayOvertimeHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 10, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalNightDifferentialHours", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "basicPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "overtimePay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "holidayPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "holidayOvertimePay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "specialHolidayPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "specialHolidayOvertimePay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "restDayPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "restDayOvertimePay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "nightDifferentialPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "grossPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "taxableIncome", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalAllowances", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalBonuses", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalBenefits", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalDeductions", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalGovernmentContributions", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "totalTaxes", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "netPay", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', { precision: 15, scale: 2, default: 0 }),
    __metadata("design:type", Number)
], Payroll.prototype, "thirteenthMonthAccrual", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: payroll_status_enum_1.PayrollStatus,
        default: payroll_status_enum_1.PayrollStatus.DRAFT
    }),
    __metadata("design:type", typeof (_c = typeof payroll_status_enum_1.PayrollStatus !== "undefined" && payroll_status_enum_1.PayrollStatus) === "function" ? _c : Object)
], Payroll.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "paymentMethod", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "bankAccount", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "checkNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "bankReferenceNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], Payroll.prototype, "paymentDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], Payroll.prototype, "processedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "processedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_f = typeof Date !== "undefined" && Date) === "function" ? _f : Object)
], Payroll.prototype, "approvedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "approvedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_g = typeof Date !== "undefined" && Date) === "function" ? _g : Object)
], Payroll.prototype, "releasedAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "releasedBy", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Payroll.prototype, "notes", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", typeof (_h = typeof Record !== "undefined" && Record) === "function" ? _h : Object)
], Payroll.prototype, "calculationDetails", void 0);
__decorate([
    (0, typeorm_1.AfterLoad)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], Payroll.prototype, "calculateTotals", null);
exports.Payroll = Payroll = __decorate([
    (0, typeorm_1.Entity)('payrolls')
], Payroll);


/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollStatus = void 0;
var PayrollStatus;
(function (PayrollStatus) {
    PayrollStatus["DRAFT"] = "DRAFT";
    PayrollStatus["PROCESSING"] = "PROCESSING";
    PayrollStatus["APPROVED"] = "APPROVED";
    PayrollStatus["RELEASED"] = "RELEASED";
    PayrollStatus["VOID"] = "VOID";
    PayrollStatus["ERROR"] = "ERROR";
})(PayrollStatus || (exports.PayrollStatus = PayrollStatus = {}));


/***/ }),
/* 65 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItem = void 0;
const base_entity_1 = __webpack_require__(34);
const employee_entity_1 = __webpack_require__(43);
const typeorm_1 = __webpack_require__(25);
const payroll_entity_1 = __webpack_require__(63);
const payroll_item_type_entity_1 = __webpack_require__(66);
let PayrollItem = class PayrollItem extends base_entity_1.BaseEntity {
    constructor() {
        super(...arguments);
        this.isActive = true;
        this.isTaxable = true;
    }
};
exports.PayrollItem = PayrollItem;
__decorate([
    (0, typeorm_1.ManyToOne)(() => employee_entity_1.Employee, (employee) => employee.payrollItems),
    (0, typeorm_1.JoinColumn)({ name: 'employeeId' }),
    __metadata("design:type", typeof (_a = typeof employee_entity_1.Employee !== "undefined" && employee_entity_1.Employee) === "function" ? _a : Object)
], PayrollItem.prototype, "employee", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => payroll_item_type_entity_1.PayrollItemType, (payrollItemType) => payrollItemType.payrollItems),
    (0, typeorm_1.JoinColumn)({ name: 'payrollItemTypeId' }),
    __metadata("design:type", typeof (_b = typeof payroll_item_type_entity_1.PayrollItemType !== "undefined" && payroll_item_type_entity_1.PayrollItemType) === "function" ? _b : Object)
], PayrollItem.prototype, "payrollItemType", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => payroll_entity_1.Payroll, (payroll) => payroll.payrollItems),
    (0, typeorm_1.JoinColumn)({ name: 'payrollId' }),
    __metadata("design:type", typeof (_c = typeof payroll_entity_1.Payroll !== "undefined" && payroll_entity_1.Payroll) === "function" ? _c : Object)
], PayrollItem.prototype, "payroll", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 15,
        scale: 2,
        default: 0
    }),
    __metadata("design:type", Number)
], PayrollItem.prototype, "amount", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 15,
        scale: 2,
        default: 0,
        nullable: true
    }),
    __metadata("design:type", Number)
], PayrollItem.prototype, "employerAmount", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", typeof (_d = typeof Record !== "undefined" && Record) === "function" ? _d : Object)
], PayrollItem.prototype, "parameters", void 0);
__decorate([
    (0, typeorm_1.Column)({
        default: 'MONTHLY',
        comment: 'How often the item is applied (ONCE, DAILY, WEEKLY, MONTHLY, etc.)'
    }),
    __metadata("design:type", String)
], PayrollItem.prototype, "occurrence", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], PayrollItem.prototype, "isActive", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], PayrollItem.prototype, "isTaxable", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], PayrollItem.prototype, "effectiveFrom", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_f = typeof Date !== "undefined" && Date) === "function" ? _f : Object)
], PayrollItem.prototype, "effectiveTo", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], PayrollItem.prototype, "reference", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true, comment: 'For tax reporting and verification' }),
    __metadata("design:type", String)
], PayrollItem.prototype, "governmentReferenceNumber", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", Object)
], PayrollItem.prototype, "calculationDetails", void 0);
exports.PayrollItem = PayrollItem = __decorate([
    (0, typeorm_1.Entity)('payroll-items')
], PayrollItem);


/***/ }),
/* 66 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemType = void 0;
const payroll_item_category_enum_1 = __webpack_require__(67);
const base_entity_1 = __webpack_require__(34);
const typeorm_1 = __webpack_require__(25);
const payroll_item_entity_1 = __webpack_require__(65);
let PayrollItemType = class PayrollItemType extends base_entity_1.BaseEntity {
    constructor() {
        super(...arguments);
        this.isActive = true;
    }
};
exports.PayrollItemType = PayrollItemType;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], PayrollItemType.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], PayrollItemType.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: payroll_item_category_enum_1.PayrollItemCategory,
    }),
    __metadata("design:type", typeof (_a = typeof payroll_item_category_enum_1.PayrollItemCategory !== "undefined" && payroll_item_category_enum_1.PayrollItemCategory) === "function" ? _a : Object)
], PayrollItemType.prototype, "category", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], PayrollItemType.prototype, "defaultOccurrence", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], PayrollItemType.prototype, "unit", void 0);
__decorate([
    (0, typeorm_1.Column)('text'),
    __metadata("design:type", String)
], PayrollItemType.prototype, "computationFormula", void 0);
__decorate([
    (0, typeorm_1.Column)('decimal', {
        precision: 10,
        scale: 2,
        nullable: true
    }),
    __metadata("design:type", Object)
], PayrollItemType.prototype, "defaultAmount", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isActive", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isSystemGenerated", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isGovernmentMandated", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], PayrollItemType.prototype, "governmentContributionType", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "hasEmployerShare", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], PayrollItemType.prototype, "employerFormulaPercentage", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isPartOfTaxCalculation", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isTaxable", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isTaxDeductible", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isDisplayedInPayslip", void 0);
__decorate([
    (0, typeorm_1.Column)('simple-array', { nullable: true }),
    __metadata("design:type", Array)
], PayrollItemType.prototype, "applicableTo", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], PayrollItemType.prototype, "isRequired", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], PayrollItemType.prototype, "effectiveFrom", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], PayrollItemType.prototype, "effectiveTo", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", typeof (_d = typeof Record !== "undefined" && Record) === "function" ? _d : Object)
], PayrollItemType.prototype, "calculationParameters", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", Object)
], PayrollItemType.prototype, "validationRules", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => payroll_item_entity_1.PayrollItem, (payrollItem) => payrollItem.payrollItemType),
    __metadata("design:type", Array)
], PayrollItemType.prototype, "payrollItems", void 0);
exports.PayrollItemType = PayrollItemType = __decorate([
    (0, typeorm_1.Entity)('payroll-item-types')
], PayrollItemType);


/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemCategory = void 0;
var PayrollItemCategory;
(function (PayrollItemCategory) {
    PayrollItemCategory["COMPENSATION"] = "Compensation";
    PayrollItemCategory["BENEFIT"] = "Benefit";
    PayrollItemCategory["DEDUCTION"] = "Deduction";
    PayrollItemCategory["GOVERNMENT"] = "Government";
    PayrollItemCategory["ALLOWANCE"] = "Allowance";
    PayrollItemCategory["REIMBURSEMENT"] = "Reimbursement";
    PayrollItemCategory["TAX"] = "Tax";
    PayrollItemCategory["OTHER"] = "Other";
    PayrollItemCategory["BONUS"] = "Bonus";
    PayrollItemCategory["COMMISSION"] = "Commission";
    PayrollItemCategory["TIP"] = "Tip";
})(PayrollItemCategory || (exports.PayrollItemCategory = PayrollItemCategory = {}));


/***/ }),
/* 68 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Holiday = void 0;
const day_enum_1 = __webpack_require__(62);
const holiday_type_enum_1 = __webpack_require__(69);
const base_entity_1 = __webpack_require__(34);
const typeorm_1 = __webpack_require__(25);
const schedule_entity_1 = __webpack_require__(53);
let Holiday = class Holiday extends base_entity_1.BaseEntity {
};
exports.Holiday = Holiday;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], Holiday.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Holiday.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: holiday_type_enum_1.HolidayType }),
    __metadata("design:type", typeof (_a = typeof holiday_type_enum_1.HolidayType !== "undefined" && holiday_type_enum_1.HolidayType) === "function" ? _a : Object)
], Holiday.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'date' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Holiday.prototype, "date", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: day_enum_1.Day }),
    __metadata("design:type", typeof (_c = typeof day_enum_1.Day !== "undefined" && day_enum_1.Day) === "function" ? _c : Object)
], Holiday.prototype, "day", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => schedule_entity_1.Schedule, (schedule) => schedule.holiday, { nullable: true, cascade: true }),
    __metadata("design:type", Array)
], Holiday.prototype, "schedules", void 0);
exports.Holiday = Holiday = __decorate([
    (0, typeorm_1.Entity)('holidays')
], Holiday);


/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HolidayType = void 0;
var HolidayType;
(function (HolidayType) {
    HolidayType["REGULAR"] = "REGULAR";
    HolidayType["SPECIAL_NON_WORKING"] = "SPECIAL_NON_WORKING";
    HolidayType["SPECIAL_WORKING"] = "SPECIAL_WORKING";
    HolidayType["LOCAL"] = "LOCAL";
})(HolidayType || (exports.HolidayType = HolidayType = {}));


/***/ }),
/* 70 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeRequest = void 0;
const request_status_enum_1 = __webpack_require__(51);
const schedule_change_request_type_enum_1 = __webpack_require__(71);
const base_entity_1 = __webpack_require__(34);
const document_entity_1 = __webpack_require__(48);
const typeorm_1 = __webpack_require__(25);
const schedule_entity_1 = __webpack_require__(53);
const schedule_change_response_entity_1 = __webpack_require__(72);
let ScheduleChangeRequest = class ScheduleChangeRequest extends base_entity_1.BaseEntity {
};
exports.ScheduleChangeRequest = ScheduleChangeRequest;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], ScheduleChangeRequest.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: request_status_enum_1.RequestStatus, default: request_status_enum_1.RequestStatus.PENDING }),
    __metadata("design:type", typeof (_a = typeof request_status_enum_1.RequestStatus !== "undefined" && request_status_enum_1.RequestStatus) === "function" ? _a : Object)
], ScheduleChangeRequest.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: schedule_change_request_type_enum_1.ScheduleChangeRequestType }),
    __metadata("design:type", typeof (_b = typeof schedule_change_request_type_enum_1.ScheduleChangeRequestType !== "undefined" && schedule_change_request_type_enum_1.ScheduleChangeRequestType) === "function" ? _b : Object)
], ScheduleChangeRequest.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => schedule_entity_1.Schedule, (schedule) => schedule.scheduleChangeRequests),
    __metadata("design:type", Array)
], ScheduleChangeRequest.prototype, "schedule", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => document_entity_1.Document, (document) => document.scheduleChangeRequest),
    __metadata("design:type", Array)
], ScheduleChangeRequest.prototype, "documents", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => schedule_change_response_entity_1.ScheduleChangeResponse, (scheduleChangeResponse) => scheduleChangeResponse.scheduleChangeRequest, { eager: true, nullable: true, cascade: true }),
    (0, typeorm_1.JoinColumn)({ name: 'scheduleChangeResponseId' }),
    __metadata("design:type", typeof (_c = typeof schedule_change_response_entity_1.ScheduleChangeResponse !== "undefined" && schedule_change_response_entity_1.ScheduleChangeResponse) === "function" ? _c : Object)
], ScheduleChangeRequest.prototype, "scheduleChangeResponse", void 0);
exports.ScheduleChangeRequest = ScheduleChangeRequest = __decorate([
    (0, typeorm_1.Entity)('schedule-change-requests')
], ScheduleChangeRequest);


/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeRequestType = void 0;
var ScheduleChangeRequestType;
(function (ScheduleChangeRequestType) {
    // Request for general time off from scheduled work
    ScheduleChangeRequestType["TIME_OFF"] = "TIME_OFF";
    // Request for time off due to illness or medical reasons
    ScheduleChangeRequestType["SICK_LEAVE"] = "SICK_LEAVE";
    // Request for time off for personal reasons
    ScheduleChangeRequestType["PERSONAL_LEAVE"] = "PERSONAL_LEAVE";
    // Request for time off due to bereavement or loss
    ScheduleChangeRequestType["BEREAVEMENT"] = "BEREAVEMENT";
    // Request for time off for maternity or paternity leave
    ScheduleChangeRequestType["MATERNITY_PATERNITY_LEAVE"] = "MATERNITY_PATERNITY_LEAVE";
    // Request for time off for jury duty or legal obligations
    ScheduleChangeRequestType["JURY_DUTY"] = "JURY_DUTY";
    // Request for time off for religious observances
    ScheduleChangeRequestType["RELIGIOUS_OBSERVANCE"] = "RELIGIOUS_OBSERVANCE";
    // Request for time off for family-related matters
    ScheduleChangeRequestType["FAMILY_LEAVE"] = "FAMILY_LEAVE";
    // Request for time off for educational purposes
    ScheduleChangeRequestType["EDUCATIONAL_LEAVE"] = "EDUCATIONAL_LEAVE";
    // Request for time off for relocation or moving
    ScheduleChangeRequestType["RELOCATION"] = "RELOCATION";
    // Request for time off for parental leave
    ScheduleChangeRequestType["PARENTAL_LEAVE"] = "PARENTAL_LEAVE";
    // Request for time off for bereavement or loss of a family member
    ScheduleChangeRequestType["FAMILY_BEREAVEMENT"] = "FAMILY_BEREAVEMENT";
    // Request for time off for personal emergencies
    ScheduleChangeRequestType["PERSONAL_EMERGENCY"] = "PERSONAL_EMERGENCY";
    // Request for business travel or work-related trips
    ScheduleChangeRequestType["BUSINESS_TRAVEL"] = "BUSINESS_TRAVEL";
    // Request for scheduled time off for vacation purposes
    ScheduleChangeRequestType["VACATION"] = "VACATION";
    // Request for schedule swap to a rest day
    ScheduleChangeRequestType["REST_DAY_SWAP"] = "REST_DAY_SWAP";
    // Request for time allocation for training or development activities
    ScheduleChangeRequestType["TRAINING"] = "TRAINING";
    // Any other type of schedule change request not covered by specific categories
    ScheduleChangeRequestType["OTHER"] = "OTHER";
})(ScheduleChangeRequestType || (exports.ScheduleChangeRequestType = ScheduleChangeRequestType = {}));


/***/ }),
/* 72 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeResponse = void 0;
const base_entity_1 = __webpack_require__(34);
const typeorm_1 = __webpack_require__(25);
const schedule_change_request_entity_1 = __webpack_require__(70);
let ScheduleChangeResponse = class ScheduleChangeResponse extends base_entity_1.BaseEntity {
};
exports.ScheduleChangeResponse = ScheduleChangeResponse;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Boolean)
], ScheduleChangeResponse.prototype, "approved", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], ScheduleChangeResponse.prototype, "message", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => schedule_change_request_entity_1.ScheduleChangeRequest, (scheduleChangeRequest) => scheduleChangeRequest.scheduleChangeResponse),
    (0, typeorm_1.JoinColumn)({ name: 'scheduleChangeRequestId' }),
    __metadata("design:type", typeof (_a = typeof schedule_change_request_entity_1.ScheduleChangeRequest !== "undefined" && schedule_change_request_entity_1.ScheduleChangeRequest) === "function" ? _a : Object)
], ScheduleChangeResponse.prototype, "scheduleChangeRequest", void 0);
exports.ScheduleChangeResponse = ScheduleChangeResponse = __decorate([
    (0, typeorm_1.Entity)('schedule-change-responses')
], ScheduleChangeResponse);


/***/ }),
/* 73 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancePunch = void 0;
const punch_method_enum_1 = __webpack_require__(74);
const punch_type_enum_1 = __webpack_require__(75);
const base_entity_1 = __webpack_require__(34);
const biometric_device_entity_1 = __webpack_require__(76);
const typeorm_1 = __webpack_require__(25);
const attendance_entity_1 = __webpack_require__(52);
let AttendancePunch = class AttendancePunch extends base_entity_1.BaseEntity {
};
exports.AttendancePunch = AttendancePunch;
__decorate([
    (0, typeorm_1.ManyToOne)(() => attendance_entity_1.Attendance, (attendance) => attendance.attendancePunches),
    (0, typeorm_1.JoinColumn)({ name: 'attendanceId' }),
    __metadata("design:type", typeof (_a = typeof attendance_entity_1.Attendance !== "undefined" && attendance_entity_1.Attendance) === "function" ? _a : Object)
], AttendancePunch.prototype, "attendance", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], AttendancePunch.prototype, "time", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: punch_method_enum_1.PunchMethod }),
    __metadata("design:type", typeof (_c = typeof punch_method_enum_1.PunchMethod !== "undefined" && punch_method_enum_1.PunchMethod) === "function" ? _c : Object)
], AttendancePunch.prototype, "punchMethod", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: punch_type_enum_1.PunchType }),
    __metadata("design:type", typeof (_d = typeof punch_type_enum_1.PunchType !== "undefined" && punch_type_enum_1.PunchType) === "function" ? _d : Object)
], AttendancePunch.prototype, "punchType", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Number)
], AttendancePunch.prototype, "employeeNumber", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => biometric_device_entity_1.BiometricDevice, (biometricDevice) => biometricDevice.attendancePunches),
    (0, typeorm_1.JoinColumn)({ name: 'biometricDeviceId' }),
    __metadata("design:type", typeof (_e = typeof biometric_device_entity_1.BiometricDevice !== "undefined" && biometric_device_entity_1.BiometricDevice) === "function" ? _e : Object)
], AttendancePunch.prototype, "biometricDevice", void 0);
exports.AttendancePunch = AttendancePunch = __decorate([
    (0, typeorm_1.Entity)('attendance-punches')
], AttendancePunch);


/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PunchMethod = void 0;
var PunchMethod;
(function (PunchMethod) {
    PunchMethod["FINGERPRINT"] = "fingerprint";
    PunchMethod["RFID"] = "rfid";
    PunchMethod["PASSWORD"] = "password";
    PunchMethod["FACE"] = "face";
    PunchMethod["QR_CODE"] = "qr_code";
    PunchMethod["NFC"] = "nfc";
    PunchMethod["MANUAL"] = "manual";
    PunchMethod["UNKNOWN"] = "unknown";
})(PunchMethod || (exports.PunchMethod = PunchMethod = {}));


/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PunchType = void 0;
var PunchType;
(function (PunchType) {
    PunchType[PunchType["CHECK_IN"] = 0] = "CHECK_IN";
    PunchType[PunchType["CHECK_OUT"] = 1] = "CHECK_OUT";
    PunchType[PunchType["BREAK_OUT"] = 2] = "BREAK_OUT";
    PunchType[PunchType["BREAK_IN"] = 3] = "BREAK_IN";
    PunchType[PunchType["OVERTIME_IN"] = 4] = "OVERTIME_IN";
    PunchType[PunchType["OVERTIME_OUT"] = 5] = "OVERTIME_OUT";
})(PunchType || (exports.PunchType = PunchType = {}));


/***/ }),
/* 76 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricDevice = void 0;
const biometrics_device_type_enum_1 = __webpack_require__(77);
const base_entity_1 = __webpack_require__(34);
const attendance_punch_entity_1 = __webpack_require__(73);
const typeorm_1 = __webpack_require__(25);
let BiometricDevice = class BiometricDevice extends base_entity_1.BaseEntity {
};
exports.BiometricDevice = BiometricDevice;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "deviceId", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], BiometricDevice.prototype, "ipAddress", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Number)
], BiometricDevice.prototype, "port", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "model", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "serialNumber", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: biometrics_device_type_enum_1.BiometricDeviceType,
        default: biometrics_device_type_enum_1.BiometricDeviceType.ZKTECO
    }),
    __metadata("design:type", typeof (_a = typeof biometrics_device_type_enum_1.BiometricDeviceType !== "undefined" && biometrics_device_type_enum_1.BiometricDeviceType) === "function" ? _a : Object)
], BiometricDevice.prototype, "provider", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "firmware", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "platform", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "deviceVersion", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], BiometricDevice.prototype, "os", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], BiometricDevice.prototype, "isConnected", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Boolean)
], BiometricDevice.prototype, "isOffline", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], BiometricDevice.prototype, "lastSync", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => attendance_punch_entity_1.AttendancePunch, (attendancePunch) => attendancePunch.biometricDevice, { nullable: true }),
    __metadata("design:type", Array)
], BiometricDevice.prototype, "attendancePunches", void 0);
exports.BiometricDevice = BiometricDevice = __decorate([
    (0, typeorm_1.Entity)('biometric_devices')
], BiometricDevice);


/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricDeviceType = void 0;
var BiometricDeviceType;
(function (BiometricDeviceType) {
    BiometricDeviceType["ZKTECO"] = "zkteco";
    BiometricDeviceType["ANVIZ"] = "anviz";
})(BiometricDeviceType || (exports.BiometricDeviceType = BiometricDeviceType = {}));


/***/ }),
/* 78 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeResponse = void 0;
const base_entity_1 = __webpack_require__(34);
const typeorm_1 = __webpack_require__(25);
const work_time_request_entity_1 = __webpack_require__(49);
let WorkTimeResponse = class WorkTimeResponse extends base_entity_1.BaseEntity {
};
exports.WorkTimeResponse = WorkTimeResponse;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Boolean)
], WorkTimeResponse.prototype, "approved", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], WorkTimeResponse.prototype, "message", void 0);
__decorate([
    (0, typeorm_1.OneToOne)(() => work_time_request_entity_1.WorkTimeRequest, (workTimeRequest) => workTimeRequest.workTimeResponse),
    (0, typeorm_1.JoinColumn)({ name: 'workTimeRequestId' }),
    __metadata("design:type", typeof (_a = typeof work_time_request_entity_1.WorkTimeRequest !== "undefined" && work_time_request_entity_1.WorkTimeRequest) === "function" ? _a : Object)
], WorkTimeResponse.prototype, "workTimeRequest", void 0);
exports.WorkTimeResponse = WorkTimeResponse = __decorate([
    (0, typeorm_1.Entity)('work-time-responses')
], WorkTimeResponse);


/***/ }),
/* 79 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentType = void 0;
const base_entity_1 = __webpack_require__(34);
const typeorm_1 = __webpack_require__(25);
const document_entity_1 = __webpack_require__(48);
let DocumentType = class DocumentType extends base_entity_1.BaseEntity {
    constructor() {
        super(...arguments);
        this.active = false;
        this.requiredForApplicants = true;
        this.requiredForEmployees = true;
    }
};
exports.DocumentType = DocumentType;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], DocumentType.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], DocumentType.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], DocumentType.prototype, "active", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], DocumentType.prototype, "requiredForApplicants", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], DocumentType.prototype, "requiredForEmployees", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => DocumentType, (parent) => parent.children, { nullable: true, onDelete: 'SET NULL' }),
    (0, typeorm_1.JoinColumn)({ name: 'parentDocumentTypeId' }),
    __metadata("design:type", DocumentType)
], DocumentType.prototype, "parent", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => DocumentType, (child) => child.parent, { nullable: true }),
    __metadata("design:type", Array)
], DocumentType.prototype, "children", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => document_entity_1.Document, (document) => document.documentType),
    __metadata("design:type", Array)
], DocumentType.prototype, "documents", void 0);
exports.DocumentType = DocumentType = __decorate([
    (0, typeorm_1.Entity)('document_types')
], DocumentType);


/***/ }),
/* 80 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivityLog = void 0;
const action_enum_1 = __webpack_require__(40);
const log_level_enum_1 = __webpack_require__(81);
const base_entity_1 = __webpack_require__(34);
const user_entity_1 = __webpack_require__(47);
const typeorm_1 = __webpack_require__(25);
let ActivityLog = class ActivityLog extends base_entity_1.BaseEntity {
};
exports.ActivityLog = ActivityLog;
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: action_enum_1.Action,
        nullable: false,
    }),
    __metadata("design:type", typeof (_a = typeof action_enum_1.Action !== "undefined" && action_enum_1.Action) === "function" ? _a : Object)
], ActivityLog.prototype, "action", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'varchar',
        nullable: false,
    }),
    __metadata("design:type", String)
], ActivityLog.prototype, "subject", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: log_level_enum_1.LogLevel,
        default: log_level_enum_1.LogLevel.LOG,
    }),
    __metadata("design:type", typeof (_b = typeof log_level_enum_1.LogLevel !== "undefined" && log_level_enum_1.LogLevel) === "function" ? _b : Object)
], ActivityLog.prototype, "logLevel", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, { nullable: true, onDelete: 'SET NULL' }),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_c = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _c : Object)
], ActivityLog.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'text',
        nullable: true,
    }),
    __metadata("design:type", String)
], ActivityLog.prototype, "message", void 0);
exports.ActivityLog = ActivityLog = __decorate([
    (0, typeorm_1.Entity)('activity-logs')
], ActivityLog);


/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogLevel = void 0;
var LogLevel;
(function (LogLevel) {
    LogLevel["LOG"] = "log";
    LogLevel["ERROR"] = "error";
    LogLevel["WARN"] = "warn";
    LogLevel["DEBUG"] = "debug";
    LogLevel["VERBOSE"] = "verbose";
})(LogLevel || (exports.LogLevel = LogLevel = {}));


/***/ }),
/* 82 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Notification = void 0;
const notification_type_enum_1 = __webpack_require__(83);
const base_entity_1 = __webpack_require__(34);
const user_entity_1 = __webpack_require__(47);
const typeorm_1 = __webpack_require__(25);
let Notification = class Notification extends base_entity_1.BaseEntity {
};
exports.Notification = Notification;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Notification.prototype, "title", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Notification.prototype, "message", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Notification.prototype, "iconOrImage", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: notification_type_enum_1.NotificationType,
        default: notification_type_enum_1.NotificationType.INFO
    }),
    __metadata("design:type", typeof (_a = typeof notification_type_enum_1.NotificationType !== "undefined" && notification_type_enum_1.NotificationType) === "function" ? _a : Object)
], Notification.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Notification.prototype, "link", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], Notification.prototype, "read", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Notification.prototype, "readAt", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Notification.prototype, "category", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", typeof (_c = typeof Record !== "undefined" && Record) === "function" ? _c : Object)
], Notification.prototype, "metadata", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, (user) => user.notifications, { eager: true, cascade: true }),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_d = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _d : Object)
], Notification.prototype, "user", void 0);
exports.Notification = Notification = __decorate([
    (0, typeorm_1.Entity)('notifications')
], Notification);


/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationType = void 0;
var NotificationType;
(function (NotificationType) {
    NotificationType["INFO"] = "info";
    NotificationType["SUCCESS"] = "success";
    NotificationType["WARNING"] = "warning";
    NotificationType["DANGER"] = "danger";
})(NotificationType || (exports.NotificationType = NotificationType = {}));


/***/ }),
/* 84 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Session = void 0;
const typeorm_1 = __webpack_require__(25);
const base_entity_1 = __webpack_require__(34);
const user_entity_1 = __webpack_require__(47);
let Session = class Session extends base_entity_1.BaseEntity {
};
exports.Session = Session;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Session.prototype, "refreshToken", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Session.prototype, "expiresAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], Session.prototype, "lastActiveAt", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => user_entity_1.User, (user) => user.sessions, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'userId' }),
    __metadata("design:type", typeof (_c = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _c : Object)
], Session.prototype, "user", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Session.prototype, "userAgent", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Session.prototype, "ipAddress", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Session.prototype, "deviceId", void 0);
exports.Session = Session = __decorate([
    (0, typeorm_1.Entity)('sessions')
], Session);


/***/ }),
/* 85 */
/***/ ((module) => {

"use strict";
module.exports = require("dotenv");

/***/ }),
/* 86 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeneralResponseDto = void 0;
const swagger_1 = __webpack_require__(8);
class GeneralResponseDto {
}
exports.GeneralResponseDto = GeneralResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'HTTP status code of the response',
        example: 404,
        type: Number,
    }),
    __metadata("design:type", Number)
], GeneralResponseDto.prototype, "statusCode", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Timestamp when the response was generated',
        example: '2025-04-07T02:04:20.545Z',
        type: String,
    }),
    __metadata("design:type", String)
], GeneralResponseDto.prototype, "timestamp", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier for tracking the request',
        example: 'dfed434d-9516-4ae3-975e-175df199dd01',
        type: String,
    }),
    __metadata("design:type", String)
], GeneralResponseDto.prototype, "traceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Request path that triggered this response',
        example: '/api/modules',
        type: String,
    }),
    __metadata("design:type", String)
], GeneralResponseDto.prototype, "path", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of exception or error that occurred',
        example: 'NotFoundException',
        type: String,
    }),
    __metadata("design:type", String)
], GeneralResponseDto.prototype, "detail", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Error message or messages describing the issue',
        example: 'Cannot GET /api/modules',
        oneOf: [
            { type: 'string' },
            { type: 'array', items: { type: 'string' } }
        ]
    }),
    __metadata("design:type", Object)
], GeneralResponseDto.prototype, "message", void 0);


/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UtilityHelper = void 0;
class UtilityHelper {
    static isEmpty(value) {
        return value === null || value === undefined || value === '';
    }
    static isEmailValid(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
    static generateRandomString(length) {
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * characters.length));
        }
        return result;
    }
    static hashPassword(password) {
        // Implement password hashing logic here (e.g., using bcrypt)
        return password; // Placeholder, replace with actual hashing
    }
    static comparePasswords(plainPassword, hashedPassword) {
        // Implement password comparison logic here (e.g., using bcrypt)
        return plainPassword === hashedPassword; // Placeholder, replace with actual comparison
    }
    static formatCriteria(criteria) {
        return Object.entries(criteria)
            .map(([key, value]) => `${key}: ${value}`)
            .join(', ');
    }
    // Helper method to calculate business days in a month
    static getBusinessDaysInMonth(date) {
        const year = date.getFullYear();
        const month = date.getMonth();
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        return this.getBusinessDays(firstDay, lastDay);
    }
    static getBusinessDays(start, end) {
        let count = 0;
        const current = new Date(start.getTime());
        while (current.getTime() <= end.getTime()) {
            const dayOfWeek = current.getDay();
            if (dayOfWeek !== 0 && dayOfWeek !== 6) { // Exclude Sundays (0) and Saturdays (6)
                count++;
            }
            current.setDate(current.getDate() + 1);
        }
        return count;
    }
    // Helper method to parse relations string into TypeORM relations object
    static parseRelations(relations) {
        const relationsObj = {};
        relations.split(',').forEach(relation => {
            relation = relation.trim();
            if (!relation)
                return;
            if (relation.includes('.')) {
                // Handle nested relation (e.g., "comments.author")
                const parts = relation.split('.');
                let currentLevel = relationsObj;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (i === parts.length - 1) {
                        // Last part in the chain
                        currentLevel[part] = true;
                    }
                    else {
                        // Create nested object if it doesn't exist
                        if (!currentLevel[part] || currentLevel[part] === true) {
                            currentLevel[part] = {};
                        }
                        // Move to next level in the object
                        currentLevel = currentLevel[part];
                    }
                }
            }
            else {
                // Handle simple relation
                relationsObj[relation] = true;
            }
        });
        return relationsObj;
    }
    // Helper method to parse select string into TypeORM select object
    static parseSelect(select) {
        const selectObj = {};
        select.split(',').forEach(field => {
            field = field.trim();
            if (!field)
                return;
            if (field.includes('.')) {
                // Handle nested selection (e.g., "profile.avatar")
                const parts = field.split('.');
                let currentLevel = selectObj;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (i === parts.length - 1) {
                        // Last part in the chain
                        currentLevel[part] = true;
                    }
                    else {
                        // Create nested object if it doesn't exist
                        if (!currentLevel[part] || typeof currentLevel[part] === 'boolean') {
                            currentLevel[part] = {};
                        }
                        // Move to next level in the object
                        currentLevel = currentLevel[part];
                    }
                }
            }
            else {
                // Handle simple field
                selectObj[field] = true;
            }
        });
        return selectObj;
    }
    // Helper method to check if a string is a valid email
    static isEmail(email) {
        if (!email)
            return false;
        // Regular expression for email validation
        const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
        return emailRegex.test(email);
    }
}
exports.UtilityHelper = UtilityHelper;


/***/ }),
/* 88 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionService = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(25);
let TransactionService = class TransactionService {
    constructor(dataSource) {
        this.dataSource = dataSource;
    }
    async executeInTransaction(operation) {
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            const result = await operation(queryRunner);
            await queryRunner.commitTransaction();
            return result;
        }
        catch (error) {
            await queryRunner.rollbackTransaction();
            throw error;
        }
        finally {
            await queryRunner.release();
        }
    }
};
exports.TransactionService = TransactionService;
exports.TransactionService = TransactionService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_1.DataSource !== "undefined" && typeorm_1.DataSource) === "function" ? _a : Object])
], TransactionService);


/***/ }),
/* 89 */
/***/ ((module) => {

"use strict";
module.exports = require("bcryptjs");

/***/ }),
/* 90 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionsService = void 0;
const base_service_1 = __webpack_require__(31);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const users_service_1 = __webpack_require__(30);
const roles_service_1 = __webpack_require__(91);
const permission_entity_1 = __webpack_require__(39);
let PermissionsService = class PermissionsService extends base_service_1.BaseService {
    constructor(permissionsRepository, usersService, rolesService) {
        super(permissionsRepository, usersService);
        this.permissionsRepository = permissionsRepository;
        this.usersService = usersService;
        this.rolesService = rolesService;
        this.cachedPermissions = new Map();
        this.preloadPermissions();
    }
    async getAllPermissions() {
        return this.permissionsRepository.find();
    }
    async preloadPermissions() {
        try {
            const permissions = await this.permissionsRepository.find();
            this.cachedPermissions.clear();
            for (const permission of permissions) {
                const key = this.getPermissionKey(permission.action, permission.subject);
                this.cachedPermissions.set(key, permission);
            }
            // this.logger.log(`Preloaded ${this.cachedPermissions.size} permissions into cache`);
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Failed to preload permissions: ${errorMessage}`);
        }
    }
    getPermissionKey(action, subject) {
        return `${action}:${subject}`;
    }
    /**
     * Find or create a permission
     * @param action The action (Create, Read, Update, Delete, Manage)
     * @param subject The subject (resource name)
     * @param name Optional name for the permission
     * @param description Optional description
     * @returns The permission entity
     */
    async findOrCreate(action, subject, name, description) {
        const permissionKey = this.getPermissionKey(action, subject);
        // Check cache first
        if (this.cachedPermissions.has(permissionKey)) {
            return this.cachedPermissions.get(permissionKey);
        }
        // Find in database
        const existingPermission = await this.permissionsRepository.findOne({
            where: { action, subject }
        });
        if (existingPermission) {
            // Update cache and return
            this.cachedPermissions.set(permissionKey, existingPermission);
            return existingPermission;
        }
        // Create new permission
        const newPermission = this.permissionsRepository.create({
            action,
            subject,
            name: name || `${action}_${subject}`.toUpperCase(),
            description: description || `Permission to ${action.toLowerCase()} ${subject}`
        });
        const savedPermission = await this.permissionsRepository.save(newPermission);
        // Update cache
        this.cachedPermissions.set(permissionKey, savedPermission);
        this.logger.log(`Created new permission: ${permissionKey}`);
        return savedPermission;
    }
    /**
     * Create multiple permissions in a transaction
     * @param permissionsData Array of permission data
     * @returns Created or found permissions
     */
    async createMultiple(permissionsData) {
        return this.transactionService.executeInTransaction(async (queryRunner) => {
            const results = [];
            for (const data of permissionsData) {
                const key = this.getPermissionKey(data.action, data.subject);
                // Check cache first
                if (this.cachedPermissions.has(key)) {
                    results.push(this.cachedPermissions.get(key));
                    continue;
                }
                // Find or create in transaction
                const existingPermission = await queryRunner.manager.findOne(permission_entity_1.Permission, {
                    where: { action: data.action, subject: data.subject }
                });
                if (existingPermission) {
                    this.cachedPermissions.set(key, existingPermission);
                    results.push(existingPermission);
                    continue;
                }
                // Create new
                const newPermission = queryRunner.manager.create(permission_entity_1.Permission, {
                    action: data.action,
                    subject: data.subject,
                    name: data.name || `${data.action}_${data.subject}`.toUpperCase(),
                    description: data.description || `Permission to ${data.action.toLowerCase()} ${data.subject}`
                });
                const savedPermission = await queryRunner.manager.save(newPermission);
                this.cachedPermissions.set(key, savedPermission);
                results.push(savedPermission);
            }
            return results;
        }).catch(error => {
            this.logger.error(`Failed to create permissions: ${error.message}`);
            throw error;
        });
    }
    /**
     * Get all permissions by subject
     * @param subject The subject name
     * @returns Array of permissions
     */
    async getPermissionsBySubject(subject) {
        // Try to get from cache first
        const cachedPermissions = Array.from(this.cachedPermissions.values())
            .filter(permission => permission.subject === subject);
        if (cachedPermissions.length > 0) {
            return cachedPermissions;
        }
        // Fetch from database
        const permissions = await this.permissionsRepository.find({
            where: { subject }
        });
        // Update cache
        for (const permission of permissions) {
            const key = this.getPermissionKey(permission.action, permission.subject);
            this.cachedPermissions.set(key, permission);
        }
        return permissions;
    }
    async getPermissionsByControllerName(baseName) {
        // Try to get from cache first
        const cachedPermissions = Array.from(this.cachedPermissions.values())
            .filter(permission => permission.subject.includes(baseName));
        if (cachedPermissions.length > 0) {
            return cachedPermissions;
        }
        const permissions = await this.permissionsRepository.find({
            where: {
                subject: baseName
            }
        });
        // Update cache
        for (const permission of permissions) {
            const key = this.getPermissionKey(permission.action, permission.subject);
            this.cachedPermissions.set(key, permission);
        }
        return permissions;
    }
};
exports.PermissionsService = PermissionsService;
exports.PermissionsService = PermissionsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(permission_entity_1.Permission)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof roles_service_1.RolesService !== "undefined" && roles_service_1.RolesService) === "function" ? _c : Object])
], PermissionsService);


/***/ }),
/* 91 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RolesService = void 0;
const base_service_1 = __webpack_require__(31);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const users_service_1 = __webpack_require__(30);
const role_entity_1 = __webpack_require__(37);
let RolesService = class RolesService extends base_service_1.BaseService {
    constructor(rolesRepository, usersService) {
        super(rolesRepository, usersService);
        this.rolesRepository = rolesRepository;
        this.usersService = usersService;
    }
    async getAllRoles() {
        return this.rolesRepository.find({ relations: ['permissions'] });
    }
    async findRoleWithPermissions(roleId) {
        const role = await this.rolesRepository.findOne({
            where: { id: roleId },
            relations: ['permissions'],
        });
        if (!role) {
            throw new common_1.NotFoundException(`Role with ID ${roleId} not found`);
        }
        return role;
    }
};
exports.RolesService = RolesService;
exports.RolesService = RolesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(role_entity_1.Role)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], RolesService);


/***/ }),
/* 92 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivityLogsService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const activity_log_entity_1 = __webpack_require__(80);
let ActivityLogsService = class ActivityLogsService extends base_service_1.BaseService {
    constructor(activityLogsRepository, usersService) {
        super(activityLogsRepository, usersService);
        this.activityLogsRepository = activityLogsRepository;
        this.usersService = usersService;
    }
};
exports.ActivityLogsService = ActivityLogsService;
exports.ActivityLogsService = ActivityLogsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(activity_log_entity_1.ActivityLog)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], ActivityLogsService);


/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Permissions = exports.PERMISSIONS_KEY = void 0;
const common_1 = __webpack_require__(5);
exports.PERMISSIONS_KEY = 'permissions';
/**
 * A decorator to set permissions metadata for a route handler.
 *
 * @param requirements - An array of permission objects that are required to access the route.
 * @returns A decorator function that sets the permissions metadata.
 *
 * @example
 * ```typescript
 * import { Permissions } from './permissions.decorator';
 * import { Controller, Get } from '@nestjs/common';
 *
 * @Controller('example')
 * export class ExampleController {
 *   @Get()
 *   @Permissions([{ name: 'read', level: 'admin' }])
 *   getExample() {
 *     return 'This route requires read permission with admin level';
 *   }
 * }
 * ```
 */
const Permissions = (requirements = []) => (0, common_1.SetMetadata)(exports.PERMISSIONS_KEY, requirements);
exports.Permissions = Permissions;


/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Role = void 0;
var Role;
(function (Role) {
    Role["SUPERADMIN"] = "SuperAdmin";
    Role["ADMIN"] = "Admin";
    Role["EMPLOYEE"] = "Employee";
})(Role || (exports.Role = Role = {}));


/***/ }),
/* 95 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var RolesGuard_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RolesGuard = void 0;
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const roles_decorator_1 = __webpack_require__(96);
const role_enum_1 = __webpack_require__(94);
let RolesGuard = RolesGuard_1 = class RolesGuard {
    constructor(reflector, usersService) {
        this.reflector = reflector;
        this.usersService = usersService;
        this.logger = new common_1.Logger(RolesGuard_1.name);
    }
    async canActivate(context) {
        var _a, _b, _c, _d;
        try {
            const requiredRoles = this.reflector.getAllAndOverride(roles_decorator_1.ROLES_KEY, [context.getHandler(), context.getClass()]);
            // If no roles are required, allow access
            if (!requiredRoles || requiredRoles.length === 0) {
                return true;
            }
            // Get the user payload from the request
            const request = context.switchToHttp().getRequest();
            const userClaims = request.user;
            var user = await this.usersService.findOneBy({ id: userClaims.sub }, { relations: { employee: { roles: true } } });
            if (!user) {
                this.logger.warn(`User with ID ${userClaims.sub} not found`);
                throw new common_1.ForbiddenException('User not found');
            }
            // If user has the super admin role, allow access
            const hasSuperAdminRole = (_b = (_a = user.employee) === null || _a === void 0 ? void 0 : _a.roles) === null || _b === void 0 ? void 0 : _b.some(role => role.name === role_enum_1.Role.SUPERADMIN);
            if (hasSuperAdminRole) {
                return true;
            }
            // Check if the user has the required roles
            const hasRequiredRoles = (_d = (_c = user === null || user === void 0 ? void 0 : user.employee) === null || _c === void 0 ? void 0 : _c.roles) === null || _d === void 0 ? void 0 : _d.some(role => requiredRoles.includes(role.name));
            if (!hasRequiredRoles) {
                throw new common_1.ForbiddenException('You are not authorized to access this resource.');
            }
            return hasRequiredRoles;
        }
        catch (error) {
            if (error instanceof common_1.ForbiddenException) {
                throw error;
            }
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Unexpected error in Roles guard: ${errorMessage}`);
            throw new common_1.ForbiddenException('Role check failed');
        }
    }
};
exports.RolesGuard = RolesGuard;
exports.RolesGuard = RolesGuard = RolesGuard_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof core_1.Reflector !== "undefined" && core_1.Reflector) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], RolesGuard);


/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Roles = exports.ROLES_KEY = void 0;
const common_1 = __webpack_require__(5);
exports.ROLES_KEY = 'roles';
/**
 * Decorator that assigns roles to a route or controller.
 * This metadata can be used with a guard to control access to specific endpoints.
 *
 * @param roles - An array of role names that are allowed to access the decorated endpoint.
 * Defaults to an empty array if not provided.
 * @returns A decorator function that sets the roles metadata on the target.
 *
 * @example
 * ```typescript
 * // Apply to a controller to restrict all routes
 * @Controller('users')
 * @Roles(['admin'])
 * export class UsersController {
 *   // ...
 * }
 *
 * // Apply to a specific route
 * @Get('profile')
 * @Roles(['admin', 'user'])
 * getProfile() {
 *   return 'This is a protected route';
 * }
 * ```
 */
const Roles = (roles = []) => (0, common_1.SetMetadata)(exports.ROLES_KEY, roles);
exports.Roles = Roles;


/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurrentUser = void 0;
const common_1 = __webpack_require__(5);
/**
 * Custom decorator to extract the current user from the request.
 *
 * @param data - The specific key of the user object to extract. If undefined, the entire user object is returned.
 * @param context - The execution context which provides access to the request object.
 *
 * @returns The user object or a specific property of the user object.
 *
 * @throws {UnauthorizedException} If the user is not authenticated.
 *
 * @example
 * // Usage in a controller to get the entire user object
 * @Get('profile')
 * getProfile(@CurrentUser() user: User) {
 *   return user;
 * }
 *
 * @example
 * Usage in a controller to get a specific property of the user object
 * @Get('profile/email')
 * getEmail(@CurrentUser('email') email: string) {
 *   return email;
 * }
 */
exports.CurrentUser = (0, common_1.createParamDecorator)((data, context) => {
    const request = context.switchToHttp().getRequest();
    if (!request.user) {
        throw new common_1.UnauthorizedException('User claims is missing.');
    }
    if (!data) {
        return request.user;
    }
    return request === null || request === void 0 ? void 0 : request.user[data];
});


/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Override = Override;
__webpack_require__(99);
/**
 * A decorator function that copies metadata from the overridden method
 * in the parent class to the overriding method in the child class.
 *
 * @returns A decorator function that can be applied to a method.
 *
 * @example
 * ```typescript
 * import { Override } from './override.decorator';
 *
 * class ParentClass {
 *   @SomeDecorator()
 *   someMethod() {
 *     // Parent method implementation
 *   }
 * }
 *
 * class ChildClass extends ParentClass {
 *   @Override()
 *   someMethod() {
 *     // Child method implementation
 *   }
 * }
 * ```
 *
 * @param target - The prototype of the class.
 * @param propertyKey - The name of the method being decorated.
 * @param descriptor - The property descriptor of the method.
 */
function Override() {
    return (target, propertyKey, descriptor) => {
        const parentTarget = Object.getPrototypeOf(target);
        const parentDescriptor = Object.getOwnPropertyDescriptor(parentTarget, propertyKey);
        if (parentDescriptor) {
            Reflect.getMetadataKeys(parentDescriptor.value).forEach((metadataKey) => {
                const metadataValue = Reflect.getMetadata(metadataKey, parentDescriptor.value);
                Reflect.defineMetadata(metadataKey, metadataValue, descriptor.value);
            });
        }
    };
}


/***/ }),
/* 99 */
/***/ ((module) => {

"use strict";
module.exports = require("reflect-metadata");

/***/ }),
/* 100 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetEmployeeDto = exports.UpdateEmployeeDto = exports.EmployeeDto = void 0;
const base_dto_1 = __webpack_require__(101);
const reference_dto_1 = __webpack_require__(102);
const employment_condition_enum_1 = __webpack_require__(44);
const employment_status_enum_1 = __webpack_require__(45);
const employment_type_enum_1 = __webpack_require__(46);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class EmployeeDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.EmployeeDto = EmployeeDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User ID associated with the employee' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], EmployeeDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employment status of the employee',
        enum: employment_status_enum_1.EmploymentStatus,
        default: employment_status_enum_1.EmploymentStatus.PENDING,
    }),
    (0, class_validator_1.IsEnum)(employment_status_enum_1.EmploymentStatus),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_a = typeof employment_status_enum_1.EmploymentStatus !== "undefined" && employment_status_enum_1.EmploymentStatus) === "function" ? _a : Object)
], EmployeeDto.prototype, "employmentStatus", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employment condition of the employee',
        enum: employment_condition_enum_1.EmploymentCondition,
        default: employment_condition_enum_1.EmploymentCondition.PROBATIONARY,
    }),
    (0, class_validator_1.IsEnum)(employment_condition_enum_1.EmploymentCondition),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_b = typeof employment_condition_enum_1.EmploymentCondition !== "undefined" && employment_condition_enum_1.EmploymentCondition) === "function" ? _b : Object)
], EmployeeDto.prototype, "employmentCondition", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employment type of the employee',
        enum: employment_type_enum_1.EmploymentType,
        default: employment_type_enum_1.EmploymentType.FULL_TIME,
    }),
    (0, class_validator_1.IsEnum)(employment_type_enum_1.EmploymentType),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_c = typeof employment_type_enum_1.EmploymentType !== "undefined" && employment_type_enum_1.EmploymentType) === "function" ? _c : Object)
], EmployeeDto.prototype, "employmentType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date when employee commenced work',
        type: Date,
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], EmployeeDto.prototype, "commencementDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Available leave credits',
        required: false,
        default: 0,
        minimum: 0,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], EmployeeDto.prototype, "leaveCredits", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Monthly rate of the employee',
        required: false,
        default: 0,
        type: Number,
        minimum: 0
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({ maxDecimalPlaces: 2 }),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], EmployeeDto.prototype, "monthlyRate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Roles associated with this employee',
        type: [reference_dto_1.ReferenceDto]
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], EmployeeDto.prototype, "roles", void 0);
class UpdateEmployeeDto extends (0, swagger_1.PartialType)(EmployeeDto) {
}
exports.UpdateEmployeeDto = UpdateEmployeeDto;
class GetEmployeeDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateEmployeeDto, "employee") {
}
exports.GetEmployeeDto = GetEmployeeDto;


/***/ }),
/* 101 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseDto = void 0;
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class BaseDto {
}
exports.BaseDto = BaseDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Organization ID - Identifies the organization that owns or scopes this resource. Used for multi-tenant access control and resource partitioning.',
        required: false,
        type: String,
        format: 'uuid',
        example: '123e4567-e89b-12d3-a456-426614174000',
        nullable: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BaseDto.prototype, "organizationId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Branch ID - Specifies the organizational branch that owns or scopes this resource. Represents a subdivision within the parent organization.',
        required: false,
        type: String,
        format: 'uuid',
        example: '123e4567-e89b-12d3-a456-426614174001',
        nullable: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BaseDto.prototype, "branchId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Department ID - Indicates the specific department that owns or scopes this resource. Used for departmental-level access control and resource organization.',
        required: false,
        type: String,
        format: 'uuid',
        example: '123e4567-e89b-12d3-a456-426614174002',
        nullable: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BaseDto.prototype, "departmentId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User ID - Identifies the specific user who owns or has primary responsibility for this resource. Used for user-level permissions and audit trails.',
        required: false,
        type: String,
        format: 'uuid',
        example: '123e4567-e89b-12d3-a456-426614174003',
        nullable: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BaseDto.prototype, "userId", void 0);


/***/ }),
/* 102 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReferenceDto = void 0;
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class ReferenceDto {
}
exports.ReferenceDto = ReferenceDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier',
        example: '123e4567-e89b-12d3-a456-426614174000'
    }),
    (0, class_validator_1.IsUUID)('4'),
    __metadata("design:type", String)
], ReferenceDto.prototype, "id", void 0);


/***/ }),
/* 103 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createGetDto = createGetDto;
const swagger_1 = __webpack_require__(8);
/**
 * Creates a Data Transfer Object (DTO) class for GET operations by extending the provided DTO
 * with standard entity metadata fields such as id, timestamps, and soft-delete information.
 *
 * This utility automatically copies all properties and decorators from the source DTO
 * and adds standardized tracking fields like creation date, update date, etc. The resulting
 * class is dynamically named with the pattern `Get${originalClassName}`.
 *
 * @template T - The type of the DTO class to extend
 * @param {new () => T} dto - The DTO class constructor to extend with metadata fields
 * @returns {any} A new DTO class that extends the original with standard entity metadata fields
 *
 * @remarks
 * The returned class includes the following additional fields:
 * - id: Unique identifier for the entity
 * - createdAt: Timestamp of entity creation
 * - updatedAt: Timestamp of last update (nullable)
 * - createdBy: ID of the user who created the entity (nullable)
 * - updatedBy: ID of the user who last updated the entity (nullable)
 * - isDeleted: Flag indicating if the entity is soft-deleted
 * - deletedBy: ID of the user who deleted the entity (nullable)
 * - deletedAt: Timestamp of entity deletion (nullable)
 *
 * @example
 * ```typescript
 * // Define a base DTO
 * class UserDto {
 *   @ApiProperty()
 *   name: string;
 *
 *   @ApiProperty()
 *   email: string;
 * }
 *
 * // Create a GetUserDto with all standard metadata fields
 * const GetUserDto = createGetDto(UserDto);
 * ```
 */
function createGetDto(dto, entity = "entity") {
    var _a, _b, _c;
    class GetDto extends dto {
        constructor(partial) {
            super();
            Object.assign(this, partial);
        }
    }
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: 'Unique identifier',
            example: '123e4567-e89b-12d3-a456-426614174000'
        }),
        __metadata("design:type", String)
    ], GetDto.prototype, "id", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `Date when this ${entity} was created`,
            example: '2023-01-01T00:00:00Z',
            type: Date
        }),
        __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
    ], GetDto.prototype, "createdAt", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `Date when this ${entity} was last updated`,
            example: '2023-01-02T00:00:00Z',
            type: Date,
            nullable: true
        }),
        __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
    ], GetDto.prototype, "updatedAt", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `ID of the user who created this ${entity}}`,
            example: '123e4567-e89b-12d3-a456-426614174000',
            nullable: true
        }),
        __metadata("design:type", String)
    ], GetDto.prototype, "createdBy", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `ID of the user who last updated this ${entity}`,
            example: '123e4567-e89b-12d3-a456-426614174000',
            nullable: true
        }),
        __metadata("design:type", String)
    ], GetDto.prototype, "updatedBy", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `Whether this ${entity} is marked as deleted`,
            example: false,
            default: false
        }),
        __metadata("design:type", Boolean)
    ], GetDto.prototype, "isDeleted", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `ID of the user who deleted this ${entity}`,
            example: '123e4567-e89b-12d3-a456-426614174000',
            nullable: true
        }),
        __metadata("design:type", String)
    ], GetDto.prototype, "deletedBy", void 0);
    __decorate([
        (0, swagger_1.ApiProperty)({
            description: `Date when this ${entity} was deleted`,
            example: '2023-01-03T00:00:00Z',
            type: Date,
            nullable: true
        }),
        __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
    ], GetDto.prototype, "deletedAt", void 0);
    // Copy properties and decorators from the source DTO
    const prototype = dto.prototype;
    Reflect.ownKeys(prototype).forEach(key => {
        if (key === 'constructor')
            return;
        const descriptor = Object.getOwnPropertyDescriptor(prototype, key);
        if (descriptor) {
            Object.defineProperty(GetDto.prototype, key, descriptor);
        }
    });
    // Rename the class
    Object.defineProperty(GetDto, 'name', { value: `Get${dto.name}` });
    return GetDto;
}


/***/ }),
/* 104 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeesService = void 0;
const role_enum_1 = __webpack_require__(94);
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const employee_entity_1 = __webpack_require__(43);
const roles_service_1 = __webpack_require__(91);
let EmployeesService = class EmployeesService extends base_service_1.BaseService {
    constructor(employeesRepository, usersService, rolesService) {
        super(employeesRepository, usersService);
        this.employeesRepository = employeesRepository;
        this.usersService = usersService;
        this.rolesService = rolesService;
    }
    async create(createDto, createdBy) {
        var _a, _b;
        // Get the highest employee number
        const highestEmpNum = await this.employeesRepository
            .createQueryBuilder('employee')
            .select('MAX(employee.employeeNumber)', 'max')
            .getRawOne();
        // Increment by 1 (or start at 1000 if no employees exist)
        const nextEmpNum = ((highestEmpNum === null || highestEmpNum === void 0 ? void 0 : highestEmpNum.max) || 999) + 1;
        // check if createDto has employeeNumber
        if (!createDto.employeeNumber) {
            createDto.employeeNumber = nextEmpNum;
        }
        // find employee role by name
        const employeeRole = await this.rolesService.findOneByOrFail({
            name: role_enum_1.Role.EMPLOYEE,
        });
        // store temporary roles
        const tempRoles = createDto.roles || [];
        // filter out non existing roles
        const existingRoles = await this.rolesService.getRepository().findBy({
            id: (0, typeorm_2.In)(tempRoles.map(role => role.id)),
        });
        // map existing roles id to the createDto
        createDto.roles = existingRoles.map(role => {
            return {
                id: role.id,
            };
        });
        // assign employee role to employee by adding to the roles array
        if (!((_a = createDto.roles) === null || _a === void 0 ? void 0 : _a.some(role => role.id === employeeRole.id))) {
            (_b = createDto.roles) === null || _b === void 0 ? void 0 : _b.push(employeeRole);
        }
        return await super.create(createDto, createdBy);
    }
    async getEmployeesByIds(employeeIds) {
        const employees = await this.employeesRepository.findBy({
            id: (0, typeorm_2.In)(employeeIds),
        });
        if (employees.length !== employeeIds.length) {
            throw new common_1.NotFoundException('Employee/s does not exist');
        }
        return employees;
    }
};
exports.EmployeesService = EmployeesService;
exports.EmployeesService = EmployeesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(employee_entity_1.Employee)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof roles_service_1.RolesService !== "undefined" && roles_service_1.RolesService) === "function" ? _c : Object])
], EmployeesService);


/***/ }),
/* 105 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionsModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const roles_module_1 = __webpack_require__(106);
const permission_entity_1 = __webpack_require__(39);
const permissions_controller_1 = __webpack_require__(122);
const permissions_service_1 = __webpack_require__(90);
const permission_seeder_service_1 = __webpack_require__(124);
let PermissionsModule = class PermissionsModule {
};
exports.PermissionsModule = PermissionsModule;
exports.PermissionsModule = PermissionsModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([permission_entity_1.Permission]), roles_module_1.RolesModule],
        providers: [permissions_service_1.PermissionsService, permission_seeder_service_1.PermissionSeederService],
        exports: [permissions_service_1.PermissionsService, permission_seeder_service_1.PermissionSeederService],
        controllers: [permissions_controller_1.PermissionsController],
    })
], PermissionsModule);


/***/ }),
/* 106 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RolesModule = void 0;
const users_module_1 = __webpack_require__(107);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const role_entity_1 = __webpack_require__(37);
const roles_controller_1 = __webpack_require__(120);
const roles_service_1 = __webpack_require__(91);
let RolesModule = class RolesModule {
};
exports.RolesModule = RolesModule;
exports.RolesModule = RolesModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([role_entity_1.Role]), users_module_1.UsersModule],
        controllers: [roles_controller_1.RolesController],
        providers: [roles_service_1.RolesService],
        exports: [roles_service_1.RolesService],
    })
], RolesModule);


/***/ }),
/* 107 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const user_entity_1 = __webpack_require__(47);
const users_gateway_1 = __webpack_require__(108);
const users_controller_1 = __webpack_require__(116);
const users_service_1 = __webpack_require__(30);
let UsersModule = class UsersModule {
};
exports.UsersModule = UsersModule;
exports.UsersModule = UsersModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([user_entity_1.User])],
        controllers: [users_controller_1.UsersController],
        providers: [users_service_1.UsersService, users_gateway_1.UsersGateway],
        exports: [users_service_1.UsersService],
    })
], UsersModule);


/***/ }),
/* 108 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersGateway = void 0;
const create_gateway_factory_1 = __webpack_require__(109);
class UsersGateway extends (0, create_gateway_factory_1.createGateway)('users') {
}
exports.UsersGateway = UsersGateway;


/***/ }),
/* 109 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createGateway = createGateway;
const jwt_service_1 = __webpack_require__(110);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const websockets_1 = __webpack_require__(113);
const base_gateway_1 = __webpack_require__(114);
function createGateway(namespace) {
    var _a, _b, _c;
    let DynamicGateway = class DynamicGateway extends base_gateway_1.BaseGateway {
        constructor(jwtService, usersService, configService) {
            super(jwtService, usersService, configService);
            this.namespace = namespace;
        }
    };
    DynamicGateway = __decorate([
        (0, websockets_1.WebSocketGateway)({ namespace }),
        (0, common_1.Injectable)(),
        __metadata("design:paramtypes", [typeof (_a = typeof jwt_service_1.JwtService !== "undefined" && jwt_service_1.JwtService) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object])
    ], DynamicGateway);
    return DynamicGateway;
}


/***/ }),
/* 110 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var JwtService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JwtService = void 0;
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const jwt_1 = __webpack_require__(111);
const uuid_1 = __webpack_require__(112);
/**
 * Service responsible for JWT (JSON Web Token) operations.
 * Provides methods for creating, verifying, and decoding JWT tokens,
 * as well as managing JWT payloads.
 */
/**
 * @class JwtService
 * @injectable
 */
/**
 * @constructor
 * @param {NestJwtService} jwtService - The NestJS JWT service instance
 */
/**
 * Creates a JWT token from the provided payload
 * @method createToken
 * @param {IJwtPayload} payload - The payload to be encoded in the JWT
 * @returns {Promise<string>} A Promise that resolves to the JWT string
 */
/**
 * Verifies and decodes a JWT token
 * @method verifyToken
 * @param {string} token - The JWT token to verify
 * @returns {Promise<IJwtPayload>} A Promise that resolves to the decoded payload
 * @throws {Error} If the token is invalid or expired
 */
/**
 * Decodes a JWT token without verifying its signature
 * @method decodeToken
 * @param {string} token - The JWT token to decode
 * @returns {Promise<IJwtPayload>} A Promise that resolves to the decoded payload
 */
/**
 * Creates a standard JWT payload with common claims
 * @method createPayload
 * @param {string} userId - The user's unique identifier
 * @param {string} [email] - Optional email address
 * @param {string[]} [roles] - Optional array of user roles
 * @returns {IJwtPayload} The formatted JWT payload
 */
/**
 * Validates the structure of a JWT payload
 * @method validatePayload
 * @param {any} payload - The payload to validate
 * @returns {boolean} True if the payload matches the IJwtPayload structure
 */
/**
 * Service responsible for handling JSON Web Token (JWT) operations.
 * Provides functionality for creating, verifying, and decoding JWT tokens.
 *
 * @class
 */
/**
 * @constructor
 * @param {NestJwtService} jwtService - The NestJS JWT service instance
 * @param {ConfigService} configService - The configuration service for accessing environment variables
 */
/**
 * Creates a JWT token from the provided payload
 * @param {IJwtPayload} payload - The payload to be encoded in the token
 * @returns {Promise<string>} A Promise that resolves to the signed JWT token
 */
/**
 * Creates a refresh token from the provided payload with configurable expiration
 * @param {IJwtPayload} payload - The payload to be encoded in the refresh token
 * @returns {Promise<string>} A Promise that resolves to the signed refresh token
 */
/**
 * Verifies and decodes a JWT token
 * @param {string} token - The JWT token to verify
 * @returns {Promise<IJwtPayload>} A Promise that resolves to the decoded and verified payload
 * @throws {Error} If the token is invalid or expired
 */
/**
 * Decodes a JWT token without verification
 * @param {string} token - The JWT token to decode
 * @returns {Promise<IJwtPayload>} A Promise that resolves to the decoded payload
 */
/**
 * Creates a standard JWT payload with user information and expiration
 * @param {string} userId - The unique identifier of the user
 * @param {string} [email] - Optional email of the user
 * @param {string[]} [roles] - Optional array of user roles
 * @returns {IJwtPayload} The created JWT payload object
 */
/**
 * Validates the structure of a JWT payload
 * @param {any} payload - The payload to validate
 * @returns {boolean} True if the payload matches the expected structure, false otherwise
 */
let JwtService = JwtService_1 = class JwtService {
    constructor(jwtService, configService) {
        this.jwtService = jwtService;
        this.configService = configService;
        this.logger = new common_1.Logger(JwtService_1.name);
    }
    /**
     * Create a JWT token from payload
     */
    async createToken(payload) {
        return this.jwtService.sign(payload);
    }
    /**
     * Create a refresh token from payload
     */
    async createRefreshToken() {
        // const refreshTokenExpirationMinutes: number = this.configService.getOrThrow<number>('REFRESH_TOKEN_EXPIRATION_MINUTES');
        // return this.jwtService.sign(payload, { expiresIn: `${refreshTokenExpirationMinutes}m` });
        return (0, uuid_1.v4)();
    }
    /**
     * Verify and decode a JWT token
     */
    async verifyToken(token) {
        return this.jwtService.verify(token);
    }
    /**
     * Decode a JWT token without verifying
     */
    async decodeToken(token) {
        return this.jwtService.decode(token);
    }
    /**
     * Create a standard JWT payload
     */
    createPayload(user, refreshToken) {
        var _a, _b, _c;
        const now = Math.floor(Date.now() / 1000);
        const mappedRoles = ((_a = user.employee) === null || _a === void 0 ? void 0 : _a.roles) ? (_b = user.employee) === null || _b === void 0 ? void 0 : _b.roles.map(role => ({
            name: role.name,
            scope: role.scope,
            departmentId: role.departmentId,
            organizationId: role.organizationId,
            branchId: role.branchId,
        })) : [];
        return {
            sub: user.id,
            iat: now,
            refreshToken,
            email: user.email,
            roles: mappedRoles !== null && mappedRoles !== void 0 ? mappedRoles : [],
            employeeId: (_c = user.employee) === null || _c === void 0 ? void 0 : _c.id,
        };
    }
    /**
     * Validate payload structure
     */
    validatePayload(payload) {
        return (typeof payload === 'object' &&
            typeof payload.sub === 'string' &&
            (!payload.email || typeof payload.email === 'string') &&
            (!payload.roles || Array.isArray(payload.roles)));
    }
};
exports.JwtService = JwtService;
exports.JwtService = JwtService = JwtService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof jwt_1.JwtService !== "undefined" && jwt_1.JwtService) === "function" ? _a : Object, typeof (_b = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _b : Object])
], JwtService);


/***/ }),
/* 111 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/jwt");

/***/ }),
/* 112 */
/***/ ((module) => {

"use strict";
module.exports = require("uuid");

/***/ }),
/* 113 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/websockets");

/***/ }),
/* 114 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseGateway = void 0;
const common_1 = __webpack_require__(5);
const websockets_1 = __webpack_require__(113);
const class_transformer_1 = __webpack_require__(23);
const socket_io_1 = __webpack_require__(115);
const uuid_1 = __webpack_require__(112);
class BaseGateway {
    constructor(jwtService, usersService, configService) {
        var _a, _b;
        this.jwtService = jwtService;
        this.usersService = usersService;
        this.configService = configService;
        this.logger = new common_1.Logger(this.constructor.name);
        this.connections = new Map();
        // Organized client tracking
        this.connectedClients = new Map();
        this.userRooms = new Map();
        // Add middleware support
        this.middlewares = [];
        // Rate limiting protection
        this.messageRateLimit = new Map();
        this.MAX_MESSAGES_PER_MINUTE = 60;
        this.HEARTBEAT_INTERVAL = 60000; // ms
        this.CONNECTION_TIMEOUT = 300000; // 5 minutes in ms
        this.AUTH_TOKEN_EXPIRY_BUFFER = 300; // 5 minutes in seconds
        this.eventHandlers = new Map();
        this.metrics = {
            totalConnections: 0,
            activeConnections: 0,
            messagesProcessed: 0,
            authFailures: 0,
            rateLimitHits: 0
        };
        // Configure compression
        const compressionThreshold = this.configService.get('websocket.compressionThreshold', 1024);
        (_b = (_a = this.server) === null || _a === void 0 ? void 0 : _a.engine) === null || _b === void 0 ? void 0 : _b.on('connection', (socket) => {
            socket.compress = (data) => {
                return data.length > compressionThreshold;
            };
        });
    }
    // Lifecycle hooks
    onModuleInit() {
        // this.logger.log(`Gateway ${this.constructor.name} initialized`);
        this.setupHeartbeat();
        this.setupEventHandlers();
    }
    onModuleDestroy() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
        }
        this.logger.log(`Gateway ${this.constructor.name} destroyed`);
    }
    afterInit(server) {
        if (!server || !server.engine) {
            // this.logger.warn('Server or server.engine not available in afterInit');
            return; // Exit early if server or server.engine is not available
        }
        const corsConfig = {
            origin: this.configService.getOrThrow('CORS_ORIGINS'),
            credentials: true,
            methods: '*',
            allowedHeaders: 'Content-Type, Accept, Authorization',
            maxAge: 86400 // 24 hours
        };
        // Apply CORS configuration to the server
        server.engine.on('headers', (headers, req) => {
            const origin = req.headers.origin;
            if (corsConfig.origin.includes(origin) || corsConfig.origin.includes('*')) {
                headers['Access-Control-Allow-Origin'] = origin;
                headers['Access-Control-Allow-Credentials'] = corsConfig.credentials;
                headers['Access-Control-Allow-Methods'] = typeof corsConfig.methods === 'string' ?
                    corsConfig.methods : corsConfig.methods.join(', ');
                headers['Access-Control-Allow-Headers'] = corsConfig.allowedHeaders;
                headers['Access-Control-Max-Age'] = corsConfig.maxAge;
                // Security headers
                headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains';
                headers['X-Content-Type-Options'] = 'nosniff';
                headers['X-XSS-Protection'] = '1; mode=block';
                headers['X-Frame-Options'] = 'SAMEORIGIN'; // Prevents clickjacking
                headers['Content-Security-Policy'] = "default-src 'self'"; // Restrictive CSP
            }
        });
    }
    handleConnection(client) {
        try {
            const ip = client.handshake.address;
            const current = this.connections.get(ip) || { count: 0, lastConnect: new Date() };
            // Rate limiting logic
            const now = new Date();
            const timeDiff = now.getTime() - current.lastConnect.getTime();
            if (timeDiff < 1000 && current.count > 5) {
                client.disconnect();
                this.logger.warn(`Rate limit exceeded for IP: ${ip}`);
                return;
            }
            // Update connection tracking
            this.connections.set(ip, {
                count: timeDiff < 10000 ? current.count + 1 : 1,
                lastConnect: now
            });
            this.metrics.totalConnections++;
            this.metrics.activeConnections++;
            // Generate a unique connection ID for this socket
            client.connectionId = (0, uuid_1.v4)();
            // Apply middlewares before proceeding with connection
            this.applyMiddlewares(client, async (err) => {
                if (err) {
                    this.logger.error(`Middleware error: ${err.message}`);
                    client.disconnect();
                    return;
                }
                // Continue with existing connection logic
                const isAuthenticated = await this.authenticateClient(client);
                if (!isAuthenticated) {
                    this.logger.warn(`Authentication failed for connection ${client.id}`);
                    client.disconnect();
                    return;
                }
                // Rest of your existing connection logic...
                if (!client.user) {
                    this.logger.warn(`User not defined after authentication for connection ${client.id}`);
                    client.disconnect();
                    return;
                }
                const user = client.user.sub;
                this.connectedClients.set(user, client);
                this.messageRateLimit.set(user, 0);
                this.logger.log(`Client connected: ${user} (${client.connectionId})`);
                this.logger.log(`Total active connections: ${this.metrics.activeConnections}`);
                this.afterConnect(client);
            });
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Connection error: ${error.message}`, error.stack);
            }
            else {
                this.logger.error('Connection error: Unknown error');
            }
            client.disconnect();
        }
    }
    // Add to BaseGateway class
    async handleShutdown() {
        this.logger.log(`Gateway ${this.constructor.name} shutting down gracefully`);
        // Send disconnect warning to all clients
        this.broadcast('server_shutdown', {
            message: 'Server is shutting down for maintenance',
            reconnectIn: 10000 // ms
        });
        // Wait to allow clients to process the message
        await new Promise(resolve => setTimeout(resolve, 1000));
        // Close all connections
        this.connectedClients.forEach((client) => {
            client.disconnect(true);
        });
        // Clear data structures
        this.connectedClients.clear();
        this.userRooms.clear();
        this.messageRateLimit.clear();
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
        }
    }
    validatePayload(payload, schema) {
        try {
            return (0, class_transformer_1.plainToClass)(schema, payload, { excludeExtraneousValues: true });
        }
        catch (error) {
            throw new websockets_1.WsException('Invalid payload format');
        }
    }
    addMiddleware(middleware) {
        this.middlewares.push(middleware);
    }
    applyMiddlewares(client, callback) {
        let index = 0;
        const next = (err) => {
            if (err)
                return callback(err);
            if (index >= this.middlewares.length)
                return callback();
            const middleware = this.middlewares[index++];
            try {
                middleware(client, next);
            }
            catch (error) {
                next(error instanceof Error ? error : new Error('Middleware error'));
            }
        };
        next();
    }
    handleDisconnect(client) {
        try {
            this.metrics.activeConnections--;
            if (!client.user || !client.user.sub || !client.user.email) {
                return;
            }
            const user = client.user.email || client.user.sub;
            // Clean up resources
            this.connectedClients.delete(user);
            this.messageRateLimit.delete(user);
            // Leave all rooms
            const rooms = this.userRooms.get(user);
            if (rooms) {
                rooms.forEach(room => {
                    client.leave(room);
                });
                this.userRooms.delete(user);
            }
            this.logger.log(`Client disconnected: ${user} (${client.connectionId})`);
            this.logger.log(`Total active connections: ${this.metrics.activeConnections}`);
            this.afterDisconnect(client);
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Disconnect error: ${error.message}`, error.stack);
            }
            else {
                this.logger.error('Disconnect error: Unknown error');
            }
        }
    }
    // A centralized error handler
    handleError(context, error, client) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        const stack = error instanceof Error ? error.stack : undefined;
        this.logger.error(`${context}: ${errorMessage}`, stack);
        if (client) {
            client.emit('error', {
                message: 'An error occurred',
                code: 'INTERNAL_ERROR',
                context
            });
        }
    }
    // Authentication - override this in derived classes for specific auth logic
    async authenticateClient(client) {
        try {
            const token = this.extractTokenFromSocket(client);
            if (!token) {
                this.logger.debug('No token provided');
                return false;
            }
            // Verify token hasn't expired
            const payload = await this.jwtService.verifyToken(token);
            // Check token expiration with buffer time to avoid edge cases
            const currentTime = Math.floor(Date.now() / 1000);
            if (payload.exp && payload.exp - this.AUTH_TOKEN_EXPIRY_BUFFER < currentTime) {
                this.logger.debug(`Token expiring soon: ${payload.exp - currentTime}s remaining`);
            }
            // Find and verify the user exists and is active
            const user = await this.usersService.findOneBy({
                id: payload.sub
            });
            if (!user) {
                this.logger.debug(`User not found or inactive: ${payload.sub}`);
                return false;
            }
            // Store minimal user data on socket
            client.user = payload;
            // Track connection with timestamp
            client.connectionId = `${user.id}-${Date.now()}`;
            client.handshake.auth.connectedAt = Date.now();
            return true;
        }
        catch (error) {
            this.handleError('Authentication', error);
            return false;
        }
    }
    // Helper method to extract token from socket connection
    extractTokenFromSocket(client) {
        // const origin = client.handshake.headers.origin;
        // // log origin
        // const allowedOrigins = this.configService.get<string[]>('cors.origins', []);
        // if (!origin || !allowedOrigins.includes(origin)) {
        //     this.logger.warn(`Connection attempt from unauthorized origin: ${origin}`);
        //     return null;
        // }
        // Try to get from handshake auth
        const authHeader = client.handshake.headers.authorization;
        if (authHeader && authHeader.startsWith('Bearer ')) {
            return authHeader.substring(7);
        }
        // Try to get from query parameters
        const { token } = client.handshake.query;
        if (token && typeof token === 'string') {
            return token;
        }
        return null;
    }
    // Room management
    joinRoom(client, room) {
        try {
            client.join(room);
            if (!client.user) {
                throw new websockets_1.WsException('User not authenticated');
            }
            const user = client.user.email || client.user.sub;
            if (!this.userRooms.has(user)) {
                this.userRooms.set(user, new Set());
            }
            const userRoomSet = this.userRooms.get(user);
            userRoomSet.add(room);
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error joining room: ${error.message}`, error.stack);
                throw new websockets_1.WsException(`Failed to join room: ${error.message}`);
            }
            else {
                this.logger.error('Error joining room: Unknown error');
                throw new websockets_1.WsException('Failed to join room: Unknown error');
            }
        }
    }
    leaveRoom(client, room) {
        try {
            client.leave(room);
            if (!client.user) {
                throw new websockets_1.WsException('User not authenticated');
            }
            const user = client.user.email || client.user.sub;
            const rooms = this.userRooms.get(user);
            if (rooms) {
                rooms.delete(room);
            }
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error leaving room: ${error.message}`, error.stack);
                throw new websockets_1.WsException(`Failed to leave room: ${error.message}`);
            }
            else {
                this.logger.error('Error leaving room: Unknown error');
                throw new websockets_1.WsException('Failed to leave room: Unknown error');
            }
        }
    }
    // Messaging Methods
    pingUser(userId) {
        this.emitToUser({ event: 'ping' }, userId);
    }
    pingAll() {
        this.broadcast(this.namespace, { event: 'ping' });
    }
    emitToUser(data, userId) {
        if (!userId || !this.connectedClients.has(userId)) {
            this.logger.warn(`User ${userId} not connected`);
            return;
        }
        const userRoom = `user:${userId}:${this.namespace}`;
        this.emitToRoom(userRoom, this.namespace, data);
    }
    emitToRoom(room, event, data) {
        try {
            this.server.to(room).emit(event, data);
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error emitting to room: ${error.message}`, error.stack);
                throw new websockets_1.WsException(`Failed to emit to room: ${error.message}`);
            }
            else {
                this.logger.error('Error emitting to room: Unknown error');
                throw new websockets_1.WsException('Failed to emit to room: Unknown error');
            }
        }
    }
    broadcast(event, data, exceptUser) {
        try {
            if (exceptUser) {
                // Send to all clients except the one with exceptUserId
                for (const [userId, client] of this.connectedClients.entries()) {
                    if (userId !== exceptUser) {
                        client.emit(event, data);
                    }
                }
            }
            else {
                // Send to all clients
                this.server.emit(event, data);
            }
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error broadcasting: ${error.message}`, error.stack);
                throw new websockets_1.WsException(`Failed to broadcast: ${error.message}`);
            }
            else {
                this.logger.error('Error broadcasting: Unknown error');
                throw new websockets_1.WsException('Failed to broadcast: Unknown error');
            }
        }
    }
    // Rate limiting
    isRateLimited(userId) {
        const currentRate = this.messageRateLimit.get(userId) || 0;
        if (currentRate >= this.MAX_MESSAGES_PER_MINUTE) {
            return true;
        }
        this.messageRateLimit.set(userId, currentRate + 1);
        return false;
    }
    // Heartbeat management
    setupHeartbeat() {
        // Reset rate limits every minute
        this.heartbeatInterval = setInterval(() => {
            this.messageRateLimit.clear();
            // Check for stale connections
            this.checkConnections();
        }, 60000); // 1 minute
    }
    checkConnections() {
        const now = Date.now();
        // Check each connection for activity
        this.connectedClients.forEach((client, user) => {
            if (!client.connected) {
                this.logger.debug(`Removing disconnected client: ${user}`);
                this.connectedClients.delete(user);
                return;
            }
            // Check for timeout (no activity for X minutes)
            const connectedAt = client.handshake.auth.connectedAt || 0;
            if (now - connectedAt > this.CONNECTION_TIMEOUT) {
                this.logger.debug(`Connection timeout for user: ${user}`);
                client.disconnect(true);
                this.connectedClients.delete(user);
            }
        });
    }
    // Event handling setup
    setupEventHandlers() {
        this.server.on('connection', (socket) => {
            // Register all event handlers from the derived class
            if (this.eventHandlers) {
                this.eventHandlers.forEach((handler, event) => {
                    socket.on(event, (payload) => {
                        try {
                            // Validate user is authenticated
                            if (!socket.user || !socket.user.sub) {
                                socket.emit('error', { message: 'Not authenticated' });
                                return;
                            }
                            // Check rate limiting
                            if (this.isRateLimited(socket.user.sub)) {
                                socket.emit('error', { message: 'Rate limit exceeded' });
                                return;
                            }
                            // Execute the handler
                            handler(socket, payload);
                        }
                        catch (error) {
                            if (error instanceof Error) {
                                this.logger.error(`Error handling event ${event}: ${error.message}`, error.stack);
                            }
                            else {
                                this.logger.error(`Error handling event ${event}: Unknown error`);
                            }
                            socket.emit('error', { message: 'Internal server error' });
                        }
                    });
                });
            }
        });
    }
    // Hooks for derived classes
    afterConnect(client) {
        if (client.user) {
            const userRoom = `user:${client.user.sub}:${this.namespace}`;
            this.joinRoom(client, userRoom);
            this.logger.log(`${client.user.email} subscribed to ${this.namespace}`);
        }
    }
    afterDisconnect(client) { }
}
exports.BaseGateway = BaseGateway;
__decorate([
    (0, websockets_1.WebSocketServer)(),
    __metadata("design:type", typeof (_a = typeof socket_io_1.Server !== "undefined" && socket_io_1.Server) === "function" ? _a : Object)
], BaseGateway.prototype, "server", void 0);


/***/ }),
/* 115 */
/***/ ((module) => {

"use strict";
module.exports = require("socket.io");

/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const user_dto_1 = __webpack_require__(117);
const user_entity_1 = __webpack_require__(47);
const users_service_1 = __webpack_require__(30);
class UsersController extends (0, create_controller_factory_1.createController)(user_entity_1.User, users_service_1.UsersService, user_dto_1.GetUserDto, undefined, user_dto_1.UpdateUserDto) {
    create(entityDto, createdById) {
        return super.create(entityDto, createdById);
    }
    async delete(id) {
        return await super.delete(id);
    }
}
exports.UsersController = UsersController;


/***/ }),
/* 117 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetUserDto = exports.UpdateUserDto = exports.UserDto = void 0;
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
const profile_dto_1 = __webpack_require__(118);
class UserDto {
}
exports.UserDto = UserDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The email address of the user',
        example: 'user@example.com'
    }),
    (0, class_validator_1.IsEmail)({}, { message: 'Please provide a valid email address' }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], UserDto.prototype, "email", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User password',
        example: 'StrongP@ssw0rd',
        minLength: 8
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MinLength)(8, { message: 'Password must be at least 8 characters long' }),
    __metadata("design:type", String)
], UserDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique username',
        example: 'john_doe'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MinLength)(3, { message: 'Username must be at least 3 characters long' }),
    __metadata("design:type", String)
], UserDto.prototype, "userName", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'User\'s phone number',
        example: '+1234567890'
    }),
    (0, class_validator_1.IsPhoneNumber)(undefined, { message: 'Please provide a valid phone number' }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], UserDto.prototype, "phoneNumber", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether the email has been verified',
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], UserDto.prototype, "emailVerified", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether the phone number has been verified',
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], UserDto.prototype, "phoneNumberVerified", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Number of failed access attempts',
        default: 0
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], UserDto.prototype, "accessFailedCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether lockout is enabled for this user',
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], UserDto.prototype, "lockoutEnabled", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Whether the user is currently locked out',
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], UserDto.prototype, "lockedOut", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'The timestamp when lockout started',
        example: '2023-01-01T00:00:00Z'
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value ? new Date(value) : undefined),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], UserDto.prototype, "lockOutStart", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'The timestamp when lockout ends',
        example: '2023-01-02T00:00:00Z'
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value ? new Date(value) : undefined),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], UserDto.prototype, "lockOutEnd", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Profile information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => profile_dto_1.ProfileDto),
    __metadata("design:type", typeof (_c = typeof profile_dto_1.ProfileDto !== "undefined" && profile_dto_1.ProfileDto) === "function" ? _c : Object)
], UserDto.prototype, "profile", void 0);
class UpdateUserDto extends (0, swagger_1.PartialType)(UserDto) {
}
exports.UpdateUserDto = UpdateUserDto;
class GetUserDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateUserDto, 'user') {
}
exports.GetUserDto = GetUserDto;


/***/ }),
/* 118 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetProfileDto = exports.UpdateProfileDto = exports.ProfileDto = void 0;
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
const address_dto_1 = __webpack_require__(119);
class ProfileDto {
}
exports.ProfileDto = ProfileDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User ID associated with the profile' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'First name of the profile', example: 'John' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Middle name of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "middleName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Last name of the profile' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Full name of the profile', example: 'John Doe' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "fullName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Suffix (Jr., Sr., etc.)', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "suffix", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Gender of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "gender", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Sex of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "sex", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Profile picture URL', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "profilePicture", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Birth date of the profile', required: false, type: Date, example: '1990-01-01' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], ProfileDto.prototype, "birthDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Civil status of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "civilStatus", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Citizenship of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "citizenship", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Nationality of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "nationality", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Religion of the profile', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfileDto.prototype, "religion", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Address information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => address_dto_1.AddressDto),
    __metadata("design:type", typeof (_b = typeof address_dto_1.AddressDto !== "undefined" && address_dto_1.AddressDto) === "function" ? _b : Object)
], ProfileDto.prototype, "address", void 0);
class UpdateProfileDto extends (0, swagger_1.PartialType)(ProfileDto) {
}
exports.UpdateProfileDto = UpdateProfileDto;
class GetProfileDto extends (0, create_get_dto_factory_1.createGetDto)(ProfileDto) {
}
exports.GetProfileDto = GetProfileDto;


/***/ }),
/* 119 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAddressDto = exports.UpdateAddressDto = exports.AddressDto = void 0;
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class AddressDto {
}
exports.AddressDto = AddressDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Street name, building and house number',
        example: '123 Main St, Building A'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(255),
    __metadata("design:type", String)
], AddressDto.prototype, "streetNameBuildingHouseNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Barangay name',
        example: 'Barangay 123'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], AddressDto.prototype, "barangay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'City or municipality name',
        example: 'Manila'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], AddressDto.prototype, "cityOrMunicipality", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Province name',
        example: 'Metro Manila'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], AddressDto.prototype, "province", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Region name',
        example: 'NCR'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], AddressDto.prototype, "region", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Postal code',
        example: 1000,
        type: Number
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], AddressDto.prototype, "postalCode", void 0);
class UpdateAddressDto extends (0, swagger_1.PartialType)(AddressDto) {
}
exports.UpdateAddressDto = UpdateAddressDto;
class GetAddressDto extends (0, create_get_dto_factory_1.createGetDto)(AddressDto) {
}
exports.GetAddressDto = GetAddressDto;


/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RolesController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const role_dto_1 = __webpack_require__(121);
const role_entity_1 = __webpack_require__(37);
const roles_service_1 = __webpack_require__(91);
class RolesController extends (0, create_controller_factory_1.createController)(role_entity_1.Role, roles_service_1.RolesService, role_dto_1.GetRoleDto, role_dto_1.RoleDto, role_dto_1.UpdateRoleDto) {
}
exports.RolesController = RolesController;


/***/ }),
/* 121 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetRoleDto = exports.UpdateRoleDto = exports.RoleDto = void 0;
const base_dto_1 = __webpack_require__(101);
const reference_dto_1 = __webpack_require__(102);
const role_scope_type_enum_1 = __webpack_require__(38);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class RoleDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
    constructor() {
        super(...arguments);
        this.scope = role_scope_type_enum_1.RoleScopeType.OWNED;
    }
}
exports.RoleDto = RoleDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The name of the role',
        example: 'admin',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(100),
    (0, class_validator_1.MinLength)(3),
    __metadata("design:type", String)
], RoleDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Description of the role',
        example: 'Administrator with full access',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.MaxLength)(500),
    (0, class_validator_1.MinLength)(3),
    __metadata("design:type", String)
], RoleDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'The scope of the role',
        enum: role_scope_type_enum_1.RoleScopeType,
        default: role_scope_type_enum_1.RoleScopeType.OWNED,
    }),
    (0, class_validator_1.IsEnum)(role_scope_type_enum_1.RoleScopeType),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof role_scope_type_enum_1.RoleScopeType !== "undefined" && role_scope_type_enum_1.RoleScopeType) === "function" ? _a : Object)
], RoleDto.prototype, "scope", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'List of permissions assigned to this role',
        type: [reference_dto_1.ReferenceDto],
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], RoleDto.prototype, "permissions", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Employees associated with this role',
        type: [reference_dto_1.ReferenceDto]
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], RoleDto.prototype, "employees", void 0);
class UpdateRoleDto extends (0, swagger_1.PartialType)(RoleDto) {
}
exports.UpdateRoleDto = UpdateRoleDto;
class GetRoleDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateRoleDto, 'role') {
}
exports.GetRoleDto = GetRoleDto;


/***/ }),
/* 122 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const permission_dto_1 = __webpack_require__(123);
const permission_entity_1 = __webpack_require__(39);
const permissions_service_1 = __webpack_require__(90);
class PermissionsController extends (0, create_controller_factory_1.createController)(permission_entity_1.Permission, permissions_service_1.PermissionsService, permission_dto_1.GetPermissionDto) {
    async findOne(id, relations, select) {
        return await super.findOne(id, relations, select);
    }
    async delete(id) {
        return await super.delete(id);
    }
    async deleteMany(ids, hardDelete) {
        return await super.deleteMany(ids, hardDelete);
    }
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async update(id, entityDto, updatedById) {
        return await super.update(id, entityDto, updatedById);
    }
}
exports.PermissionsController = PermissionsController;


/***/ }),
/* 123 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPermissionDto = exports.UpdatePermissionDto = exports.PermissionDto = void 0;
const action_enum_1 = __webpack_require__(40);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
class PermissionDto {
}
exports.PermissionDto = PermissionDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission name', required: false }),
    __metadata("design:type", String)
], PermissionDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission description', required: false }),
    __metadata("design:type", String)
], PermissionDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The action this permission grants',
        enum: action_enum_1.Action,
        enumName: 'Action'
    }),
    __metadata("design:type", typeof (_a = typeof action_enum_1.Action !== "undefined" && action_enum_1.Action) === "function" ? _a : Object)
], PermissionDto.prototype, "action", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'The subject this permission applies to' }),
    __metadata("design:type", String)
], PermissionDto.prototype, "subject", void 0);
class UpdatePermissionDto extends (0, swagger_1.PartialType)(PermissionDto) {
}
exports.UpdatePermissionDto = UpdatePermissionDto;
class GetPermissionDto extends (0, create_get_dto_factory_1.createGetDto)(UpdatePermissionDto, 'permission') {
}
exports.GetPermissionDto = GetPermissionDto;


/***/ }),
/* 124 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PermissionSeederService_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionSeederService = void 0;
const action_enum_1 = __webpack_require__(40);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const fs = __importStar(__webpack_require__(125));
const glob_1 = __webpack_require__(126);
const path = __importStar(__webpack_require__(127));
const typeorm_2 = __webpack_require__(25);
const permission_entity_1 = __webpack_require__(39);
let PermissionSeederService = PermissionSeederService_1 = class PermissionSeederService {
    constructor(permissionRepository) {
        this.permissionRepository = permissionRepository;
        this.logger = new common_1.Logger(PermissionSeederService_1.name);
    }
    // Automatically run on module initialization
    async onModuleInit() {
        if (process.env.NODE_ENV !== 'test') {
            try {
                await this.seedPermissions();
            }
            catch (error) {
                this.logger.error(`Failed to seed permissions: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    async seedPermissions() {
        // this.logger.log('🔍 Scanning controllers for permissions...');
        // Get permissions from controllers created with createController factory
        const factoryControllerPerms = await this.scanFactoryControllers();
        // this.logger.log(`Found ${factoryControllerPerms.length} permissions from factory controllers`);
        // // Get permissions from regular BaseController extensions
        // const baseControllerPerms = await this.scanBaseControllerExtensions();
        // this.logger.log(`Found ${baseControllerPerms.length} permissions from BaseController extensions`);
        // // Get permissions from code patterns
        // const codePatternPerms = await this.scanForPermissions();
        // this.logger.log(`Found ${codePatternPerms.length} permissions from code patterns`);
        // Combine all permissions
        const allPermissions = [...factoryControllerPerms];
        const uniquePermissions = this.removeDuplicates(allPermissions);
        // this.logger.log(`Total unique permissions found: ${uniquePermissions.length}`);
        let created = 0;
        let updated = 0;
        try {
            for (const permDef of uniquePermissions) {
                const result = await this.createOrUpdatePermission(permDef);
                if (result.isNew)
                    created++;
                else
                    updated++;
            }
            // this.logger.log(`Permission seeding completed: ${created} created, ${updated} updated`);
        }
        catch (error) {
            this.logger.error(`Error creating permissions: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }
    /**
     * NEW METHOD: Scan for controllers created with createController factory
     */
    async scanFactoryControllers() {
        const permissions = [];
        const controllers = await this.findControllerFiles();
        // Updated pattern to match controllers that extend from createController() without generic types
        const factoryControllerPattern = /export\s+class\s+(\w+)\s+extends\s+createController\s*\(\s*([\w.]+)\s*,\s*([\w.]+)\s*,\s*([\w.]+)(?:\s*,\s*([\w.]+))?(?:\s*,\s*([\w.]+))?\s*\)/;
        // this.logger.debug(`Scanning ${controllers.length} controller files for factory controllers`);
        for (const file of controllers) {
            try {
                const fileContent = fs.readFileSync(file, 'utf8');
                const factoryMatch = fileContent.match(factoryControllerPattern);
                if (factoryMatch) {
                    const controllerName = factoryMatch[1];
                    const entityClass = factoryMatch[2];
                    const serviceClass = factoryMatch[3];
                    const getDtoClass = factoryMatch[4];
                    const createDtoClass = factoryMatch[5];
                    const updateDtoClass = factoryMatch[6];
                    // Get entity name from class reference
                    // First try to extract from entity class (removing "Entity" suffix if present)
                    let entityName = entityClass.replace(/Entity$/, '');
                    // If entityName contains dots (like module.Entity), get the last part
                    if (entityName.includes('.')) {
                        entityName = entityName.split('.').pop() || entityName;
                    }
                    // this.logger.debug(`Found factory controller: ${controllerName} for entity ${entityName}`);
                    // Always generate MANAGE permission
                    permissions.push(this.createPermissionDefinition(action_enum_1.Action.MANAGE, entityName));
                    // Check for GetDto (Read permission)
                    if (getDtoClass && getDtoClass.trim() !== 'null' && getDtoClass.trim() !== 'undefined') {
                        permissions.push(this.createPermissionDefinition(action_enum_1.Action.READ, entityName));
                    }
                    // Check for CreateDto (Create permission)
                    if (createDtoClass && createDtoClass.trim() !== 'null' && createDtoClass.trim() !== 'undefined') {
                        permissions.push(this.createPermissionDefinition(action_enum_1.Action.CREATE, entityName));
                    }
                    // Check for UpdateDto (Update permission)
                    if (updateDtoClass && updateDtoClass.trim() !== 'null' && updateDtoClass.trim() !== 'undefined') {
                        permissions.push(this.createPermissionDefinition(action_enum_1.Action.UPDATE, entityName));
                    }
                    // Add DELETE permission by default too (since most controllers likely support it)
                    permissions.push(this.createPermissionDefinition(action_enum_1.Action.DELETE, entityName));
                }
            }
            catch (error) {
                this.logger.warn(`Error processing file ${file}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
        return permissions;
    }
    /**
     * Helper to create a permission definition object
     */
    createPermissionDefinition(action, subject) {
        const actionName = this.capitalizeFirstLetter(action);
        return {
            action,
            subject,
            name: `${actionName} ${subject}`,
            description: `Permission to ${action.toLowerCase()} ${subject}`
        };
    }
    /**
     * Scan for controllers extending BaseController directly
     */
    async scanBaseControllerExtensions() {
        const permissions = [];
        const controllers = await this.findControllerFiles();
        const baseControllerPattern = /extends\s+(?:[\w.]+\.)?BaseController\s*<\s*\w+\s*,\s*\w+(?:\s*,\s*\w+)*\s*>/;
        const entityPattern = /(?:super\s*\(\s*[\w\s.,]+,\s*[\w\s.,]+,\s*['"](\w+)['"]|protected\s+readonly\s+entityName\s*[:=]\s*['"](\w+)['"])/;
        // Get all actions from the enum
        const allActions = Object.values(action_enum_1.Action);
        // this.logger.debug(`Scanning ${controllers.length} controller files for BaseController extensions`);
        for (const file of controllers) {
            try {
                const fileContent = fs.readFileSync(file, 'utf8');
                // Skip files that use createController (we handle those separately)
                if (fileContent.includes('extends createController')) {
                    continue;
                }
                // Check if this extends BaseController directly
                if (baseControllerPattern.test(fileContent)) {
                    this.logger.debug(`Found BaseController extension in ${path.basename(file)}`);
                    // Extract entity name
                    const entityMatch = fileContent.match(entityPattern);
                    let entityName = null;
                    if (entityMatch) {
                        // Get the first capturing group that has a value
                        entityName = entityMatch[1] || entityMatch[2];
                        this.logger.debug(`Found entity name: ${entityName} in ${path.basename(file)}`);
                        // If entity name was found, create permissions for all actions
                        if (entityName) {
                            for (const action of allActions) {
                                permissions.push(this.createPermissionDefinition(action, entityName));
                            }
                        }
                    }
                    else {
                        // Try to infer entity name from controller name
                        const controllerName = path.basename(file, '.controller.ts');
                        if (controllerName) {
                            const inferredEntityName = this.singularize(controllerName);
                            this.logger.debug(`Inferred entity name from controller: ${inferredEntityName}`);
                            for (const action of allActions) {
                                permissions.push(this.createPermissionDefinition(action, inferredEntityName));
                            }
                        }
                    }
                }
            }
            catch (error) {
                this.logger.warn(`Error processing file ${file}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
        return permissions;
    }
    /**
     * Capitalize first letter of a string
     */
    capitalizeFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
    }
    /**
     * Simple singularization for English words
     */
    singularize(word) {
        if (word.endsWith('ies')) {
            return word.slice(0, -3) + 'y';
        }
        else if (word.endsWith('s') && !word.endsWith('ss')) {
            return word.slice(0, -1);
        }
        return word;
    }
    async createOrUpdatePermission(permDef) {
        // Check if permission already exists
        let permission = await this.permissionRepository.findOne({
            where: {
                action: permDef.action,
                subject: permDef.subject
            }
        });
        let isNew = false;
        if (!permission) {
            permission = this.permissionRepository.create({
                action: permDef.action,
                subject: permDef.subject,
                name: permDef.name,
                description: permDef.description
            });
            isNew = true;
        }
        else {
            // Update existing permission with any new metadata
            permission.name = permDef.name || permission.name;
            permission.description = permDef.description || permission.description;
        }
        await this.permissionRepository.save(permission);
        return { permission, isNew };
    }
    // Keep your existing scan methods
    async scanForPermissions() {
        // Existing code...
        return [];
    }
    extractNamedPermissions(fileContent, permissions) {
        // Existing code...
    }
    extractAuthorizationRules(fileContent, permissions) {
        // Existing code...
    }
    async findControllerFiles() {
        try {
            return await (0, glob_1.glob)('src/**/*.controller.ts', { ignore: 'node_modules/**' });
        }
        catch (err) {
            throw err;
        }
    }
    mapActionNameToEnum(actionName) {
        const map = {
            'Create': action_enum_1.Action.CREATE,
            'Read': action_enum_1.Action.READ,
            'Update': action_enum_1.Action.UPDATE,
            'Delete': action_enum_1.Action.DELETE,
            'Manage': action_enum_1.Action.MANAGE
        };
        return map[actionName] || action_enum_1.Action.READ;
    }
    removeDuplicates(permissions) {
        const uniqueSet = new Map();
        for (const perm of permissions) {
            const key = `${perm.action}:${perm.subject}`;
            uniqueSet.set(key, perm);
        }
        return Array.from(uniqueSet.values());
    }
};
exports.PermissionSeederService = PermissionSeederService;
exports.PermissionSeederService = PermissionSeederService = PermissionSeederService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(permission_entity_1.Permission)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], PermissionSeederService);


/***/ }),
/* 125 */
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),
/* 126 */
/***/ ((module) => {

"use strict";
module.exports = require("glob");

/***/ }),
/* 127 */
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),
/* 128 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CutoffsModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const cutoffs_controller_1 = __webpack_require__(129);
const cutoffs_service_1 = __webpack_require__(130);
const cutoff_entity_1 = __webpack_require__(55);
let CutoffsModule = class CutoffsModule {
};
exports.CutoffsModule = CutoffsModule;
exports.CutoffsModule = CutoffsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([cutoff_entity_1.Cutoff]),
        ],
        providers: [cutoffs_service_1.CutoffsService],
        exports: [cutoffs_service_1.CutoffsService],
        controllers: [cutoffs_controller_1.CutoffsController],
    })
], CutoffsModule);


/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CutoffsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const cutoffs_service_1 = __webpack_require__(130);
const cutoff_dto_1 = __webpack_require__(132);
const cutoff_entity_1 = __webpack_require__(55);
class CutoffsController extends (0, create_controller_factory_1.createController)(cutoff_entity_1.Cutoff, cutoffs_service_1.CutoffsService, cutoff_dto_1.GetCutoffDto, cutoff_dto_1.CutoffDto, cutoff_dto_1.UpdateCutoffDto) {
}
exports.CutoffsController = CutoffsController;


/***/ }),
/* 130 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CutoffsService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CutoffsService = void 0;
const cutoff_status_enum_1 = __webpack_require__(56);
const cutoff_type_enum_1 = __webpack_require__(57);
const utility_helper_1 = __webpack_require__(87);
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const schedule_1 = __webpack_require__(131);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const cutoff_entity_1 = __webpack_require__(55);
let CutoffsService = CutoffsService_1 = class CutoffsService extends base_service_1.BaseService {
    constructor(cutoffsRepository, usersService) {
        super(cutoffsRepository, usersService);
        this.cutoffsRepository = cutoffsRepository;
        this.usersService = usersService;
        this.logger = new common_1.Logger(CutoffsService_1.name);
    }
    /**
     * Initialize cutoffs when application starts
     */
    async onModuleInit() {
        this.logger.log('Checking if cutoffs exist on application startup');
        try {
            const cutoffsCount = await this.cutoffsRepository.count();
            if (cutoffsCount === 0) {
                this.logger.log('No cutoffs found. Generating yearly cutoffs for current year.');
                const currentYear = new Date().getFullYear();
                await this.generateYearlyCutoffs({
                    year: currentYear,
                    startMonth: 0, // January
                    cutoffType: cutoff_type_enum_1.CutoffType.BI_WEEKLY,
                    save: true
                });
                this.logger.log('Initial yearly cutoffs generated successfully');
            }
            else {
                this.logger.log(`Found ${cutoffsCount} existing cutoffs. Skipping initial generation.`);
            }
            // Also update statuses of existing cutoffs on startup
            await this.updateCutoffStatuses();
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error initializing cutoffs: ${error.message}`, error.stack);
            }
            else {
                this.logger.error(`Error initializing cutoffs: ${String(error)}`);
            }
        }
    }
    async generateYearlyCutoffs(options = {}) {
        const { year = new Date().getFullYear(), startMonth = new Date().getMonth(), cutoffType = cutoff_type_enum_1.CutoffType.BI_WEEKLY, save = true } = options;
        const cutoffs = [];
        // Generate cutoffs for each month from startMonth to December
        for (let month = startMonth; month < 12; month++) {
            const periodCutoffs = this.generateCutoffsForMonth(year, month, cutoffType);
            cutoffs.push(...periodCutoffs);
        }
        // Save to database if requested
        if (save && cutoffs.length > 0) {
            await this.cutoffsRepository.save(cutoffs);
        }
        return cutoffs;
    }
    generateCutoffsForMonth(year, month, cutoffType) {
        const cutoffs = [];
        const monthName = new Date(year, month, 1).toLocaleString('default', { month: 'long' });
        switch (cutoffType) {
            case cutoff_type_enum_1.CutoffType.BI_WEEKLY: {
                // For bi-weekly: 1-15 and 16-end of month
                const firstHalfStart = new Date(year, month, 1);
                const firstHalfEnd = new Date(year, month, 15);
                const secondHalfStart = new Date(year, month, 16);
                const secondHalfEnd = new Date(year, month + 1, 0);
                // Calculate business days
                const firstHalfBusinessDays = utility_helper_1.UtilityHelper.getBusinessDays(firstHalfStart, firstHalfEnd);
                const secondHalfBusinessDays = utility_helper_1.UtilityHelper.getBusinessDays(secondHalfStart, secondHalfEnd);
                // Create the cutoff entities
                const firstHalf = new cutoff_entity_1.Cutoff({});
                firstHalf.startDate = firstHalfStart;
                firstHalf.endDate = firstHalfEnd;
                firstHalf.status = cutoff_status_enum_1.CutoffStatus.ACTIVE;
                firstHalf.cutoffType = cutoffType;
                firstHalf.description = `${monthName} 1-15, ${year} (${firstHalfBusinessDays} business days)`;
                const secondHalf = new cutoff_entity_1.Cutoff({});
                secondHalf.startDate = secondHalfStart;
                secondHalf.endDate = secondHalfEnd;
                secondHalf.status = cutoff_status_enum_1.CutoffStatus.ACTIVE;
                secondHalf.cutoffType = cutoffType;
                secondHalf.description = `${monthName} 16-${secondHalfEnd.getDate()}, ${year} (${secondHalfBusinessDays} business days)`;
                cutoffs.push(firstHalf, secondHalf);
                break;
            }
            // Add other cutoff types if needed (WEEKLY, MONTHLY, etc.)
            default:
                break;
        }
        return cutoffs;
    }
    async getActiveCutoffs() {
        return await this.repository.find({
            where: {
                status: cutoff_status_enum_1.CutoffStatus.ACTIVE,
                startDate: (0, typeorm_2.MoreThan)(new Date()),
                isDeleted: false
            },
            order: { startDate: 'ASC' }
        });
    }
    async getActiveCutoff() {
        return await this.repository.findOne({
            where: {
                status: cutoff_status_enum_1.CutoffStatus.ACTIVE,
                startDate: (0, typeorm_2.MoreThan)(new Date()),
                isDeleted: false
            },
            order: { startDate: 'ASC' }
        });
    }
    /**
     * Updates cutoff statuses based on current date
     * - Active cutoffs with startDate <= today => PENDING
     * - Pending cutoffs with endDate < today => COMPLETED
     */
    async updateCutoffStatuses() {
        this.logger.log('Updating cutoff statuses based on current date');
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);
        yesterday.setHours(0, 0, 0, 0);
        let updated = 0;
        let errors = 0;
        try {
            // Find active cutoffs that have started
            const activeCutoffs = await this.cutoffsRepository.find({
                where: {
                    status: cutoff_status_enum_1.CutoffStatus.ACTIVE,
                    startDate: (0, typeorm_2.LessThanOrEqual)(today)
                }
            });
            if (activeCutoffs.length > 0) {
                this.logger.log(`Found ${activeCutoffs.length} active cutoffs to mark as PENDING`);
                const result = await this.cutoffsRepository.update({ id: (0, typeorm_2.In)(activeCutoffs.map(c => c.id)) }, { status: cutoff_status_enum_1.CutoffStatus.PENDING });
                updated += result.affected || 0;
            }
            // Find pending cutoffs that have ended
            const pendingCutoffs = await this.cutoffsRepository.find({
                where: {
                    status: cutoff_status_enum_1.CutoffStatus.PENDING,
                    endDate: (0, typeorm_2.LessThanOrEqual)(yesterday)
                }
            });
            if (pendingCutoffs.length > 0) {
                this.logger.log(`Found ${pendingCutoffs.length} pending cutoffs to mark as COMPLETED`);
                const result = await this.cutoffsRepository.update({ id: (0, typeorm_2.In)(pendingCutoffs.map(c => c.id)) }, { status: cutoff_status_enum_1.CutoffStatus.COMPLETED });
                updated += result.affected || 0;
            }
            return { updated, errors };
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error updating cutoff statuses: ${error.message}`, error.stack);
            }
            else {
                this.logger.error(`Error updating cutoff statuses: ${String(error)}`);
            }
            errors++;
            return { updated, errors };
        }
    }
    /**
     * Get the current active or pending cutoff
     */
    async getCurrentCutoff() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        // First try to find a PENDING cutoff that includes today
        const pendingCutoff = await this.cutoffsRepository.findOne({
            where: {
                status: cutoff_status_enum_1.CutoffStatus.PENDING,
                startDate: (0, typeorm_2.LessThanOrEqual)(today),
                endDate: (0, typeorm_2.MoreThanOrEqual)(today)
            }
        });
        if (pendingCutoff) {
            return pendingCutoff;
        }
        // If no pending cutoff, try to find the next ACTIVE cutoff
        return this.cutoffsRepository.findOne({
            where: {
                status: cutoff_status_enum_1.CutoffStatus.ACTIVE
            },
            order: {
                startDate: 'ASC'
            }
        });
    }
    /**
     * Scheduled job to automatically update cutoff statuses daily
     */
    async scheduledCutoffStatusUpdate() {
        this.logger.log('Running scheduled cutoff status update');
        const result = await this.updateCutoffStatuses();
        this.logger.log(`Scheduled update complete. Updated: ${result.updated}, Errors: ${result.errors}`);
    }
    /**
     * Scheduled job to generate cutoffs for the next year
     * Runs on January 1st at 1:00 AM
     */
    async generateNextYearCutoffs() {
        const nextYear = new Date().getFullYear() + 1;
        this.logger.log(`Running scheduled yearly cutoff generation for year ${nextYear}`);
        try {
            // Check if cutoffs already exist for the next year
            const existingCutoffs = await this.cutoffsRepository.count({
                where: {
                    startDate: (0, typeorm_2.MoreThanOrEqual)(new Date(`${nextYear}-01-01`)),
                }
            });
            if (existingCutoffs > 0) {
                this.logger.log(`Cutoffs for year ${nextYear} already exist. Skipping generation.`);
                return;
            }
            // Generate cutoffs for the next year
            await this.generateYearlyCutoffs({
                year: nextYear,
                startMonth: 0,
                cutoffType: cutoff_type_enum_1.CutoffType.BI_WEEKLY,
                save: true
            });
            this.logger.log(`Successfully generated ${nextYear} cutoffs`);
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error generating next year cutoffs: ${error.message}`, error.stack);
            }
            else {
                this.logger.error(`Error generating next year cutoffs: ${String(error)}`);
            }
        }
    }
};
exports.CutoffsService = CutoffsService;
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_DAY_AT_MIDNIGHT),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CutoffsService.prototype, "scheduledCutoffStatusUpdate", null);
__decorate([
    (0, schedule_1.Cron)('0 1 1 1 *'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CutoffsService.prototype, "generateNextYearCutoffs", null);
exports.CutoffsService = CutoffsService = CutoffsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(cutoff_entity_1.Cutoff)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], CutoffsService);


/***/ }),
/* 131 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/schedule");

/***/ }),
/* 132 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetCutoffDto = exports.UpdateCutoffDto = exports.CutoffDto = void 0;
const base_dto_1 = __webpack_require__(101);
const cutoff_status_enum_1 = __webpack_require__(56);
const cutoff_type_enum_1 = __webpack_require__(57);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class CutoffDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.CutoffDto = CutoffDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of the cutoff period',
        example: 'First half of January 2023',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CutoffDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Start date of the cutoff period',
        example: '2023-01-01',
        type: Date
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], CutoffDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'End date of the cutoff period',
        example: '2023-01-15',
        type: Date
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], CutoffDto.prototype, "endDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Status of the cutoff period',
        enum: cutoff_status_enum_1.CutoffStatus,
        example: cutoff_status_enum_1.CutoffStatus.ACTIVE,
        default: cutoff_status_enum_1.CutoffStatus.ACTIVE,
        required: true
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(cutoff_status_enum_1.CutoffStatus),
    __metadata("design:type", typeof (_c = typeof cutoff_status_enum_1.CutoffStatus !== "undefined" && cutoff_status_enum_1.CutoffStatus) === "function" ? _c : Object)
], CutoffDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of the cutoff period',
        enum: cutoff_type_enum_1.CutoffType,
        example: cutoff_type_enum_1.CutoffType.BI_WEEKLY,
        default: cutoff_type_enum_1.CutoffType.BI_WEEKLY,
        required: true
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(cutoff_type_enum_1.CutoffType),
    __metadata("design:type", typeof (_d = typeof cutoff_type_enum_1.CutoffType !== "undefined" && cutoff_type_enum_1.CutoffType) === "function" ? _d : Object)
], CutoffDto.prototype, "cutoffType", void 0);
class UpdateCutoffDto extends (0, swagger_1.PartialType)(CutoffDto) {
}
exports.UpdateCutoffDto = UpdateCutoffDto;
class GetCutoffDto extends (0, create_get_dto_factory_1.createGetDto)(CutoffDto, 'cutoff') {
}
exports.GetCutoffDto = GetCutoffDto;


/***/ }),
/* 133 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShiftManagementModule = void 0;
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const typeorm_1 = __webpack_require__(16);
const cutoffs_module_1 = __webpack_require__(128);
const shift_day_entity_1 = __webpack_require__(61);
const shift_entity_1 = __webpack_require__(59);
const groups_module_1 = __webpack_require__(134);
const holidays_module_1 = __webpack_require__(140);
const schedule_change_requests_module_1 = __webpack_require__(142);
const schedule_change_responses_module_1 = __webpack_require__(146);
const schedules_module_1 = __webpack_require__(141);
const default_shift_seeder_service_1 = __webpack_require__(161);
const shifts_controller_1 = __webpack_require__(163);
const shifts_service_1 = __webpack_require__(162);
let ShiftManagementModule = class ShiftManagementModule {
};
exports.ShiftManagementModule = ShiftManagementModule;
exports.ShiftManagementModule = ShiftManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([shift_entity_1.Shift, shift_day_entity_1.ShiftDay]),
            core_1.RouterModule.register([
                {
                    path: 'shifts',
                    module: ShiftManagementModule,
                    children: [
                        {
                            path: 'schedules',
                            module: schedules_module_1.SchedulesModule,
                            children: [
                                {
                                    path: 'requests',
                                    module: schedule_change_requests_module_1.ScheduleChangeRequestsModule,
                                    children: [
                                        {
                                            path: 'responses',
                                            module: schedule_change_responses_module_1.ScheduleChangeResponsesModule,
                                        }
                                    ]
                                },
                            ]
                        },
                        {
                            path: 'groups',
                            module: groups_module_1.GroupsModule
                        },
                    ]
                },
                {
                    path: 'holiday',
                    module: holidays_module_1.HolidaysModule,
                }
            ]),
            holidays_module_1.HolidaysModule,
            schedules_module_1.SchedulesModule,
            groups_module_1.GroupsModule,
            cutoffs_module_1.CutoffsModule,
        ],
        providers: [shifts_service_1.ShiftsService, default_shift_seeder_service_1.DefaultShiftsSeeder],
        exports: [
            shifts_service_1.ShiftsService,
            holidays_module_1.HolidaysModule,
            schedules_module_1.SchedulesModule,
            groups_module_1.GroupsModule,
        ],
        controllers: [shifts_controller_1.ShiftsController],
    })
], ShiftManagementModule);


/***/ }),
/* 134 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupsModule = void 0;
const employee_management_module_1 = __webpack_require__(15);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const group_entity_1 = __webpack_require__(60);
const groups_controller_1 = __webpack_require__(135);
const groups_service_1 = __webpack_require__(137);
let GroupsModule = class GroupsModule {
};
exports.GroupsModule = GroupsModule;
exports.GroupsModule = GroupsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([group_entity_1.Group]),
            employee_management_module_1.EmployeeManagementModule,
        ],
        providers: [groups_service_1.GroupsService],
        exports: [groups_service_1.GroupsService],
        controllers: [groups_controller_1.GroupsController],
    })
], GroupsModule);


/***/ }),
/* 135 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const group_dto_1 = __webpack_require__(136);
const group_entity_1 = __webpack_require__(60);
const groups_service_1 = __webpack_require__(137);
class GroupsController extends (0, create_controller_factory_1.createController)(group_entity_1.Group, groups_service_1.GroupsService, group_dto_1.GetGroupDto, group_dto_1.GroupDto, group_dto_1.UpdateGroupDto) {
}
exports.GroupsController = GroupsController;


/***/ }),
/* 136 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetGroupDto = exports.UpdateGroupDto = exports.GroupDto = void 0;
const base_dto_1 = __webpack_require__(101);
const reference_dto_1 = __webpack_require__(102);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class GroupDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.GroupDto = GroupDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the group',
        example: 'Morning Shift Team'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GroupDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of the group',
        example: 'Team responsible for morning operations',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GroupDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Shift assigned to this group',
        type: reference_dto_1.ReferenceDto,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", typeof (_a = typeof reference_dto_1.ReferenceDto !== "undefined" && reference_dto_1.ReferenceDto) === "function" ? _a : Object)
], GroupDto.prototype, "shift", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Employees assigned to this group',
        type: [reference_dto_1.ReferenceDto]
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], GroupDto.prototype, "employees", void 0);
class UpdateGroupDto extends (0, swagger_1.PartialType)(GroupDto) {
}
exports.UpdateGroupDto = UpdateGroupDto;
class GetGroupDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateGroupDto, "group") {
}
exports.GetGroupDto = GetGroupDto;


/***/ }),
/* 137 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var GroupsService_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupsService = void 0;
const employee_assigned_event_1 = __webpack_require__(138);
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const employees_service_1 = __webpack_require__(104);
const common_1 = __webpack_require__(5);
const event_emitter_1 = __webpack_require__(139);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const group_entity_1 = __webpack_require__(60);
let GroupsService = GroupsService_1 = class GroupsService extends base_service_1.BaseService {
    constructor(groupsRepository, usersService, employeesService, eventEmitter) {
        super(groupsRepository, usersService);
        this.groupsRepository = groupsRepository;
        this.usersService = usersService;
        this.employeesService = employeesService;
        this.eventEmitter = eventEmitter;
        this.logger = new common_1.Logger(GroupsService_1.name);
    }
    async create(createDto, createdBy) {
        // Extract employee references before creating the group
        const employeeRefs = createDto.employees;
        const employeeRefsIds = employeeRefs ? employeeRefs.map(ref => ref.id).filter((id) => id !== undefined) : [];
        const employees = await this.employeesService.getEmployeesByIds(employeeRefsIds);
        // Create the group first (without employees)
        const group = await super.create(createDto, createdBy);
        // Emit event for employee assignment to group
        this.eventEmitter.emit(employee_assigned_event_1.GROUP_EVENTS.EMPLOYEE_ASSIGNED, new employee_assigned_event_1.EmployeeAssignedEvent(group, employees, createdBy));
        return group;
    }
    async update(id, updateDto, updatedBy) {
        // Extract employee references before updating the group
        const employeeRefs = updateDto.employees;
        const employeeRefsIds = employeeRefs ? employeeRefs.map(ref => ref.id).filter((id) => id !== undefined) : [];
        await this.employeesService.getEmployeesByIds(employeeRefsIds);
        const currentEmployees = await this.employeesService.getRepository().findBy({
            group: { id }
        });
        const currentEmployeeIds = currentEmployees ? currentEmployees.map(emp => emp.id).filter((id) => id !== undefined) : [];
        // Update the group first (without employees)
        const group = await super.update(id, updateDto, updatedBy);
        const employeesToRemove = currentEmployeeIds.filter(id => !employeeRefsIds.includes(id));
        const employeesToAdd = employeeRefsIds.filter(id => !currentEmployeeIds.includes(id));
        // Remove employees from the group
        if (employeesToRemove.length > 0) {
            const removedEmployees = await this.employeesService.getRepository().findBy({
                id: (0, typeorm_2.In)(employeesToRemove)
            });
            this.eventEmitter.emit(employee_assigned_event_1.GROUP_EVENTS.EMPLOYEE_REMOVED, new employee_assigned_event_1.EmployeeAssignedEvent(group, removedEmployees, updatedBy));
        }
        // Add new employees to the group
        if (employeesToAdd.length > 0) {
            const employees = await this.employeesService.getRepository().findBy({
                id: (0, typeorm_2.In)(employeesToAdd)
            });
            this.eventEmitter.emit(employee_assigned_event_1.GROUP_EVENTS.EMPLOYEE_ASSIGNED, new employee_assigned_event_1.EmployeeAssignedEvent(group, employees, updatedBy));
        }
        return group;
    }
};
exports.GroupsService = GroupsService;
exports.GroupsService = GroupsService = GroupsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(group_entity_1.Group)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _c : Object, typeof (_d = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _d : Object])
], GroupsService);


/***/ }),
/* 138 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeeAssignedEvent = exports.SCHEDULE_EVENTS = exports.GROUP_EVENTS = void 0;
exports.GROUP_EVENTS = {
    EMPLOYEE_ASSIGNED: 'employee.assigned.to.group',
    EMPLOYEE_REMOVED: 'employee.removed.from.group',
};
exports.SCHEDULE_EVENTS = {
    GENERATION_REQUESTED: 'schedule.generation.requested',
    GENERATION_COMPLETED: 'schedule.generation.completed',
    GENERATION_FAILED: 'schedule.generation.failed',
};
class EmployeeAssignedEvent {
    constructor(group, employees, assignedBy) {
        this.group = group;
        this.employees = employees;
        this.assignedBy = assignedBy;
    }
}
exports.EmployeeAssignedEvent = EmployeeAssignedEvent;


/***/ }),
/* 139 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/event-emitter");

/***/ }),
/* 140 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HolidaysModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const schedules_module_1 = __webpack_require__(141);
const holiday_entity_1 = __webpack_require__(68);
const holidays_controller_1 = __webpack_require__(159);
const holidays_service_1 = __webpack_require__(156);
let HolidaysModule = class HolidaysModule {
};
exports.HolidaysModule = HolidaysModule;
exports.HolidaysModule = HolidaysModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([holiday_entity_1.Holiday]),
            (0, common_1.forwardRef)(() => schedules_module_1.SchedulesModule),
        ],
        providers: [holidays_service_1.HolidaysService],
        exports: [holidays_service_1.HolidaysService],
        controllers: [holidays_controller_1.HolidaysController],
    })
], HolidaysModule);


/***/ }),
/* 141 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SchedulesModule = void 0;
const cutoffs_module_1 = __webpack_require__(128);
const bull_1 = __webpack_require__(4);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const employee_management_module_1 = __webpack_require__(15);
const groups_module_1 = __webpack_require__(134);
const holidays_module_1 = __webpack_require__(140);
const schedule_entity_1 = __webpack_require__(53);
const schedule_change_requests_module_1 = __webpack_require__(142);
const schedules_controller_1 = __webpack_require__(150);
const schedules_service_1 = __webpack_require__(153);
const schedule_generation_service_1 = __webpack_require__(157);
let SchedulesModule = class SchedulesModule {
};
exports.SchedulesModule = SchedulesModule;
exports.SchedulesModule = SchedulesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([schedule_entity_1.Schedule]),
            bull_1.BullModule.registerQueue({
                name: 'schedule-generation',
            }),
            schedule_change_requests_module_1.ScheduleChangeRequestsModule,
            cutoffs_module_1.CutoffsModule,
            employee_management_module_1.EmployeeManagementModule,
            groups_module_1.GroupsModule,
            (0, common_1.forwardRef)(() => holidays_module_1.HolidaysModule),
        ],
        providers: [schedules_service_1.SchedulesService, schedule_generation_service_1.ScheduleGenerationProcessor, schedule_generation_service_1.ScheduleGenerationService],
        exports: [
            schedules_service_1.SchedulesService,
            schedule_change_requests_module_1.ScheduleChangeRequestsModule,
            schedule_generation_service_1.ScheduleGenerationProcessor,
            schedule_generation_service_1.ScheduleGenerationService,
        ],
        controllers: [schedules_controller_1.SchedulesController],
    })
], SchedulesModule);


/***/ }),
/* 142 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeRequestsModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const schedule_change_request_entity_1 = __webpack_require__(70);
const schedule_change_requests_controller_1 = __webpack_require__(143);
const schedule_change_requests_service_1 = __webpack_require__(145);
const schedule_change_responses_module_1 = __webpack_require__(146);
let ScheduleChangeRequestsModule = class ScheduleChangeRequestsModule {
};
exports.ScheduleChangeRequestsModule = ScheduleChangeRequestsModule;
exports.ScheduleChangeRequestsModule = ScheduleChangeRequestsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([schedule_change_request_entity_1.ScheduleChangeRequest]),
            schedule_change_responses_module_1.ScheduleChangeResponsesModule,
        ],
        providers: [schedule_change_requests_service_1.ScheduleChangeRequestsService],
        exports: [
            schedule_change_requests_service_1.ScheduleChangeRequestsService,
            schedule_change_responses_module_1.ScheduleChangeResponsesModule,
        ],
        controllers: [schedule_change_requests_controller_1.ScheduleChangeRequestsController],
    })
], ScheduleChangeRequestsModule);


/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeRequestsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const schedule_change_request_dto_1 = __webpack_require__(144);
const schedule_change_request_entity_1 = __webpack_require__(70);
const schedule_change_requests_service_1 = __webpack_require__(145);
class ScheduleChangeRequestsController extends (0, create_controller_factory_1.createController)(schedule_change_request_entity_1.ScheduleChangeRequest, schedule_change_requests_service_1.ScheduleChangeRequestsService, schedule_change_request_dto_1.GetScheduleChangeRequestDto, schedule_change_request_dto_1.ScheduleChangeRequestDto, schedule_change_request_dto_1.UpdateScheduleChangeRequestDto) {
    async delete(id) {
        return await super.delete(id);
    }
}
exports.ScheduleChangeRequestsController = ScheduleChangeRequestsController;


/***/ }),
/* 144 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetScheduleChangeRequestDto = exports.UpdateScheduleChangeRequestDto = exports.ScheduleChangeRequestDto = void 0;
const base_dto_1 = __webpack_require__(101);
const request_status_enum_1 = __webpack_require__(51);
const schedule_change_request_type_enum_1 = __webpack_require__(71);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class ScheduleChangeRequestDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.ScheduleChangeRequestDto = ScheduleChangeRequestDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Reason for the schedule change request',
        example: 'Medical appointment'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ScheduleChangeRequestDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Status of the request',
        enum: request_status_enum_1.RequestStatus,
        default: request_status_enum_1.RequestStatus.PENDING,
        example: request_status_enum_1.RequestStatus.PENDING
    }),
    (0, class_validator_1.IsEnum)(request_status_enum_1.RequestStatus),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_a = typeof request_status_enum_1.RequestStatus !== "undefined" && request_status_enum_1.RequestStatus) === "function" ? _a : Object)
], ScheduleChangeRequestDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of schedule change request',
        enum: schedule_change_request_type_enum_1.ScheduleChangeRequestType,
        example: schedule_change_request_type_enum_1.ScheduleChangeRequestType.SICK_LEAVE // Assuming this is one of the enum values
    }),
    (0, class_validator_1.IsEnum)(schedule_change_request_type_enum_1.ScheduleChangeRequestType),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_b = typeof schedule_change_request_type_enum_1.ScheduleChangeRequestType !== "undefined" && schedule_change_request_type_enum_1.ScheduleChangeRequestType) === "function" ? _b : Object)
], ScheduleChangeRequestDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID of the schedule this request is associated with',
        example: '123e4567-e89b-12d3-a456-426614174000'
    }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ScheduleChangeRequestDto.prototype, "scheduleId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID of the schedule change response if exists',
        example: '123e4567-e89b-12d3-a456-426614174000',
        required: false
    }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ScheduleChangeRequestDto.prototype, "scheduleChangeResponseId", void 0);
class UpdateScheduleChangeRequestDto extends (0, swagger_1.PartialType)(ScheduleChangeRequestDto) {
}
exports.UpdateScheduleChangeRequestDto = UpdateScheduleChangeRequestDto;
class GetScheduleChangeRequestDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateScheduleChangeRequestDto, 'schedule change request') {
}
exports.GetScheduleChangeRequestDto = GetScheduleChangeRequestDto;


/***/ }),
/* 145 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeRequestsService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const schedule_change_request_entity_1 = __webpack_require__(70);
let ScheduleChangeRequestsService = class ScheduleChangeRequestsService extends base_service_1.BaseService {
    constructor(scheduleChangeRequestsRepository, usersService) {
        super(scheduleChangeRequestsRepository, usersService);
        this.scheduleChangeRequestsRepository = scheduleChangeRequestsRepository;
        this.usersService = usersService;
    }
};
exports.ScheduleChangeRequestsService = ScheduleChangeRequestsService;
exports.ScheduleChangeRequestsService = ScheduleChangeRequestsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(schedule_change_request_entity_1.ScheduleChangeRequest)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], ScheduleChangeRequestsService);


/***/ }),
/* 146 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeResponsesModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const schedule_change_response_entity_1 = __webpack_require__(72);
const schedule_change_responses_controller_1 = __webpack_require__(147);
const schedule_change_responses_service_1 = __webpack_require__(149);
let ScheduleChangeResponsesModule = class ScheduleChangeResponsesModule {
};
exports.ScheduleChangeResponsesModule = ScheduleChangeResponsesModule;
exports.ScheduleChangeResponsesModule = ScheduleChangeResponsesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([schedule_change_response_entity_1.ScheduleChangeResponse]),
        ],
        providers: [schedule_change_responses_service_1.ScheduleChangeResponsesService],
        exports: [schedule_change_responses_service_1.ScheduleChangeResponsesService],
        controllers: [schedule_change_responses_controller_1.ScheduleChangeResponsesController],
    })
], ScheduleChangeResponsesModule);


/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeResponsesController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const schedule_change_response_dto_1 = __webpack_require__(148);
const schedule_change_response_entity_1 = __webpack_require__(72);
const schedule_change_responses_service_1 = __webpack_require__(149);
class ScheduleChangeResponsesController extends (0, create_controller_factory_1.createController)(schedule_change_response_entity_1.ScheduleChangeResponse, schedule_change_responses_service_1.ScheduleChangeResponsesService, schedule_change_response_dto_1.GetScheduleChangeResponseDto, schedule_change_response_dto_1.ScheduleChangeResponseDto, schedule_change_response_dto_1.UpdateScheduleChangeResponseDto) {
    async delete(id) {
        return await super.delete(id);
    }
}
exports.ScheduleChangeResponsesController = ScheduleChangeResponsesController;


/***/ }),
/* 148 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetScheduleChangeResponseDto = exports.UpdateScheduleChangeResponseDto = exports.ScheduleChangeResponseDto = void 0;
const base_dto_1 = __webpack_require__(101);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class ScheduleChangeResponseDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.ScheduleChangeResponseDto = ScheduleChangeResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the schedule change request is approved',
        example: true
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ScheduleChangeResponseDto.prototype, "approved", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Response message for the schedule change request',
        example: 'Your schedule change has been approved.'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ScheduleChangeResponseDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID of the associated schedule change request',
        example: '123e4567-e89b-12d3-a456-426614174000'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], ScheduleChangeResponseDto.prototype, "scheduleChangeRequestId", void 0);
class UpdateScheduleChangeResponseDto extends (0, swagger_1.PartialType)(ScheduleChangeResponseDto) {
}
exports.UpdateScheduleChangeResponseDto = UpdateScheduleChangeResponseDto;
class GetScheduleChangeResponseDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateScheduleChangeResponseDto, 'schedule change response') {
}
exports.GetScheduleChangeResponseDto = GetScheduleChangeResponseDto;


/***/ }),
/* 149 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleChangeResponsesService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const schedule_change_response_entity_1 = __webpack_require__(72);
let ScheduleChangeResponsesService = class ScheduleChangeResponsesService extends base_service_1.BaseService {
    constructor(scheduleChangeResponsesRepository, usersService) {
        super(scheduleChangeResponsesRepository, usersService);
        this.scheduleChangeResponsesRepository = scheduleChangeResponsesRepository;
        this.usersService = usersService;
    }
};
exports.ScheduleChangeResponsesService = ScheduleChangeResponsesService;
exports.ScheduleChangeResponsesService = ScheduleChangeResponsesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(schedule_change_response_entity_1.ScheduleChangeResponse)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], ScheduleChangeResponsesService);


/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SchedulesController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const schedule_dto_1 = __webpack_require__(151);
const schedule_entity_1 = __webpack_require__(53);
const schedules_service_1 = __webpack_require__(153);
class SchedulesController extends (0, create_controller_factory_1.createController)(schedule_entity_1.Schedule, schedules_service_1.SchedulesService, schedule_dto_1.GetScheduleDto, schedule_dto_1.ScheduleDto, schedule_dto_1.UpdateScheduleDto) {
}
exports.SchedulesController = SchedulesController;


/***/ }),
/* 151 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetScheduleDto = exports.UpdateScheduleDto = exports.ScheduleDto = void 0;
const is_time_string_decorator_1 = __webpack_require__(152);
const base_dto_1 = __webpack_require__(101);
const schedule_status_1 = __webpack_require__(54);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class ScheduleDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.ScheduleDto = ScheduleDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Date of the schedule', example: '2023-01-01' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], ScheduleDto.prototype, "date", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Notes about the schedule', required: false, example: 'Special schedule for holiday season' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ScheduleDto.prototype, "notes", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Status of the schedule',
        enum: schedule_status_1.ScheduleStatus,
        default: schedule_status_1.ScheduleStatus.DEFAULT,
        example: schedule_status_1.ScheduleStatus.DEFAULT
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(schedule_status_1.ScheduleStatus),
    __metadata("design:type", typeof (_b = typeof schedule_status_1.ScheduleStatus !== "undefined" && schedule_status_1.ScheduleStatus) === "function" ? _b : Object)
], ScheduleDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Start time of the schedule', required: false, example: '09:00:00' }),
    (0, class_validator_1.IsOptional)(),
    (0, is_time_string_decorator_1.IsTimeString)(),
    __metadata("design:type", String)
], ScheduleDto.prototype, "startTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'End time of the schedule', required: false, example: '17:00:00' }),
    (0, class_validator_1.IsOptional)(),
    (0, is_time_string_decorator_1.IsTimeString)(),
    __metadata("design:type", String)
], ScheduleDto.prototype, "endTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Break time in minutes', required: false, example: 60 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], ScheduleDto.prototype, "breakTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Duration in hours', required: false, example: 8 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], ScheduleDto.prototype, "duration", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the associated shift', required: true, example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ScheduleDto.prototype, "shiftId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the associated holiday', required: false, example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], ScheduleDto.prototype, "holidayId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the associated employee', required: true, example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ScheduleDto.prototype, "employeeId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the associated cutoff', required: true, example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ScheduleDto.prototype, "cutoffId", void 0);
class UpdateScheduleDto extends (0, swagger_1.PartialType)(ScheduleDto) {
}
exports.UpdateScheduleDto = UpdateScheduleDto;
class GetScheduleDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateScheduleDto, 'schedule') {
}
exports.GetScheduleDto = GetScheduleDto;


/***/ }),
/* 152 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsTimeString = IsTimeString;
const class_validator_1 = __webpack_require__(24);
function IsTimeString(validationOptions) {
    return function (target, propertyName) {
        (0, class_validator_1.registerDecorator)({
            name: 'isTimeString',
            target: target.constructor,
            propertyName: propertyName,
            options: validationOptions,
            validator: {
                validate(value) {
                    if (typeof value !== 'string')
                        return false;
                    // Regular expression to match HH:MM:SS format
                    const timeRegex = /^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/;
                    return timeRegex.test(value);
                },
                defaultMessage(args) {
                    return `${args.property} must be a valid time string in the format HH:MM:SS`;
                }
            }
        });
    };
}


/***/ }),
/* 153 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SchedulesService = void 0;
const schedule_status_1 = __webpack_require__(54);
const base_service_1 = __webpack_require__(31);
const day_util_1 = __webpack_require__(154);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const date_fns_1 = __webpack_require__(155);
const typeorm_2 = __webpack_require__(25);
const employees_service_1 = __webpack_require__(104);
const cutoffs_service_1 = __webpack_require__(130);
const groups_service_1 = __webpack_require__(137);
const holidays_service_1 = __webpack_require__(156);
const schedule_entity_1 = __webpack_require__(53);
let SchedulesService = class SchedulesService extends base_service_1.BaseService {
    constructor(schedulesRepository, usersService, groupsService, cutoffsService, holidaysService, employeesService) {
        super(schedulesRepository, usersService);
        this.schedulesRepository = schedulesRepository;
        this.usersService = usersService;
        this.groupsService = groupsService;
        this.cutoffsService = cutoffsService;
        this.holidaysService = holidaysService;
        this.employeesService = employeesService;
    }
    async getEmployeeScheduleToday(employeeId) {
        return await this.schedulesRepository.findOne({
            where: {
                employee: { id: employeeId },
                date: (0, date_fns_1.parseISO)((0, date_fns_1.format)(new Date(), 'yyyy-MM-dd'))
            },
            relations: { shift: { days: true }, holiday: true, employee: true }
        });
    }
    /**
     * Delete future schedules (starting from tomorrow) for employees in a specific group and cutoff
     * Uses hard delete to permanently remove the records
     */
    async deleteSchedules(params) {
        const { employeeIds, groupId, cutoffId } = params;
        // Get tomorrow's date
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(0, 0, 0, 0); // Set to beginning of day
        try {
            // Delete schedules matching our criteria, but only from tomorrow onwards
            const result = await this.schedulesRepository.delete({
                employee: { id: (0, typeorm_2.In)(employeeIds) },
                cutoff: { id: cutoffId },
                date: (0, typeorm_2.MoreThanOrEqual)(tomorrow)
            });
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Failed to delete future schedules: ${error.message}`, error.stack);
            }
            else {
                this.logger.error(`Failed to delete future schedules: Unknown error`);
            }
            throw error;
        }
    }
    async generateSchedulesForEmployees(employeeIds, groupId, cutoffId) {
        this.logger.log(`Generating schedules for ${employeeIds.length} employees in group ${groupId}`);
        // Get the group with shift
        const group = await this.groupsService.findOneByOrFail({ id: groupId }, { relations: { shift: true } });
        if (!group.shift) {
            throw new common_1.NotFoundException(`${group.name} has no shift assigned`);
        }
        // Get cutoff
        const cutoff = await this.cutoffsService.findOneByOrFail({ id: cutoffId });
        // Get employees
        const employees = await this.employeesService.getRepository().findBy({
            id: (0, typeorm_2.In)(employeeIds)
        });
        // Generate schedules for each employee
        const generatedSchedules = [];
        for (const employee of employees) {
            const schedules = await this.generateSchedulesForEmployee(employee, group.shift, cutoff);
            generatedSchedules.push(...schedules);
        }
        // Save all generated schedules
        return this.schedulesRepository.save(generatedSchedules);
    }
    async generateSchedulesForEmployee(employee, shift, cutoff) {
        const { startDate, endDate } = cutoff;
        const { commencementDate } = employee;
        const schedules = [];
        // Delete existing schedules for this employee and cutoff
        await this.deleteSchedules({
            employeeIds: [employee.id],
            groupId: employee.group.id,
            cutoffId: cutoff.id,
        });
        // Get today and tomorrow dates
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);
        // Parse dates
        const parsedCommencementDate = (0, date_fns_1.parseISO)(commencementDate.toString());
        const parsedCutoffStartDate = (0, date_fns_1.parseISO)(startDate.toString());
        // Determine effective start date based on the new logic:
        // - If cutoff start date is in the future, use it
        // - Otherwise use tomorrow
        let baseStartDate;
        if (parsedCutoffStartDate > today) {
            this.logger.log(`Using future cutoff start date: ${(0, date_fns_1.format)(parsedCutoffStartDate, 'yyyy-MM-dd')}`);
            baseStartDate = parsedCutoffStartDate;
        }
        else {
            this.logger.log(`Cutoff already started, using tomorrow: ${(0, date_fns_1.format)(tomorrow, 'yyyy-MM-dd')}`);
            baseStartDate = tomorrow;
        }
        // Still respect employee's commencement date
        let effectiveStartDate = new Date(Math.max(baseStartDate.getTime(), parsedCommencementDate.getTime()));
        this.logger.log(`Effective schedule start date: ${(0, date_fns_1.format)(effectiveStartDate, 'yyyy-MM-dd')}`);
        // Generate schedule for each day in the cutoff period
        let currentDate = new Date(effectiveStartDate);
        const cutoffEndDate = new Date(endDate);
        while ((0, date_fns_1.isBefore)(currentDate, cutoffEndDate) || (0, date_fns_1.isSameDay)(currentDate, cutoffEndDate)) {
            const dayOfWeek = day_util_1.DayUtils.fromDate(currentDate);
            // Find if this day is in the shift's schedule
            const shiftDay = shift.days.find(day => day.day === dayOfWeek);
            if (shiftDay) {
                // Check if the current date is a holiday
                const holiday = await this.holidaysService.findOneBy({
                    date: currentDate
                });
                // Create a schedule entry with specific shift details for this day
                const scheduleEntry = {
                    date: new Date(currentDate),
                    status: schedule_status_1.ScheduleStatus.DEFAULT,
                    employee: { id: employee.id },
                    shift: { id: shift.id },
                    cutoff: { id: cutoff.id },
                    startTime: shiftDay.startTime || shift.defaultStartTime,
                    endTime: shiftDay.endTime || shift.defaultEndTime,
                    breakTime: shiftDay.breakTime || shift.defaultBreakTime,
                    duration: shiftDay.duration || shift.defaultDuration,
                };
                // If it's a holiday, associate it with the schedule
                if (holiday) {
                    scheduleEntry.holiday = { id: holiday.id };
                }
                schedules.push(scheduleEntry);
            }
            // Move to the next day
            currentDate = (0, date_fns_1.addDays)(currentDate, 1);
        }
        return schedules;
    }
    // Check if a schedule already exists
    async findExistingSchedules(employeeId, cutoffId, startDate, endDate) {
        return this.schedulesRepository.find({
            where: {
                employee: { id: employeeId },
                cutoff: { id: cutoffId },
                date: (0, typeorm_2.Between)(startDate, endDate),
            },
        });
    }
};
exports.SchedulesService = SchedulesService;
exports.SchedulesService = SchedulesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(schedule_entity_1.Schedule)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof groups_service_1.GroupsService !== "undefined" && groups_service_1.GroupsService) === "function" ? _c : Object, typeof (_d = typeof cutoffs_service_1.CutoffsService !== "undefined" && cutoffs_service_1.CutoffsService) === "function" ? _d : Object, typeof (_e = typeof holidays_service_1.HolidaysService !== "undefined" && holidays_service_1.HolidaysService) === "function" ? _e : Object, typeof (_f = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _f : Object])
], SchedulesService);


/***/ }),
/* 154 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLogLevels = exports.DayUtils = void 0;
const day_enum_1 = __webpack_require__(62);
exports.DayUtils = {
    isWeekend: (day) => {
        return day === day_enum_1.Day.SATURDAY || day === day_enum_1.Day.SUNDAY;
    },
    fromDate: (date) => {
        const dayName = new Intl.DateTimeFormat('en-US', { weekday: 'long' }).format(date);
        return dayName.toUpperCase();
    }
};
const getLogLevels = (isDevelopment) => {
    if (isDevelopment) {
        return ['log', 'error', 'warn', 'debug', 'verbose'];
    }
    return ['log', 'error', 'warn'];
};
exports.getLogLevels = getLogLevels;


/***/ }),
/* 155 */
/***/ ((module) => {

"use strict";
module.exports = require("date-fns");

/***/ }),
/* 156 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HolidaysService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const schedules_service_1 = __webpack_require__(153);
const holiday_entity_1 = __webpack_require__(68);
let HolidaysService = class HolidaysService extends base_service_1.BaseService {
    constructor(holidaysRepository, usersService, schedulesService) {
        super(holidaysRepository, usersService);
        this.holidaysRepository = holidaysRepository;
        this.usersService = usersService;
        this.schedulesService = schedulesService;
    }
    async create(createDto, createdBy) {
        // Check if holiday already exists for the same date
        const existingHoliday = await this.holidaysRepository.findOne({
            where: { date: createDto.date }
        });
        if (existingHoliday) {
            throw new common_1.ConflictException(`A holiday already exists on ${createDto.date}`);
        }
        // Call the base class create method
        const holiday = await super.create(createDto, createdBy);
        // Find all schedules on this date and link them to the holiday
        await this.linkHolidayToSchedules(holiday);
        return holiday;
    }
    async update(id, updateDto, updatedBy) {
        // Get existing holiday
        const existingHoliday = await this.findOneByOrFail({ id });
        // If date is being updated, check if another holiday exists on the new date
        if (updateDto.date && updateDto.date !== existingHoliday.date) {
            const conflictingHoliday = await this.holidaysRepository.findOne({
                where: { date: updateDto.date }
            });
            if (conflictingHoliday && conflictingHoliday.id !== id) {
                throw new common_1.ConflictException(`A holiday already exists on ${updateDto.date}`);
            }
        }
        // Call the base class update method
        const updatedHoliday = await super.update(id, updateDto, updatedBy);
        // If the date was changed, update all schedules for the new date
        if (updateDto.date && updateDto.date !== existingHoliday.date) {
            // Unlink schedules from the old date
            await this.schedulesService.getRepository().update({ holiday: { id } }, { holiday: undefined });
            // Link schedules to the new date
            await this.linkHolidayToSchedules(updatedHoliday);
        }
        return updatedHoliday;
    }
    /**
     * Links a holiday to all schedules on the same date
     */
    async linkHolidayToSchedules(holiday) {
        // Create a date range for the entire day
        const startDate = new Date(holiday.date);
        startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(holiday.date);
        endDate.setHours(23, 59, 59, 999);
        // Find all schedules on this date
        const schedules = await this.schedulesService.getRepository().find({
            where: {
                date: (0, typeorm_2.Between)(startDate, endDate)
            }
        });
        // Link the holiday to all schedules
        if (schedules.length > 0) {
            await Promise.all(schedules.map(schedule => this.schedulesService.getRepository().update(schedule.id, { holiday: { id: holiday.id } })));
        }
    }
};
exports.HolidaysService = HolidaysService;
exports.HolidaysService = HolidaysService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(holiday_entity_1.Holiday)),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => schedules_service_1.SchedulesService))),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _c : Object])
], HolidaysService);


/***/ }),
/* 157 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ScheduleGenerationService_1, ScheduleGenerationProcessor_1;
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScheduleGenerationProcessor = exports.ScheduleGenerationService = void 0;
const employee_assigned_event_1 = __webpack_require__(138);
const bull_1 = __webpack_require__(4);
const common_1 = __webpack_require__(5);
const event_emitter_1 = __webpack_require__(139);
const bull_2 = __webpack_require__(158);
const schedules_service_1 = __webpack_require__(153);
let ScheduleGenerationService = ScheduleGenerationService_1 = class ScheduleGenerationService {
    constructor(scheduleQueue) {
        this.scheduleQueue = scheduleQueue;
        this.logger = new common_1.Logger(ScheduleGenerationService_1.name);
    }
    async addGenerationJob(data) {
        this.logger.log(`Adding schedule generation job for ${data.employeeIds.length} employees in group ${data.groupId}`);
        return this.scheduleQueue.add('generate', data);
    }
};
exports.ScheduleGenerationService = ScheduleGenerationService;
exports.ScheduleGenerationService = ScheduleGenerationService = ScheduleGenerationService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, bull_1.InjectQueue)('schedule-generation')),
    __metadata("design:paramtypes", [typeof (_a = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _a : Object])
], ScheduleGenerationService);
let ScheduleGenerationProcessor = ScheduleGenerationProcessor_1 = class ScheduleGenerationProcessor {
    constructor(schedulesService, eventEmitter) {
        this.schedulesService = schedulesService;
        this.eventEmitter = eventEmitter;
        this.logger = new common_1.Logger(ScheduleGenerationProcessor_1.name);
    }
    async processScheduleGeneration(job) {
        this.logger.log(`Processing schedule generation job ${job.id}`);
        const { employeeIds, groupId, cutoffId, requestedBy } = job.data;
        try {
            const result = await this.schedulesService.generateSchedulesForEmployees(employeeIds, groupId, cutoffId);
            this.eventEmitter.emit(employee_assigned_event_1.SCHEDULE_EVENTS.GENERATION_COMPLETED, {
                jobId: job.id,
                employeeIds,
                groupId,
                cutoffId,
                schedulesGenerated: result.length,
                requestedBy,
            });
            this.logger.log(`Generated ${result.length} schedules for job ${job.id}`);
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Schedule generation failed for job ${job.id}: ${error.message}`, error.stack);
                this.eventEmitter.emit(employee_assigned_event_1.SCHEDULE_EVENTS.GENERATION_FAILED, {
                    jobId: job.id,
                    employeeIds,
                    groupId,
                    cutoffId,
                    error: error.message,
                    requestedBy,
                });
            }
            else {
                this.logger.error(`Schedule generation failed for job ${job.id}: Unknown error`);
                this.eventEmitter.emit(employee_assigned_event_1.SCHEDULE_EVENTS.GENERATION_FAILED, {
                    jobId: job.id,
                    employeeIds,
                    groupId,
                    cutoffId,
                    error: 'Unknown error',
                    requestedBy,
                });
            }
            throw error;
        }
    }
};
exports.ScheduleGenerationProcessor = ScheduleGenerationProcessor;
__decorate([
    (0, bull_1.Process)('generate'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof bull_2.Job !== "undefined" && bull_2.Job) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], ScheduleGenerationProcessor.prototype, "processScheduleGeneration", null);
exports.ScheduleGenerationProcessor = ScheduleGenerationProcessor = ScheduleGenerationProcessor_1 = __decorate([
    (0, bull_1.Processor)('schedule-generation'),
    __metadata("design:paramtypes", [typeof (_b = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _b : Object, typeof (_c = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _c : Object])
], ScheduleGenerationProcessor);


/***/ }),
/* 158 */
/***/ ((module) => {

"use strict";
module.exports = require("bull");

/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HolidaysController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const holiday_dto_1 = __webpack_require__(160);
const holiday_entity_1 = __webpack_require__(68);
const holidays_service_1 = __webpack_require__(156);
class HolidaysController extends (0, create_controller_factory_1.createController)(holiday_entity_1.Holiday, holidays_service_1.HolidaysService, holiday_dto_1.GetHolidayDto, holiday_dto_1.HolidayDto, holiday_dto_1.UpdateHolidayDto) {
}
exports.HolidaysController = HolidaysController;


/***/ }),
/* 160 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetHolidayDto = exports.UpdateHolidayDto = exports.HolidayDto = void 0;
const base_dto_1 = __webpack_require__(101);
const day_enum_1 = __webpack_require__(62);
const holiday_type_enum_1 = __webpack_require__(69);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class HolidayDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.HolidayDto = HolidayDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the holiday',
        example: 'Christmas Day'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], HolidayDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of the holiday',
        example: 'Annual celebration on December 25th',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], HolidayDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of holiday',
        enum: holiday_type_enum_1.HolidayType,
        enumName: 'HolidayType',
        example: Object.values(holiday_type_enum_1.HolidayType)[0]
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(holiday_type_enum_1.HolidayType, { message: 'Type must be a valid holiday type' }),
    __metadata("design:type", typeof (_a = typeof holiday_type_enum_1.HolidayType !== "undefined" && holiday_type_enum_1.HolidayType) === "function" ? _a : Object)
], HolidayDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date of the holiday',
        example: '2023-12-25'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], HolidayDto.prototype, "date", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Day of the week for the holiday',
        enum: day_enum_1.Day,
        enumName: 'Day',
        example: Object.values(day_enum_1.Day)[0]
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(day_enum_1.Day, { message: 'Day must be a valid day of the week' }),
    __metadata("design:type", typeof (_c = typeof day_enum_1.Day !== "undefined" && day_enum_1.Day) === "function" ? _c : Object)
], HolidayDto.prototype, "day", void 0);
class UpdateHolidayDto extends (0, swagger_1.PartialType)(HolidayDto) {
}
exports.UpdateHolidayDto = UpdateHolidayDto;
class GetHolidayDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateHolidayDto, 'holiday') {
}
exports.GetHolidayDto = GetHolidayDto;


/***/ }),
/* 161 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var DefaultShiftsSeeder_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultShiftsSeeder = void 0;
const cutoff_status_enum_1 = __webpack_require__(56);
const day_enum_1 = __webpack_require__(62);
const cutoffs_service_1 = __webpack_require__(130);
const common_1 = __webpack_require__(5);
const groups_service_1 = __webpack_require__(137);
const shifts_service_1 = __webpack_require__(162);
let DefaultShiftsSeeder = DefaultShiftsSeeder_1 = class DefaultShiftsSeeder {
    constructor(shiftsService, groupsService, cutoffsService) {
        this.shiftsService = shiftsService;
        this.groupsService = groupsService;
        this.cutoffsService = cutoffsService;
        this.logger = new common_1.Logger(DefaultShiftsSeeder_1.name);
    }
    async onModuleInit() {
        await this.seed();
    }
    async seed() {
        // this.logger.log('Seeding default shifts and groups...');
        // Check if default shift already exists
        const existingShifts = await this.shiftsService.getRepository().count();
        if (existingShifts > 0) {
            // this.logger.log('Shifts already exist, skipping seeder');
            return;
        }
        // Find or create a default cutoff to associate with shifts
        let defaultCutoff = await this.cutoffsService.findOneBy({
            status: cutoff_status_enum_1.CutoffStatus.PENDING
        }) || await this.cutoffsService.getActiveCutoff();
        if (!defaultCutoff) {
            throw new Error('No active cutoff found. Please create a cutoff first.');
        }
        // Common reference for cutoff
        const cutoffRef = { id: defaultCutoff.id };
        const weekdays = [day_enum_1.Day.MONDAY, day_enum_1.Day.TUESDAY, day_enum_1.Day.WEDNESDAY, day_enum_1.Day.THURSDAY, day_enum_1.Day.FRIDAY];
        // 1. Create standard day shift
        await this.createDayShift(weekdays, cutoffRef);
        // 2. Create night shift with overnight flag
        await this.createNightShift(weekdays, cutoffRef);
        // 3. Create graveyard shift
        await this.createGraveyardShift(weekdays, cutoffRef);
        // 4. Create weekend shift
        await this.createWeekendShift(cutoffRef);
        // 5. Create flexible shift
        await this.createFlexibleShift(cutoffRef);
        this.logger.log('Successfully seeded all default shifts and groups');
    }
    async createDayShift(weekdays, cutoffRef) {
        // Create shift days array for cascade insertion
        const dayShifts = weekdays.map(day => ({
            day,
            startTime: '09:00:00',
            endTime: '18:00:00',
            breakTime: 60,
            duration: 8,
            isOvernight: false,
        }));
        // Create shift with days using cascade
        const dayShift = await this.shiftsService.create({
            name: 'Standard Day Shift',
            description: 'Regular 9-6 workday with 1 hour break',
            defaultStartTime: '09:00:00',
            defaultEndTime: '18:00:00',
            defaultBreakTime: 60,
            defaultDuration: 8,
            days: dayShifts,
            cutoffs: [cutoffRef]
        });
        this.logger.log(`Created day shift: ${dayShift.id}`);
        // Create default group for day shift
        const dayGroup = await this.groupsService.create({
            name: 'Standard Day Shift Group',
            description: 'Default group working standard office hours',
            shift: { id: dayShift.id },
        });
        this.logger.log(`Created day shift group: ${dayGroup.id}`);
        return dayShift;
    }
    async createNightShift(weekdays, cutoffRef) {
        // Create shift days array for cascade insertion
        const nightShiftDays = weekdays.map(day => ({
            day,
            startTime: '16:00:00',
            endTime: '00:00:00',
            breakTime: 45,
            duration: 7.25,
            isOvernight: true, // This shift crosses midnight
        }));
        // Create shift with days using cascade
        const nightShift = await this.shiftsService.create({
            name: 'Night Shift',
            description: 'Evening to midnight shift',
            defaultStartTime: '16:00:00',
            defaultEndTime: '00:00:00',
            defaultBreakTime: 45,
            defaultDuration: 7.25,
            days: nightShiftDays,
            cutoffs: [cutoffRef]
        });
        this.logger.log(`Created night shift: ${nightShift.id}`);
        // Create night shift group
        const nightGroup = await this.groupsService.create({
            name: 'Night Shift Group',
            description: 'Group working evening to midnight hours',
            shift: { id: nightShift.id },
        });
        this.logger.log(`Created night shift group: ${nightGroup.id}`);
        return nightShift;
    }
    async createGraveyardShift(weekdays, cutoffRef) {
        // Create shift days array for cascade insertion
        const graveyardShiftDays = weekdays.map(day => ({
            day,
            startTime: '00:00:00',
            endTime: '08:00:00',
            breakTime: 30,
            duration: 7.5,
            isOvernight: false,
        }));
        // Create shift with days using cascade
        const graveyardShift = await this.shiftsService.create({
            name: 'Graveyard Shift',
            description: 'Midnight to morning shift',
            defaultStartTime: '00:00:00',
            defaultEndTime: '08:00:00',
            defaultBreakTime: 30,
            defaultDuration: 7.5,
            days: graveyardShiftDays,
            cutoffs: [cutoffRef]
        });
        this.logger.log(`Created graveyard shift: ${graveyardShift.id}`);
        // Create graveyard shift group
        const graveyardGroup = await this.groupsService.create({
            name: 'Graveyard Shift Group',
            description: 'Group working overnight hours',
            shift: { id: graveyardShift.id },
        });
        this.logger.log(`Created graveyard shift group: ${graveyardGroup.id}`);
        return graveyardShift;
    }
    async createWeekendShift(cutoffRef) {
        // Create shift days array for cascade insertion
        const weekendShiftDays = [day_enum_1.Day.SATURDAY, day_enum_1.Day.SUNDAY].map(day => ({
            day,
            startTime: '10:00:00',
            endTime: '16:00:00',
            breakTime: 30,
            duration: 5.5,
            isOvernight: false,
        }));
        // Create shift with days using cascade
        const weekendShift = await this.shiftsService.create({
            name: 'Weekend Shift',
            description: 'Weekend coverage with different hours',
            defaultStartTime: '10:00:00',
            defaultEndTime: '16:00:00',
            defaultBreakTime: 30,
            defaultDuration: 5.5,
            days: weekendShiftDays,
            cutoffs: [cutoffRef]
        });
        this.logger.log(`Created weekend shift: ${weekendShift.id}`);
        // Create weekend shift group
        const weekendGroup = await this.groupsService.create({
            name: 'Weekend Shift Group',
            description: 'Group working weekend hours',
            shift: { id: weekendShift.id },
        });
        this.logger.log(`Created weekend shift group: ${weekendGroup.id}`);
        return weekendShift;
    }
    async createFlexibleShift(cutoffRef) {
        // Define different schedules for each day
        const flexSchedules = [
            { day: day_enum_1.Day.MONDAY, start: '08:00:00', end: '16:00:00', break: 60, duration: 7 },
            { day: day_enum_1.Day.TUESDAY, start: '09:00:00', end: '17:00:00', break: 45, duration: 7.25 },
            { day: day_enum_1.Day.WEDNESDAY, start: '10:00:00', end: '18:00:00', break: 45, duration: 7.25 },
            { day: day_enum_1.Day.THURSDAY, start: '09:00:00', end: '17:00:00', break: 45, duration: 7.25 },
            { day: day_enum_1.Day.FRIDAY, start: '08:00:00', end: '14:00:00', break: 30, duration: 5.5 },
        ];
        // Create shift days array for cascade insertion
        const flexShiftDays = flexSchedules.map(schedule => ({
            day: schedule.day,
            startTime: schedule.start,
            endTime: schedule.end,
            breakTime: schedule.break,
            duration: schedule.duration,
            isOvernight: false,
        }));
        // Create shift with days using cascade
        const flexShift = await this.shiftsService.create({
            name: 'Flexible Shift',
            description: 'Different hours each day of the week',
            defaultStartTime: '09:00:00',
            defaultEndTime: '17:00:00',
            defaultBreakTime: 45,
            defaultDuration: 7.25,
            days: flexShiftDays,
            cutoffs: [cutoffRef]
        });
        this.logger.log(`Created flexible shift: ${flexShift.id}`);
        // Create flexible shift group
        const flexGroup = await this.groupsService.create({
            name: 'Flexible Shift Group',
            description: 'Group with different hours each day',
            shift: { id: flexShift.id },
        });
        this.logger.log(`Created flexible shift group: ${flexGroup.id}`);
        return flexShift;
    }
};
exports.DefaultShiftsSeeder = DefaultShiftsSeeder;
exports.DefaultShiftsSeeder = DefaultShiftsSeeder = DefaultShiftsSeeder_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof shifts_service_1.ShiftsService !== "undefined" && shifts_service_1.ShiftsService) === "function" ? _a : Object, typeof (_b = typeof groups_service_1.GroupsService !== "undefined" && groups_service_1.GroupsService) === "function" ? _b : Object, typeof (_c = typeof cutoffs_service_1.CutoffsService !== "undefined" && cutoffs_service_1.CutoffsService) === "function" ? _c : Object])
], DefaultShiftsSeeder);


/***/ }),
/* 162 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShiftsService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const shift_entity_1 = __webpack_require__(59);
let ShiftsService = class ShiftsService extends base_service_1.BaseService {
    constructor(shiftsRepository, usersService) {
        super(shiftsRepository, usersService);
        this.shiftsRepository = shiftsRepository;
        this.usersService = usersService;
    }
};
exports.ShiftsService = ShiftsService;
exports.ShiftsService = ShiftsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(shift_entity_1.Shift)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], ShiftsService);


/***/ }),
/* 163 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShiftsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const shift_dto_1 = __webpack_require__(164);
const shift_entity_1 = __webpack_require__(59);
const shifts_service_1 = __webpack_require__(162);
class ShiftsController extends (0, create_controller_factory_1.createController)(shift_entity_1.Shift, shifts_service_1.ShiftsService, shift_dto_1.GetShiftDto, shift_dto_1.ShiftDto, shift_dto_1.UpdateShiftDto) {
}
exports.ShiftsController = ShiftsController;


/***/ }),
/* 164 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetShiftDto = exports.UpdateShiftDto = exports.ShiftDto = void 0;
const is_time_string_decorator_1 = __webpack_require__(152);
const base_dto_1 = __webpack_require__(101);
const reference_dto_1 = __webpack_require__(102);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
const shift_day_dto_1 = __webpack_require__(165);
class ShiftDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
    get defaultDuration() {
        if (!this.defaultStartTime || !this.defaultEndTime) {
            return 0;
        }
        // Parse times
        const [startHours, startMinutes] = this.defaultStartTime.split(':').map(Number);
        const [endHours, endMinutes] = this.defaultEndTime.split(':').map(Number);
        // Calculate duration in hours
        let durationHours = endHours - startHours;
        let durationMinutes = endMinutes - startMinutes;
        // Adjust for negative minutes
        if (durationMinutes < 0) {
            durationHours -= 1;
            durationMinutes += 60;
        }
        // Calculate break time in hours
        const breakHours = this.defaultBreakTime ? this.defaultBreakTime / 60 : 0;
        // Return duration minus break time
        return Math.max(0, durationHours + (durationMinutes / 60) - breakHours);
    }
}
exports.ShiftDto = ShiftDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the shift',
        example: 'Morning Shift',
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ShiftDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of the shift',
        example: 'Standard morning work schedule',
        required: false,
        type: String
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ShiftDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Default start time of the shift',
        example: '09:00:00',
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, is_time_string_decorator_1.IsTimeString)(),
    __metadata("design:type", String)
], ShiftDto.prototype, "defaultStartTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Default end time of the shift',
        example: '18:00:00',
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, is_time_string_decorator_1.IsTimeString)(),
    __metadata("design:type", String)
], ShiftDto.prototype, "defaultEndTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Default break time in minutes',
        example: 60,
        required: false,
        type: Number
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], ShiftDto.prototype, "defaultBreakTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Default duration of the shift in hours (computed from start/end times)',
        example: 8,
        readOnly: true,
        type: Number
    }),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], ShiftDto.prototype, "defaultDuration", null);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Shift details for specific days',
        type: [shift_day_dto_1.ShiftDayDto],
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => shift_day_dto_1.ShiftDayDto),
    __metadata("design:type", Array)
], ShiftDto.prototype, "days", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Associated cutoffs',
        type: [reference_dto_1.ReferenceDto],
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], ShiftDto.prototype, "cutoffs", void 0);
class UpdateShiftDto extends (0, swagger_1.PartialType)(ShiftDto) {
}
exports.UpdateShiftDto = UpdateShiftDto;
class GetShiftDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateShiftDto, 'shift') {
}
exports.GetShiftDto = GetShiftDto;


/***/ }),
/* 165 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShiftDayDto = void 0;
const is_time_string_decorator_1 = __webpack_require__(152);
const day_enum_1 = __webpack_require__(62);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class ShiftDayDto {
}
exports.ShiftDayDto = ShiftDayDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Day of the week',
        enum: day_enum_1.Day,
        example: day_enum_1.Day.MONDAY
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(day_enum_1.Day),
    __metadata("design:type", typeof (_a = typeof day_enum_1.Day !== "undefined" && day_enum_1.Day) === "function" ? _a : Object)
], ShiftDayDto.prototype, "day", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Start time of the shift',
        example: '09:00:00',
        type: String,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, is_time_string_decorator_1.IsTimeString)(),
    __metadata("design:type", String)
], ShiftDayDto.prototype, "startTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'End time of the shift',
        example: '18:00:00',
        type: String,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, is_time_string_decorator_1.IsTimeString)(),
    __metadata("design:type", String)
], ShiftDayDto.prototype, "endTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Break time in minutes',
        example: 60,
        required: false,
        type: Number
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], ShiftDayDto.prototype, "breakTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Duration of the shift in hours',
        example: 480,
        required: false,
        type: Number
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], ShiftDayDto.prototype, "duration", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Indicates if the shift runs overnight',
        example: false,
        default: false,
        required: false,
        type: Boolean,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ShiftDayDto.prototype, "isOvernight", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID of the associated shift',
        example: '123e4567-e89b-12d3-a456-426614174000'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ShiftDayDto.prototype, "shiftId", void 0);


/***/ }),
/* 166 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var EmployeeGroupAssignmentListener_1;
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmployeeGroupAssignmentListener = void 0;
const cutoffs_service_1 = __webpack_require__(130);
const schedules_service_1 = __webpack_require__(153);
const schedule_generation_service_1 = __webpack_require__(157);
const common_1 = __webpack_require__(5);
const event_emitter_1 = __webpack_require__(139);
const cutoff_status_enum_1 = __webpack_require__(56);
const employee_assigned_event_1 = __webpack_require__(138);
let EmployeeGroupAssignmentListener = EmployeeGroupAssignmentListener_1 = class EmployeeGroupAssignmentListener {
    constructor(cutoffsService, scheduleGenerationService, scheduleService) {
        this.cutoffsService = cutoffsService;
        this.scheduleGenerationService = scheduleGenerationService;
        this.scheduleService = scheduleService;
        this.logger = new common_1.Logger(EmployeeGroupAssignmentListener_1.name);
    }
    async handleEmployeeAssignedToGroup(event) {
        this.logger.log(`Handling employee assignment event for ${event.employees.length} employees to group ${event.group.id}`);
        // Find all future active cutoffs instead of just one
        const cutoff = await this.cutoffsService.findOneBy({ status: cutoff_status_enum_1.CutoffStatus.PENDING }) || await this.cutoffsService.getActiveCutoff();
        if (!cutoff) {
            this.logger.warn('No pending/active cutoff found, skipping schedule generation');
            return;
        }
        if (!event.group.shift) {
            this.logger.warn(`Group ${event.group.id} has no shift assigned, skipping schedule generation`);
            return;
        }
        // Get employee IDs
        const employeeIds = event.employees.map((employee) => employee.id);
        this.logger.log(`Schedule generation job queued for cutoff ${cutoff.id} (${new Date(cutoff.startDate).toLocaleDateString()})`);
        // Queue schedule generation jobs for each cutoff
        await this.scheduleGenerationService.addGenerationJob({
            employeeIds,
            groupId: event.group.id,
            cutoffId: cutoff.id,
            requestedBy: event.assignedBy,
        });
    }
    async handleEmployeeRemovedFromGroup(event) {
        // Find all future active cutoffs instead of just one
        const cutoff = await this.cutoffsService.findOneBy({ status: cutoff_status_enum_1.CutoffStatus.PENDING }) || await this.cutoffsService.getActiveCutoff();
        if (!cutoff) {
            this.logger.warn('No pending/active cutoff found, skipping schedule generation');
            return;
        }
        // Get employee IDs
        const employeeIds = event.employees.map((employee) => employee.id);
        // Delete schedules for each cutoff and removed employee
        await this.scheduleService.deleteSchedules({
            employeeIds,
            groupId: event.group.id,
            cutoffId: cutoff.id,
        });
        this.logger.log(`Schedules deleted for cutoff ${cutoff.id} (${new Date(cutoff.startDate).toLocaleDateString()}) for ${employeeIds.length} employees`);
    }
};
exports.EmployeeGroupAssignmentListener = EmployeeGroupAssignmentListener;
__decorate([
    (0, event_emitter_1.OnEvent)(employee_assigned_event_1.GROUP_EVENTS.EMPLOYEE_ASSIGNED),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof employee_assigned_event_1.EmployeeAssignedEvent !== "undefined" && employee_assigned_event_1.EmployeeAssignedEvent) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], EmployeeGroupAssignmentListener.prototype, "handleEmployeeAssignedToGroup", null);
__decorate([
    (0, event_emitter_1.OnEvent)(employee_assigned_event_1.GROUP_EVENTS.EMPLOYEE_REMOVED),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_f = typeof employee_assigned_event_1.EmployeeAssignedEvent !== "undefined" && employee_assigned_event_1.EmployeeAssignedEvent) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], EmployeeGroupAssignmentListener.prototype, "handleEmployeeRemovedFromGroup", null);
exports.EmployeeGroupAssignmentListener = EmployeeGroupAssignmentListener = EmployeeGroupAssignmentListener_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof cutoffs_service_1.CutoffsService !== "undefined" && cutoffs_service_1.CutoffsService) === "function" ? _a : Object, typeof (_b = typeof schedule_generation_service_1.ScheduleGenerationService !== "undefined" && schedule_generation_service_1.ScheduleGenerationService) === "function" ? _b : Object, typeof (_c = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _c : Object])
], EmployeeGroupAssignmentListener);


/***/ }),
/* 167 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonService = void 0;
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
let CommonService = class CommonService {
    constructor(configService) {
        this.configService = configService;
    }
    isProduction() {
        return this.configService.getOrThrow('NODE_ENV') === 'production';
    }
    isDevelopment() {
        return this.configService.getOrThrow('NODE_ENV') === 'development';
    }
};
exports.CommonService = CommonService;
exports.CommonService = CommonService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], CommonService);


/***/ }),
/* 168 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigModule = void 0;
const bull_module_1 = __webpack_require__(169);
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const event_emitter_1 = __webpack_require__(139);
const schedule_1 = __webpack_require__(131);
const config_schema_1 = __webpack_require__(172);
let ConfigModule = class ConfigModule {
};
exports.ConfigModule = ConfigModule;
exports.ConfigModule = ConfigModule = __decorate([
    (0, common_1.Module)({
        imports: [
            config_1.ConfigModule.forRoot({
                isGlobal: true,
                envFilePath: [`.env.stage.${process.env.STAGE}`],
                validationSchema: config_schema_1.configValidationSchema,
            }),
            event_emitter_1.EventEmitterModule.forRoot(),
            bull_module_1.BullModule.forRoot(),
            schedule_1.ScheduleModule.forRoot(),
        ],
        exports: [config_1.ConfigModule, event_emitter_1.EventEmitterModule, bull_module_1.BullModule, schedule_1.ScheduleModule],
    })
], ConfigModule);


/***/ }),
/* 169 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BullModule_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BullModule = void 0;
const bull_1 = __webpack_require__(4);
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const queues_config_1 = __webpack_require__(170);
const queue_factory_service_1 = __webpack_require__(171);
let BullModule = BullModule_1 = class BullModule {
    static forRoot() {
        return {
            module: BullModule_1,
            imports: [
                bull_1.BullModule.forRootAsync({
                    imports: [config_1.ConfigModule],
                    inject: [config_1.ConfigService],
                    useFactory: (configService) => ({
                        redis: {
                            host: configService.get('REDIS_HOST', 'localhost'),
                            port: configService.get('REDIS_PORT', 6379),
                            password: configService.get('REDIS_PASSWORD', undefined),
                        },
                        defaultJobOptions: {
                            attempts: 3,
                            backoff: { type: 'exponential', delay: 1000 },
                            removeOnComplete: true,
                            removeOnFail: false,
                        },
                    }),
                }),
                bull_1.BullModule.registerQueue(...queues_config_1.queues.map((queueConfig) => ({
                    name: queueConfig.name,
                    options: queueConfig.options,
                }))),
            ],
            providers: [queue_factory_service_1.QueueFactoryService],
            exports: [bull_1.BullModule],
        };
    }
};
exports.BullModule = BullModule;
exports.BullModule = BullModule = BullModule_1 = __decorate([
    (0, common_1.Module)({})
], BullModule);


/***/ }),
/* 170 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.queues = void 0;
exports.queues = [
    {
        name: 'notifications',
        options: {
            limiter: {
                max: 100,
                duration: 5000,
            },
            defaultJobOptions: {
                attempts: 3,
                backoff: {
                    type: 'exponential',
                    delay: 2000,
                },
                removeOnComplete: true,
                removeOnFail: false,
            },
        },
    },
    {
        name: 'schedule-generation',
        options: {
            defaultJobOptions: {
                attempts: 3,
                backoff: {
                    type: 'exponential',
                    delay: 5000,
                },
                removeOnComplete: true,
            },
        },
    },
    // Add other queues as needed
];


/***/ }),
/* 171 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueueFactoryService = void 0;
const bull_1 = __webpack_require__(4);
const common_1 = __webpack_require__(5);
const bull_2 = __webpack_require__(158);
let QueueFactoryService = class QueueFactoryService {
    constructor(notificationsQueue, scheduleQueue) {
        this.notificationsQueue = notificationsQueue;
        this.scheduleQueue = scheduleQueue;
        this.queues = new Map();
        this.queues.set('notifications', notificationsQueue);
        this.queues.set('schedule-generation', scheduleQueue);
    }
    getQueue(name) {
        return this.queues.get(name);
    }
    async addJob(queueName, jobName, data, options) {
        const queue = this.getQueue(queueName);
        if (!queue) {
            return null;
        }
        return queue.add(jobName, data, options);
    }
};
exports.QueueFactoryService = QueueFactoryService;
exports.QueueFactoryService = QueueFactoryService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, bull_1.InjectQueue)('notifications')),
    __param(1, (0, bull_1.InjectQueue)('schedule-generation')),
    __metadata("design:paramtypes", [typeof (_a = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _a : Object, typeof (_b = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _b : Object])
], QueueFactoryService);


/***/ }),
/* 172 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configValidationSchema = void 0;
const Joi = __importStar(__webpack_require__(173));
exports.configValidationSchema = Joi.object({
    PORT: Joi.number().default(3000),
    NODE_ENV: Joi.string().default('development'),
    DB_HOST: Joi.string().required(),
    DB_PORT: Joi.number().default(3306).required(),
    DB_USERNAME: Joi.string().required(),
    DB_PASSWORD: Joi.string().required(),
    DB_DATABASE: Joi.string().required(),
    CACHE_TTL: Joi.number().default(60),
    RATE_LIMIT_WINDOW_MS: Joi.number().default(900000),
    RATE_LIMIT_MAX: Joi.number().default(100),
    APP_URL: Joi.string().default('http://localhost:3000'),
    GOOGLE_CLIENT_ID: Joi.string().required(),
    GOOGLE_CLIENT_SECRET: Joi.string().required(),
    GOOGLE_CALLBACK_URL: Joi.string().required(),
    EMAIL_HOST: Joi.string().required(),
    EMAIL_PORT: Joi.number().default(587),
    EMAIL_SECURE: Joi.boolean().default(false),
    EMAIL_USERNAME: Joi.string().required(),
    EMAIL_PASSWORD: Joi.string().required(),
    //ACCESS_TOKEN_SECRET: Joi.string().required(),
    ACCESS_TOKEN_EXPIRATION_MINUTES: Joi.number().default(15),
    // REFRESH_TOKEN_SECRET: Joi.string().required(),
    REFRESH_TOKEN_EXPIRATION_MINUTES: Joi.number().default(10080),
    ACCESS_TOKEN_MAX_AGE: Joi.number().default(900),
    REFRESH_TOKEN_MAX_AGE: Joi.number().default(10080),
    ACCESS_TOKEN_SECRET: Joi.string().required(),
});


/***/ }),
/* 173 */
/***/ ((module) => {

"use strict";
module.exports = require("joi");

/***/ }),
/* 174 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DatabaseModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const config_1 = __webpack_require__(6);
const data_source_1 = __webpack_require__(32);
let DatabaseModule = class DatabaseModule {
};
exports.DatabaseModule = DatabaseModule;
exports.DatabaseModule = DatabaseModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forRootAsync({
                imports: [config_1.ConfigModule],
                inject: [config_1.ConfigService],
                useFactory: (configService) => (Object.assign(Object.assign({}, data_source_1.dataSourceOptions), { autoLoadEntities: true })),
            }),
        ],
    })
], DatabaseModule);


/***/ }),
/* 175 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccountManagementModule = void 0;
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const employee_management_module_1 = __webpack_require__(15);
const roles_module_1 = __webpack_require__(106);
const auth_module_1 = __webpack_require__(176);
const profiles_module_1 = __webpack_require__(214);
const user_seeder_service_1 = __webpack_require__(217);
const sessions_module_1 = __webpack_require__(199);
const users_module_1 = __webpack_require__(107);
let AccountManagementModule = class AccountManagementModule {
};
exports.AccountManagementModule = AccountManagementModule;
exports.AccountManagementModule = AccountManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            roles_module_1.RolesModule,
            auth_module_1.AuthModule,
            sessions_module_1.SessionsModule,
            profiles_module_1.ProfilesModule,
            employee_management_module_1.EmployeeManagementModule,
            core_1.RouterModule.register([
                {
                    path: 'account',
                    module: AccountManagementModule,
                    children: [
                        { path: 'auth', module: auth_module_1.AuthModule },
                        { path: 'users', module: users_module_1.UsersModule },
                        {
                            path: 'profiles',
                            module: profiles_module_1.ProfilesModule
                        },
                        { path: 'sessions', module: sessions_module_1.SessionsModule },
                    ],
                },
            ]),
        ],
        providers: [user_seeder_service_1.UserSeederService],
        exports: [
            auth_module_1.AuthModule,
            sessions_module_1.SessionsModule,
            profiles_module_1.ProfilesModule
        ]
    })
], AccountManagementModule);


/***/ }),
/* 176 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthModule = void 0;
const emails_module_1 = __webpack_require__(177);
const permissions_module_1 = __webpack_require__(105);
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const jwt_1 = __webpack_require__(111);
const passport_1 = __webpack_require__(28);
const jwt_auth_guard_1 = __webpack_require__(27);
const permissions_guard_1 = __webpack_require__(29);
const roles_guard_1 = __webpack_require__(95);
const sessions_module_1 = __webpack_require__(199);
const auth_controller_1 = __webpack_require__(203);
const auth_service_1 = __webpack_require__(207);
const jwt_service_1 = __webpack_require__(110);
const access_token_strategy_1 = __webpack_require__(212);
let AuthModule = class AuthModule {
};
exports.AuthModule = AuthModule;
exports.AuthModule = AuthModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            passport_1.PassportModule.register({ defaultStrategy: 'jwt' }),
            sessions_module_1.SessionsModule,
            permissions_module_1.PermissionsModule,
            jwt_1.JwtModule.registerAsync({
                imports: [config_1.ConfigModule],
                inject: [config_1.ConfigService],
                useFactory: async (configService) => ({
                    secret: configService.get('ACCESS_TOKEN_SECRET'),
                    signOptions: { expiresIn: `${configService.get('ACCESS_TOKEN_EXPIRATION_MINUTES')}m` },
                }),
            }),
            emails_module_1.EmailsModule,
        ],
        providers: [auth_service_1.AuthService, jwt_service_1.JwtService, access_token_strategy_1.AccessTokenStrategy, jwt_auth_guard_1.JwtAuthGuard, permissions_guard_1.PermissionsGuard, roles_guard_1.RolesGuard],
        controllers: [auth_controller_1.AuthController],
        exports: [auth_service_1.AuthService, jwt_service_1.JwtService],
    })
], AuthModule);


/***/ }),
/* 177 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailsModule = void 0;
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const typeorm_1 = __webpack_require__(16);
const email_configurations_module_1 = __webpack_require__(178);
const email_templates_module_1 = __webpack_require__(189);
const emails_controller_1 = __webpack_require__(195);
const emails_service_1 = __webpack_require__(197);
const email_entity_1 = __webpack_require__(185);
const email_seeder_service_1 = __webpack_require__(198);
let EmailsModule = class EmailsModule {
};
exports.EmailsModule = EmailsModule;
exports.EmailsModule = EmailsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([email_entity_1.Email]),
            core_1.RouterModule.register([
                {
                    path: 'emails',
                    module: EmailsModule,
                },
            ]),
            email_templates_module_1.EmailTemplatesModule,
            email_configurations_module_1.EmailConfigurationsModule,
        ],
        providers: [email_seeder_service_1.EmailSeederService, emails_service_1.EmailsService],
        exports: [
            emails_service_1.EmailsService,
            email_templates_module_1.EmailTemplatesModule,
            email_configurations_module_1.EmailConfigurationsModule,
        ],
        controllers: [emails_controller_1.EmailsController],
    })
], EmailsModule);


/***/ }),
/* 178 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailConfigurationsModule = void 0;
const mailer_1 = __webpack_require__(179);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const email_configurations_controller_1 = __webpack_require__(180);
const email_configurations_service_1 = __webpack_require__(182);
const email_configuration_entity_1 = __webpack_require__(184);
const dynamic_mailer_config_service_1 = __webpack_require__(187);
let EmailConfigurationsModule = class EmailConfigurationsModule {
};
exports.EmailConfigurationsModule = EmailConfigurationsModule;
exports.EmailConfigurationsModule = EmailConfigurationsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([email_configuration_entity_1.EmailConfiguration]),
            mailer_1.MailerModule.forRootAsync({
                imports: [EmailConfigurationsModule], // Import the module that provides the service
                useClass: dynamic_mailer_config_service_1.DynamicMailerConfigService, // Use useExisting instead of useClass
            }),
        ],
        providers: [email_configurations_service_1.EmailConfigurationsService, dynamic_mailer_config_service_1.DynamicMailerConfigService],
        exports: [email_configurations_service_1.EmailConfigurationsService, dynamic_mailer_config_service_1.DynamicMailerConfigService],
        controllers: [email_configurations_controller_1.EmailConfigurationsController],
    })
], EmailConfigurationsModule);


/***/ }),
/* 179 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs-modules/mailer");

/***/ }),
/* 180 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailConfigurationsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const email_configuration_dto_1 = __webpack_require__(181);
const email_configurations_service_1 = __webpack_require__(182);
const email_configuration_entity_1 = __webpack_require__(184);
class EmailConfigurationsController extends (0, create_controller_factory_1.createController)(email_configuration_entity_1.EmailConfiguration, email_configurations_service_1.EmailConfigurationsService, email_configuration_dto_1.GetEmailConfigurationDto, email_configuration_dto_1.EmailConfigurationDto, email_configuration_dto_1.UpdateEmailConfigurationDto) {
}
exports.EmailConfigurationsController = EmailConfigurationsController;


/***/ }),
/* 181 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetEmailConfigurationDto = exports.UpdateEmailConfigurationDto = exports.EmailConfigurationDto = void 0;
const base_dto_1 = __webpack_require__(101);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class EmailConfigurationDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.EmailConfigurationDto = EmailConfigurationDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the email configuration',
        example: 'Gmail SMTP'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of the email configuration',
        required: false,
        example: 'Gmail SMTP server for sending notifications'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'SMTP server host',
        example: 'smtp.gmail.com'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "host", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'SMTP server port',
        example: 587,
        type: Number
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    __metadata("design:type", Number)
], EmailConfigurationDto.prototype, "port", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether to use secure connection (TLS/SSL)',
        example: false,
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], EmailConfigurationDto.prototype, "secure", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'SMTP username',
        example: 'user@example.com'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'SMTP password',
        example: 'password123'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Email address to send emails from',
        example: 'noreply@example.com'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEmail)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "fromEmail", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Display name for the from email address',
        required: false,
        example: 'Example System'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailConfigurationDto.prototype, "fromName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether this is the default email configuration',
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], EmailConfigurationDto.prototype, "isDefault", void 0);
class UpdateEmailConfigurationDto extends (0, swagger_1.PartialType)(EmailConfigurationDto) {
}
exports.UpdateEmailConfigurationDto = UpdateEmailConfigurationDto;
class GetEmailConfigurationDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateEmailConfigurationDto, 'email configuration') {
}
exports.GetEmailConfigurationDto = GetEmailConfigurationDto;


/***/ }),
/* 182 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailConfigurationsService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const typeorm_1 = __webpack_require__(16);
const nodemailer = __importStar(__webpack_require__(183));
const typeorm_2 = __webpack_require__(25);
const email_configuration_entity_1 = __webpack_require__(184);
let EmailConfigurationsService = class EmailConfigurationsService extends base_service_1.BaseService {
    constructor(emailConfigurationsRepository, usersService, configService) {
        super(emailConfigurationsRepository, usersService);
        this.emailConfigurationsRepository = emailConfigurationsRepository;
        this.usersService = usersService;
        this.configService = configService;
    }
    async findByName(name) {
        const config = await this.emailConfigurationsRepository.findOne({ where: { name } });
        if (!config) {
            throw new common_1.NotFoundException(`Email configuration with name ${name} not found`);
        }
        return config;
    }
    async testConnection(config) {
        try {
            const transporter = nodemailer.createTransport({
                host: config.host,
                port: config.port,
                secure: config.secure,
                auth: {
                    user: config.username,
                    pass: config.password,
                },
            });
            await transporter.verify();
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`SMTP connection test failed: ${errorMessage}`);
            return false;
        }
    }
    async getMailerOptions() {
        try {
            // First try to get default configuration from database
            return await this.getDefaultConfiguration();
        }
        catch (error) {
            // If no default config in database, fall back to environment variables
            return {
                host: this.configService.getOrThrow('EMAIL_HOST'),
                port: this.configService.getOrThrow('EMAIL_PORT'),
                secure: this.configService.getOrThrow('EMAIL_SECURE'),
                username: this.configService.getOrThrow('EMAIL_USERNAME'),
                password: this.configService.getOrThrow('EMAIL_PASSWORD'),
                fromEmail: this.configService.getOrThrow('EMAIL_FROM'),
                fromName: this.configService.getOrThrow('EMAIL_FROM_NAME'),
            };
        }
    }
    async getDefaultConfiguration() {
        const config = await this.emailConfigurationsRepository.findOne({
            where: { isDefault: true, isDeleted: false },
            select: ['id', 'name', 'host', 'port', 'secure', 'username', 'password', 'fromEmail', 'fromName']
        });
        if (!config) {
            throw new common_1.NotFoundException('No default email configuration found');
        }
        return config;
    }
    async getDepartmentConfiguration(departmentId) {
        const config = await this.emailConfigurationsRepository.findOne({
            where: { departmentId, isDeleted: false },
            select: ['id', 'name', 'host', 'port', 'secure', 'username', 'password', 'fromEmail', 'fromName']
        });
        if (!config) {
            return this.getDefaultConfiguration();
        }
        return config;
    }
    async getOrganizationConfiguration(organizationId) {
        const config = await this.emailConfigurationsRepository.findOne({
            where: { organizationId, isDeleted: false },
            select: ['id', 'name', 'host', 'port', 'secure', 'username', 'password', 'fromEmail', 'fromName']
        });
        if (!config) {
            return this.getDefaultConfiguration();
        }
        return config;
    }
    async getBranchConfiguration(branchId) {
        const config = await this.emailConfigurationsRepository.findOne({
            where: { branchId, isDeleted: false },
            select: ['id', 'name', 'host', 'port', 'secure', 'username', 'password', 'fromEmail', 'fromName']
        });
        if (!config) {
            return this.getDefaultConfiguration();
        }
        return config;
    }
    async setAsDefault(id) {
        // First, remove default status from all configurations
        await this.emailConfigurationsRepository.update({}, { isDefault: false });
        // Then set the specified one as default
        await this.emailConfigurationsRepository.update(id, { isDefault: true });
        return this.findOneByOrFail({ id });
    }
};
exports.EmailConfigurationsService = EmailConfigurationsService;
exports.EmailConfigurationsService = EmailConfigurationsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(email_configuration_entity_1.EmailConfiguration)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object])
], EmailConfigurationsService);


/***/ }),
/* 183 */
/***/ ((module) => {

"use strict";
module.exports = require("nodemailer");

/***/ }),
/* 184 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailConfiguration = void 0;
const base_entity_1 = __webpack_require__(34);
const typeorm_1 = __webpack_require__(25);
const email_entity_1 = __webpack_require__(185);
let EmailConfiguration = class EmailConfiguration extends base_entity_1.BaseEntity {
};
exports.EmailConfiguration = EmailConfiguration;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "host", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'int' }),
    __metadata("design:type", Number)
], EmailConfiguration.prototype, "port", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], EmailConfiguration.prototype, "secure", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "username", void 0);
__decorate([
    (0, typeorm_1.Column)({ select: false }),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "password", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "fromEmail", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], EmailConfiguration.prototype, "fromName", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], EmailConfiguration.prototype, "isDefault", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => email_entity_1.Email, (email) => email.emailConfiguration, { cascade: true, nullable: true }),
    __metadata("design:type", Array)
], EmailConfiguration.prototype, "emails", void 0);
exports.EmailConfiguration = EmailConfiguration = __decorate([
    (0, typeorm_1.Entity)('email-configurations')
], EmailConfiguration);


/***/ }),
/* 185 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Email = void 0;
const email_status_enum_1 = __webpack_require__(186);
const base_entity_1 = __webpack_require__(34);
const typeorm_1 = __webpack_require__(25);
const email_configuration_entity_1 = __webpack_require__(184);
let Email = class Email extends base_entity_1.BaseEntity {
};
exports.Email = Email;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Email.prototype, "to", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Email.prototype, "cc", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Email.prototype, "bcc", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], Email.prototype, "subject", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], Email.prototype, "htmlContent", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], Email.prototype, "textContent", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], Email.prototype, "sentAt", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'enum', enum: email_status_enum_1.EmailStatus }),
    __metadata("design:type", typeof (_b = typeof email_status_enum_1.EmailStatus !== "undefined" && email_status_enum_1.EmailStatus) === "function" ? _b : Object)
], Email.prototype, "status", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Email.prototype, "error", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Email.prototype, "templateName", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => email_configuration_entity_1.EmailConfiguration, (emailConfiguration) => emailConfiguration.emails),
    (0, typeorm_1.JoinColumn)({ name: 'emailConfigurationId' }),
    __metadata("design:type", typeof (_c = typeof email_configuration_entity_1.EmailConfiguration !== "undefined" && email_configuration_entity_1.EmailConfiguration) === "function" ? _c : Object)
], Email.prototype, "emailConfiguration", void 0);
exports.Email = Email = __decorate([
    (0, typeorm_1.Entity)('emails')
], Email);


/***/ }),
/* 186 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailStatus = void 0;
var EmailStatus;
(function (EmailStatus) {
    EmailStatus["SENT"] = "SENT";
    EmailStatus["FAILED"] = "FAILED";
    EmailStatus["PENDING"] = "PENDING";
    EmailStatus["QUEUED"] = "QUEUED";
    EmailStatus["DELIVERED"] = "DELIVERED";
    EmailStatus["OPENED"] = "OPENED";
    EmailStatus["CLICKED"] = "CLICKED";
    EmailStatus["UNSUBSCRIBED"] = "UNSUBSCRIBED";
    EmailStatus["SPAM"] = "SPAM";
    EmailStatus["BOUNCED"] = "BOUNCED";
    EmailStatus["COMPLAINED"] = "COMPLAINED";
    EmailStatus["DELAYED"] = "DELAYED";
    EmailStatus["REJECTED"] = "REJECTED";
    EmailStatus["INVALID"] = "INVALID";
})(EmailStatus || (exports.EmailStatus = EmailStatus = {}));


/***/ }),
/* 187 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicMailerConfigService = void 0;
const handlebars_adapter_1 = __webpack_require__(188);
const common_1 = __webpack_require__(5);
const email_configurations_service_1 = __webpack_require__(182);
let DynamicMailerConfigService = class DynamicMailerConfigService {
    constructor(emailConfigService) {
        this.emailConfigService = emailConfigService;
    }
    async createMailerOptions() {
        // Get default configuration from database
        const defaultConfig = await this.emailConfigService.getMailerOptions();
        return {
            transport: {
                host: defaultConfig.host,
                port: defaultConfig.port,
                secure: defaultConfig.secure,
                auth: {
                    user: defaultConfig.username,
                    pass: defaultConfig.password,
                },
                debug: process.env.NODE_ENV !== 'production', // Enable debug output
                logger: process.env.NODE_ENV !== 'production', // Log to console
            },
            defaults: {
                from: `"${defaultConfig.fromName || defaultConfig.fromEmail}" <${defaultConfig.fromEmail}>`,
            },
            template: {
                // We'll use in-memory templates instead of filesystem templates
                // since our templates are stored in the database
                adapter: new handlebars_adapter_1.HandlebarsAdapter({
                    // Global helpers can be added here
                    formatDate: (value) => new Date(value).toLocaleDateString(),
                    year: () => new Date().getFullYear(),
                }),
                options: {
                    strict: true,
                },
            },
        };
    }
};
exports.DynamicMailerConfigService = DynamicMailerConfigService;
exports.DynamicMailerConfigService = DynamicMailerConfigService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof email_configurations_service_1.EmailConfigurationsService !== "undefined" && email_configurations_service_1.EmailConfigurationsService) === "function" ? _a : Object])
], DynamicMailerConfigService);


/***/ }),
/* 188 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs-modules/mailer/dist/adapters/handlebars.adapter");

/***/ }),
/* 189 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailTemplatesModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const email_templates_controller_1 = __webpack_require__(190);
const email_templates_service_1 = __webpack_require__(192);
const email_template_entity_1 = __webpack_require__(194);
let EmailTemplatesModule = class EmailTemplatesModule {
};
exports.EmailTemplatesModule = EmailTemplatesModule;
exports.EmailTemplatesModule = EmailTemplatesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([email_template_entity_1.EmailTemplate]),
        ],
        providers: [email_templates_service_1.EmailTemplatesService],
        exports: [email_templates_service_1.EmailTemplatesService],
        controllers: [email_templates_controller_1.EmailTemplatesController],
    })
], EmailTemplatesModule);


/***/ }),
/* 190 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailTemplatesController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const email_template_dto_1 = __webpack_require__(191);
const email_templates_service_1 = __webpack_require__(192);
const email_template_entity_1 = __webpack_require__(194);
class EmailTemplatesController extends (0, create_controller_factory_1.createController)(email_template_entity_1.EmailTemplate, email_templates_service_1.EmailTemplatesService, email_template_dto_1.GetEmailTemplateDto, email_template_entity_1.EmailTemplate, email_template_dto_1.UpdateEmailTemplateDto) {
    async previewTemplate(body) {
        return this.baseService.renderTemplate(body.templateName, body.context, body.department);
    }
}
exports.EmailTemplatesController = EmailTemplatesController;
__decorate([
    (0, common_1.Post)('templates/preview'),
    (0, swagger_1.ApiOperation)({ summary: 'Preview rendered email template' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], EmailTemplatesController.prototype, "previewTemplate", null);


/***/ }),
/* 191 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetEmailTemplateDto = exports.UpdateEmailTemplateDto = exports.EmailTemplateDto = void 0;
const base_dto_1 = __webpack_require__(101);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
const swagger_2 = __webpack_require__(8);
class EmailTemplateDto extends (0, swagger_2.PartialType)(base_dto_1.BaseDto) {
}
exports.EmailTemplateDto = EmailTemplateDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the email-template' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailTemplateDto.prototype, "name", void 0);
class UpdateEmailTemplateDto extends (0, swagger_2.PartialType)(EmailTemplateDto) {
}
exports.UpdateEmailTemplateDto = UpdateEmailTemplateDto;
class GetEmailTemplateDto extends (0, create_get_dto_factory_1.createGetDto)(EmailTemplateDto) {
}
exports.GetEmailTemplateDto = GetEmailTemplateDto;


/***/ }),
/* 192 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailTemplatesService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const Handlebars = __importStar(__webpack_require__(193));
const typeorm_2 = __webpack_require__(25);
const email_template_entity_1 = __webpack_require__(194);
let EmailTemplatesService = class EmailTemplatesService extends base_service_1.BaseService {
    constructor(emailTemplatesRepository, usersService) {
        super(emailTemplatesRepository, usersService);
        this.emailTemplatesRepository = emailTemplatesRepository;
        this.usersService = usersService;
    }
    async findByName(name) {
        const template = await this.emailTemplatesRepository.findOne({ where: { name, isActive: true } });
        if (!template) {
            throw new common_1.NotFoundException(`Email template with name ${name} not found`);
        }
        return template;
    }
    async findDepartmentTemplate(name, departmentId) {
        const template = await this.emailTemplatesRepository.findOne({
            where: { name, departmentId, isActive: true }
        });
        if (!template) {
            // Fall back to general template if department-specific not found
            return this.findByName(name);
        }
        return template;
    }
    async renderTemplate(name, context, department) {
        // Get the appropriate template based on department or default
        const template = department
            ? await this.findDepartmentTemplate(name, department).catch(() => this.findByName(name))
            : await this.findByName(name);
        // Compile the templates
        const compiledSubject = Handlebars.compile(template.subject);
        const compiledHtml = Handlebars.compile(template.htmlContent);
        const compiledText = template.textContent ? Handlebars.compile(template.textContent) : null;
        // Render with provided context
        return {
            subject: compiledSubject(context),
            html: compiledHtml(context),
            text: compiledText ? compiledText(context) : undefined,
        };
    }
    async validateContext(templateName, context) {
        const template = await this.findByName(templateName);
        const missingVariables = [];
        if (template.requiredVariables) {
            for (const variable of template.requiredVariables) {
                if (context[variable] === undefined) {
                    missingVariables.push(variable);
                }
            }
        }
        return {
            isValid: missingVariables.length === 0,
            missingVariables
        };
    }
};
exports.EmailTemplatesService = EmailTemplatesService;
exports.EmailTemplatesService = EmailTemplatesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(email_template_entity_1.EmailTemplate)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], EmailTemplatesService);


/***/ }),
/* 193 */
/***/ ((module) => {

"use strict";
module.exports = require("handlebars");

/***/ }),
/* 194 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailTemplate = void 0;
const base_entity_1 = __webpack_require__(34);
const typeorm_1 = __webpack_require__(25);
let EmailTemplate = class EmailTemplate extends base_entity_1.BaseEntity {
};
exports.EmailTemplate = EmailTemplate;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], EmailTemplate.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], EmailTemplate.prototype, "description", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], EmailTemplate.prototype, "subject", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], EmailTemplate.prototype, "htmlContent", void 0);
__decorate([
    (0, typeorm_1.Column)('text', { nullable: true }),
    __metadata("design:type", String)
], EmailTemplate.prototype, "textContent", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], EmailTemplate.prototype, "isActive", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", Array)
], EmailTemplate.prototype, "requiredVariables", void 0);
__decorate([
    (0, typeorm_1.Column)('json', { nullable: true }),
    __metadata("design:type", Array)
], EmailTemplate.prototype, "optionalVariables", void 0);
exports.EmailTemplate = EmailTemplate = __decorate([
    (0, typeorm_1.Entity)('email-templates')
], EmailTemplate);


/***/ }),
/* 195 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const email_dto_1 = __webpack_require__(196);
const emails_service_1 = __webpack_require__(197);
const email_entity_1 = __webpack_require__(185);
class EmailsController extends (0, create_controller_factory_1.createController)(email_entity_1.Email, emails_service_1.EmailsService, email_dto_1.GetEmailDto, email_dto_1.EmailDto, email_dto_1.UpdateEmailDto) {
    // // Email sending endpoints
    // @Post('send')
    // @HttpCode(HttpStatus.OK)
    // @ApiOperation({ summary: 'Send an email' })
    // @ApiResponse({ status: HttpStatus.OK, description: 'Email sent successfully' })
    // async sendEmail(@Body() sendEmailDto: EmailDto): Promise<{ success: boolean; message: string }> {
    //   const result = await this.baseService.send(sendEmailDto);
    //   return {
    //     success: result,
    //     message: result 
    //       ? 'Email sent successfully' 
    //       : 'Failed to send email',
    //   };
    // }
    async sendTemplatedEmail(body) {
        const result = await this.baseService.sendTemplatedEmail(body.to, body.templateName, body.context, {
            cc: body.cc,
            bcc: body.bcc,
            department: body.department,
            organization: body.organization,
        });
        return {
            success: result,
            message: result
                ? 'Templated email sent successfully'
                : 'Failed to send templated email',
        };
    }
}
exports.EmailsController = EmailsController;
__decorate([
    (0, common_1.Post)('send-template'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Send a templated email' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Email sent successfully' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], EmailsController.prototype, "sendTemplatedEmail", null);


/***/ }),
/* 196 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetEmailDto = exports.UpdateEmailDto = exports.EmailDto = void 0;
const base_dto_1 = __webpack_require__(101);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
const swagger_2 = __webpack_require__(8);
class EmailDto extends (0, swagger_2.PartialType)(base_dto_1.BaseDto) {
}
exports.EmailDto = EmailDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the email' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], EmailDto.prototype, "name", void 0);
class UpdateEmailDto extends (0, swagger_2.PartialType)(EmailDto) {
}
exports.UpdateEmailDto = UpdateEmailDto;
class GetEmailDto extends (0, create_get_dto_factory_1.createGetDto)(EmailDto) {
}
exports.GetEmailDto = GetEmailDto;


/***/ }),
/* 197 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailsService = void 0;
const email_status_enum_1 = __webpack_require__(186);
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const mailer_1 = __webpack_require__(179);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const email_configurations_service_1 = __webpack_require__(182);
const email_templates_service_1 = __webpack_require__(192);
const email_entity_1 = __webpack_require__(185);
let EmailsService = class EmailsService extends base_service_1.BaseService {
    constructor(emailsRepository, usersService, emailConfigService, emailTemplateService, mailerService) {
        super(emailsRepository, usersService);
        this.emailsRepository = emailsRepository;
        this.usersService = usersService;
        this.emailConfigService = emailConfigService;
        this.emailTemplateService = emailTemplateService;
        this.mailerService = mailerService;
    }
    /**
     * Send an email with complete flexibility for sender configuration
     */
    async send(options) {
        // Create a database record immediately with PENDING status
        const emailRecord = new email_entity_1.Email({});
        emailRecord.to = Array.isArray(options.to) ? options.to.join(', ') : options.to;
        emailRecord.cc = Array.isArray(options.cc) ? options.cc.join(', ') : options.cc;
        emailRecord.bcc = Array.isArray(options.bcc) ? options.bcc.join(', ') : options.bcc;
        emailRecord.subject = options.subject || '';
        emailRecord.templateName = options.templateName;
        emailRecord.status = email_status_enum_1.EmailStatus.PENDING;
        emailRecord.sentAt = new Date();
        try {
            // Determine which email configuration to use
            let emailConfig;
            if (options.configId) {
                emailConfig = await this.emailConfigService.findOneByOrFail({ id: options.configId });
            }
            else if (options.configName) {
                emailConfig = await this.emailConfigService.findByName(options.configName);
            }
            else if (options.department) {
                emailConfig = await this.emailConfigService.getDepartmentConfiguration(options.department);
            }
            else if (options.organization) {
                emailConfig = await this.emailConfigService.getOrganizationConfiguration(options.organization);
            }
            else if (options.branch) {
                emailConfig = await this.emailConfigService.getBranchConfiguration(options.branch);
            }
            else {
                emailConfig = await this.emailConfigService.getDefaultConfiguration();
            }
            // Set the email configuration relationship
            emailRecord.emailConfiguration = emailConfig;
            // test connection first before sending
            const testConnection = await this.emailConfigService.testConnection(emailConfig);
            if (!testConnection) {
                this.logger.error(`Failed to connect to email server for configuration: ${emailConfig.name}`);
                return false;
            }
            // Prepare email content
            let subject = options.subject;
            let html = options.html;
            let text = options.text;
            // If using a template
            if (options.templateName) {
                const validation = await this.emailTemplateService.validateContext(options.templateName, options.templateContext || {});
                if (!validation.isValid) {
                    const errorMsg = `Missing required variables for template ${options.templateName}: ${validation.missingVariables.join(', ')}`;
                    this.logger.error(errorMsg);
                    // Update the email record with FAILED status
                    emailRecord.status = email_status_enum_1.EmailStatus.FAILED;
                    emailRecord.error = errorMsg;
                    await this.emailsRepository.save(emailRecord);
                    return false;
                }
                const rendered = await this.emailTemplateService.renderTemplate(options.templateName, options.templateContext || {}, options.department);
                subject = rendered.subject;
                html = rendered.html;
                text = rendered.text;
            }
            // Update email record with content
            emailRecord.subject = subject || '';
            emailRecord.htmlContent = html;
            emailRecord.textContent = text;
            // Create a unique transporter name based on the configuration
            const transporterName = `config_${emailConfig.id}`;
            // Add or update the transporter for this configuration
            this.mailerService.addTransporter(transporterName, {
                host: emailConfig.host,
                port: emailConfig.port,
                secure: emailConfig.secure,
                auth: {
                    user: emailConfig.username,
                    pass: emailConfig.password,
                },
            });
            // Send the email using the specific transporter
            const mailOptions = {
                to: options.to,
                cc: options.cc,
                bcc: options.bcc,
                subject,
                text,
                html,
                attachments: options.attachments,
                from: options.from || `"${emailConfig.fromName || emailConfig.fromEmail}" <${emailConfig.fromEmail}>`,
                transporterName: transporterName, // Use the transporter we just added
            };
            await this.mailerService.sendMail(mailOptions);
            // You can also send the email to the platform emails for the recipients in here
            //
            /// Update the email record with SENT status
            emailRecord.status = email_status_enum_1.EmailStatus.SENT;
            await this.emailsRepository.save(emailRecord);
            this.logger.log(`Email sent to ${options.to}, subject: ${subject}, using config: ${emailConfig.name}`);
            return true;
        }
        catch (error) {
            const errorMessage = `Failed to send email: ${error instanceof Error ? error.message : 'Unknown error'}`;
            this.logger.error(errorMessage, error instanceof Error ? error.stack : undefined);
            // Update the email record with FAILED status and error details
            emailRecord.status = email_status_enum_1.EmailStatus.FAILED;
            emailRecord.error = errorMessage;
            await this.emailsRepository.save(emailRecord);
            return false;
        }
    }
    /**
     * Send a templated email with simpler options
     */
    async sendTemplatedEmail(to, templateName, context, options = {}) {
        return this.send({
            to,
            cc: options.cc,
            bcc: options.bcc,
            templateName,
            templateContext: context,
            department: options.department,
            organization: options.organization,
            branch: options.branch,
            attachments: options.attachments,
        });
    }
    /**
     * Send a direct email without a template
     */
    async sendDirectEmail(to, subject, content, options = {}) {
        return this.send({
            to,
            cc: options.cc,
            bcc: options.bcc,
            subject,
            html: content.html,
            text: content.text,
            department: options.department,
            organization: options.organization,
            branch: options.branch,
            attachments: options.attachments,
        });
    }
    /**
     * Send a notification to multiple recipients
     */
    async sendBulkNotification(recipients, subject, content, options = {}) {
        const batchSize = options.batchSize || 50;
        let success = 0;
        let failed = 0;
        // Process in batches to avoid overwhelming the email server
        for (let i = 0; i < recipients.length; i += batchSize) {
            const batch = recipients.slice(i, i + batchSize);
            for (const recipient of batch) {
                let result;
                if ('templateName' in content) {
                    result = await this.sendTemplatedEmail(recipient, content.templateName, content.context, {
                        department: options.department,
                        organization: options.organization,
                    });
                }
                else {
                    result = await this.sendDirectEmail(recipient, subject, { html: content.html, text: content.text }, {
                        department: options.department,
                        organization: options.organization,
                    });
                }
                if (result) {
                    success++;
                }
                else {
                    failed++;
                }
            }
            // Add a small delay between batches
            if (i + batchSize < recipients.length) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
        return { success, failed };
    }
};
exports.EmailsService = EmailsService;
exports.EmailsService = EmailsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(email_entity_1.Email)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof email_configurations_service_1.EmailConfigurationsService !== "undefined" && email_configurations_service_1.EmailConfigurationsService) === "function" ? _c : Object, typeof (_d = typeof email_templates_service_1.EmailTemplatesService !== "undefined" && email_templates_service_1.EmailTemplatesService) === "function" ? _d : Object, typeof (_e = typeof mailer_1.MailerService !== "undefined" && mailer_1.MailerService) === "function" ? _e : Object])
], EmailsService);


/***/ }),
/* 198 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var EmailSeederService_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailSeederService = void 0;
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const email_configurations_service_1 = __webpack_require__(182);
const email_templates_service_1 = __webpack_require__(192);
let EmailSeederService = EmailSeederService_1 = class EmailSeederService {
    constructor(emailConfigService, emailTemplatesService, configService) {
        this.emailConfigService = emailConfigService;
        this.emailTemplatesService = emailTemplatesService;
        this.configService = configService;
        this.logger = new common_1.Logger(EmailSeederService_1.name);
    }
    async onModuleInit() {
        await this.seedDefaultEmailConfiguration();
        await this.seedDefaultEmailTemplates();
    }
    async seedDefaultEmailConfiguration() {
        try {
            // Check if a default configuration already exists
            try {
                await this.emailConfigService.getDefaultConfiguration();
                // this.logger.log('Default email configuration already exists, skipping seeder');
                return;
            }
            catch (error) {
                // No default config exists, proceed with seeding
                // this.logger.log('Creating default email configuration...');
            }
            // Create default email configuration using environment variables
            const defaultConfig = await this.emailConfigService.create({
                name: 'Default System Email',
                description: 'Default email configuration for system emails like verification, password reset, etc.',
                host: this.configService.getOrThrow('EMAIL_HOST'),
                port: this.configService.getOrThrow('EMAIL_PORT'),
                secure: this.configService.getOrThrow('EMAIL_SECURE'),
                username: this.configService.getOrThrow('EMAIL_USERNAME'),
                password: this.configService.getOrThrow('EMAIL_PASSWORD'),
                fromEmail: this.configService.getOrThrow('EMAIL_FROM'),
                fromName: this.configService.getOrThrow('EMAIL_FROM_NAME'),
                isDefault: true,
            });
            // this.logger.log(`Default email configuration created: ${defaultConfig.id}`);
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Failed to seed default email configuration: ${errorMessage}`);
        }
    }
    async seedDefaultEmailTemplates() {
        try {
            // Define default templates to seed
            const templates = [
                {
                    name: 'email-verification',
                    subject: 'Verify Your Email Address',
                    description: 'Email sent to users to verify their email address',
                    htmlContent: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h2>Verify Your Email Address</h2>
              <p>Hello {{firstName}},</p>
              <p>Thank you for registering. Please click the button below to verify your email address:</p>
              <p style="text-align: center;">
                <a href="{{verificationUrl}}" style="background-color: #4CAF50; color: white; padding: 10px 20px; text-decoration: none; border-radius: 4px; display: inline-block;">
                  Verify Email
                </a>
              </p>
              <p>If the button doesn't work, you can copy and paste this link into your browser:</p>
              <p>{{verificationUrl}}</p>
              <p>This link will expire in {{expiry}} hours.</p>
              <p>If you didn't create an account, you can safely ignore this email.</p>
              <p>Thanks,<br>The Team</p>
            </div>
          `,
                    textContent: `
            Verify Your Email Address
            
            Hello {{firstName}},
            
            Thank you for registering. Please click the link below to verify your email address:
            
            {{verificationUrl}}
            
            This link will expire in {{expiry}} hours.
            
            If you didn't create an account, you can safely ignore this email.
            
            Thanks,
            The Team
          `,
                    requiredVariables: ['firstName', 'verificationUrl', 'expiry'],
                    optionalVariables: ['lastName'],
                    isActive: true,
                },
                {
                    name: 'password-reset',
                    subject: 'Reset Your Password',
                    description: 'Email sent to users to reset their password',
                    htmlContent: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h2>Reset Your Password</h2>
              <p>Hello {{firstName}},</p>
              <p>We received a request to reset your password. Click the button below to set a new password:</p>
              <p style="text-align: center;">
                <a href="{{resetUrl}}" style="background-color: #4CAF50; color: white; padding: 10px 20px; text-decoration: none; border-radius: 4px; display: inline-block;">
                  Reset Password
                </a>
              </p>
              <p>If the button doesn't work, you can copy and paste this link into your browser:</p>
              <p>{{resetUrl}}</p>
              <p>This link will expire in 1 hour.</p>
              <p>If you didn't request a password reset, you can safely ignore this email.</p>
              <p>Thanks,<br>The Team</p>
            </div>
          `,
                    textContent: `
            Reset Your Password
            
            Hello {{firstName}},
            
            We received a request to reset your password. Click the link below to set a new password:
            
            {{resetUrl}}
            
            This link will expire in 1 hour.
            
            If you didn't request a password reset, you can safely ignore this email.
            
            Thanks,
            The Team
          `,
                    requiredVariables: ['firstName', 'resetUrl'],
                    optionalVariables: ['lastName'],
                    isActive: true,
                },
                {
                    name: 'welcome',
                    subject: 'Welcome to {{appName}}',
                    description: 'Welcome email sent to users after registration',
                    htmlContent: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h2>Welcome to {{appName}}!</h2>
              <p>Hello {{firstName}},</p>
              <p>Thank you for joining us. We're excited to have you as a member of our community.</p>
              <p>Here are a few things you can do to get started:</p>
              <ul>
                <li>Complete your profile</li>
                <li>Explore our features</li>
                <li>Connect with other members</li>
              </ul>
              <p>If you have any questions, feel free to reply to this email.</p>
              <p>Best regards,<br>The {{appName}} Team</p>
            </div>
          `,
                    textContent: `
            Welcome to {{appName}}!
            
            Hello {{firstName}},
            
            Thank you for joining us. We're excited to have you as a member of our community.
            
            Here are a few things you can do to get started:
            - Complete your profile
            - Explore our features
            - Connect with other members
            
            If you have any questions, feel free to reply to this email.
            
            Best regards,
            The {{appName}} Team
          `,
                    requiredVariables: ['firstName', 'appName'],
                    optionalVariables: ['lastName'],
                    isActive: true,
                }
            ];
            // Seed each template if it doesn't exist
            for (const template of templates) {
                // Check if template already exists
                try {
                    await this.emailTemplatesService.findByName(template.name);
                    // this.logger.log(`Email template '${template.name}' already exists, skipping`);
                }
                catch (error) {
                    // Template doesn't exist, create it
                    const createdTemplate = await this.emailTemplatesService.create(template);
                    // this.logger.log(`Created email template: ${template.name} (${createdTemplate.id})`);
                }
            }
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Failed to seed email templates: ${errorMessage}`);
        }
    }
};
exports.EmailSeederService = EmailSeederService;
exports.EmailSeederService = EmailSeederService = EmailSeederService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof email_configurations_service_1.EmailConfigurationsService !== "undefined" && email_configurations_service_1.EmailConfigurationsService) === "function" ? _a : Object, typeof (_b = typeof email_templates_service_1.EmailTemplatesService !== "undefined" && email_templates_service_1.EmailTemplatesService) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object])
], EmailSeederService);


/***/ }),
/* 199 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionsModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const session_entity_1 = __webpack_require__(84);
const sessions_controller_1 = __webpack_require__(200);
const sessions_service_1 = __webpack_require__(202);
let SessionsModule = class SessionsModule {
};
exports.SessionsModule = SessionsModule;
exports.SessionsModule = SessionsModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([session_entity_1.Session])],
        providers: [sessions_service_1.SessionsService],
        exports: [sessions_service_1.SessionsService],
        controllers: [sessions_controller_1.SessionsController],
    })
], SessionsModule);


/***/ }),
/* 200 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const session_dto_1 = __webpack_require__(201);
const session_entity_1 = __webpack_require__(84);
const sessions_service_1 = __webpack_require__(202);
class SessionsController extends (0, create_controller_factory_1.createController)(session_entity_1.Session, sessions_service_1.SessionsService, session_dto_1.GetSessionDto, undefined, session_dto_1.UpdateSessionDto) {
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async delete(id) {
        return await super.delete(id);
    }
}
exports.SessionsController = SessionsController;


/***/ }),
/* 201 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetSessionDto = exports.UpdateSessionDto = exports.SessionDto = void 0;
const base_dto_1 = __webpack_require__(101);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class SessionDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.SessionDto = SessionDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'userId123', description: 'The ID of the user' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], SessionDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'refreshToken123', description: 'The refresh token for the session' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], SessionDto.prototype, "refreshToken", void 0);
class UpdateSessionDto extends (0, swagger_1.PartialType)(SessionDto) {
}
exports.UpdateSessionDto = UpdateSessionDto;
class GetSessionDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateSessionDto, 'session') {
}
exports.GetSessionDto = GetSessionDto;


/***/ }),
/* 202 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionsService = void 0;
const base_service_1 = __webpack_require__(31);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const users_service_1 = __webpack_require__(30);
const session_entity_1 = __webpack_require__(84);
let SessionsService = class SessionsService extends base_service_1.BaseService {
    constructor(sessionsRepository, usersService) {
        super(sessionsRepository, usersService);
        this.sessionsRepository = sessionsRepository;
        this.usersService = usersService;
    }
};
exports.SessionsService = SessionsService;
exports.SessionsService = SessionsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(session_entity_1.Session)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], SessionsService);


/***/ }),
/* 203 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthController = void 0;
const authorize_decorator_1 = __webpack_require__(26);
const current_user_decorator_1 = __webpack_require__(97);
const jwt_payload_interface_1 = __webpack_require__(204);
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const express_1 = __webpack_require__(205);
const google_auth_guard_1 = __webpack_require__(206);
const user_dto_1 = __webpack_require__(117);
const users_service_1 = __webpack_require__(30);
const auth_service_1 = __webpack_require__(207);
const login_user_dto_1 = __webpack_require__(209);
const register_user_dto_1 = __webpack_require__(210);
const token_dto_1 = __webpack_require__(211);
let AuthController = class AuthController {
    constructor(authService, usersService) {
        this.authService = authService;
        this.usersService = usersService;
    }
    async googleOAuth() { }
    async login(loginDto, request, response) {
        const login = await this.authService.loginUser(loginDto, request);
        await this.authService.setAuthCookies(response, login);
        return login;
    }
    async verifyEmail(body) {
        const result = await this.authService.verifyEmail(body.token);
        return {
            statusCode: result ? 200 : 400,
            message: result
                ? 'Email verified successfully'
                : 'Invalid or expired verification token',
        };
    }
    async resendVerification(body) {
        const user = await this.usersService.findOneByOrFail({ email: body.email });
        if (user.emailVerified) {
            return {
                message: 'Email is already verified',
            };
        }
        const result = await this.authService.sendVerificationEmail(user);
        return {
            message: result
                ? 'Verification email sent successfully'
                : 'Failed to send verification email',
        };
    }
    // @Public()
    // @Get('google/redirect')
    // @UseGuards(GoogleOAuthGuard)
    // async googleCallback(@Req() request: Request, @Res() response: Response) {
    //   const redirectUrl = new URL(`${this.commonService.getAppUrl}/login`);
    //   const user = request.user as IUser;
    //   try
    //   {
    //     const tokens: Tokens = await this.authService.googleOAuth(user);
    //     const responseWithCookies = this.authService.setAuthCookies(response, tokens);
    //     redirectUrl.searchParams.set('auth', 'success');
    //     return responseWithCookies.redirect(redirectUrl.toString());
    //   }
    //   catch (error) {
    //     redirectUrl.searchParams.set('auth', 'failed');
    //     return response.redirect(redirectUrl.toString());
    //   }
    // }
    async refreshToken(bodyRefreshToken, request, response) {
        var _a;
        // Get refresh token from cookies or request body
        const refreshToken = ((_a = request.cookies) === null || _a === void 0 ? void 0 : _a.refreshToken) ||
            bodyRefreshToken;
        if (!refreshToken) {
            throw new common_1.UnauthorizedException('Refresh token not found');
        }
        const tokens = await this.authService.refreshTokens(refreshToken, request);
        await this.authService.setAuthCookies(response, tokens);
        return tokens;
    }
    async logout(bodyRefreshToken, request, response) {
        var _a;
        // Get refresh token from cookies or request body
        const refreshToken = ((_a = request.cookies) === null || _a === void 0 ? void 0 : _a.refreshToken) ||
            bodyRefreshToken;
        if (!refreshToken) {
            throw new common_1.UnauthorizedException('Refresh token not found');
        }
        await this.authService.logoutUser(refreshToken, response);
        return { message: 'Logged out successfully' };
    }
    async register(registerDto) {
        return (0, class_transformer_1.plainToInstance)(user_dto_1.GetUserDto, this.authService.registerUser(registerDto));
    }
    // @Get('google')
    // @UseGuards(GoogleAuthGuard)
    // @ApiOperation({ summary: 'Login with Google' })
    // @ApiResponse({ status: 200, description: 'Redirect to Google login.' })
    // async googleAuth(@Request() req) {}
    // @Get('google/redirect')
    // @UseGuards(GoogleAuthGuard)
    // @ApiOperation({ summary: 'Google login redirect' })
    // @ApiResponse({ status: 200, description: 'User logged in with Google successfully.' })
    // googleAuthRedirect(@Request() req) {
    //   return this.authService.googleLogin(req);
    // }
    getCurrentUser(user) {
        return user;
    }
};
exports.AuthController = AuthController;
__decorate([
    (0, common_1.Get)('google'),
    (0, common_1.UseGuards)(google_auth_guard_1.GoogleAuthGuard),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "googleOAuth", null);
__decorate([
    (0, common_1.Post)('login'),
    (0, swagger_1.ApiOperation)({ summary: 'Login with email and password' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User logged in successfully.' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, common_1.Res)({ passthrough: true })),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof login_user_dto_1.LoginUserDto !== "undefined" && login_user_dto_1.LoginUserDto) === "function" ? _c : Object, typeof (_d = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _d : Object, typeof (_e = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _e : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "login", null);
__decorate([
    (0, common_1.Post)('verify-email'),
    (0, swagger_1.ApiOperation)({
        summary: 'Verify user email address',
        description: 'Validates the verification token and marks the user\'s email as verified if valid'
    }),
    (0, swagger_1.ApiBody)({
        description: 'Verification token received in the email',
        type: token_dto_1.TokenDto,
        required: true,
        examples: {
            example1: {
                value: { token: 'your-verification-token' },
                description: 'Example of a verification token',
            },
        },
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Email verified successfully'
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Invalid or expired verification token'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_f = typeof token_dto_1.TokenDto !== "undefined" && token_dto_1.TokenDto) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], AuthController.prototype, "verifyEmail", null);
__decorate([
    (0, common_1.Post)('resend-verification'),
    (0, swagger_1.ApiOperation)({ summary: 'Resend email verification link' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Verification email sent successfully.' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Email is already verified' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], AuthController.prototype, "resendVerification", null);
__decorate([
    (0, common_1.Post)('refresh'),
    (0, swagger_1.ApiOperation)({ summary: 'Refresh access token using refresh token' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                refreshToken: {
                    type: 'string',
                    description: 'Refresh token (optional if provided in cookies)',
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Access token refreshed successfully.' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized - Refresh token not found or invalid' }),
    __param(0, (0, common_1.Body)('refreshToken')),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, common_1.Res)({ passthrough: true })),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_j = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _j : Object, typeof (_k = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _k : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "refreshToken", null);
__decorate([
    (0, common_1.Post)('logout'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Logout user' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                refreshToken: {
                    type: 'string',
                    description: 'Refresh token (optional if provided in cookies)',
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User logged out successfully.' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized - Refresh token not found or invalid' }),
    __param(0, (0, common_1.Body)('refreshToken')),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, common_1.Res)({ passthrough: true })),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_l = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _l : Object, typeof (_m = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _m : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "logout", null);
__decorate([
    (0, common_1.Post)('register'),
    (0, swagger_1.ApiOperation)({ summary: 'Register a new user' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'User registered successfully.' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_o = typeof register_user_dto_1.RegisterUserDto !== "undefined" && register_user_dto_1.RegisterUserDto) === "function" ? _o : Object]),
    __metadata("design:returntype", typeof (_p = typeof Promise !== "undefined" && Promise) === "function" ? _p : Object)
], AuthController.prototype, "register", null);
__decorate([
    (0, common_1.Get)('me'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get current authenticated user' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Return authenticated user details'
    }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_q = typeof jwt_payload_interface_1.IJwtPayload !== "undefined" && jwt_payload_interface_1.IJwtPayload) === "function" ? _q : Object]),
    __metadata("design:returntype", void 0)
], AuthController.prototype, "getCurrentUser", null);
exports.AuthController = AuthController = __decorate([
    (0, swagger_1.ApiTags)('Auth'),
    (0, common_1.Controller)(),
    __metadata("design:paramtypes", [typeof (_a = typeof auth_service_1.AuthService !== "undefined" && auth_service_1.AuthService) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], AuthController);


/***/ }),
/* 204 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),
/* 205 */
/***/ ((module) => {

"use strict";
module.exports = require("express");

/***/ }),
/* 206 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoogleAuthGuard = void 0;
const common_1 = __webpack_require__(5);
const passport_1 = __webpack_require__(28);
let GoogleAuthGuard = class GoogleAuthGuard extends (0, passport_1.AuthGuard)('google-auth') {
};
exports.GoogleAuthGuard = GoogleAuthGuard;
exports.GoogleAuthGuard = GoogleAuthGuard = __decorate([
    (0, common_1.Injectable)()
], GoogleAuthGuard);


/***/ }),
/* 207 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AuthService_1;
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthService = void 0;
const utility_helper_1 = __webpack_require__(87);
const common_service_1 = __webpack_require__(167);
const emails_service_1 = __webpack_require__(197);
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const bcrypt = __importStar(__webpack_require__(208));
const uuid_1 = __webpack_require__(112);
const sessions_service_1 = __webpack_require__(202);
const users_service_1 = __webpack_require__(30);
const jwt_service_1 = __webpack_require__(110);
let AuthService = AuthService_1 = class AuthService {
    constructor(usersService, jwtService, configService, commonService, sessionsService, emailsService) {
        this.usersService = usersService;
        this.jwtService = jwtService;
        this.configService = configService;
        this.commonService = commonService;
        this.sessionsService = sessionsService;
        this.emailsService = emailsService;
        this.logger = new common_1.Logger(AuthService_1.name);
        this.VERIFICATION_TOKEN_EXPIRATION_HOURS = 24; // 24 hours
        this.commonCookieOptions = {
            httpOnly: true,
            secure: this.commonService.isProduction(),
            // sameSite: 'lax',
            maxAge: this.configService.getOrThrow('ACCESS_TOKEN_EXPIRATION_MINUTES') * 60 * 1000,
        };
    }
    // Add this method for sending verification emails
    async sendVerificationEmail(user) {
        var _a, _b;
        // Generate verification token (you may want to store this in the user record)
        const verificationToken = (0, uuid_1.v4)();
        // Store the token in the user record with an expiration
        user.verificationToken = verificationToken;
        user.verificationTokenExpires = new Date(Date.now() + this.VERIFICATION_TOKEN_EXPIRATION_HOURS * 60 * 60 * 1000); // 24 hours
        await this.usersService.update(user.id, user);
        // Build verification URL
        const baseUrl = this.configService.getOrThrow('FRONTEND_URL');
        const verificationUrl = `${baseUrl}/verify-email?token=${verificationToken}`;
        // Send the email
        return this.emailsService.sendTemplatedEmail(user.email, 'email-verification', {
            firstName: ((_a = user.profile) === null || _a === void 0 ? void 0 : _a.firstName) || 'User',
            lastName: (_b = user.profile) === null || _b === void 0 ? void 0 : _b.lastName,
            verificationUrl,
            expiry: this.VERIFICATION_TOKEN_EXPIRATION_HOURS,
        });
    }
    async validateUser(model) {
        // check if emailOrUserName property is an email
        var user = null;
        if (utility_helper_1.UtilityHelper.isEmail(model.emailOrUserName)) {
            // check if email exists
            user = await this.usersService.findOneBy({ email: model.emailOrUserName.toLowerCase().trim() }, { relations: { employee: { roles: true } } });
            if (!user) {
                return null;
            }
        }
        else {
            // check if username exists
            user = await this.usersService.findOneBy({ userName: model.emailOrUserName.toLowerCase().trim() }, { relations: { employee: { roles: true } } });
            if (!user) {
                return null;
            }
        }
        if (!user || !(await bcrypt.compare(model.password, user.password))) {
            return null;
        }
        return user;
    }
    //   /**
    //  * Validates a user from social authentication providers (Google, Facebook, etc.)
    //  * Handles user creation, updates, and generates authentication tokens.
    //  * 
    //  * @param socialUser User data received from the OAuth provider
    //  * @returns User entity with tokens
    //  */
    // async validateSocialUser(socialUser: ISocialUser): Promise<any> {
    //   const { email, provider, providerId, firstName, lastName, picture } = socialUser;
    //   this.logger.log(`Validating social user: ${email} from ${provider}`);
    //   // Start a transaction to ensure data consistency
    //   return await this.transactionService.executeInTransaction(async (manager) => {
    //     const userRepository = manager. y(User);
    //     // Try to find existing user by email
    //     let user = await userRepository.findOne({ 
    //       where: { email },
    //       relations: ['socialLogins'],
    //     });
    //     // Try to find by social provider ID if not found by email
    //     if (!user) {
    //       const socialLoginRepository = manager.getRepository(SocialLogin);
    //       const socialLogin = await socialLoginRepository.findOne({
    //         where: { provider, providerId },
    //         relations: ['user'],
    //       });
    //       if (socialLogin) {
    //         user = socialLogin.user;
    //       }
    //     }
    //     // If we found a user, update their information
    //     if (user) {
    //       this.logger.log(`Found existing user with email ${email}`);
    //       // Check if user is active
    //       if (user.isActive === false) {
    //         this.logger.warn(`User ${email} account is deactivated`);
    //         throw new UnauthorizedException('Your account has been deactivated');
    //       }
    //       // Ensure this social login is linked to the user's account
    //       const socialLoginRepository = manager.getRepository(SocialLogin);
    //       let socialLogin = await socialLoginRepository.findOne({
    //         where: { 
    //           user: { id: user.id },
    //           provider,
    //           providerId,
    //         },
    //       });
    //       // Link this social provider if not already linked
    //       if (!socialLogin) {
    //         socialLogin = socialLoginRepository.create({
    //           user,
    //           provider,
    //           providerId,
    //           lastLogin: new Date(),
    //         });
    //         await socialLoginRepository.save(socialLogin);
    //         this.logger.log(`Linked ${provider} account to existing user ${email}`);
    //       } else {
    //         // Update last login time
    //         socialLogin.lastLogin = new Date();
    //         await socialLoginRepository.save(socialLogin);
    //       }
    //     } 
    //     // Create new user if not found
    //     else {
    //       this.logger.log(`Creating new user for ${email} from ${provider}`);
    //       // Create user with data from social profile
    //       user = userRepository.create({
    //         email,
    //         firstName: firstName || '',
    //         lastName: lastName || '',
    //         profileImage: picture,
    //         isEmailVerified: true, // Social logins are considered verified
    //         lastLoginAt: new Date(),
    //       });
    //       // Try to auto-assign default role (e.g., "user")
    //       try {
    //         const roleRepository = manager.getRepository(Role);
    //         const userRole = await roleRepository.findOne({ 
    //           where: { name: 'user' } 
    //         });
    //         if (userRole) {
    //           user.roles = [userRole];
    //         }
    //       } catch (error) {
    //         this.logger.warn(`Could not assign default role to new user: ${error.message}`);
    //       }
    //       // Save the new user
    //       user = await userRepository.save(user);
    //       // Create social login record
    //       const socialLoginRepository = manager.getRepository(SocialLogin);
    //       const socialLogin = socialLoginRepository.create({
    //         user,
    //         provider,
    //         providerId,
    //         lastLogin: new Date(),
    //       });
    //       await socialLoginRepository.save(socialLogin);
    //     }
    //     // Update profile information if missing or incomplete
    //     let needsUpdate = false;
    //     if (!user.firstName && firstName) {
    //       user.firstName = firstName;
    //       needsUpdate = true;
    //     }
    //     if (!user.lastName && lastName) {
    //       user.lastName = lastName;
    //       needsUpdate = true;
    //     }
    //     if (!user.profileImage && picture) {
    //       user.profileImage = picture;
    //       needsUpdate = true;
    //     }
    //     if (needsUpdate) {
    //       await userRepository.save(user);
    //     }
    //     // Generate tokens for the user
    //     const tokens = await this.jwtService.generateTokens(user);
    //     // Return user with tokens
    //     return {
    //       user: this.usersService.sanitizeUser(user),
    //       ...tokens
    //     };
    //   });
    // }
    async registerUser(model) {
        // check if user already exists
        const existingEmail = await this.usersService.findOneBy({ email: model.email.toLowerCase().trim() });
        const existingUserName = await this.usersService.findOneBy({ userName: model.userName.toLowerCase().trim() });
        if (existingEmail) {
            // throw error if user already exists
            throw new common_1.ConflictException('Email is already used by another user.');
        }
        if (existingUserName) {
            // throw error if user already exists
            throw new common_1.ConflictException('Username is already used by another user.');
        }
        // create new user
        const user = await this.usersService.signUpUser(model);
        // can be decoupled to an event or queue
        await this.sendVerificationEmail(user).catch((error) => {
            this.logger.error('Failed to send verification email', error);
        });
        return user;
    }
    // Add a method to verify email
    async verifyEmail(token) {
        var _a, _b;
        const user = await this.usersService.findOneBy({ verificationToken: token });
        if (!user || !user.verificationTokenExpires) {
            return false;
        }
        // Check if token is expired
        if (user.verificationTokenExpires < new Date()) {
            return false;
        }
        // Mark email as verified
        user.emailVerified = true;
        user.verificationToken = undefined;
        user.verificationTokenExpires = undefined;
        await this.usersService.update(user.id, user);
        // Optionally send welcome email
        // can be decoupled
        this.emailsService.sendTemplatedEmail(user.email, 'welcome', {
            firstName: ((_a = user.profile) === null || _a === void 0 ? void 0 : _a.firstName) || 'User',
            lastName: (_b = user.profile) === null || _b === void 0 ? void 0 : _b.lastName,
            appName: this.configService.getOrThrow('APP_NAME'),
        }).catch(error => {
            this.logger.error(`Failed to send welcome email: ${error.message}`);
        });
        return true;
    }
    clearAuthCookies(response) {
        response.clearCookie('accessToken', this.commonCookieOptions);
        response.clearCookie('refreshToken', this.commonCookieOptions);
        return response;
    }
    setAuthCookies(response, tokens) {
        const accessTokenExpirationMinutes = this.configService.getOrThrow('ACCESS_TOKEN_EXPIRATION_MINUTES');
        const refreshTokenExpirationMinutes = this.configService.getOrThrow('REFRESH_TOKEN_EXPIRATION_MINUTES');
        // Set access token cookie
        response.cookie('accessToken', tokens.accessToken, Object.assign(Object.assign({}, this.commonCookieOptions), { maxAge: accessTokenExpirationMinutes * 60 * 1000 }));
        // response.cookie('refreshToken', tokens.refreshToken, {
        //   ...this.commonCookieOptions,
        //   maxAge: refreshTokenExpirationMinutes * 60 * 1000,
        // });
    }
    async logoutUser(refreshToken, response) {
        // Find the session with this refresh token
        const session = await this.sessionsService.findOneBy({ refreshToken });
        if (session) {
            // Update last active instead of deleting
            await this.sessionsService.update(session.id, {
                lastActiveAt: new Date(),
            });
        }
        // Clear auth cookies
        this.clearAuthCookies(response);
    }
    async refreshTokens(refreshToken, request) {
        const session = await this.sessionsService.findOneBy({ refreshToken }, {
            relations: {
                user: { employee: { roles: true } } // Include nested employee relation
            },
            order: { createdAt: 'DESC' }, // Get the newest session first
        });
        if (!session) {
            throw new common_1.UnauthorizedException('Session not found');
        }
        if (session.expiresAt && session.expiresAt < new Date()) {
            throw new common_1.UnauthorizedException('Refresh token expired');
        }
        // Check if user exists
        const user = session.user;
        if (!user) {
            throw new common_1.UnauthorizedException('User not found');
        }
        // Create new tokens
        const newRefreshToken = await this.jwtService.createRefreshToken();
        const newPayload = this.jwtService.createPayload(user, newRefreshToken);
        const accessToken = await this.jwtService.createToken(newPayload);
        // Calculate expiration time for refresh token
        const refreshTokenExpirationMinutes = this.configService.getOrThrow('REFRESH_TOKEN_EXPIRATION_MINUTES');
        const expiresAt = new Date();
        expiresAt.setMinutes(expiresAt.getMinutes() + refreshTokenExpirationMinutes * 2);
        // save refresh token to database
        await this.sessionsService.create({
            refreshToken,
            userId: user.id,
            expiresAt,
            userAgent: request === null || request === void 0 ? void 0 : request.headers['user-agent'],
            ipAddress: request === null || request === void 0 ? void 0 : request.ip,
            deviceId: Array.isArray(request === null || request === void 0 ? void 0 : request.headers['device-id'])
                ? request === null || request === void 0 ? void 0 : request.headers['device-id'][0]
                : request === null || request === void 0 ? void 0 : request.headers['device-id'],
        }, user.id);
        return {
            accessToken,
        };
    }
    // login user
    async loginUser(model, req) {
        var user = await this.validateUser(model);
        if (!user) {
            throw new common_1.UnauthorizedException('Invalid email or password');
        }
        if (user.emailVerified === false) {
            throw new common_1.UnauthorizedException('Email not verified');
        }
        const refreshToken = await this.jwtService.createRefreshToken();
        const payload = this.jwtService.createPayload(user, refreshToken);
        const accessToken = await this.jwtService.createToken(payload);
        // Calculate expiration time for refresh token
        const refreshTokenExpirationMinutes = this.configService.getOrThrow('REFRESH_TOKEN_EXPIRATION_MINUTES');
        const expiresAt = new Date();
        expiresAt.setMinutes(expiresAt.getMinutes() + refreshTokenExpirationMinutes * 2);
        // save refresh token to database
        await this.sessionsService.create({
            refreshToken,
            userId: user.id,
            expiresAt,
            userAgent: req === null || req === void 0 ? void 0 : req.headers['user-agent'],
            ipAddress: req === null || req === void 0 ? void 0 : req.ip,
            deviceId: Array.isArray(req === null || req === void 0 ? void 0 : req.headers['device-id'])
                ? req === null || req === void 0 ? void 0 : req.headers['device-id'][0]
                : req === null || req === void 0 ? void 0 : req.headers['device-id'],
        }, user.id);
        const response = {
            accessToken,
        };
        return response;
    }
};
exports.AuthService = AuthService;
exports.AuthService = AuthService = AuthService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _a : Object, typeof (_b = typeof jwt_service_1.JwtService !== "undefined" && jwt_service_1.JwtService) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object, typeof (_d = typeof common_service_1.CommonService !== "undefined" && common_service_1.CommonService) === "function" ? _d : Object, typeof (_e = typeof sessions_service_1.SessionsService !== "undefined" && sessions_service_1.SessionsService) === "function" ? _e : Object, typeof (_f = typeof emails_service_1.EmailsService !== "undefined" && emails_service_1.EmailsService) === "function" ? _f : Object])
], AuthService);


/***/ }),
/* 208 */
/***/ ((module) => {

"use strict";
module.exports = require("bcrypt");

/***/ }),
/* 209 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoginUserDto = void 0;
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class LoginUserDto {
}
exports.LoginUserDto = LoginUserDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'user@example.com', description: 'The email or username of the user' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_transformer_1.Expose)(),
    __metadata("design:type", String)
], LoginUserDto.prototype, "emailOrUserName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'password', description: 'The password of the user' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], LoginUserDto.prototype, "password", void 0);


/***/ }),
/* 210 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RegisterUserDto = void 0;
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
const profile_dto_1 = __webpack_require__(118);
class RegisterUserDto {
}
exports.RegisterUserDto = RegisterUserDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'user@example.com', description: 'The email of the user' }),
    (0, class_validator_1.IsEmail)({}, { message: 'Invalid email address' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_transformer_1.Expose)(),
    __metadata("design:type", String)
], RegisterUserDto.prototype, "email", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'user', description: 'The username of the user' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.Matches)(/^[a-z0-9]+$/, { message: 'Username must contain only lowercase letters and numbers' }),
    (0, class_validator_1.MinLength)(5, { message: 'Username must be at least 5 characters long' }),
    (0, class_transformer_1.Expose)(),
    __metadata("design:type", String)
], RegisterUserDto.prototype, "userName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'password', description: 'The password of the user' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MinLength)(8, { message: 'Password must be at least 8 characters long' }),
    (0, class_validator_1.Matches)(/(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W)/, { message: 'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character' }),
    __metadata("design:type", String)
], RegisterUserDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'password', description: 'The password confirmation' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MinLength)(8, { message: 'Confirm Password must be at least 8 characters long' }),
    (0, class_validator_1.Matches)(/(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W)/, { message: 'Confirm Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character' }),
    (0, class_validator_1.ValidateIf)((o) => o.password === o.confirmPassword, { message: 'Passwords do not match' }),
    __metadata("design:type", String)
], RegisterUserDto.prototype, "confirmPassword", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Profile information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Type)(() => profile_dto_1.ProfileDto),
    __metadata("design:type", typeof (_a = typeof profile_dto_1.ProfileDto !== "undefined" && profile_dto_1.ProfileDto) === "function" ? _a : Object)
], RegisterUserDto.prototype, "profile", void 0);


/***/ }),
/* 211 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenDto = void 0;
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class TokenDto {
}
exports.TokenDto = TokenDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier token',
        example: '123e4567-e89b-12d3-a456-426614174000',
        required: true
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsUUID)('4'),
    __metadata("design:type", String)
], TokenDto.prototype, "token", void 0);


/***/ }),
/* 212 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccessTokenStrategy = void 0;
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const passport_1 = __webpack_require__(28);
const passport_jwt_1 = __webpack_require__(213);
const jwt_service_1 = __webpack_require__(110);
let AccessTokenStrategy = class AccessTokenStrategy extends (0, passport_1.PassportStrategy)(passport_jwt_1.Strategy, 'jwt') {
    constructor(configService, jwtService, userService) {
        super({
            // Combine extractors to check both the Authorization header and the query parameter
            jwtFromRequest: (req) => {
                // Try to extract JWT from the Authorization header
                const authHeaderToken = passport_jwt_1.ExtractJwt.fromAuthHeaderAsBearerToken()(req);
                if (authHeaderToken) {
                    return authHeaderToken;
                }
                // If not found, try to extract JWT from the query parameter named 'token'
                const queryToken = passport_jwt_1.ExtractJwt.fromUrlQueryParameter('token')(req);
                return queryToken;
            },
            secretOrKey: configService.getOrThrow('ACCESS_TOKEN_SECRET'),
            ignoreExpiration: false,
        });
        this.configService = configService;
        this.jwtService = jwtService;
        this.userService = userService;
    }
    async validate(payload) {
        if (!this.jwtService.validatePayload(payload)) {
            throw new common_1.UnauthorizedException('Invalid token payload');
        }
        const user = await this.userService.findOneBy({ id: payload.sub });
        if (!user)
            throw new common_1.UnauthorizedException('User not found');
        return payload;
    }
};
exports.AccessTokenStrategy = AccessTokenStrategy;
exports.AccessTokenStrategy = AccessTokenStrategy = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object, typeof (_b = typeof jwt_service_1.JwtService !== "undefined" && jwt_service_1.JwtService) === "function" ? _b : Object, typeof (_c = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _c : Object])
], AccessTokenStrategy);


/***/ }),
/* 213 */
/***/ ((module) => {

"use strict";
module.exports = require("passport-jwt");

/***/ }),
/* 214 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProfilesModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const profile_entity_1 = __webpack_require__(33);
const profiles_controller_1 = __webpack_require__(215);
const profiles_service_1 = __webpack_require__(216);
let ProfilesModule = class ProfilesModule {
};
exports.ProfilesModule = ProfilesModule;
exports.ProfilesModule = ProfilesModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([profile_entity_1.Profile])],
        controllers: [profiles_controller_1.ProfilesController],
        providers: [profiles_service_1.ProfilesService],
        exports: [profiles_service_1.ProfilesService],
    })
], ProfilesModule);


/***/ }),
/* 215 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProfilesController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const profile_dto_1 = __webpack_require__(118);
const profile_entity_1 = __webpack_require__(33);
const profiles_service_1 = __webpack_require__(216);
class ProfilesController extends (0, create_controller_factory_1.createController)(profile_entity_1.Profile, profiles_service_1.ProfilesService, profile_dto_1.GetProfileDto, profile_dto_1.ProfileDto, profile_dto_1.UpdateProfileDto) {
    findAllAdvanced(paginationDto) {
        return super.findAllAdvanced(paginationDto);
    }
    async findOne(id) {
        return await super.findOne(id);
    }
    async softDelete(id, deletedBy) {
        return super.softDelete(id, deletedBy);
    }
    async delete(id) {
        return super.delete(id);
    }
    deleteMany(ids, hardDelete) {
        return super.deleteMany(ids, hardDelete);
    }
}
exports.ProfilesController = ProfilesController;


/***/ }),
/* 216 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProfilesService = void 0;
const base_service_1 = __webpack_require__(31);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const users_service_1 = __webpack_require__(30);
const profile_entity_1 = __webpack_require__(33);
let ProfilesService = class ProfilesService extends base_service_1.BaseService {
    constructor(ProfilesRepository, usersService) {
        super(ProfilesRepository, usersService);
        this.ProfilesRepository = ProfilesRepository;
        this.usersService = usersService;
    }
};
exports.ProfilesService = ProfilesService;
exports.ProfilesService = ProfilesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(profile_entity_1.Profile)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], ProfilesService);


/***/ }),
/* 217 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UserSeederService_1;
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserSeederService = void 0;
const employment_condition_enum_1 = __webpack_require__(44);
const employment_status_enum_1 = __webpack_require__(45);
const employment_type_enum_1 = __webpack_require__(46);
const role_scope_type_enum_1 = __webpack_require__(38);
const role_enum_1 = __webpack_require__(94);
const auth_service_1 = __webpack_require__(207);
const employees_service_1 = __webpack_require__(104);
const roles_service_1 = __webpack_require__(91);
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const bcrypt = __importStar(__webpack_require__(208));
const users_service_1 = __webpack_require__(30);
let UserSeederService = UserSeederService_1 = class UserSeederService {
    constructor(usersService, authService, rolesService, employeesService, configService) {
        this.usersService = usersService;
        this.authService = authService;
        this.rolesService = rolesService;
        this.employeesService = employeesService;
        this.configService = configService;
        this.logger = new common_1.Logger(UserSeederService_1.name);
    }
    async onModuleInit() {
        await this.seedSuperAdmin();
    }
    async seedSuperAdmin() {
        var _a, _b, _c, _d;
        const superAdminEmail = this.configService.getOrThrow('SUPER_ADMIN_EMAIL');
        const superAdminPassword = this.configService.getOrThrow('SUPER_ADMIN_PASSWORD');
        // this.logger.log('Checking if super admin role exists...');
        const superAdminRole = await this.seedSuperAdminRole();
        const employeeRole = await this.seedEmployeeRole();
        let superAdminEmployee = await this.seedSuperAdminEmployee();
        // check if super admin employee has the super admin and employee role
        const hasSuperAdminAndEmployeeRole = ((_a = superAdminEmployee.roles) === null || _a === void 0 ? void 0 : _a.some(role => role.name === role_enum_1.Role.SUPERADMIN)) &&
            ((_b = superAdminEmployee.roles) === null || _b === void 0 ? void 0 : _b.some(role => role.name === role_enum_1.Role.EMPLOYEE));
        if (!hasSuperAdminAndEmployeeRole) {
            this.logger.warn('Super admin employee does not have the super admin and employee role');
            superAdminEmployee.roles = [superAdminRole, employeeRole];
            await this.employeesService.update(superAdminEmployee.id, superAdminEmployee);
            // this.logger.log('Super admin employee associated with the super admin and employee role successfully');
        }
        else {
            // this.logger.log('Super admin employee already has the super admin and employee role');
        }
        // Check if super admin user exists
        let superAdminUser = await this.usersService.findOneBy({ employee: { id: superAdminEmployee.id } }, { relations: { employee: true } });
        if (!superAdminUser) {
            // Check if super admin user exists with the super admin email
            superAdminUser = await this.usersService.findOneBy({ email: superAdminEmail });
            if (superAdminUser) {
                this.logger.warn('Super admin user exists but is not associated with the super admin employee');
                superAdminEmployee.user = superAdminUser;
            }
            else {
                // this.logger.log('Creating super admin user...');
                // create super admin user
                superAdminUser = await this.usersService.create({
                    email: superAdminEmail,
                    password: await bcrypt.hash(superAdminPassword, 10),
                    userName: superAdminEmail,
                    employee: superAdminEmployee
                });
                // this.logger.log('Super admin user created successfully');
            }
        }
        else {
            // Check if super admin email is the same as the one in the config
            if (superAdminUser.email !== superAdminEmail) {
                // log super admin email
                this.logger.warn('Super admin email is different from the one in the config');
                // Update super admin email to the one in the config
                superAdminUser.email = superAdminEmail;
                superAdminUser.userName = superAdminEmail;
                await this.usersService.update(superAdminUser.id, superAdminUser);
                // this.logger.log('Super admin email updated successfully');
            }
            // Check if either password is missing
            if (!superAdminUser.password) {
                this.logger.warn('Missing password - updating to config password');
                superAdminUser.password = await bcrypt.hash(superAdminPassword, 10);
                await this.usersService.update(superAdminUser.id, superAdminUser);
            }
            else {
                // Only validate if both passwords exist
                var loginCredentials = {
                    emailOrUserName: (_c = superAdminUser.email) !== null && _c !== void 0 ? _c : "",
                    password: superAdminPassword
                };
                if (await this.authService.validateUser(loginCredentials)) {
                    // this.logger.log('Super admin password is the same as the one in the config');
                }
                else {
                    this.logger.warn('Super admin password is different from the one in the config');
                    superAdminUser.password = await bcrypt.hash(superAdminPassword, 10);
                    await this.usersService.update(superAdminUser.id, superAdminUser);
                }
            }
        }
        // check if superAdminUser is associated with the super admin employee
        if (((_d = superAdminUser.employee) === null || _d === void 0 ? void 0 : _d.id) !== superAdminEmployee.id) {
            this.logger.warn('Super admin user is not associated with the super admin employee');
            superAdminUser.employee = superAdminEmployee;
            await this.usersService.update(superAdminUser.id, superAdminUser);
            // this.logger.log('Super admin user associated with the super admin employee successfully');
        }
    }
    async seedSuperAdminRole() {
        // Check if super admin role exists
        let superAdminRole = await this.rolesService.findOneBy({ name: role_enum_1.Role.SUPERADMIN });
        // Create super admin role if it doesn't exist
        if (!superAdminRole) {
            // this.logger.log('Creating SuperAdmin role...');
            superAdminRole = await this.rolesService.create({
                name: role_enum_1.Role.SUPERADMIN,
                description: 'Super Admin Role',
                scope: role_scope_type_enum_1.RoleScopeType.GLOBAL,
            });
            // this.logger.log('SuperAdmin role created successfully');
        }
        else {
            // this.logger.log('SuperAdmin role already exists');
        }
        return superAdminRole;
    }
    async seedEmployeeRole() {
        // Check if employee role exists
        let employeeRole = await this.rolesService.findOneBy({ name: role_enum_1.Role.EMPLOYEE });
        // Create employee role if it doesn't exist
        if (!employeeRole) {
            // this.logger.log('Creating Employee role...');
            employeeRole = await this.rolesService.create({
                name: role_enum_1.Role.EMPLOYEE,
                description: 'Employee Role',
                scope: role_scope_type_enum_1.RoleScopeType.OWNED,
            });
            // this.logger.log('Employee role created successfully');
        }
        else {
            // this.logger.log('Employee role already exists');
        }
        return employeeRole;
    }
    async seedSuperAdminEmployee() {
        // Check if super admin employee exists
        let superAdminEmployee = await this.employeesService.findOneBy({ employeeNumber: 1 }, { relations: { roles: true } });
        // Create super admin employee if it doesn't exist
        if (!superAdminEmployee) {
            this.logger.log('Creating SuperAdmin employee...');
            superAdminEmployee = await this.employeesService.create({
                employmentStatus: employment_status_enum_1.EmploymentStatus.ACTIVE,
                employmentCondition: employment_condition_enum_1.EmploymentCondition.REGULAR,
                employmentType: employment_type_enum_1.EmploymentType.FULL_TIME,
                commencementDate: new Date(),
                employeeNumber: 1,
            });
            // this.logger.log('SuperAdmin employee created successfully');
        }
        else {
            // this.logger.log('SuperAdmin employee already exists');
        }
        return superAdminEmployee;
    }
};
exports.UserSeederService = UserSeederService;
exports.UserSeederService = UserSeederService = UserSeederService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _a : Object, typeof (_b = typeof auth_service_1.AuthService !== "undefined" && auth_service_1.AuthService) === "function" ? _b : Object, typeof (_c = typeof roles_service_1.RolesService !== "undefined" && roles_service_1.RolesService) === "function" ? _c : Object, typeof (_d = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _d : Object, typeof (_e = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _e : Object])
], UserSeederService);


/***/ }),
/* 218 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddressesModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const addresses_service_1 = __webpack_require__(219);
const address_entity_1 = __webpack_require__(35);
let AddressesModule = class AddressesModule {
};
exports.AddressesModule = AddressesModule;
exports.AddressesModule = AddressesModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([address_entity_1.Address])],
        providers: [addresses_service_1.AddressesService],
        exports: [addresses_service_1.AddressesService],
    })
], AddressesModule);


/***/ }),
/* 219 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddressesService = void 0;
const base_service_1 = __webpack_require__(31);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const users_service_1 = __webpack_require__(30);
const address_entity_1 = __webpack_require__(35);
let AddressesService = class AddressesService extends base_service_1.BaseService {
    constructor(AddressesService, usersService) {
        super(AddressesService, usersService);
        this.AddressesService = AddressesService;
        this.usersService = usersService;
    }
};
exports.AddressesService = AddressesService;
exports.AddressesService = AddressesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(address_entity_1.Address)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], AddressesService);


/***/ }),
/* 220 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendanceManagementModule = void 0;
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const typeorm_1 = __webpack_require__(16);
const biometrics_module_1 = __webpack_require__(221);
const employee_management_module_1 = __webpack_require__(15);
const shift_management_module_1 = __webpack_require__(133);
const attendance_punches_module_1 = __webpack_require__(255);
const attendances_controller_1 = __webpack_require__(259);
const attendances_service_1 = __webpack_require__(260);
const attendance_entity_1 = __webpack_require__(52);
const final_work_hours_module_1 = __webpack_require__(265);
const attendance_listener_1 = __webpack_require__(270);
const work_time_requests_module_1 = __webpack_require__(271);
const work_time_responses_module_1 = __webpack_require__(274);
let AttendanceManagementModule = class AttendanceManagementModule {
};
exports.AttendanceManagementModule = AttendanceManagementModule;
exports.AttendanceManagementModule = AttendanceManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([attendance_entity_1.Attendance]),
            core_1.RouterModule.register([
                {
                    path: 'attendances',
                    module: AttendanceManagementModule,
                    children: [
                        {
                            path: 'punches',
                            module: attendance_punches_module_1.AttendancePunchesModule,
                        },
                        {
                            path: 'work-time-requests',
                            module: work_time_requests_module_1.WorkTimeRequestsModule,
                            children: [
                                {
                                    path: 'responses',
                                    module: work_time_responses_module_1.WorkTimeResponsesModule,
                                }
                            ]
                        },
                        {
                            path: 'final-work-hours',
                            module: final_work_hours_module_1.FinalWorkHoursModule,
                        }
                    ],
                }
            ]),
            attendance_punches_module_1.AttendancePunchesModule,
            work_time_requests_module_1.WorkTimeRequestsModule,
            work_time_responses_module_1.WorkTimeResponsesModule,
            final_work_hours_module_1.FinalWorkHoursModule,
            biometrics_module_1.BiometricsModule,
            employee_management_module_1.EmployeeManagementModule,
            shift_management_module_1.ShiftManagementModule,
        ],
        providers: [attendances_service_1.AttendancesService, attendance_listener_1.AttendanceListener],
        exports: [
            attendances_service_1.AttendancesService,
            attendance_punches_module_1.AttendancePunchesModule,
            work_time_requests_module_1.WorkTimeRequestsModule,
            work_time_responses_module_1.WorkTimeResponsesModule,
            final_work_hours_module_1.FinalWorkHoursModule,
        ],
        controllers: [attendances_controller_1.AttendancesController],
    })
], AttendanceManagementModule);


/***/ }),
/* 221 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricsModule = void 0;
const attendance_punch_entity_1 = __webpack_require__(73);
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const typeorm_1 = __webpack_require__(16);
const biometric_devices_controller_1 = __webpack_require__(222);
const biometrics_controller_1 = __webpack_require__(229);
const biometric_device_entity_1 = __webpack_require__(76);
const biometric_template_entity_1 = __webpack_require__(234);
const timeout_interceptor_1 = __webpack_require__(231);
const anvis_biometrics_service_1 = __webpack_require__(235);
const biometric_devices_service_1 = __webpack_require__(226);
const biometrics_factory_service_1 = __webpack_require__(227);
const biometrics_polling_service_1 = __webpack_require__(252);
const zkteco_biometrics_service_1 = __webpack_require__(253);
let BiometricsModule = class BiometricsModule {
};
exports.BiometricsModule = BiometricsModule;
exports.BiometricsModule = BiometricsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([biometric_device_entity_1.BiometricDevice, biometric_template_entity_1.BiometricTemplate, attendance_punch_entity_1.AttendancePunch]),
            core_1.RouterModule.register([{
                    path: 'biometrics',
                    module: BiometricsModule,
                }]),
        ],
        controllers: [biometrics_controller_1.BiometricsController, biometric_devices_controller_1.BiometricDevicesController],
        providers: [
            // Register ZKTeco service
            {
                provide: 'ZKTECO_SERVICE',
                useClass: zkteco_biometrics_service_1.ZKTecoBiometricsService,
            },
            // Register Anviz service
            {
                provide: 'ANVIZ_SERVICE',
                useClass: anvis_biometrics_service_1.AnvizBiometricsService,
            },
            // Register the legacy token for backward compatibility
            {
                provide: 'BIOMETRIC_SERVICE',
                useExisting: 'ZKTECO_SERVICE', // Default to ZKTeco for backward compatibility
            },
            {
                provide: timeout_interceptor_1.TimeoutInterceptor,
                useFactory: () => new timeout_interceptor_1.TimeoutInterceptor(30),
            },
            biometrics_polling_service_1.BiometricsPollingService,
            biometric_devices_service_1.BiometricDevicesService,
            biometrics_factory_service_1.BiometricsFactoryService,
        ],
        exports: [
            'ZKTECO_SERVICE',
            'ANVIZ_SERVICE',
            'BIOMETRIC_SERVICE',
            biometric_devices_service_1.BiometricDevicesService,
            biometrics_factory_service_1.BiometricsFactoryService,
        ],
    })
], BiometricsModule);


/***/ }),
/* 222 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricDevicesController = void 0;
const generalresponse_dto_1 = __webpack_require__(86);
const create_controller_factory_1 = __webpack_require__(18);
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const bson_typings_1 = __webpack_require__(223);
const biometric_device_dto_1 = __webpack_require__(224);
const connect_device_dto_1 = __webpack_require__(225);
const biometric_device_entity_1 = __webpack_require__(76);
const biometric_devices_service_1 = __webpack_require__(226);
const biometrics_factory_service_1 = __webpack_require__(227);
let BiometricDevicesController = class BiometricDevicesController extends (0, create_controller_factory_1.createController)(biometric_device_entity_1.BiometricDevice, biometric_devices_service_1.BiometricDevicesService, biometric_device_dto_1.GetBiometricDeviceDto, undefined, biometric_device_dto_1.UpdateBiometricDeviceDto) {
    constructor(biometricsFactory, biometricDevicesService) {
        super(biometricDevicesService);
        this.biometricsFactory = biometricsFactory;
        this.biometricDevicesService = biometricDevicesService;
    }
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    async deleteMany(ids, hardDelete) {
        await super.deleteMany(ids, hardDelete);
    }
    async connectDevice(connectDeviceDto) {
        const service = this.biometricsFactory.getService(connectDeviceDto.deviceType);
        return await service.connect(connectDeviceDto);
    }
    async disconnectDevice(deviceId) {
        // Get the appropriate service based on the device ID
        const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
        return await service.disconnect(deviceId, true);
    }
};
exports.BiometricDevicesController = BiometricDevicesController;
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Connect to a biometric device' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        description: 'Device connected successfully',
        type: biometric_device_dto_1.GetBiometricDeviceDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid input data',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiBody)({
        description: 'Device connection parameters',
        type: connect_device_dto_1.ConnectDeviceDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Connection error',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, common_1.Post)('devices/connect'),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof connect_device_dto_1.ConnectDeviceDto !== "undefined" && connect_device_dto_1.ConnectDeviceDto) === "function" ? _c : Object]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], BiometricDevicesController.prototype, "connectDevice", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Disconnect from a biometric device' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Device disconnected successfully',
        type: biometric_device_dto_1.GetBiometricDeviceDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Error disconnecting device',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiParam)({
        name: 'deviceId', description: 'Device ID to disconnect from',
        type: bson_typings_1.UUID
    }),
    (0, common_1.Post)('devices/:deviceId/disconnect'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], BiometricDevicesController.prototype, "disconnectDevice", null);
exports.BiometricDevicesController = BiometricDevicesController = __decorate([
    __param(0, (0, common_1.Inject)(biometrics_factory_service_1.BiometricsFactoryService)),
    __metadata("design:paramtypes", [typeof (_a = typeof biometrics_factory_service_1.BiometricsFactoryService !== "undefined" && biometrics_factory_service_1.BiometricsFactoryService) === "function" ? _a : Object, typeof (_b = typeof biometric_devices_service_1.BiometricDevicesService !== "undefined" && biometric_devices_service_1.BiometricDevicesService) === "function" ? _b : Object])
], BiometricDevicesController);


/***/ }),
/* 223 */
/***/ ((module) => {

"use strict";
module.exports = require("typeorm/driver/mongodb/bson.typings");

/***/ }),
/* 224 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBiometricDeviceDto = exports.UpdateBiometricDeviceDto = exports.BiometricDeviceDto = void 0;
const base_dto_1 = __webpack_require__(101);
const biometrics_device_type_enum_1 = __webpack_require__(77);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class BiometricDeviceDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.BiometricDeviceDto = BiometricDeviceDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the biometric device',
        example: 'Main Entrance Scanner',
        required: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(255),
    __metadata("design:type", String)
], BiometricDeviceDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier for the device (assigned by manufacturer)',
        example: 'ZK-123456',
        required: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], BiometricDeviceDto.prototype, "deviceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'IP address of the biometric device',
        example: '192.168.1.100',
        required: true
    }),
    (0, class_validator_1.IsIP)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], BiometricDeviceDto.prototype, "ipAddress", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Port number the device is accessible on',
        example: 4370,
        required: true
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsPort)(),
    __metadata("design:type", Number)
], BiometricDeviceDto.prototype, "port", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Model of the biometric device',
        example: 'F18',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], BiometricDeviceDto.prototype, "model", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Serial number of the device',
        example: 'SN12345678',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], BiometricDeviceDto.prototype, "serialNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Provider/manufacturer of the biometric device',
        enum: biometrics_device_type_enum_1.BiometricDeviceType,
        default: biometrics_device_type_enum_1.BiometricDeviceType.ZKTECO,
        example: biometrics_device_type_enum_1.BiometricDeviceType.ZKTECO
    }),
    (0, class_validator_1.IsEnum)(biometrics_device_type_enum_1.BiometricDeviceType),
    __metadata("design:type", typeof (_a = typeof biometrics_device_type_enum_1.BiometricDeviceType !== "undefined" && biometrics_device_type_enum_1.BiometricDeviceType) === "function" ? _a : Object)
], BiometricDeviceDto.prototype, "provider", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Firmware version of the device',
        example: '1.2.5',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], BiometricDeviceDto.prototype, "firmware", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Platform information of the device',
        example: 'ZKTeco Biometric Platform',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], BiometricDeviceDto.prototype, "platform", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Version of the device',
        example: 'V1.0',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], BiometricDeviceDto.prototype, "deviceVersion", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Operating system of the device',
        example: 'Linux Embedded',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], BiometricDeviceDto.prototype, "os", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the device is currently connected',
        example: false,
        default: false
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], BiometricDeviceDto.prototype, "isConnected", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the device is in offline mode',
        example: false,
        required: true
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], BiometricDeviceDto.prototype, "isOffline", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date and time of the last synchronization',
        example: '2023-09-15T10:30:00Z',
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsDateString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], BiometricDeviceDto.prototype, "lastSync", void 0);
class UpdateBiometricDeviceDto extends (0, swagger_1.PartialType)(BiometricDeviceDto) {
}
exports.UpdateBiometricDeviceDto = UpdateBiometricDeviceDto;
class GetBiometricDeviceDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateBiometricDeviceDto, 'biometric device') {
}
exports.GetBiometricDeviceDto = GetBiometricDeviceDto;


/***/ }),
/* 225 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectDeviceDto = void 0;
const biometrics_device_type_enum_1 = __webpack_require__(77);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class ConnectDeviceDto {
    constructor() {
        this.port = 4370;
    }
}
exports.ConnectDeviceDto = ConnectDeviceDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Device IP address',
        example: '192.168.1.100'
    }),
    (0, class_validator_1.IsIP)(4),
    __metadata("design:type", String)
], ConnectDeviceDto.prototype, "ipAddress", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Device port number',
        example: 4370,
        default: 4370
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(65535),
    __metadata("design:type", Number)
], ConnectDeviceDto.prototype, "port", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Device type/manufacturer',
        enum: biometrics_device_type_enum_1.BiometricDeviceType,
        default: biometrics_device_type_enum_1.BiometricDeviceType.ZKTECO,
        example: 'zkteco'
    }),
    (0, class_validator_1.IsEnum)(biometrics_device_type_enum_1.BiometricDeviceType),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof biometrics_device_type_enum_1.BiometricDeviceType !== "undefined" && biometrics_device_type_enum_1.BiometricDeviceType) === "function" ? _a : Object)
], ConnectDeviceDto.prototype, "deviceType", void 0);


/***/ }),
/* 226 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricDevicesService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const biometric_device_entity_1 = __webpack_require__(76);
let BiometricDevicesService = class BiometricDevicesService extends base_service_1.BaseService {
    constructor(biometricDevicesRepository, usersService) {
        super(biometricDevicesRepository, usersService);
        this.biometricDevicesRepository = biometricDevicesRepository;
        this.usersService = usersService;
    }
};
exports.BiometricDevicesService = BiometricDevicesService;
exports.BiometricDevicesService = BiometricDevicesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(biometric_device_entity_1.BiometricDevice)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], BiometricDevicesService);


/***/ }),
/* 227 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricsFactoryService = void 0;
const common_1 = __webpack_require__(5);
const biometric_interface_1 = __webpack_require__(228);
const biometric_devices_service_1 = __webpack_require__(226);
let BiometricsFactoryService = class BiometricsFactoryService {
    constructor(zktecoService, anvizService, biometricDevicesService) {
        this.zktecoService = zktecoService;
        this.anvizService = anvizService;
        this.biometricDevicesService = biometricDevicesService;
    }
    /**
     * Get the appropriate biometric service based on device type
     * @param deviceType Type of biometric device (zkteco or anviz)
     */
    getService(deviceType) {
        switch (deviceType.toLowerCase()) {
            case 'anviz':
                return this.anvizService;
            case 'zkteco':
            default:
                return this.zktecoService;
        }
    }
    /**
     * Get the appropriate biometric service for an existing device
     * @param deviceId Device identifier
     */
    async getServiceByDeviceId(deviceId) {
        // Look up the device in the database
        const device = await this.biometricDevicesService.findOneByOrFail({ deviceId });
        // Return the appropriate service based on the provider
        return this.getService(device.provider);
    }
};
exports.BiometricsFactoryService = BiometricsFactoryService;
exports.BiometricsFactoryService = BiometricsFactoryService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)('ZKTECO_SERVICE')),
    __param(1, (0, common_1.Inject)('ANVIZ_SERVICE')),
    __metadata("design:paramtypes", [typeof (_a = typeof biometric_interface_1.IBiometricService !== "undefined" && biometric_interface_1.IBiometricService) === "function" ? _a : Object, typeof (_b = typeof biometric_interface_1.IBiometricService !== "undefined" && biometric_interface_1.IBiometricService) === "function" ? _b : Object, typeof (_c = typeof biometric_devices_service_1.BiometricDevicesService !== "undefined" && biometric_devices_service_1.BiometricDevicesService) === "function" ? _c : Object])
], BiometricsFactoryService);


/***/ }),
/* 228 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),
/* 229 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricsController = void 0;
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
const error_response_dto_1 = __webpack_require__(230);
const timeout_interceptor_1 = __webpack_require__(231);
const biometric_devices_service_1 = __webpack_require__(226);
const biometrics_factory_service_1 = __webpack_require__(227);
class SetUserDto {
}
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Device ID to register user on',
        example: '192.168.1.100:4370'
    }),
    __metadata("design:type", String)
], SetUserDto.prototype, "deviceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User ID',
        example: '1001'
    }),
    __metadata("design:type", String)
], SetUserDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User name',
        example: 'John Doe'
    }),
    __metadata("design:type", String)
], SetUserDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User password',
        example: '1234',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], SetUserDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User card number',
        example: '8987656789',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], SetUserDto.prototype, "cardNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User role (0=normal, 14=admin)',
        example: 0,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SetUserDto.prototype, "role", void 0);
class GetFingerprintDto {
    constructor() {
        this.fingerId = 0;
    }
}
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Device ID to get fingerprint from',
        example: '192.168.1.100:4370'
    }),
    __metadata("design:type", String)
], GetFingerprintDto.prototype, "deviceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User ID',
        example: '1001'
    }),
    __metadata("design:type", String)
], GetFingerprintDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Finger ID (0-9)',
        example: 0,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], GetFingerprintDto.prototype, "fingerId", void 0);
// New DTOs for additional endpoints
class SetDeviceTimeDto {
}
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Time to set on the device (ISO format)',
        example: '2025-05-06T12:00:00.000Z',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SetDeviceTimeDto.prototype, "time", void 0);
class UnlockDoorDto {
}
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Delay in seconds to keep the door unlocked',
        example: 3,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], UnlockDoorDto.prototype, "delay", void 0);
class SyncUsersDto {
}
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Source device ID to copy users from',
        example: '192.168.1.100:4370'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SyncUsersDto.prototype, "sourceDeviceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Target device ID to copy users to',
        example: '192.168.1.101:4370'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SyncUsersDto.prototype, "targetDeviceId", void 0);
class ExecuteCommandDto {
}
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Command to execute on device',
        example: 'get_device_info1'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ExecuteCommandDto.prototype, "command", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Data for the command (optional)',
        example: '{"value": 1}',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ExecuteCommandDto.prototype, "data", void 0);
let BiometricsController = class BiometricsController {
    constructor(biometricsFactory, biometricDevicesService) {
        this.biometricsFactory = biometricsFactory;
        this.biometricDevicesService = biometricDevicesService;
    }
    getErrorMessage(error) {
        return error instanceof Error ? error.message : 'An unknown error occurred';
    }
    handleError(error, defaultMessage, notImplementedMessage) {
        if (error instanceof common_1.HttpException) {
            throw error;
        }
        const errorMessage = this.getErrorMessage(error);
        // Check if this is a "not implemented" error
        if (errorMessage.includes('not implemented') || errorMessage.includes('NOT_IMPLEMENTED')) {
            throw new common_1.HttpException(notImplementedMessage, common_1.HttpStatus.NOT_IMPLEMENTED);
        }
        // Check if this is a "not found" error
        if (errorMessage.includes('not found') || errorMessage.includes('not connected')) {
            throw new common_1.HttpException(`Device not found or not connected: ${errorMessage}`, common_1.HttpStatus.NOT_FOUND);
        }
        // Generic error response
        throw new common_1.HttpException(`${defaultMessage}: ${errorMessage}`, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
    }
    async getUserFingerprint(getFingerprintDto) {
        try {
            const { deviceId, userId, fingerId = 0 } = getFingerprintDto;
            // Get the appropriate service based on device type
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const template = await service.getUserFingerprint(deviceId, userId, fingerId);
            if (!template) {
                throw new common_1.HttpException(`No fingerprint template found for user ${userId} (finger ${fingerId})`, common_1.HttpStatus.NOT_FOUND);
            }
            return template;
        }
        catch (error) {
            return this.handleError(error, 'Failed to retrieve fingerprint template', 'Fingerprint template retrieval not supported by this device type');
        }
    }
    async registerUser(setUserDto) {
        // Get the appropriate service based on the device ID
        const service = await this.biometricsFactory.getServiceByDeviceId(setUserDto.deviceId);
        return await service.registerUser(setUserDto.deviceId, {
            userId: setUserDto.userId,
            name: setUserDto.name,
            password: setUserDto.password,
            cardNumber: setUserDto.cardNumber,
            role: setUserDto.role
        });
    }
    async setTime(deviceId, body) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            // Parse the time or use current time
            const time = body.time ? new Date(body.time) : new Date();
            // Validate time format
            if (isNaN(time.getTime())) {
                throw new common_1.HttpException('Invalid time format', common_1.HttpStatus.BAD_REQUEST);
            }
            const result = await service.setTime(deviceId, time);
            return { success: result };
        }
        catch (error) {
            return this.handleError(error, 'Failed to set device time', 'Time setting not supported by this device type');
        }
    }
    async deleteUser(deviceId, userId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const result = await service.deleteUser(deviceId, userId);
            return { success: result };
        }
        catch (error) {
            return this.handleError(error, 'Failed to delete user', 'User deletion not supported by this device type');
        }
    }
    async getUsers(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            return await service.getUsers(deviceId);
        }
        catch (error) {
            return this.handleError(error, 'Failed to get users', 'User retrieval not supported by this device type');
        }
    }
    async getAttendanceRecords(deviceId, startDateParam, endDateParam) {
        try {
            // Parse dates if provided
            const startDate = startDateParam ? new Date(startDateParam) : undefined;
            const endDate = endDateParam ? new Date(endDateParam) : undefined;
            // Validate date formats
            if ((startDate && isNaN(startDate.getTime())) ||
                (endDate && isNaN(endDate.getTime()))) {
                throw new common_1.HttpException('Invalid date format', common_1.HttpStatus.BAD_REQUEST);
            }
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const records = await service.getAttendanceRecords(deviceId, startDate, endDate);
            return {
                records,
                count: records.length,
                deviceId
            };
        }
        catch (error) {
            return this.handleError(error, 'Failed to get attendance records', 'Attendance record retrieval not supported by this device type');
        }
    }
    async getAttendanceSize(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const size = await service.getAttendanceSize(deviceId);
            return { size, deviceId };
        }
        catch (error) {
            return this.handleError(error, 'Failed to get attendance size', 'Attendance size retrieval not supported by this device type');
        }
    }
    async clearAttendanceRecords(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const result = await service.clearAttendanceRecords(deviceId);
            return {
                success: result,
                message: result
                    ? 'Attendance records cleared successfully'
                    : 'Failed to clear attendance records'
            };
        }
        catch (error) {
            return this.handleError(error, 'Failed to clear attendance records', 'Attendance record clearing not supported by this device type');
        }
    }
    async getTime(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const time = await service.getTime(deviceId);
            return { deviceId, time };
        }
        catch (error) {
            return this.handleError(error, 'Failed to get device time', 'Time retrieval not supported by this device type');
        }
    }
    async getSerialNumber(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const serialNumber = await service.getSerialNumber(deviceId);
            return { deviceId, serialNumber };
        }
        catch (error) {
            return this.handleError(error, 'Failed to get device serial number', 'Serial number retrieval not supported by this device type');
        }
    }
    async getFirmwareVersion(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const firmwareVersion = await service.getFirmwareVersion(deviceId);
            return { deviceId, firmwareVersion };
        }
        catch (error) {
            return this.handleError(error, 'Failed to get device firmware version', 'Firmware version retrieval not supported by this device type');
        }
    }
    async restartDevice(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const success = await service.restartDevice(deviceId);
            return { deviceId, success };
        }
        catch (error) {
            return this.handleError(error, 'Failed to restart device', 'Device restart not supported by this device type');
        }
    }
    async unlockDoor(deviceId, unlockDoorDto) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            // Unlock door with delay (if supported)
            const success = await service.unlockDoor(deviceId);
            return { deviceId, success };
        }
        catch (error) {
            return this.handleError(error, 'Failed to unlock door', 'Door unlocking not supported by this device type');
        }
    }
    async syncUsers(syncUsersDto) {
        try {
            const { sourceDeviceId, targetDeviceId } = syncUsersDto;
            // Get the appropriate service based on source device ID (could also check target device type)
            const service = await this.biometricsFactory.getServiceByDeviceId(sourceDeviceId);
            const count = await service.syncUsers(sourceDeviceId, targetDeviceId);
            return { sourceDeviceId, targetDeviceId, count };
        }
        catch (error) {
            return this.handleError(error, 'Failed to sync users between devices', 'User synchronization not supported by this device type');
        }
    }
    async executeCommand(deviceId, executeCommandDto) {
        try {
            const { command, data } = executeCommandDto;
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            const result = await service.executeCommand(deviceId, command, data);
            return { deviceId, command, result };
        }
        catch (error) {
            return this.handleError(error, 'Failed to execute command', 'Command execution not supported by this device type');
        }
    }
    async getUserDetails(deviceId) {
        try {
            // Get the appropriate service based on the device ID
            const service = await this.biometricsFactory.getServiceByDeviceId(deviceId);
            return await service.getUserDetails(deviceId);
        }
        catch (error) {
            return this.handleError(error, 'Failed to get user details', 'User details retrieval not supported by this device type');
        }
    }
};
exports.BiometricsController = BiometricsController;
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get fingerprint template for a user' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Fingerprint template retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                id: { type: 'string', example: '1001-0' },
                userId: { type: 'string', example: '1001' },
                fingerId: { type: 'number', example: 0 },
                template: { type: 'string', format: 'binary', description: 'Binary template data' },
                provider: { type: 'string', example: 'zkteco' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Template or device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid request',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, common_1.Get)('users/fingerprint'),
    __param(0, (0, common_1.Query)(new common_1.ValidationPipe({ transform: true }))),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [GetFingerprintDto]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], BiometricsController.prototype, "getUserFingerprint", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Register a new user on a biometric device' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        description: 'User registered successfully',
        type: Object
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid input data',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, common_1.Post)('users/register'),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [SetUserDto]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], BiometricsController.prototype, "registerUser", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Set device time' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Device time set successfully' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid time format',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Put)('devices/:deviceId/time'),
    __param(0, (0, common_1.Param)('deviceId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], BiometricsController.prototype, "setTime", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Delete a user from a device' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'User deleted successfully' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device or user not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid user ID format',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Error deleting user',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, swagger_1.ApiParam)({ name: 'userId', description: 'User ID to delete' }),
    (0, common_1.Delete)('devices/:deviceId/users/:userId'),
    __param(0, (0, common_1.Param)('deviceId')),
    __param(1, (0, common_1.Param)('userId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], BiometricsController.prototype, "deleteUser", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get users registered on a device' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'List of user IDs',
        type: [Object]
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Get)('devices/:deviceId/users'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], BiometricsController.prototype, "getUsers", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get attendance records from a device' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'List of attendance records',
        type: [Object]
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Filter by start date (ISO format)' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'Filter by end date (ISO format)' }),
    (0, common_1.Get)('devices/:deviceId/attendance'),
    __param(0, (0, common_1.Param)('deviceId')),
    __param(1, (0, common_1.Query)('startDate')),
    __param(2, (0, common_1.Query)('endDate')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], BiometricsController.prototype, "getAttendanceRecords", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get attendance records size' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Attendance record count',
        type: Number
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Get)('devices/:deviceId/attendance/size'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], BiometricsController.prototype, "getAttendanceSize", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Clear attendance records from a device' }),
    (0, swagger_1.ApiResponse)({ status: common_1.HttpStatus.OK, description: 'Attendance records cleared successfully' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Delete)('devices/:deviceId/attendance'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], BiometricsController.prototype, "clearAttendanceRecords", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get device time' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Device time retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                deviceId: { type: 'string', example: '192.168.1.100:4370' },
                time: { type: 'string', format: 'date-time', example: '2025-05-06T12:00:00.000Z' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Get)('devices/:deviceId/time'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], BiometricsController.prototype, "getTime", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get device serial number' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Device serial number retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                deviceId: { type: 'string', example: '192.168.1.100:4370' },
                serialNumber: { type: 'string', example: 'ABC123456' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Get)('devices/:deviceId/serial'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], BiometricsController.prototype, "getSerialNumber", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get device firmware version' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Device firmware version retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                deviceId: { type: 'string', example: '192.168.1.100:4370' },
                firmwareVersion: { type: 'string', example: '1.2.3' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Get)('devices/:deviceId/firmware'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], BiometricsController.prototype, "getFirmwareVersion", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Restart device' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Device restarted successfully',
        schema: {
            type: 'object',
            properties: {
                deviceId: { type: 'string', example: '192.168.1.100:4370' },
                success: { type: 'boolean', example: true }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Post)('devices/:deviceId/restart'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_p = typeof Promise !== "undefined" && Promise) === "function" ? _p : Object)
], BiometricsController.prototype, "restartDevice", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Unlock device door' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Door unlocked successfully',
        schema: {
            type: 'object',
            properties: {
                deviceId: { type: 'string', example: '192.168.1.100:4370' },
                success: { type: 'boolean', example: true }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Post)('devices/:deviceId/unlock-door'),
    __param(0, (0, common_1.Param)('deviceId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, UnlockDoorDto]),
    __metadata("design:returntype", typeof (_q = typeof Promise !== "undefined" && Promise) === "function" ? _q : Object)
], BiometricsController.prototype, "unlockDoor", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Sync users between devices' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Users synced successfully',
        schema: {
            type: 'object',
            properties: {
                sourceDeviceId: { type: 'string', example: '192.168.1.100:4370' },
                targetDeviceId: { type: 'string', example: '192.168.1.101:4370' },
                count: { type: 'number', example: 10 }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, common_1.Post)('devices/sync-users'),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [SyncUsersDto]),
    __metadata("design:returntype", typeof (_r = typeof Promise !== "undefined" && Promise) === "function" ? _r : Object)
], BiometricsController.prototype, "syncUsers", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Execute custom command on device' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Command executed successfully',
        schema: {
            type: 'object',
            properties: {
                deviceId: { type: 'string', example: '192.168.1.100:4370' },
                command: { type: 'string', example: 'get_device_info1' },
                result: { type: 'object', additionalProperties: true }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid command',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Post)('devices/:deviceId/command'),
    __param(0, (0, common_1.Param)('deviceId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, ExecuteCommandDto]),
    __metadata("design:returntype", typeof (_s = typeof Promise !== "undefined" && Promise) === "function" ? _s : Object)
], BiometricsController.prototype, "executeCommand", null);
__decorate([
    (0, swagger_1.ApiOperation)({ summary: 'Get user details including fingerprint info' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'User details retrieved successfully',
        type: [Object]
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Device not found',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_IMPLEMENTED,
        description: 'Feature not implemented on this device',
        type: error_response_dto_1.ErrorResponseDto
    }),
    (0, swagger_1.ApiParam)({ name: 'deviceId', description: 'Target device ID' }),
    (0, common_1.Get)('devices/:deviceId/user-details'),
    __param(0, (0, common_1.Param)('deviceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_t = typeof Promise !== "undefined" && Promise) === "function" ? _t : Object)
], BiometricsController.prototype, "getUserDetails", null);
exports.BiometricsController = BiometricsController = __decorate([
    (0, swagger_1.ApiTags)('Biometrics'),
    (0, common_1.Controller)(),
    (0, common_1.UseInterceptors)(new timeout_interceptor_1.TimeoutInterceptor(30)),
    __metadata("design:paramtypes", [typeof (_a = typeof biometrics_factory_service_1.BiometricsFactoryService !== "undefined" && biometrics_factory_service_1.BiometricsFactoryService) === "function" ? _a : Object, typeof (_b = typeof biometric_devices_service_1.BiometricDevicesService !== "undefined" && biometric_devices_service_1.BiometricDevicesService) === "function" ? _b : Object])
], BiometricsController);


/***/ }),
/* 230 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ErrorResponseDto = void 0;
const swagger_1 = __webpack_require__(8);
/**
 * DTO for biometrics API error responses
 */
class ErrorResponseDto {
}
exports.ErrorResponseDto = ErrorResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'HTTP status code of the error response',
        example: 400,
        type: Number,
    }),
    __metadata("design:type", Number)
], ErrorResponseDto.prototype, "statusCode", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Error message or messages describing the issue',
        example: 'Failed to connect to device',
        oneOf: [
            { type: 'string' },
            { type: 'array', items: { type: 'string' } }
        ]
    }),
    __metadata("design:type", Object)
], ErrorResponseDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Error code for client identification',
        example: 'DEVICE_CONNECTION_ERROR',
        type: String,
    }),
    __metadata("design:type", String)
], ErrorResponseDto.prototype, "code", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Additional error details or context',
        example: 'Device might be offline or credentials are invalid',
        type: String,
        required: false
    }),
    __metadata("design:type", String)
], ErrorResponseDto.prototype, "detail", void 0);


/***/ }),
/* 231 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutInterceptor = void 0;
const common_1 = __webpack_require__(5);
const rxjs_1 = __webpack_require__(232);
const operators_1 = __webpack_require__(233);
let TimeoutInterceptor = class TimeoutInterceptor {
    constructor(timeoutSeconds = 30) {
        this.timeoutSeconds = timeoutSeconds;
    }
    intercept(context, next) {
        return next.handle().pipe((0, operators_1.timeout)(this.timeoutSeconds * 1000), (0, operators_1.catchError)(err => {
            if (err instanceof rxjs_1.TimeoutError) {
                return (0, rxjs_1.throwError)(() => new common_1.RequestTimeoutException('Request timed out'));
            }
            return (0, rxjs_1.throwError)(() => err);
        }));
    }
};
exports.TimeoutInterceptor = TimeoutInterceptor;
exports.TimeoutInterceptor = TimeoutInterceptor = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [Number])
], TimeoutInterceptor);


/***/ }),
/* 232 */
/***/ ((module) => {

"use strict";
module.exports = require("rxjs");

/***/ }),
/* 233 */
/***/ ((module) => {

"use strict";
module.exports = require("rxjs/operators");

/***/ }),
/* 234 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricTemplate = void 0;
const base_entity_1 = __webpack_require__(34);
const typeorm_1 = __webpack_require__(25);
let BiometricTemplate = class BiometricTemplate extends base_entity_1.BaseEntity {
};
exports.BiometricTemplate = BiometricTemplate;
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], BiometricTemplate.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Number)
], BiometricTemplate.prototype, "fingerId", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'longblob' }),
    __metadata("design:type", typeof (_a = typeof Buffer !== "undefined" && Buffer) === "function" ? _a : Object)
], BiometricTemplate.prototype, "template", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], BiometricTemplate.prototype, "provider", void 0);
exports.BiometricTemplate = BiometricTemplate = __decorate([
    (0, typeorm_1.Entity)('biometric_templates')
], BiometricTemplate);


/***/ }),
/* 235 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var AnvizBiometricsService_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnvizBiometricsService = void 0;
const biometrics_device_type_enum_1 = __webpack_require__(77);
const punch_method_enum_1 = __webpack_require__(74);
const punch_type_enum_1 = __webpack_require__(75);
const attendance_event_1 = __webpack_require__(236);
const common_1 = __webpack_require__(5);
const event_emitter_1 = __webpack_require__(139);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const biometric_device_entity_1 = __webpack_require__(76);
const biometric_template_entity_1 = __webpack_require__(234);
const base_biometrics_service_1 = __webpack_require__(237);
// Import the Anviz protocol library
const { Device, Record, RecordInformation, DeviceInfo1, DeviceInfo2 } = __webpack_require__(238);
let AnvizBiometricsService = AnvizBiometricsService_1 = class AnvizBiometricsService extends base_biometrics_service_1.BaseBiometricsService {
    constructor(templateRepository, deviceRepository, eventEmitter) {
        super(deviceRepository, eventEmitter);
        this.templateRepository = templateRepository;
        this.deviceRepository = deviceRepository;
        this.eventEmitter = eventEmitter;
        this.logger = new common_1.Logger(AnvizBiometricsService_1.name);
        this.biometricDeviceType = biometrics_device_type_enum_1.BiometricDeviceType.ANVIZ;
        // Command queue to avoid multiple operations on the same device simultaneously
        this.commandQueues = new Map();
        // Flag to track if a device's queue is being processed
        this.processingQueues = new Map();
        // Default command timeout (15 seconds)
        this.commandTimeout = 15000;
    }
    /**
     * Queue a command to be executed on a device
     * @param deviceId Device identifier
     * @param operation Operation name for logging
     * @param execute Function to execute
     * @returns Promise that resolves when the operation completes
     */
    queueCommand(deviceId, operation, execute) {
        return new Promise((resolve, reject) => {
            // Create queue for device if it doesn't exist
            if (!this.commandQueues.has(deviceId)) {
                this.commandQueues.set(deviceId, []);
                this.processingQueues.set(deviceId, false);
            }
            // Create a unique ID for this command
            const commandId = `${operation}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            // Create command queue item
            const queueItem = {
                id: commandId,
                operation,
                execute,
                resolve,
                reject,
                timestamp: Date.now(),
                timeout: setTimeout(() => {
                    // Remove item from queue if it times out
                    this.removeFromQueue(deviceId, commandId);
                    reject(new Error(`Operation '${operation}' timed out after ${this.commandTimeout}ms`));
                }, this.commandTimeout)
            };
            // Add item to device queue
            const queue = this.commandQueues.get(deviceId); // Non-null assertion as we create it above if it doesn't exist
            queue.push(queueItem);
            this.logger.debug(`Queued operation '${operation}' for device ${deviceId}. Queue length: ${queue.length}`);
            // Start processing queue if not already processing
            if (!this.processingQueues.get(deviceId)) {
                this.processQueue(deviceId);
            }
        });
    }
    /**
     * Process the command queue for a device
     * @param deviceId Device identifier
     */
    async processQueue(deviceId) {
        if (!this.commandQueues.has(deviceId))
            return;
        // Set processing flag
        this.processingQueues.set(deviceId, true);
        const queue = this.commandQueues.get(deviceId); // Non-null assertion as we already checked above
        // Process queue items one by one
        while (queue.length > 0) {
            const item = queue[0];
            this.logger.debug(`Executing operation '${item.operation}' for device ${deviceId}`);
            try {
                // Execute the command
                const result = await item.execute();
                // Clear timeout and resolve promise
                if (item.timeout)
                    clearTimeout(item.timeout);
                item.resolve(result);
            }
            catch (error) {
                // Clear timeout and reject promise
                if (item.timeout)
                    clearTimeout(item.timeout);
                item.reject(error);
            }
            finally {
                // Remove item from queue
                queue.shift();
            }
        }
        // Clear processing flag
        this.processingQueues.set(deviceId, false);
    }
    /**
     * Remove an item from the command queue
     * @param deviceId Device identifier
     * @param commandId Command ID to remove
     */
    removeFromQueue(deviceId, commandId) {
        if (!this.commandQueues.has(deviceId))
            return false;
        const queue = this.commandQueues.get(deviceId); // Non-null assertion as we already checked above
        const initialLength = queue.length;
        // Filter out item with matching ID
        const newQueue = queue.filter(item => item.id !== commandId);
        this.commandQueues.set(deviceId, newQueue);
        return newQueue.length !== initialLength;
    }
    // Helper method to execute a promise with timeout
    async executeWithTimeout(promiseFn, timeoutMs, timeoutMessage) {
        return new Promise(async (resolve, reject) => {
            // Create timeout that rejects the promise
            const timeoutId = setTimeout(() => {
                reject(new common_1.RequestTimeoutException(timeoutMessage));
            }, timeoutMs);
            try {
                // Execute the actual promise
                const result = await promiseFn();
                clearTimeout(timeoutId);
                resolve(result);
            }
            catch (error) {
                clearTimeout(timeoutId);
                reject(error);
            }
        });
    }
    /**
     * Connect to an Anviz device with robust retry logic
     * @param dto Connection details
     * @param deviceId Device identifier
     * @returns Connected device information
     */
    async connectWithRetry(dto, deviceId) {
        const { ipAddress, port } = dto;
        // Check if already connected
        if (this.connections.has(deviceId)) {
            this.logger.warn(`Device ${deviceId} is already connected. Disconnecting first...`);
            await this.disconnect(deviceId);
        }
        try {
            // Create a connection promise with timeout
            const connectionPromise = async () => {
                // Create a new Anviz device connection
                const anvizDevice = new Device(ipAddress, port);
                // Set up connection events with proper reconnection handling
                anvizDevice.listener = {
                    onConnectionLost: async () => {
                        this.logger.warn(`Connection lost to Anviz device ${deviceId}`);
                        // Clear any heartbeat interval
                        if (anvizDevice._heartbeatInterval) {
                            clearInterval(anvizDevice._heartbeatInterval);
                            anvizDevice._heartbeatInterval = null;
                        }
                        await this.disconnect(deviceId);
                        // Schedule automatic reconnection
                        this.scheduleReconnect(deviceId);
                    },
                    onError: async (error) => {
                        const errorMessage = error instanceof Error ? error.message : String(error);
                        this.logger.error(`Anviz device ${deviceId} error: ${errorMessage}`);
                        // Clear any heartbeat interval
                        if (anvizDevice._heartbeatInterval) {
                            clearInterval(anvizDevice._heartbeatInterval);
                            anvizDevice._heartbeatInterval = null;
                        }
                    },
                    onRecord: (record) => {
                        // Validate and standardize the record
                        if (!record || typeof record.userId === 'undefined' || !record.dateTime) {
                            this.logger.warn(`Received invalid record from device ${deviceId}`);
                            return;
                        }
                        const standardizedRecord = {
                            userId: record.userId.toString(),
                            // used the system date instead of the device date because time is not accurate and consistent
                            timestamp: new Date(),
                            punchType: record.type,
                            punchMethod: this.getPunchMethod(record.backupCode),
                            deviceId: deviceId,
                        };
                        this.logger.log(`Received attendance record from device ${deviceId}: ${JSON.stringify(standardizedRecord)}`);
                        // Emit the attendance event
                        this.eventEmitter.emit(attendance_event_1.ATTENDANCE_EVENTS.ATTENDANCE_RECORDED, new attendance_event_1.AttendanceRecordedEvent([standardizedRecord], deviceId));
                        anvizDevice.clearAllRecords();
                    }
                };
                anvizDevice.connect();
                // Connection successful - configure device
                await new Promise((resolve, reject) => {
                    anvizDevice.getDeviceInfo2((info) => {
                        try {
                            info.realTimeModeSetting = 1; // enable real time mode
                            info.relayMode = 3; // 0 control lock, 1 scheduled bell, 3 disabled
                            info.lockDelay = 2; // 2 seconds
                            anvizDevice.setDeviceInfo2(info);
                            // Fetch and process any pending records
                            anvizDevice.getNewRecords((records) => {
                                try {
                                    if (records && records.length > 0) {
                                        for (let i = 0; i < records.length; ++i) {
                                            anvizDevice.listener.onRecord(records[i]);
                                        }
                                        anvizDevice.clearAllRecordsSign();
                                    }
                                    resolve();
                                }
                                catch (err) {
                                    reject(err);
                                }
                            });
                        }
                        catch (err) {
                            reject(err);
                        }
                    });
                });
                // Store the connection
                this.connections.set(deviceId, anvizDevice);
                // Fetch device information
                const deviceInfo = await this.getAnvizDeviceInfo(deviceId);
                // Check if device ID already exists
                const existingDevice = await this.deviceRepository.findOne({ where: { deviceId } });
                // Create a standardized device object
                let device = {
                    id: existingDevice === null || existingDevice === void 0 ? void 0 : existingDevice.id,
                    deviceId,
                    ipAddress,
                    port,
                    serialNumber: deviceInfo.serialNumber || 'Unknown',
                    firmware: deviceInfo.firmwareVersion || 'Unknown',
                    isConnected: true,
                    isOffline: false,
                    provider: biometrics_device_type_enum_1.BiometricDeviceType.ANVIZ,
                    lastSync: new Date(),
                };
                // Set up heartbeat to monitor connection health
                if (anvizDevice._heartbeatInterval) {
                    clearInterval(anvizDevice._heartbeatInterval);
                }
                anvizDevice._heartbeatInterval = setInterval(() => {
                    this.verifyDeviceConnection(anvizDevice, deviceId)
                        .then(() => {
                        // Connection is healthy
                    })
                        .catch((error) => {
                        this.logger.error(`Device ${deviceId} connection verification failed: ${error.message}`);
                        // If heartbeat fails, connection is likely lost
                        if (anvizDevice.listener && anvizDevice.listener.onConnectionLost) {
                            anvizDevice.listener.onConnectionLost();
                        }
                    });
                }, 10000); // Check every 30 seconds to reduce overhead
                // log
                this.logger.log(`Connected to Anviz device ${deviceId} (${deviceInfo.serialNumber})`);
                // Update or create device in database
                return await this.deviceRepository.save(device);
            };
            // Execute with timeout
            return await this.executeWithTimeout(connectionPromise, 30000, `Connection to device ${deviceId} timed out after 30 seconds`);
        }
        catch (error) {
            // Schedule automatic reconnection
            this.logger.error(`Failed to connect to Anviz device ${deviceId}: ${error.message}`);
            throw new common_1.InternalServerErrorException(`Failed to connect to Anviz device ${deviceId}`);
        }
    }
    /**
     * Map Anviz punch types to system punch types
     */
    mapPunchType(backupCode) {
        switch (backupCode) {
            case 0:
                return punch_type_enum_1.PunchType.CHECK_IN;
            case 1:
                return punch_type_enum_1.PunchType.CHECK_OUT;
            case 2:
                return punch_type_enum_1.PunchType.BREAK_OUT;
            case 3:
                return punch_type_enum_1.PunchType.BREAK_IN;
            case 4:
                return punch_type_enum_1.PunchType.OVERTIME_IN;
            case 5:
                return punch_type_enum_1.PunchType.OVERTIME_OUT;
            default:
                return punch_type_enum_1.PunchType.CHECK_IN;
        }
    }
    /**
     * Schedule a reconnection attempt
     * @param deviceId Device identifier
     * @param attempt Current attempt number (default: 0)
     */
    scheduleReconnect(deviceId, attempt = 0) {
        // Calculate backoff time (exponential with max of 5 minutes)
        const backoffMs = Math.min(5000 * Math.pow(1.5, attempt), 300000);
        // Create new timer
        setTimeout(async () => {
            try {
                // Check if device exists in database before reconnecting
                const deviceInfo = await this.deviceRepository.findOne({ where: { deviceId } });
                if (!deviceInfo) {
                    this.logger.warn(`Device ${deviceId} no longer exists in database. Stopping reconnection attempts.`);
                    return;
                }
                // Try to reconnect
                await this.connectWithRetry({
                    ipAddress: deviceInfo.ipAddress,
                    port: deviceInfo.port,
                    deviceType: biometrics_device_type_enum_1.BiometricDeviceType.ANVIZ
                }, deviceId);
            }
            catch (error) {
                // If reconnection fails, schedule another attempt
                this.scheduleReconnect(deviceId, attempt + 1);
            }
        }, backoffMs);
        return attempt + 1;
    }
    /**
     * Verify device connection is still active and responsive
     * @param device Anviz device instance
     * @param deviceId Device identifier
     */
    verifyDeviceConnection(device, deviceId) {
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error(`Device ${deviceId} connection verification timeout`));
            }, 5000);
            try {
                device.getSerialNumber((serialNumber) => {
                    clearTimeout(timeoutId);
                    resolve();
                });
            }
            catch (error) {
                clearTimeout(timeoutId);
                reject(error);
            }
        });
    }
    /**
     * Disconnect from an Anviz device
     * @param deviceId Device identifier
     * @param isManual Whether this is a manual disconnect (if false, may trigger reconnection)
     * @returns Disconnected device information
     */
    async disconnect(deviceId, isManual = false) {
        const anvizDevice = this.connections.get(deviceId);
        if (anvizDevice) {
            // Clear heartbeat interval
            if (anvizDevice._heartbeatInterval) {
                clearInterval(anvizDevice._heartbeatInterval);
                anvizDevice._heartbeatInterval = null;
            }
            try {
                anvizDevice.disconnect();
            }
            catch (err) {
                const error = err;
                this.logger.warn(`Error during disconnect for device ${deviceId}: ${error.message}`);
            }
            // Remove from connections map
            this.connections.delete(deviceId);
        }
        // Clear command queue for device
        if (this.commandQueues.has(deviceId)) {
            const queue = this.commandQueues.get(deviceId);
            // Reject all pending commands
            for (const item of queue) {
                if (item.timeout)
                    clearTimeout(item.timeout);
                item.reject(new Error(`Device ${deviceId} disconnected during operation '${item.operation}'`));
            }
            this.commandQueues.delete(deviceId);
            this.processingQueues.delete(deviceId);
        }
        return await this.updateDeviceStatus(deviceId, !isManual, true);
    }
    getPunchMethod(value) {
        switch (value) {
            case 35:
                return punch_method_enum_1.PunchMethod.FINGERPRINT;
            case 19:
                return punch_method_enum_1.PunchMethod.FINGERPRINT;
            case 8:
                return punch_method_enum_1.PunchMethod.RFID;
            case 4:
                return punch_method_enum_1.PunchMethod.PASSWORD;
            default:
                return punch_method_enum_1.PunchMethod.UNKNOWN;
        }
    }
    /**
     * Get device information from Anviz device
     * @param deviceId Device identifier
     */
    getAnvizDeviceInfo(deviceId) {
        return new Promise((resolve, reject) => {
            const anvizDevice = this.getAnvizDevice(deviceId);
            // Get device information (DeviceInfo1 and DeviceInfo2)
            anvizDevice.getDeviceInfo1((deviceInfo1) => {
                anvizDevice.getDeviceInfo2((deviceInfo2) => {
                    // Get serial number
                    anvizDevice.getSerialNumber((serialNumber) => {
                        const info = {
                            serialNumber,
                            firmwareVersion: deviceInfo1.firmwareVersion,
                            deviceType: 'Anviz',
                            attendanceState: deviceInfo1.attendanceState,
                            language: deviceInfo1.language,
                            timeFormat: deviceInfo1.timeFormat,
                            dateFormat: deviceInfo1.dateFormat,
                            fingerprintPrecision: deviceInfo2.fingerprintPrecision,
                            workCodePermission: deviceInfo2.workCodePermission
                        };
                        resolve(info);
                    });
                });
            });
        });
    }
    /**
     * Get device information
     * @param deviceId Device identifier
     */
    async getDeviceInfo(deviceId) {
        try {
            this.checkDeviceConnection(deviceId);
            this.logger.log(`Getting device info for ${deviceId}`);
            const info = await this.getAnvizDeviceInfo(deviceId);
            // Update device in database with latest information
            await this.deviceRepository.update({ id: deviceId }, {
                serialNumber: info.serialNumber,
                firmware: info.firmwareVersion,
                lastSync: new Date()
            });
            return info;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting device info for ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get device info: ${errorMessage}`);
        }
    }
    /**
     * Get users from Anviz device
     * @param deviceId Device identifier
     */
    async getUsers(deviceId) {
        return this.queueCommand(deviceId, 'getUsers', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                this.logger.log(`Getting users from device ${deviceId}`);
                return new Promise((resolve, reject) => {
                    const anvizDevice = this.getAnvizDevice(deviceId);
                    anvizDevice.getUserInfos((userInfos) => {
                        try {
                            // Convert Anviz user format to system format
                            const users = userInfos.map((user) => {
                                var _a, _b;
                                return ({
                                    userId: user.userId.toString(),
                                    name: user.name || '',
                                    password: ((_a = user.password) === null || _a === void 0 ? void 0 : _a.toString()) || '',
                                    cardNumber: ((_b = user.card) === null || _b === void 0 ? void 0 : _b.toString()) || '',
                                    role: user.group || 0,
                                    enrolledFingerprints: []
                                });
                            });
                            resolve(users);
                        }
                        catch (error) {
                            reject(error);
                        }
                    });
                });
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error getting users from device ${deviceId}: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to get users: ${errorMessage}`);
            }
        });
    }
    /**
     * Get fingerprint template for a user
     * @param deviceId Device identifier
     * @param userId User ID
     * @param fingerId Finger ID (default: 1 for Anviz devices)
     */
    async getUserFingerprint(deviceId, userId, fingerId = 1) {
        try {
            this.checkDeviceConnection(deviceId);
            this.logger.log(`Getting fingerprint for user ${userId} (finger ${fingerId}) from device ${deviceId}`);
            // First check database for cached template
            try {
                const existingTemplate = await this.templateRepository.findOne({
                    where: {
                        userId,
                        fingerId,
                        provider: 'anviz'
                    }
                });
                if (existingTemplate && existingTemplate.template) {
                    this.logger.log(`Found existing template in database for user ${userId} (finger ${fingerId})`);
                    return {
                        id: `${userId}-${fingerId}`,
                        userId,
                        fingerId,
                        template: existingTemplate.template,
                        provider: 'anviz'
                    };
                }
            }
            catch (dbError) {
                this.logger.warn(`Database lookup failed: ${dbError instanceof Error ? dbError.message : String(dbError)}`);
            }
            return new Promise((resolve, reject) => {
                const anvizDevice = this.getAnvizDevice(deviceId);
                anvizDevice.getFpTemplate(parseInt(userId), fingerId, (templateData) => {
                    try {
                        if (!templateData || templateData.length === 0) {
                            resolve(null);
                            return;
                        }
                        // Create template object
                        const template = {
                            id: `${userId}-${fingerId}`,
                            userId,
                            fingerId,
                            template: Buffer.from(templateData),
                            provider: 'anviz'
                        };
                        // Cache template in database
                        this.templateRepository.save({
                            userId,
                            fingerId,
                            template: Buffer.isBuffer(template.template) ? template.template : Buffer.from(template.template),
                            provider: 'anviz'
                        }).catch(err => {
                            this.logger.warn(`Failed to cache template in database: ${err.message}`);
                        });
                        resolve(template);
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            });
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting fingerprint from device ${deviceId}: ${errorMessage}`);
            if (errorMessage.includes('not found') || errorMessage.includes('No Record')) {
                return null;
            }
            throw new base_biometrics_service_1.BiometricException(`Failed to get fingerprint: ${errorMessage}`);
        }
    }
    /**
     * Register a new user on Anviz device
     * @param deviceId Device identifier
     * @param userData User data
     */
    async registerUser(deviceId, userData) {
        try {
            this.checkDeviceConnection(deviceId);
            this.logger.log(`Registering user ${userData.userId} on device ${deviceId}`);
            const anvizDevice = this.getAnvizDevice(deviceId);
            // Create Anviz user object
            const userInfo = {
                userId: parseInt(userData.userId),
                name: userData.name,
                password: userData.password ? parseInt(userData.password) : 0,
                passwordLength: userData.password ? userData.password.length : 0,
                card: userData.cardNumber ? parseInt(userData.cardNumber) : 0,
                group: userData.role || 0,
                dpt: 1, // Department (default: 1)
                attendanceMode: 0 // Default mode
            };
            // Set user on device
            await new Promise((resolve, reject) => {
                try {
                    anvizDevice.setUserInfo(userInfo);
                    resolve();
                }
                catch (error) {
                    reject(error);
                }
            });
            // Return standardized user object
            const createdUser = {
                userId: userData.userId,
                name: userData.name,
                password: userData.password || '', // Provide a default empty string if password is undefined
                cardNumber: userData.cardNumber,
                role: userData.role || 0,
                department: 1,
                attendanceMode: 0,
                enrolledFingerprints: []
            };
            this.logger.log(`Successfully registered user ${userData.userId} on device ${deviceId}`);
            return createdUser;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error registering user on device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to register user: ${errorMessage}`);
        }
    }
    /**
     * Delete a user from Anviz device
     * @param deviceId Device identifier
     * @param userId User ID to delete
     */
    async deleteUser(deviceId, userId) {
        try {
            this.checkDeviceConnection(deviceId);
            this.logger.log(`Deleting user ${userId} from device ${deviceId}`);
            const anvizDevice = this.getAnvizDevice(deviceId);
            // Delete user
            anvizDevice.deleteUser(parseInt(userId));
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error deleting user ${userId} from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to delete user: ${errorMessage}`);
        }
    }
    /**
     * Get attendance records from Anviz device
     * @param deviceId Device identifier
     * @param startDate Start date for filtering (optional)
     * @param endDate End date for filtering (optional)
     */
    async getAttendanceRecords(deviceId, startDate, endDate) {
        try {
            this.checkDeviceConnection(deviceId);
            this.logger.log(`Getting attendance records from device ${deviceId}`);
            return new Promise((resolve, reject) => {
                const anvizDevice = this.getAnvizDevice(deviceId);
                // Get all records
                anvizDevice.getAllRecords((records) => {
                    try {
                        // Convert Anviz records to system format
                        let attendanceRecords = records.map((record) => {
                            const timestamp = new Date(record.dateTime);
                            // Filter by date if provided
                            if ((startDate && timestamp < startDate) ||
                                (endDate && timestamp > endDate)) {
                                return null;
                            }
                            return {
                                userId: record.userId.toString(),
                                timestamp: timestamp,
                                type: record.type || 0,
                                deviceId: deviceId,
                                status: record.workTypes ? record.workTypes[0] : 0
                            };
                        });
                        // Filter out null records (those outside date range)
                        attendanceRecords = attendanceRecords.filter(record => record !== null);
                        resolve(attendanceRecords);
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            });
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting attendance records from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get attendance records: ${errorMessage}`);
        }
    }
    /**
     * Get attendance records size
     * @param deviceId Device identifier
     */
    async getAttendanceSize(deviceId) {
        try {
            this.checkDeviceConnection(deviceId);
            return new Promise((resolve, reject) => {
                const anvizDevice = this.getAnvizDevice(deviceId);
                anvizDevice.getRecordInformation((info) => {
                    try {
                        resolve(info.allRecordAmount || 0);
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            });
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting attendance size from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get attendance size: ${errorMessage}`);
        }
    }
    /**
     * Clear attendance records from device
     * @param deviceId Device identifier
     */
    async clearAttendanceRecords(deviceId) {
        try {
            this.checkDeviceConnection(deviceId);
            this.logger.log(`Clearing attendance records from device ${deviceId}`);
            return new Promise((resolve, reject) => {
                const anvizDevice = this.getAnvizDevice(deviceId);
                anvizDevice.clearAllRecords((result) => {
                    try {
                        resolve(true);
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            });
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error clearing attendance records from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to clear attendance records: ${errorMessage}`);
        }
    }
    /**
     * Unlock door of Anviz device
     * @param deviceId Device identifier
     */
    async unlockDoor(deviceId) {
        try {
            this.checkDeviceConnection(deviceId);
            this.logger.log(`Unlocking door for device ${deviceId}`);
            const anvizDevice = this.getAnvizDevice(deviceId);
            anvizDevice.openLock();
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error unlocking door for device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to unlock door: ${errorMessage}`);
        }
    }
    /**
     * Get the Anviz device connection, throwing an exception if not connected
     * @param deviceId Device identifier
     */
    getAnvizDevice(deviceId) {
        const anvizDevice = this.connections.get(deviceId);
        if (!anvizDevice) {
            throw new base_biometrics_service_1.BiometricException(`Device ${deviceId} not connected`, common_1.HttpStatus.NOT_FOUND);
        }
        return anvizDevice;
    }
    /**
     * Check if device is connected
     * @param deviceId Device identifier
     */
    checkDeviceConnection(deviceId) {
        if (!this.connections.has(deviceId)) {
            throw new base_biometrics_service_1.BiometricException(`Device ${deviceId} not connected`, common_1.HttpStatus.NOT_FOUND);
        }
    }
    /**
     * Get device time
     * @param deviceId Device identifier
     */
    async getTime(deviceId) {
        return this.queueCommand(deviceId, 'getTime', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error('Get time operation timed out'));
                    }, 5000);
                    const anvizDevice = this.getAnvizDevice(deviceId);
                    anvizDevice.getDateTime((date) => {
                        clearTimeout(timeoutId);
                        resolve(date);
                    });
                });
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error getting device time: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to get device time: ${errorMessage}`);
            }
        });
    }
    /**
     * Set device time
     * @param deviceId Device identifier
     * @param time Date to set
     */
    async setTime(deviceId, time) {
        return this.queueCommand(deviceId, 'setTime', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error('Set time operation timed out'));
                    }, 5000);
                    try {
                        const anvizDevice = this.getAnvizDevice(deviceId);
                        anvizDevice.setDateTime(time);
                        clearTimeout(timeoutId);
                        resolve(true);
                    }
                    catch (error) {
                        clearTimeout(timeoutId);
                        reject(error);
                    }
                });
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error setting device time: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to set device time: ${errorMessage}`);
            }
        });
    }
    /**
     * Get the firmware version from device
     * @param deviceId Device identifier
     */
    async getFirmwareVersion(deviceId) {
        return this.queueCommand(deviceId, 'getFirmwareVersion', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                const info = await this.getAnvizDeviceInfo(deviceId);
                return info.firmwareVersion || 'Unknown';
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error getting firmware version: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to get firmware version: ${errorMessage}`);
            }
        });
    }
    /**
     * Get the serial number from device
     * @param deviceId Device identifier
     */
    async getSerialNumber(deviceId) {
        return this.queueCommand(deviceId, 'getSerialNumber', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error('Get serial number operation timed out'));
                    }, 5000);
                    const anvizDevice = this.getAnvizDevice(deviceId);
                    anvizDevice.getSerialNumber((serialNumber) => {
                        clearTimeout(timeoutId);
                        resolve(serialNumber || 'Unknown');
                    });
                });
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error getting serial number: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to get serial number: ${errorMessage}`);
            }
        });
    }
    /**
     * Get device name - Not directly supported by Anviz, returns model name from device info
     * @param deviceId Device identifier
     */
    async getDeviceName(deviceId) {
        return this.queueCommand(deviceId, 'getDeviceName', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                // Anviz doesn't provide a direct method to get the device name, so we return the device type
                const info = await this.getAnvizDeviceInfo(deviceId);
                return info.deviceType || 'Anviz Device';
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error getting device name: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to get device name: ${errorMessage}`);
            }
        });
    }
    /**
     * Restart the Anviz device - Not directly supported by Anviz protocol
     * @param deviceId Device identifier
     */
    async restartDevice(deviceId) {
        return this.queueCommand(deviceId, 'restartDevice', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                // Anviz doesn't provide a direct method to restart the device
                // We'll simulate it by disconnecting and reconnecting
                const deviceInfo = await this.deviceRepository.findOne({ where: { deviceId } });
                if (!deviceInfo) {
                    throw new base_biometrics_service_1.BiometricException(`Device ${deviceId} not found in database`, common_1.HttpStatus.NOT_FOUND);
                }
                await this.disconnect(deviceId, true);
                // Wait a moment before reconnecting
                await new Promise(resolve => setTimeout(resolve, 2000));
                await this.connectWithRetry({
                    ipAddress: deviceInfo.ipAddress,
                    port: deviceInfo.port,
                    deviceType: biometrics_device_type_enum_1.BiometricDeviceType.ANVIZ
                }, deviceId);
                return true;
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error restarting device: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to restart device: ${errorMessage}`, common_1.HttpStatus.NOT_IMPLEMENTED);
            }
        });
    }
    /**
     * Get user details (enhanced user information)
     * @param deviceId Device identifier
     */
    async getUserDetails(deviceId) {
        // For Anviz devices, getUserDetails and getUsers return the same information
        return this.getUsers(deviceId);
    }
    /**
     * Enroll a user's fingerprint
     * Anviz devices don't support direct enrollment via API, must be done on the device
     * @param deviceId Device identifier
     * @param userId User ID
     * @param fingerId Finger ID
     */
    async enrollUser(deviceId, userId, fingerId) {
        throw new base_biometrics_service_1.BiometricException('Fingerprint enrollment via API is not supported by Anviz devices. Users must enroll fingerprints directly on the device.', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    /**
     * Verify fingerprint on device - Not directly supported by Anviz via API
     * @param deviceId Device identifier
     * @param template Template to verify
     */
    async verifyFingerprint(deviceId, template) {
        throw new base_biometrics_service_1.BiometricException('Fingerprint verification via API is not supported by Anviz devices', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    /**
     * Set a user on the device with more detailed options
     * @param deviceId Device identifier
     * @param uid Internal user ID
     * @param userId External user ID
     * @param name User name
     * @param password User password (optional)
     * @param role User role (optional)
     * @param cardno Card number (optional)
     */
    async setUser(deviceId, uid, userId, name, password, role, cardno) {
        return this.queueCommand(deviceId, 'setUser', async () => {
            try {
                this.checkDeviceConnection(deviceId);
                this.logger.log(`Setting user ${userId} on device ${deviceId}`);
                const anvizDevice = this.getAnvizDevice(deviceId);
                // Create Anviz user object
                const userInfo = {
                    userId: parseInt(userId),
                    name,
                    password: password ? parseInt(password) : 0,
                    passwordLength: password ? password.length : 0,
                    card: cardno || 0,
                    group: role || 0,
                    dpt: 1, // Department (default: 1)
                    attendanceMode: 0 // Default mode
                };
                return new Promise((resolve, reject) => {
                    try {
                        anvizDevice.setUserInfo(userInfo);
                        resolve(true);
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error setting user on device ${deviceId}: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to set user: ${errorMessage}`);
            }
        });
    }
    /**
     * Sync users from one device to another
     * @param sourceDeviceId Source device ID
     * @param targetDeviceId Target device ID
     */
    async syncUsers(sourceDeviceId, targetDeviceId) {
        return this.queueCommand(sourceDeviceId, `syncUsers-to-${targetDeviceId}`, async () => {
            try {
                this.checkDeviceConnection(sourceDeviceId);
                this.checkDeviceConnection(targetDeviceId);
                this.logger.log(`Syncing users from device ${sourceDeviceId} to device ${targetDeviceId}`);
                // Get users from source device
                const users = await this.getUsers(sourceDeviceId);
                // Create sync queue for target device
                let syncCount = 0;
                // Process each user
                for (const user of users) {
                    try {
                        // Register user on target device
                        await this.registerUser(targetDeviceId, {
                            userId: user.userId,
                            name: user.name,
                            password: user.password,
                            cardNumber: user.cardNumber,
                            role: user.role
                        });
                        syncCount++;
                    }
                    catch (userError) {
                        const error = userError;
                        this.logger.warn(`Error syncing user ${user.userId}: ${error.message}`);
                        // Continue with next user
                    }
                }
                this.logger.log(`Successfully synced ${syncCount} users from ${sourceDeviceId} to ${targetDeviceId}`);
                return syncCount;
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error syncing users: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to sync users: ${errorMessage}`);
            }
        });
    }
    /**
     * Execute a custom command on the device
     * @param deviceId Device identifier
     * @param command Command to execute
     * @param data Additional data for the command
     */
    async executeCommand(deviceId, command, data) {
        return this.queueCommand(deviceId, `executeCommand-${command}`, async () => {
            try {
                this.checkDeviceConnection(deviceId);
                this.logger.log(`Executing custom command '${command}' on device ${deviceId}`);
                // Map command string to Anviz protocol command code
                const commandMap = {
                    'get_device_id': 0x74,
                    'set_device_id': 0x75,
                    'get_device_info1': 0x30,
                    'set_device_info1': 0x31,
                    'get_device_info2': 0x32,
                    'set_device_info2': 0x33,
                    'get_serial_number': 0x24,
                    'get_date_time': 0x38,
                    'set_date_time': 0x39,
                    'get_record_info': 0x3C,
                    'get_records': 0x40,
                    'clear_records': 0x4E,
                    'get_user_info': 0x72,
                    'set_user_info': 0x73,
                    'delete_user': 0x4C,
                    'get_fp_template': 0x44,
                    'set_fp_template': 0x45,
                    'open_lock': 0x5E
                };
                const commandCode = commandMap[command.toLowerCase()];
                if (!commandCode) {
                    throw new base_biometrics_service_1.BiometricException(`Unsupported command: ${command}`, common_1.HttpStatus.BAD_REQUEST);
                }
                // Convert data string to Buffer if provided
                let dataBuffer;
                if (data) {
                    try {
                        // Try to parse as JSON first
                        const jsonData = JSON.parse(data);
                        // Convert JSON to buffer (implementation depends on command)
                        // This is a simplified example
                        dataBuffer = Buffer.from(JSON.stringify(jsonData));
                    }
                    catch (_a) {
                        // If not JSON, treat as hex string
                        dataBuffer = Buffer.from(data, 'hex');
                    }
                }
                // Execute command (this is a simplified example)
                // In a real implementation, you would need to handle different commands differently
                throw new base_biometrics_service_1.BiometricException('Custom command execution is not fully implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Error executing command: ${errorMessage}`);
                throw new base_biometrics_service_1.BiometricException(`Failed to execute command: ${errorMessage}`);
            }
        });
    }
};
exports.AnvizBiometricsService = AnvizBiometricsService;
exports.AnvizBiometricsService = AnvizBiometricsService = AnvizBiometricsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(biometric_template_entity_1.BiometricTemplate)),
    __param(1, (0, typeorm_1.InjectRepository)(biometric_device_entity_1.BiometricDevice)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _c : Object])
], AnvizBiometricsService);


/***/ }),
/* 236 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FinalWorkHoursCalculationEvent = exports.AttendanceProcessedEvent = exports.AttendanceRecordedEvent = exports.ATTENDANCE_EVENTS = void 0;
exports.ATTENDANCE_EVENTS = {
    ATTENDANCE_RECORDED: 'attendance.recorded',
    ATTENDANCE_PROCESSED: 'attendance.processed',
    FINAL_WORK_HOURS_CALCULATION: 'attendance.final_work_hours_calculation'
};
class AttendanceRecordedEvent {
    constructor(attendances, deviceId) {
        this.attendances = attendances;
        this.deviceId = deviceId;
    }
}
exports.AttendanceRecordedEvent = AttendanceRecordedEvent;
class AttendanceProcessedEvent {
    constructor(attendances) {
        this.attendances = attendances;
    }
}
exports.AttendanceProcessedEvent = AttendanceProcessedEvent;
class FinalWorkHoursCalculationEvent {
    constructor(attendanceIds, batchId, processedBy) {
        this.attendanceIds = attendanceIds;
        this.batchId = batchId;
        this.processedBy = processedBy;
    }
}
exports.FinalWorkHoursCalculationEvent = FinalWorkHoursCalculationEvent;


/***/ }),
/* 237 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseBiometricsService = exports.BiometricException = void 0;
const common_1 = __webpack_require__(5);
/**
 * Base exception class for biometric-related errors
 */
class BiometricException extends common_1.HttpException {
    constructor(message, statusCode = common_1.HttpStatus.INTERNAL_SERVER_ERROR) {
        super(message, statusCode);
    }
}
exports.BiometricException = BiometricException;
/**
 * Abstract base class for all biometric service implementations
 * Provides common functionality and defines the interface that all biometric services must implement
 */
class BaseBiometricsService {
    constructor(deviceRepository, eventEmitter) {
        this.deviceRepository = deviceRepository;
        this.eventEmitter = eventEmitter;
        // Make logger protected so it can be inherited by derived classes
        this.logger = new common_1.Logger(this.constructor.name);
        this.connections = new Map();
        this.activeMonitoring = new Map();
        this.initializeFromDatabase();
    }
    /**
     * Load previously connected devices from database on service startup
     */
    async initializeFromDatabase() {
        try {
            const savedDevices = await this.deviceRepository.find({ where: { isConnected: true } });
            if (savedDevices.length > 0) {
                // Try to reconnect to devices in parallel
                await Promise.allSettled(savedDevices.map(device => 
                // convert device to ConnectDeviceDto using class transformer
                this.connect({
                    deviceId: device.deviceId,
                    ipAddress: device.ipAddress,
                    port: device.port,
                    deviceType: device.provider
                })
                    .catch()));
            }
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Error initializing devices from database: ${errorMessage}`);
        }
    }
    emitAttendanceEvent(record) {
        try {
            this.eventEmitter.emit('biometric.attendance', record);
        }
        catch (error) {
            this.logger.error(`Error emitting attendance event: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Connect to a Biometric device
     * @param ipAddress Device IP address
     * @param port Device port
     * @returns Connected device information
     */
    async connect(dto) {
        if (this.biometricDeviceType !== dto.deviceType) {
            throw new common_1.InternalServerErrorException(`Device type mismatch: expected ${this.biometricDeviceType}, got ${dto.deviceType}`);
        }
        const deviceId = this.generateDeviceId(dto.ipAddress, dto.port);
        // Create new connection with retry logic
        return await this.connectWithRetry(dto, deviceId);
    }
    /**
   * Update device connection and online status in memory and database
   * @param deviceId Device identifier
   * @param isConnected Whether the device is connected
   * @param isOffline Whether the device is considered offline
   * @returns Updated device information
   */
    async updateDeviceStatus(deviceId, isConnected, isOffline) {
        // Find the device in the database
        let device = await this.deviceRepository.findOne({ where: { deviceId } });
        if (!device) {
            this.logger.warn(`Device ${deviceId} not found in database during status update`);
            throw new BiometricException(`Device ${deviceId} not found`, common_1.HttpStatus.NOT_FOUND);
        }
        // Update properties
        device.isConnected = isConnected;
        device.isOffline = isOffline;
        // Update lastSync for successful connections
        if (isConnected) {
            device.lastSync = new Date();
        }
        // Save to database
        device = await this.deviceRepository.save(device);
        return device;
    }
    // Device information methods (optional with default implementation)
    async getDeviceInfo(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async getSerialNumber(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async getFirmwareVersion(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async getDeviceName(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async restartDevice(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    // Time management methods (optional)
    async getTime(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async setTime(deviceId, time) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    // User management methods (optional)
    async enrollUser(deviceId, userId, fingerId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async deleteUser(deviceId, userId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async verifyFingerprint(deviceId, template) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async getUsers(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async getUserDetails(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async setUser(deviceId, uid, userId, name, password, role, cardno) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async syncUsers(sourceDeviceId, targetDeviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    // Attendance management methods (optional)
    async getAttendanceRecords(deviceId, startDate, endDate) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async clearAttendanceRecords(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    async getAttendanceSize(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    // Real-time monitoring methods (optional)
    startRealTimeMonitoring(deviceId, callback) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    stopRealTimeMonitoring(monitoringId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    // Door control (optional)
    async unlockDoor(deviceId) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    // Command execution (optional)
    async executeCommand(deviceId, command, data) {
        throw new BiometricException('Method not implemented', common_1.HttpStatus.NOT_IMPLEMENTED);
    }
    /**
     * Generate a unique device ID from IP address and port
     * @param ipAddress Device IP address
     * @param port Device port
     * @returns Unique device identifier
     */
    generateDeviceId(ipAddress, port) {
        return `${ipAddress}:${port}`;
    }
    /**
     * Safely handle errors by ensuring proper type conversion
     * @param error The error to process
     * @returns Standardized error message string
     */
    formatErrorMessage(error) {
        return error instanceof Error ? error.message : String(error);
    }
}
exports.BaseBiometricsService = BaseBiometricsService;


/***/ }),
/* 238 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Device } = __webpack_require__(239);
const { Record } = __webpack_require__(243);
const { RecordInformation } = __webpack_require__(250);
const { DeviceInfo1 } = __webpack_require__(248);
const { DeviceInfo2 } = __webpack_require__(249);

module.exports = { Device, Record, RecordInformation, DeviceInfo1, DeviceInfo2 };

/***/ }),
/* 239 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const { Connection } = __webpack_require__(240);
const { Message } = __webpack_require__(242);
const { DeviceInfo1 } = __webpack_require__(248);
const { DeviceInfo2 } = __webpack_require__(249);
const { Record } = __webpack_require__(243);
const { RecordInformation } = __webpack_require__(250);
const { UserInfo } = __webpack_require__(251);
const { setInt32BigEndian, setLong40BigEndian } = __webpack_require__(244);

class Device extends Connection {

    constructor(host, port = 5010, deviceId = 0) { // When deviceId (CH) is 0，all devices connected will response to this command.
        super(host, port);
        this.deviceId = deviceId;
    }

    handleResponse = (cmd, callback)=> {
        cmd.onResponse = (response) => {
            if (response.command != cmd.command) {
                let message = `Command code mismatch, expected: ${cmd.command}, received: ${response.command}`;
                throw new Error(message);
            }
            if(response.returnValue != Connection.ACK_SUCCESS) {
                throw new Error("ACK Error: " + response.returnValue);
            }
            return callback(response);
        };
        this.send(cmd);
    }

    setDeviceId = (id) => {
        const cmd = new Message();
        cmd.info = 'setDeviceId';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.SET_DEVICE_ID;
        const data = Buffer.alloc(4);
        setInt32BigEndian(data, 0, id);
        cmd.data = data;
        this.handleResponse(cmd, (response)=> {
            this.deviceId = id;
        });
    }

    getDeviceId = (callback)=> { // FIXME: there's no answer
		/*const cmd = new Message();
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_DEVICE_ID;
        this.handleResponse(cmd, (response)=> {
            callback(getInt32BigEndian(response.data, 0));
        });*/
        if(callback) callback(this.deviceId);
        return this.deviceId;
    }

    getDeviceInfo1 = (callback) => {
		const cmd = new Message();
        cmd.info = 'getDeviceInfo1';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_DEVICE_INFO1;
        this.handleResponse(cmd, (response)=> {
            callback(DeviceInfo1.valueOf(response.data));
        });
	}

    setDeviceInfo1 = (deviceInfo) => {
        const cmd = new Message();
        cmd.info = 'setDeviceInfo1';
		cmd.deviceCode = this.deviceId;
        const data = Buffer.alloc(12);
        deviceInfo.getBytes(data, 0);
        cmd.data = data;
		cmd.command = Message.SET_DEVICE_INFO1;
        this.handleResponse(cmd, (response)=> {});
    }

    getDeviceInfo2 = (callback) => {
		const cmd = new Message();
        cmd.info = 'getDeviceInfo2';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_DEVICE_INFO2;
        this.handleResponse(cmd, (response)=> {
            callback(DeviceInfo2.valueOf(response.data));
        });
	}

    setDeviceInfo2 = (deviceInfo) => {
        const cmd = new Message();
        cmd.info = 'setDeviceInfo2';
		cmd.deviceCode = this.deviceId;
        const data = Buffer.alloc(15);
        deviceInfo.getBytes(data, 0);
        cmd.data = data;
		cmd.command = Message.SET_DEVICE_INFO2;
        this.handleResponse(cmd, (response)=> {});
    }

    getRecordInformation = (callback)=> {
        const cmd = new Message();
        cmd.info = 'getRecordInformation';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_RECORD_INFORMATION;
        this.handleResponse(cmd, (response)=> {
            callback(RecordInformation.valueOf(response.data));
        });
    }

    getAllRecords(callback) {
        this.getRecordInformation((info)=> {
            this._getRecords(0x1, info.allRecordAmount, callback);
        });
    }

    getNewRecords(callback) {
        this.getRecordInformation((info)=> {
            this._getRecords(0x2, info.newRecordAmount, callback);
        });
    }

    _getRecords = (mode, amount, callback)=> {
        
        const cmd = new Message();
        cmd.info = '_getRecords';
        cmd.deviceCode = this.deviceId;
        cmd.command = Message.GET_RECORDS;
        cmd.data = Buffer.from([mode, Math.min(amount, Message.MAX_RESULTS)]);
        
        let retries = 2;
        let records = [];

        const handler = (response)=> { 
            try {
                const count = response.data[0] & 0xFF; // valid records
                for(let i = 0; i < count; ++i) {
                    let offset = i * 14 + 1;
                    const record = Record.valueOf(response.data, offset);
                    record.deviceCode = response.deviceCode;
                    records.push(record);
                }
                amount -= count;
                if(count > 0 && amount > 0) {
                    retries = 2;
                    cmd.data[0] = 0x0; // Download normal;
                    cmd.data[1] = Math.min(amount, Message.MAX_RESULTS); 
                } else {
                    callback(records);
                    return null;
                }
            } catch(e) {
                if(retries === 0) throw e;
                retries--;
                cmd.data[0] = 0x10; // Send last packet again
            }
            // this.handleResponse(cmd, handler);
            return cmd;
        }
        this.handleResponse(cmd, handler);
  
    }

    clearAllRecords = (callback)=> {
        const cmd = new Message();
        cmd.info = 'clearAllRecords';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.CLEAR_RECORDS;
        cmd.data = Buffer.from([0, 0, 0, 0]);
        this.handleResponse(cmd, (response)=> {
            const data = response.data;
            if(callback) callback(data[0] << 16 | (data[1] & 0xFF) << 8 | (data[2] & 0xFF));
        });
    }

    clearAllRecordsSign = (callback)=> {
        this.clearRecordsSign(0, callback);
    }

    /**
	 * Cancel all records, or cancel all/part new records sign
	 * @param amount 0 = all redords sign
	 */
    clearRecordsSign = (amount, callback)=>{
        let code;
		if(amount < 1) {
			amount = 0;
			code = 0x1; // all sign
		} else {
			code = 0x2; // amount sign
		}
		const cmd = new Message();
        cmd.info = 'clearRecordSign';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.CLEAR_RECORDS;
        cmd.data = Buffer.from([code, (amount >> 16) & 0xFF, (amount >> 8) & 0xFF, amount & 0xFF]);

        this.handleResponse(cmd, (response)=> {
            const data = response.data;
            if(callback) callback(data[0] << 16 | (data[1] & 0xFF) << 8 | (data[2] & 0xFF));
        })
    }

    getSerialNumber = (callback) => {
		const cmd = new Message();
        cmd.info = 'getSerialNumber';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_SERIAL_NUMBER;
        this.handleResponse(cmd, (response)=> {
            callback(response.data.toString('utf8', 0, 16));
        });
	}

    openLock = ()=> {
        const cmd = new Message();
        cmd.info = 'openLock';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.OPEN_LOCK;
        this.handleResponse(cmd, (response)=> {});
    }

    getDateTime = (callback) => {
		const cmd = new Message();
        cmd.info = 'getDateTime';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_DATE_TIME;
        this.handleResponse(cmd, (response)=> {
            const data = response.data;
            const millis = Date.UTC(
                (data[0] & 0xFF) + 2000, // YEAR
                data[1], // MONTH
                data[2], // DAY_OF_MONTH
                data[3], // HOUR_OF_DAY
                data[4], // MINUTE
                data[5], // SECOND
                0 // MILLISECOND
            );
            const date = new Date(millis);
            callback(date);
        });
    }

    setDateTime = (date) => {
        const cmd = new Message();
        cmd.info = 'setDateTime';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.SET_DATE_TIME;
        const data = Buffer.alloc(6);
        data[0] = date.getFullYear() - 2000;
		data[1] = date.getMonth() + 1;
		data[2] = date.getDate();
		data[3] = date.getHours();
		data[4] = date.getMinutes();
		data[5] = date.getSeconds();
        cmd.data = data;
        this.handleResponse(cmd, (response)=> {});
    }

    /**
	 * Download fingerprint/face template from T&A device
	 * Note: The template information contains the userId, and cannot be used with a different id (setFpTemplate)
	 * @param userId
	 * @param backupCode 11 -> Facepass 7, 1 -> fingerprint
     */
    getFpTemplate = (userId, backupCode, callback)=> {
        const cmd = new Message();
        cmd.info = 'getFpTemplate';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.GET_FP_TEMPLATE;
        const data = Buffer.alloc(6);
        setLong40BigEndian(data, 0, userId);
		data[5] = backupCode;
        cmd.data = data;
        this.handleResponse(cmd, (response)=> {
            callback(response.data);
        });
    }

    /**
	 * Upload fingerprint/face template to the T&A device
	 * Note: The template information contains the userId, and cannot be used with a different id.
	 * @param userId
	 * @param backupCode 11 -> Facepass 7, 1 -> fingerprint
	 * @param ftTemplate
     */
    setFpTemplate = (userId, backupCode, ftTemplate) => {
        const cmd = new Message();
        cmd.info = 'setFpTemplate';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.SET_FP_TEMPLATE;
        const data = Buffer.alloc(6);
        setLong40BigEndian(data, 0, userId);
		data[5] = backupCode;
        cmd.data = Buffer.concat([data, ftTemplate]);
        this.handleResponse(cmd, (response)=> { });
    }

    getUserInfos = (callback)=> {

        const cmd = new Message();
        cmd.info = 'getUserInfos';
        cmd.deviceCode = this.deviceId;
        cmd.command = Message.GET_USER_INFO;
        cmd.data = Buffer.from([0x1, Message.MAX_RESULTS]); // 0x1 = Download Start
        
        let retries = 2;
        let records = [];

        const handler = (response)=> {
            try {
                const count = response.data[0] & 0xFF;
                for(let i = 0; i < count; ++i) {
                    let offset = i * 40 + 1;
                    const userInfo = UserInfo.valueOf(response.data, offset);
                    userInfo.deviceCode = response.deviceCode;
                    records.push(userInfo);
                }
                if(count > 0) {
                    retries = 2;
                    cmd.data[0] = 0x0; // Download normal;
                } else {
                    callback(records);
                    return null;
                }
            } catch(e) {
                if(retries === 0) throw e;
                retries--;
                cmd.data[0] = 0x10; // Send last packet again
            }
            // this.handleResponse(cmd, handler);
            return cmd;
        }
        this.handleResponse(cmd, handler);

    }

    deleteUser = (userId) => {
        const cmd = new Message();
        cmd.info = 'deleteUser';
        cmd.deviceCode = this.deviceId;
        cmd.command = Message.DELETE_USER;
        var data = Buffer.alloc(6); 
        setLong40BigEndian(data, 0, userId);
        data[5] = 0xFF;
        cmd.data = data;
        this.handleResponse(cmd, (response) => {});
    }

    setUserInfo = (userInfo) => {
        this.setUserInfos([userInfo]);
    }

    setUserInfos = (userInfos) => {
        for(let i = 0; i < userInfos.length;) {
			let j = Math.min(userInfos.length, i + 12); // sub list max 12 items
			this._setUserInfos(userInfos.slice(i, j));
			i = j;
		}
    }

    _setUserInfos(userInfos) {
        const cmd = new Message();
        cmd.info = '_setUserInfos';
		cmd.deviceCode = this.deviceId;
		cmd.command = Message.SET_USER_INFO;
        const n = userInfos.length;
		const data = Buffer.alloc(1 + n * 40);
		data[0] = n; // Information Num
		for (let i = 0; i < n; ++i) {
			const userInfo = userInfos[i];
			userInfo.getBytes(data, i * 40 + 1);
		}
		cmd.data = data;
        this.handleResponse(cmd, (response) => {});
    }

}

module.exports = { Device };

/***/ }),
/* 240 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const net = __webpack_require__(241);
const { Message } = __webpack_require__(242);
const { Record } = __webpack_require__(243);
const { getInt16BigEndian, getInt32BigEndian, getInt16LittleEndian, setInt32BigEndian, setInt16BigEndian, setInt16LittleEndian } = __webpack_require__(244);
const { calculateChecksum } = __webpack_require__(245);
const {toString} = __webpack_require__(246);
const { connected } = __webpack_require__(247);

class Connection {

    static STX = 0xA5; // START TEXT

    static ACK_SUCCESS = 0x0;

    constructor(host, port) {
        this.host = host;
        this.port = port;

        this.buffer = Buffer.from([]);
    }

    connect = ()=> {
        
        this.disconnect();

        this.queue = [];

        this.busy = false;

        const socket = new net.Socket();
        socket.on('error', (e) => {
            if(this.isConnected()) {
                this.disconnect();
                this.listener.onError(e);
            }
        });

        socket.on('close', ()=> {
            if(this.isConnected()) {
                this.disconnect();
                this.listener.onConnectionLost();
            }
        });

        socket.on("data", (data)=> {
            try {
                this.buffer = this.handleData(Buffer.concat([this.buffer, data]));
            } catch (e) { // Unhandled exception
                console.log(e);
            }
        });
        
        socket.connect({ port: this.port, host: this.host });
        
        this.socket = socket;

    }

    handleData = (buffer)=> {

        while(buffer.length > 9) {
            if(buffer[0] != Connection.STX ) {
                buffer = buffer.slice(1); // ignore byte index 0
            } else {
                // LEN （data length） 2 Byte
                const len = getInt16BigEndian(buffer, 7) + 11; 
                if(buffer.length  < len) {
                    break; // wait for data
                }
                this._handleResponse(buffer.slice(0, len));
                buffer = buffer.slice(len, buffer.length); // remove frame
            }
        }

        return buffer; // return data
    }

    _handleResponse = (data)=> {

        const n = data.length - 2;
        let crc1 = calculateChecksum(data, n);
		let crc2 = getInt16LittleEndian(data, n) & 0xFFFF;
		if(crc1 != crc2) {
			const message = "Invalid Checksum: " + toString(data, 0, data.length);
			this.listener.onError(new Error(message));
		} else {

            const message = new Message();
            message.deviceCode = getInt32BigEndian(data, 1);
            message.command = data[5] - 0x80;
            message.returnValue = data[6];
            message.data = data.slice(9, n);

            if((message.command & 0xFF) == 0x13) { // it only happens when the device starts up
                // Message data:
                // 05 00 01 00 00 00 00 00 2a 47 53 c4 00 05 00 00
            } else if((message.command & 0xFF) == 0x5F) { // RealTime mode
                const record = Record.valueOf(message.data, 0);
                record.deviceCode = message.deviceCode;
                this.listener.onRecord(record);
            } else {
                const cmd = this.queue.shift();
                const next = cmd.onResponse(message);
                if(next) {
                    this.queue.unshift(next);
                    this.socket.write(this.toBuffer(next));
                } else if(this.queue.length > 0) {
                    this.socket.write(this.toBuffer(this.queue[0]));
                } else {
                    this.busy = false;
                }
            }

        }

    }

    isConnected = ()=> {
        return this.socket != null; 
    }

    disconnect = ()=> {
        if(this.socket != null) {
            try {
                this.socket.destroy();
            } catch(e) { // ignore
            } finally {
                this.socket = null;
            }
        }
    }

    send = (cmd) => {
       this.queue.push(cmd);
       if(!this.busy) {
           this.busy = true;
           this.socket.write(this.toBuffer(cmd));
       }
    }

    getQueueInfo() {
        let value = [];
        for(let i = 0; i < this.queue.length; ++i) {
            value.push(this.getInfo(this.queue[i]));
        }
        return value;
    }

    getInfo(cmd) {
        return cmd.info + ':' + cmd.command;
    }

    toBuffer(cmd) {
		const data = cmd.data;
		const dataLen = data != null ? data.length : 0;
		const cmdData = Buffer.alloc(10 + dataLen);
		// STX
		cmdData[0] = Connection.STX;
		// CH （device code)
		setInt32BigEndian(cmdData, 1, cmd.deviceCode);
		// CMD （command)
		cmdData[5] = cmd.command;
		if(dataLen > 0) {
			// LEN (data length)
			setInt16BigEndian(cmdData, 6, dataLen);
			// DATA
            data.copy(cmdData, 8, 0, dataLen);
		}
		// CRC16
		const crc = calculateChecksum(cmdData, cmdData.length - 2); 
		setInt16LittleEndian(cmdData, cmdData.length - 2, crc);
		return cmdData;
	}

    /*print(b) {
        let str = "";
        for(let i = 0; i < b.length; ++i) {
            str += b[i] + ", ";
        }
        console.log(str);
    }*/

}

module.exports = { Connection };


/***/ }),
/* 241 */
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),
/* 242 */
/***/ ((module) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

class Message {

    static MAX_RESULTS = 0x8;
	
	static GET_DEVICE_ID = 0x74;
	static SET_DEVICE_ID = 0x75;
	
	static GET_DEVICE_INFO1  = 0x30; // Get the information of T&A device 1
	static SET_DEVICE_INFO1  = 0x31; // Set the configure information of T&A 1
	static GET_DEVICE_INFO2  = 0x32; // Get the information of T&A device 2
	static SET_DEVICE_INFO2  = 0x33; // Set the configure information of T&A 2
	static GET_SERIAL_NUMBER = 0x24;
	
	static GET_DATE_TIME = 0x38; // Get the date and time of T&A
	static SET_DATE_TIME = 0x39; // Set the date and time of T&A
	
	static GET_RECORD_INFORMATION = 0x3C;
	
	static GET_RECORDS   = 0x40;
	static CLEAR_RECORDS = 0x4E;

	static GET_USER_INFO = 0x72;
	static SET_USER_INFO = 0x73;
	static DELETE_USER   = 0x4C;
	
	static GET_FP_TEMPLATE = 0x44;
	static SET_FP_TEMPLATE = 0x45;
		
	static OPEN_LOCK = 0x5E;

    constructor() {

    }

}

module.exports = { Message };

/***/ }),
/* 243 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const { getInt32BigEndian, getLong40BigEndian } = __webpack_require__(244);

class Record {

    static MILLIS_INC = 946771200000; // 01/02/2000 in milliseconds since 01/01/1970

    static valueOf(data, offset) {
		const result = new Record();
		result.userId = getLong40BigEndian(data, offset);
		result.dateTime = Record.toDateTime(getInt32BigEndian(data, offset + 5));
		result.backupCode = data[offset + 9];
		result.type = data[offset + 10];
		result.workTypes = [data[offset + 11], data[offset + 12], data[offset + 13]];
		return result;
	}

	static toDateTime(seconds) {
		const time = seconds * 1000 + Record.MILLIS_INC;
		return time; /* time - TimeZone.getDefault().getOffset(time); */
	}

}

module.exports = {Record};

/***/ }),
/* 244 */
/***/ ((module) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const setLong40BigEndian = (data, offset, value) => {
    data[offset    ] = Number(BigInt(value) >> 32n);
    data[offset + 1] = value >> 24;
    data[offset + 2] = value >> 16;
    data[offset + 3] = value >> 8 ;
    data[offset + 4] = value;
}

const getLong40BigEndian = (data, offset) => {
    return data[offset] << 32 
        | (data[offset + 1] & 0xFF) << 24
        | (data[offset + 2] & 0xFF) << 16
        | (data[offset + 3] & 0xFF) << 8 
        | (data[offset + 4] & 0xFF);
}

const getInt32BigEndian = (data, offset) => {
    return data[offset] << 24 
        | (data[offset + 1] & 0xFF) << 16
        | (data[offset + 2] & 0xFF) << 8 
        | (data[offset + 3] & 0xFF);
}

const setInt32BigEndian = (data, offset, value) => {
    data[offset    ] = value >> 24;
    data[offset + 1] = value >> 16;
    data[offset + 2] = value >> 8;
    data[offset + 3] = value;
}

const getInt24BigEndian = (data, offset) => {
    return data[offset] << 16 
        | (data[offset + 1] & 0xFF) << 8 
        | (data[offset + 2] & 0xFF);
}

const setInt24BigEndian = (data, offset, value) => {
    data[offset    ] = value >> 16;
    data[offset + 1] = value >> 8;
    data[offset + 2] = value;
}

const getInt16BigEndian = (data, offset) => {
    return data[offset] << 8 | (data[offset + 1] & 0xFF);
}

const setInt16BigEndian = (data, offset, value) => {
    data[offset    ] = value >> 8;
    data[offset + 1] = value;
}

const getInt16LittleEndian = (data, offset) => {
    return (data[offset] & 0XFF) | (data[offset + 1] << 8);
}

const setInt16LittleEndian = (data, offset, value) => {
    data[offset    ] = value;
    data[offset + 1] = value >> 8;
}

module.exports = {getLong40BigEndian, setLong40BigEndian, getInt32BigEndian, setInt32BigEndian, getInt24BigEndian, setInt24BigEndian, getInt16BigEndian, setInt16BigEndian, getInt16LittleEndian, setInt16LittleEndian};

/***/ }),
/* 245 */
/***/ ((module) => {

const table = [];
const polynomial = 0x8408;
for (let b = 0; b < 256; b++) {
    let crc = b;
    for (let i = 0; i < 8; i++) {
        crc = (crc >> 1) ^ ((crc & 1) == 1 ? polynomial : 0);
    }
    table[b] = 0xFFFF & crc;
}

const calculateChecksum = (data, len) => {
    let crc = 0xFFFF;
    for(let i = 0; i < len; ++i) {
        let b = data[i];
        crc = (crc >> 8) ^ table[(crc ^ b) & 0xFF];
    }
    return crc & 0xFFFF;
}

module.exports = {calculateChecksum};

/***/ }),
/* 246 */
/***/ ((module) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const toString = (data, start, end) => {
    let result = "";
    for(var i = start; i < end; i++) {
        let code = String.fromCharCode(data[i]);
        if(code !== '\x00') {
            result += code;
        }
    } 
    return result;
}

module.exports = {toString};

/***/ }),
/* 247 */
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),
/* 248 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const { getInt16BigEndian } = __webpack_require__(244);

class DeviceInfo1 {

	getBytes(data, offset) {
		data[offset] = ((this.communicationPassword >> 16) & 0xF) | ((this.communicationPasswordLength & 0xF) << 4);
		data[offset + 1] = (this.communicationPassword >> 8) & 0xFF;
		data[offset + 2] = this.communicationPassword & 0xFF;
		data[offset + 3] = this.sleepTime;
		data[offset + 4] = this.volume;
		data[offset + 5] = this.language;
		data[offset + 6] = this.timeFormat | ((this.dateFormat & 0xF) << 4);
		data[offset + 7] = this.attendanceState;
		data[offset + 8] = this.languageSetting;
	}

   static valueOf(data) {
		const deviceInfo = new DeviceInfo1();
		deviceInfo.firmwareVersion = data.toString('utf-8', 0, 8);
		deviceInfo.communicationPasswordLength = (data[8] >> 4) & 0xF; 
		const v1 = (data[8] & 0xF) << 16;
		const v2 = (getInt16BigEndian(data, 9) & 0xFFFF);
		deviceInfo.communicationPassword = v1 | v2;
		deviceInfo.sleepTime = data[11];
		deviceInfo.volume = data[12];
		deviceInfo.language = data[13];
		deviceInfo.timeFormat = data[14] & 0xF;
		deviceInfo.dateFormat = (data[14] >> 4) & 0xF;
		deviceInfo.attendanceState = data[15];
		deviceInfo.languageSetting = data[16];
		deviceInfo.commandVersion = data[17];
		return deviceInfo;
	}

}

module.exports = {DeviceInfo1};

/***/ }),
/* 249 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const { getInt24BigEndian, setInt24BigEndian } = __webpack_require__(244);

class DeviceInfo2 {

	getBytes(data, offset) {
		data[offset] = this.fingerprintPrecision;
		data[offset + 1] = this.wiegandHeadCode;
		data[offset + 2] = this.wieganOption;
		data[offset + 3] = this.workCodePermission;
		data[offset + 4] = this.realTimeModeSetting;
		data[offset + 5] = this.autoUpdateFpSetting;
		data[offset + 6] = this.relayMode;
		data[offset + 7] = this.lockDelay;
		setInt24BigEndian(data, offset + 8, this.memoryFullAlarm);
		data[offset + 11] = this.repeatAttendanceDelay;
		data[offset + 12] = this.doorSensorDelay;
		data[offset + 13] = this.scheduledBellDelay;
		data[offset + 14] = this.reserved;
	}

    static valueOf(data) {
        const deviceInfo = new DeviceInfo2();
		deviceInfo.fingerprintPrecision = data[0];
		deviceInfo.wiegandHeadCode = data[1];
		deviceInfo.wieganOption = data[2];
		deviceInfo.workCodePermission = data[3];
		deviceInfo.realTimeModeSetting = data[4];
		deviceInfo.autoUpdateFpSetting = data[5];
		deviceInfo.relayMode = data[6];
		deviceInfo.lockDelay = data[7];
		deviceInfo.memoryFullAlarm = getInt24BigEndian(data, 8);
		deviceInfo.repeatAttendanceDelay = data[11];
		deviceInfo.doorSensorDelay = data[12];
		deviceInfo.scheduledBellDelay = data[13];
		deviceInfo.reserved = data[14];
		return deviceInfo;
    }

}

module.exports = { DeviceInfo2 };

/***/ }),
/* 250 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const { getInt24BigEndian } = __webpack_require__(244);

class RecordInformation {

	static valueOf(data) {
		const result = new RecordInformation();
		result.userAmount = getInt24BigEndian(data, 0);
		result.fpAmount = getInt24BigEndian(data, 3);
		result.passwordAmount =getInt24BigEndian(data, 6);
		result.cardAmount = getInt24BigEndian(data, 9);
		result.allRecordAmount = getInt24BigEndian(data, 12);
		result.newRecordAmount = getInt24BigEndian(data, 15);
		return result;
	}

}

module.exports = {RecordInformation};

/***/ }),
/* 251 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Copyright (c) 2022, Sergio S.- sergi.ss4@gmail.com http://sergiosoriano.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *    	
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

const { getInt16BigEndian, getInt32BigEndian, getLong40BigEndian, setInt16BigEndian, setInt32BigEndian, setLong40BigEndian } = __webpack_require__(244);
const { toString } = __webpack_require__(246);

class UserInfo {

    constructor() {
        this.password = 0;
        this.passwordLength = 0;
        this.card = 0;
        this.dpt = 0;
        this.group = 0;
        this.attendanceMode = 0;
        this.enrollFpState = 0;
        this.keep = 0;
        this.specialMessage = 0;
    }

    getBytes(data, offset) {

        setLong40BigEndian(data, offset, this.userId);
		
		//result.passwordLength = (data[offset + 5] >> 4) & 0xF; 
		//int v1 = ((data[offset + 5] & 0xF) << 16) | getInt16BigEndian(data, offset + 6);
		//int v2 = data[offset + 27] << 12;
		
		data[offset + 5] = (this.passwordLength << 4) | ((this.password >> 16) & 0xF);
		setInt16BigEndian(data, offset + 6, this.password & 0xFFFF);
		setInt16BigEndian(data, offset + 27, this.password >> 12); // 8 bits
		
		setInt32BigEndian(data, offset + 8, this.card);

		for(let i = offset + 12, n = i + 19; i < n; ++i) { // Clear name bytes
            data[i] = 0;
        }
        
		if(this.name != null) { // set name bytes
            let index = offset + 12;
            let n = Math.min(index + 19, index + (this.name.length * 2 + 2));
            data[index++] = -2;
            data[index++] = -1;
            let i = 0;
            while(index < n) {
                data[index++] = 0;
                data[index++] = this.name.charCodeAt(i++);
            }
		}

		data[offset + 32] = this.dpt;
		data[offset + 33] = this.group;
		data[offset + 34] = this.attendanceMode;
		setInt16BigEndian(data, offset + 35, this.enrollFpState);
		data[offset + 38] = this.keep;
		data[offset + 39] = this.specialMessage;
    }

    static valueOf(data, offset) { // UNICODE version 
		const result = new UserInfo();
		result.userId = getLong40BigEndian(data, offset);
		result.passwordLength = (data[offset + 5] >> 4) & 0xF; 
        // The low 20bits of password is saved in Byte 6-8, high 8 bits saved in Byte28
		const v1 = (((data[offset + 5] & 0xF) << 16) | getInt16BigEndian(data, offset + 6));
		const v2 = data[offset + 27] << 12;
        result.password = v1 | v2;
		result.card = getInt32BigEndian(data, offset + 8);
        const d = data.slice(offset + 12, offset + 19);
		result.name = toString(data, offset + 12, offset + 31);
		result.dpt   = data[offset + 32];
		result.group = data[offset + 33];
		result.attendanceMode = data[offset + 34];
		result.enrollFpState = getInt16BigEndian(data, offset + 35);
		result.keep = data[offset + 38];
		result.specialMessage = data[offset + 39];
		return result;
	}

}

module.exports = {UserInfo};

/***/ }),
/* 252 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var BiometricsPollingService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BiometricsPollingService = void 0;
const biometrics_device_type_enum_1 = __webpack_require__(77);
const punch_method_enum_1 = __webpack_require__(74);
const attendance_event_1 = __webpack_require__(236);
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const event_emitter_1 = __webpack_require__(139);
let BiometricsPollingService = BiometricsPollingService_1 = class BiometricsPollingService {
    constructor(configService, eventEmitter) {
        this.configService = configService;
        this.eventEmitter = eventEmitter;
        this.logger = new common_1.Logger(BiometricsPollingService_1.name);
        this.devicePollers = new Map();
        this.connections = new Map();
        this.recordCache = new Set();
    }
    // Lifecycle hooks
    onModuleInit() {
        // this.logger.log('Biometric polling service initialized');
    }
    onModuleDestroy() {
        this.stopAllPolling();
    }
    // Provide a way to register device connections
    registerDeviceConnection(deviceId, device) {
        this.connections.set(deviceId, device);
        // this.logger.log(`Registered device ${deviceId} for polling`);
    }
    // Start polling for a specific device
    startPolling(deviceId) {
        const device = this.connections.get(deviceId);
        if (!device) {
            this.logger.warn(`Cannot start polling for device ${deviceId}: Device not registered`);
            return false;
        }
        // Check if already polling
        if (this.devicePollers.has(deviceId)) {
            this.logger.warn(`Already polling device ${deviceId}`);
            return true;
        }
        const pollingInterval = this.configService.get('BIOMETRIC_DEVICE_POLLING_INTERVAL', 1000);
        // let lastAttendanceCount = 0;
        let lastCheckedTime = new Date();
        // Start the interval for polling
        const intervalId = setInterval(async () => {
            if (!this.connections.has(deviceId)) {
                // log 
                this.logger.warn(`Device ${deviceId} not registered, stopping polling`);
                this.stopPolling(deviceId);
                return;
            }
            try {
                // Get current attendance size
                const currentCount = await device.getAttendanceSize();
                // If there are new records
                if (currentCount > 0) {
                    // Get all attendance records - returns { data: records, err: error }
                    const response = await device.getAttendances();
                    // Extract the records array from the response
                    const records = response.data || [];
                    // Filter new records and use a cache to prevent duplicates
                    const filteredRecords = records.filter((record) => {
                        // Basic validation
                        const hasValidUserId = record.user_id !== undefined &&
                            record.user_id !== null &&
                            record.user_id.trim() !== ''; // Check after trimming
                        if (!hasValidUserId)
                            return false;
                        // Year validation
                        const recordTime = new Date(record.record_time);
                        const recordYear = recordTime.getFullYear();
                        const currentYear = new Date().getFullYear();
                        const isReasonableYear = Math.abs(recordYear - currentYear) <= 5;
                        if (!isReasonableYear)
                            return false;
                        // Create a unique key to detect duplicates
                        const cacheKey = `${record.user_id}-${record.record_time}-${record.type || 0}`;
                        // Skip if we've seen this record before
                        if (this.recordCache.has(cacheKey)) {
                            return false;
                        }
                        // Add to cache and accept the record
                        this.recordCache.add(cacheKey);
                        // Limit cache size to prevent memory leaks
                        if (this.recordCache.size > 10000) {
                            // Remove oldest entries (converting to array first)
                            const cacheArray = Array.from(this.recordCache);
                            this.recordCache = new Set(cacheArray.slice(-5000));
                        }
                        return true;
                    });
                    if (filteredRecords.length > 0) {
                        this.logger.log(`[${deviceId}] Processing ${filteredRecords.length} new attendance records`);
                        let attendances = [];
                        // Process each new record
                        filteredRecords.forEach((record) => {
                            // Standardize record format
                            const standardizedRecord = {
                                userId: record.user_id.trim(), // Trim any whitespace
                                timestamp: new Date(record.record_time || Date.now()),
                                deviceId: deviceId,
                                punchMethod: this.getPunchMethod(record.status || 0, device.provider),
                                punchType: record.type, // Default to 0 if not provided
                            };
                            // Add to the attendance list
                            attendances.push(standardizedRecord);
                        });
                        // Emit event for new records
                        this.eventEmitter.emit(attendance_event_1.ATTENDANCE_EVENTS.ATTENDANCE_RECORDED, new attendance_event_1.AttendanceRecordedEvent(attendances, deviceId));
                    }
                    // Update counters
                    // lastAttendanceCount = currentCount;
                }
                // Update timestamp
                lastCheckedTime = new Date();
            }
            catch (error) {
                this.logger.error(`Polling error for ${deviceId}: ${error instanceof Error
                    ? JSON.stringify(Object.assign({}, error, { message: error.message, stack: error.stack }))
                    : JSON.stringify(error)}`);
            }
        }, pollingInterval);
        // Store interval info to clean up later
        this.devicePollers.set(deviceId, {
            intervalId: intervalId,
            lastCheckedTime,
        });
        this.logger.log(`Started polling for device ${deviceId} at ${pollingInterval}ms intervals`);
        return true;
    }
    getPunchMethod(value, deviceType) {
        if (deviceType === biometrics_device_type_enum_1.BiometricDeviceType.ZKTECO) {
            switch (value) {
                case 0:
                    return punch_method_enum_1.PunchMethod.FINGERPRINT;
                default:
                    return punch_method_enum_1.PunchMethod.UNKNOWN;
            }
        }
        else {
            return punch_method_enum_1.PunchMethod.UNKNOWN;
        }
    }
    // Stop polling for a specific device
    stopPolling(deviceId) {
        const poller = this.devicePollers.get(deviceId);
        if (!poller) {
            return false;
        }
        clearInterval(poller.intervalId);
        this.devicePollers.delete(deviceId);
        this.logger.log(`Stopped polling for device ${deviceId}`);
        return true;
    }
    // Stop all polling
    stopAllPolling() {
        this.logger.log(`Stopping all device polling (${this.devicePollers.size} active)`);
        for (const [deviceId, poller] of this.devicePollers.entries()) {
            clearInterval(poller.intervalId);
            this.logger.log(`Stopped polling for device ${deviceId}`);
        }
        this.devicePollers.clear();
    }
};
exports.BiometricsPollingService = BiometricsPollingService;
exports.BiometricsPollingService = BiometricsPollingService = BiometricsPollingService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object, typeof (_b = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _b : Object])
], BiometricsPollingService);


/***/ }),
/* 253 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZKTecoBiometricsService = void 0;
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const typeorm_1 = __webpack_require__(16);
const ZKLib = __webpack_require__(254);
const biometrics_device_type_enum_1 = __webpack_require__(77);
const punch_method_enum_1 = __webpack_require__(74);
const event_emitter_1 = __webpack_require__(139);
const typeorm_2 = __webpack_require__(25);
const biometric_device_entity_1 = __webpack_require__(76);
const biometric_template_entity_1 = __webpack_require__(234);
const base_biometrics_service_1 = __webpack_require__(237);
const biometrics_polling_service_1 = __webpack_require__(252);
/**
 * ZKTeco implementation of the biometric service
 * Handles communication with ZKTeco biometric devices
 */
let ZKTecoBiometricsService = class ZKTecoBiometricsService extends base_biometrics_service_1.BaseBiometricsService {
    constructor(configService, deviceRepository, biometricsPollingService, templateRepository, eventEmitter) {
        super(deviceRepository, eventEmitter);
        this.configService = configService;
        this.deviceRepository = deviceRepository;
        this.biometricsPollingService = biometricsPollingService;
        this.templateRepository = templateRepository;
        this.eventEmitter = eventEmitter;
        this.biometricDeviceType = biometrics_device_type_enum_1.BiometricDeviceType.ZKTECO;
        // Listen for attendance events from polling service
        this.eventEmitter.on('attendance.recorded', (record) => {
            this.emitAttendanceEvent(record);
            // Call any registered callback
            const monitorInfo = this.activeMonitoring.get(record.deviceId);
            if (monitorInfo && typeof monitorInfo.callback === 'function') {
                monitorInfo.callback(record);
            }
        });
    }
    /**
     * Register a new user on the ZKTeco device without fingerprint enrollment
     * @param deviceId Device identifier
     * @param userData User data to register
     * @returns Created user information
     */
    async registerUser(deviceId, userData) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Registering user ${userData.userId} on device ${deviceId}`);
            // Convert userId to numeric ID if possible, or use a default
            const uid = parseInt(userData.userId) || Math.floor(Math.random() * 9000) + 1000;
            // Prepare parameters with defaults
            const name = userData.name || `User ${userData.userId}`;
            const password = userData.password || '';
            const role = userData.role || 0; // 0 = normal user, 14 = admin
            const cardno = userData.cardNumber ? parseInt(userData.cardNumber) : 0;
            // Validate input parameters
            if (uid <= 0 || uid > 65535) {
                throw new Error('User ID must be a positive integer less than 65535');
            }
            if (name.length > 24) {
                throw new Error('Name must be less than 24 characters');
            }
            if (password.length > 8) {
                throw new Error('Password must be less than 8 characters');
            }
            // Create/update the user on the device
            await zkDevice.setUser(uid, userData.userId, name, password, role, cardno);
            // Create a standardized user object to return
            const createdUser = {
                userId: userData.userId,
                name: name,
                password: password,
                cardNumber: cardno.toString(),
                role: role
            };
            this.logger.log(`Successfully registered user ${userData.userId} on device ${deviceId}`);
            return createdUser;
        }
        catch (error) {
            // log error object as json
            this.logger.error(`Error registering user on device ${deviceId}: ${JSON.stringify(error)}`);
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error registering user on device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to register user: ${errorMessage}`, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    /**
     * Get fingerprint template for a specific user and finger
     * @param deviceId Device identifier
     * @param userId User ID
     * @param fingerId Finger ID (0-9)
     * @returns Fingerprint template data
     */
    async getUserFingerprint(deviceId, userId, fingerId = 0) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Retrieving fingerprint template for user ${userId} (finger ${fingerId}) from device ${deviceId}`);
            // First check database for existing template
            try {
                const existingTemplate = await this.templateRepository.findOne({
                    where: {
                        userId,
                        fingerId,
                        provider: 'zkteco'
                    }
                });
                if (existingTemplate && existingTemplate.template) {
                    this.logger.log(`Found existing template in database for user ${userId} (finger ${fingerId})`);
                    return {
                        id: `${userId}-${fingerId}`,
                        userId,
                        fingerId,
                        template: existingTemplate.template,
                        provider: 'zkteco'
                    };
                }
            }
            catch (dbError) {
                this.logger.warn(`Database lookup failed: ${dbError instanceof Error ? dbError.message : String(dbError)}`);
            }
            // Convert userId to numeric ID if it's a number
            const uid = parseInt(userId) || Number(userId);
            if (isNaN(uid)) {
                throw new Error(`Invalid user ID format: ${userId}`);
            }
            // Create data buffer for the command
            const cmdData = Buffer.alloc(8);
            cmdData.writeUInt32LE(uid, 0); // User ID in little-endian format
            cmdData.writeUInt32LE(fingerId, 4); // Finger ID in little-endian format
            // Check if executeCmd is available
            if (typeof zkDevice.executeCmd !== 'function') {
                throw new Error('Device does not support the required commands');
            }
            // Clear any pending data
            try {
                await zkDevice.freeData();
            }
            catch (err) {
                this.logger.warn(`Could not free data buffer: ${err instanceof Error ? err.message : String(err)}`);
            }
            // Proper device state management
            await zkDevice.disableDevice();
            await zkDevice.enableDevice();
            // Add a small delay to ensure device is ready
            await new Promise(resolve => setTimeout(resolve, 200));
            // Execute the command to get the fingerprint template
            // CMD_USERTEMP_RRQ = 9 (0x0009)
            const result = await zkDevice.executeCmd('CMD_USERTEMP_RRQ', cmdData);
            // Log raw result for debugging
            this.logger.debug(`Raw result from device: length=${(result === null || result === void 0 ? void 0 : result.length) || 0}, first bytes: ${result ? result.slice(0, 20).toString('hex') : 'null'}`);
            // Check if we got a valid response
            if (!result || result.length < 12) {
                this.logger.warn(`No fingerprint template found for user ${userId} (finger ${fingerId})`);
                return null;
            }
            // Parse the result according to ZKTeco protocol
            const templateData = result.subarray(12);
            if (templateData.length === 0) {
                this.logger.warn(`Empty template data for user ${userId} (finger ${fingerId})`);
                return null;
            }
            this.logger.debug(`Retrieved fingerprint template for user ${userId} (finger ${fingerId}): ${templateData.length} bytes`);
            // Create a standardized template object
            const template = {
                id: `${userId}-${fingerId}`,
                userId,
                fingerId,
                template: templateData,
                provider: 'zkteco'
            };
            // Optionally save the template to database
            try {
                await this.templateRepository.save({
                    userId,
                    fingerId,
                    template: templateData,
                    provider: 'zkteco'
                });
                this.logger.debug(`Saved fingerprint template for user ${userId} (finger ${fingerId}) to database`);
            }
            catch (dbError) {
                this.logger.warn(`Could not save template to database: ${dbError instanceof Error ? dbError.message : String(dbError)}`);
                // Continue even if database save fails
            }
            return template;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error retrieving fingerprint template from device ${deviceId}: ${errorMessage}`);
            // Check if it's a "template not exist" error, which should return null instead of throwing
            if (errorMessage.includes('not exist') || errorMessage.includes('No Record')) {
                this.logger.warn(`No fingerprint template exists for user ${userId} (finger ${fingerId})`);
                return null;
            }
            throw new base_biometrics_service_1.BiometricException(`Failed to get fingerprint template: ${errorMessage}`);
        }
    }
    /**
     * Connect to a device with retry logic
     * @param deviceId Device identifier
     * @param ipAddress Device IP address
     * @param port Device port
     * @returns Connected device information
     */
    async connectWithRetry(dto, deviceId) {
        const timeout = this.configService.get('ZKTECO_TIMEOUT', 5000);
        const retryAttempts = this.configService.get('ZKTECO_RETRY_ATTEMPTS', 3);
        const retryDelay = this.configService.get('ZKTECO_RETRY_DELAY', 1000);
        const { ipAddress, port } = dto;
        let attempts = 0;
        let lastError = new Error('No connection attempts made');
        while (attempts < retryAttempts) {
            try {
                attempts++;
                this.logger.log(`Connecting to device ${deviceId} (attempt ${attempts}/${retryAttempts})`);
                // Create ZK instance with parameters, not options object
                // According to the example: new ZKLib(host, port, timeout, retry)
                const zk = new ZKLib(ipAddress, port, timeout, retryDelay);
                // Create socket connection first (as per example)
                await zk.createSocket();
                // Collect comprehensive device information
                let deviceInfo = await zk.getInfo();
                // Try to get additional device information
                try {
                    const serialNumber = await zk.getSerialNumber();
                    const firmware = await zk.getFirmware();
                    const platform = await zk.getPlatform();
                    const deviceName = await zk.getDeviceName();
                    const deviceVersion = await zk.getDeviceVersion();
                    const os = await zk.getOS();
                    // Enhance device info with additional details
                    deviceInfo = Object.assign(Object.assign({}, deviceInfo), { serialNumber: serialNumber || (deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.serialNumber), firmware: firmware || (deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.firmware), platform: platform || (deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.platform), deviceName: deviceName, deviceVersion: deviceVersion, os: os });
                }
                catch (infoError) {
                    this.logger.warn(`Could not retrieve comprehensive device info: ${infoError instanceof Error ? infoError.message : String(infoError)}`);
                }
                // Store connection
                this.connections.set(deviceId, zk);
                // Create device object with enhanced info
                const device = {
                    deviceId,
                    ipAddress,
                    port,
                    provider: this.biometricDeviceType,
                    model: (deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.deviceName) || (deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.model) || 'Unknown',
                    serialNumber: (deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.serialNumber) || 'Unknown',
                    firmware: deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.firmware,
                    platform: deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.platform,
                    deviceVersion: deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.deviceVersion,
                    os: deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.os,
                    isConnected: true,
                };
                // Store in database
                const save = await this.deviceRepository.save(device);
                // Register the connection with the polling service
                this.biometricsPollingService.registerDeviceConnection(deviceId, zk);
                // Start polling instead of direct setup
                this.biometricsPollingService.startPolling(deviceId);
                this.logger.log(`Successfully connected to ZKTeco device at ${ipAddress}:${port}`);
                return save;
            }
            catch (error) {
                // Ensure error is properly typed
                this.logger.warn(`Connection attempt ${attempts} to device ${deviceId}`);
                // If we have retries left, wait before trying again
                if (attempts < retryAttempts) {
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                }
            }
        }
        // If we get here, all connection attempts failed
        this.logger.error(`Failed to connect to ZKTeco device after ${attempts} attempts: ${lastError.message}`);
        throw new base_biometrics_service_1.BiometricException(`Failed to connect to device: ${lastError.message}`, common_1.HttpStatus.SERVICE_UNAVAILABLE);
    }
    async disconnect(deviceId, isManual = true) {
        // Stop the polling first
        this.biometricsPollingService.stopPolling(deviceId);
        const zkDevice = this.connections.get(deviceId);
        if (!zkDevice) {
            throw new common_1.BadRequestException(`Device ${deviceId} not connected`);
        }
        // Clear monitoring first
        this.activeMonitoring.delete(deviceId);
        ~
        // Use disconnect method
        await zkDevice.disconnect();
        this.connections.delete(deviceId);
        return await this.updateDeviceStatus(deviceId, false, isManual ? false : true);
    }
    /**
     * Get connected device by ID, throwing an exception if not found
     * @param deviceId Device identifier
     * @returns ZK device instance
     */
    getConnectedDevice(deviceId) {
        const zkDevice = this.connections.get(deviceId);
        if (!zkDevice) {
            throw new base_biometrics_service_1.BiometricException(`Device ${deviceId} not connected or not found`, common_1.HttpStatus.NOT_FOUND);
        }
        return zkDevice;
    }
    /**
     * Get device information
     * @param deviceId Device identifier
     * @returns Device information
     */
    async getDeviceInfo(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const info = await zkDevice.getInfo();
            this.logger.debug(`Retrieved device info for ${deviceId}: ${JSON.stringify(info)}`);
            return info;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting device info from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get device info: ${errorMessage}`);
        }
    }
    /**
     * Get device serial number
     * @param deviceId Device identifier
     * @returns Device serial number
     */
    async getSerialNumber(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const serialNumber = await zkDevice.getSerialNumber();
            this.logger.debug(`Retrieved serial number for ${deviceId}: ${serialNumber}`);
            return serialNumber;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting serial number from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get serial number: ${errorMessage}`);
        }
    }
    /**
     * Get firmware version
     * @param deviceId Device identifier
     * @returns Firmware version
     */
    async getFirmwareVersion(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const firmware = await zkDevice.getFaceOn();
            this.logger.debug(`Retrieved firmware version for ${deviceId}: ${firmware}`);
            return firmware;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting firmware version from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get firmware version: ${errorMessage}`);
        }
    }
    /**
     * Get device platform
     * @param deviceId Device identifier
     * @returns Platform information
     */
    async getPlatform(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const platform = await zkDevice.getPlatform();
            this.logger.debug(`Retrieved platform info for ${deviceId}: ${platform}`);
            return platform;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting platform info from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get platform info: ${errorMessage}`);
        }
    }
    /**
     * Get device name
     * @param deviceId Device identifier
     * @returns Device name
     */
    async getDeviceName(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const name = await zkDevice.getDeviceName();
            this.logger.debug(`Retrieved device name for ${deviceId}: ${name}`);
            return name;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting device name from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get device name: ${errorMessage}`);
        }
    }
    /**
     * Get device OS version
     * @param deviceId Device identifier
     * @returns OS version
     */
    async getOS(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const os = await zkDevice.getOS();
            this.logger.debug(`Retrieved OS info for ${deviceId}: ${os}`);
            return os;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting OS info from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get OS info: ${errorMessage}`);
        }
    }
    /**
     * Get device version
     * @param deviceId Device identifier
     * @returns Device version
     */
    async getDeviceVersion(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const version = await zkDevice.getDeviceVersion();
            this.logger.debug(`Retrieved device version for ${deviceId}: ${version}`);
            return version;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting device version from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get device version: ${errorMessage}`);
        }
    }
    /**
     * Get device PIN
     * @param deviceId Device identifier
     * @returns Device PIN
     */
    async getPIN(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const pin = await zkDevice.getPIN();
            this.logger.debug(`Retrieved PIN for ${deviceId}: ${pin}`);
            return pin;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting PIN from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get PIN: ${errorMessage}`);
        }
    }
    /**
     * Check if face recognition is enabled
     * @param deviceId Device identifier
     * @returns True if face recognition is enabled
     */
    async getFaceOn(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const faceOn = await zkDevice.getFaceOn();
            this.logger.debug(`Retrieved face recognition status for ${deviceId}: ${faceOn}`);
            return faceOn;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting face recognition status from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get face recognition status: ${errorMessage}`);
        }
    }
    /**
     * Get Self-Service-Recorder status
     * @param deviceId Device identifier
     * @returns SSR status
     */
    async getSSR(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const ssr = await zkDevice.getSSR();
            this.logger.debug(`Retrieved SSR status for ${deviceId}: ${JSON.stringify(ssr)}`);
            return ssr;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting SSR status from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get SSR status: ${errorMessage}`);
        }
    }
    /**
     * Get device time
     * @param deviceId Device identifier
     * @returns Current device time
     */
    async getTime(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const time = await zkDevice.getTime();
            this.logger.debug(`Retrieved time for ${deviceId}: ${time}`);
            return time;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting time from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get time: ${errorMessage}`);
        }
    }
    /**
     * Set device time
     * @param deviceId Device identifier
     * @param time Date to set
     * @returns Success indicator
     */
    async setTime(deviceId, time) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            await zkDevice.setTime(time);
            this.logger.debug(`Set time for ${deviceId} to ${time}`);
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error setting time for ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to set time: ${errorMessage}`);
        }
    }
    /**
     * Get work code from device
     * @param deviceId Device identifier
     * @returns Work code
     */
    async getWorkCode(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const workCode = await zkDevice.getWorkCode();
            this.logger.debug(`Retrieved work code for ${deviceId}: ${workCode}`);
            return workCode;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting work code from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get work code: ${errorMessage}`);
        }
    }
    /**
     * Get attendance log size
     * @param deviceId Device identifier
     * @returns Attendance log size
     */
    async getAttendanceSize(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            const size = await zkDevice.getAttendanceSize();
            this.logger.debug(`Retrieved attendance size for ${deviceId}: ${size}`);
            return size;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting attendance size from ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get attendance size: ${errorMessage}`);
        }
    }
    /**
     * Get users from a device
     * @param deviceId Device identifier
     * @returns Array of user IDs
     */
    async getUsers(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Getting users from device ${deviceId}`);
            const response = await zkDevice.getUsers();
            // Extract the data array from the response object
            const users = response && response.data && Array.isArray(response.data)
                ? response.data
                : [];
            if (users.length === 0) {
                return [];
            }
            // Extract essential information for each user
            const userInfo = users.map((user) => {
                var _a;
                return ({
                    userId: user.userId || user.id || '',
                    name: user.name || '',
                    password: user.password || '',
                    role: user.role || 0,
                    uid: user.uid || parseInt(user.userId) || 0,
                    cardNumber: ((_a = user.cardno) === null || _a === void 0 ? void 0 : _a.toString()) || ''
                });
            }).filter((user) => user.userId && user.role <= 14);
            this.logger.log(`Found ${userInfo.length} users on device ${deviceId}`);
            return userInfo;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting users from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get users: ${errorMessage}`);
        }
    }
    /**
     * Delete a user from the device with specific ZKTeco protocol implementation
     * @param deviceId Device identifier
     * @param userId User ID to delete
     * @returns True if deleted successfully
     */
    async deleteUser(deviceId, userId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Deleting user ${userId} from device ${deviceId}`);
            // Convert userId to numeric ID
            const uid = parseInt(userId);
            // Validate input parameter
            if (isNaN(uid) || uid <= 0 || uid > 65535) {
                throw new Error('Invalid user ID: must be a positive number less than 65535');
            }
            // Clear any pending data
            try {
                await zkDevice.freeData();
            }
            catch (err) {
                this.logger.warn(`Could not free data buffer: ${err instanceof Error ? err.message : String(err)}`);
            }
            if (typeof zkDevice.deleteUser === 'function') {
                const response = await zkDevice.deleteUser(uid);
                // Check the response for success
                const success = response && response.length > 0;
                // After successful deletion from device, also remove templates from database
                if (success) {
                    try {
                        const deleteResult = await this.templateRepository.delete({
                            userId: userId,
                            provider: 'zkteco'
                        });
                        this.logger.debug(`Deleted ${deleteResult.affected || 0} templates from database for user ${userId}`);
                    }
                    catch (dbError) {
                        this.logger.warn(`Failed to delete templates from database: ${dbError instanceof Error ? dbError.message : String(dbError)}`);
                        // Continue even if database deletion fails
                    }
                }
                this.logger.log(`User ${userId} deletion ${success ? 'successful' : 'failed'}`);
                return success;
            }
            else {
                throw new Error('Device does not support direct user deletion through this library');
            }
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error deleting user ${userId} from device ${deviceId}: ${errorMessage}`);
            // If the user doesn't exist, consider it a success
            if (errorMessage.includes('not found') || errorMessage.includes('does not exist')) {
                this.logger.warn(`User ${userId} not found on device ${deviceId}, considering deletion successful`);
                return true;
            }
            throw new base_biometrics_service_1.BiometricException(`Failed to delete user: ${errorMessage}`);
        }
    }
    /**
     * Enroll a user's fingerprint
     * @param deviceId Device identifier
     * @param userId User ID
     * @param fingerId Finger ID (0-9)
     * @returns Biometric template
     */
    async enrollUser(deviceId, userId, fingerId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Enrolling fingerprint for user ${userId} (finger ${fingerId}) on device ${deviceId}`);
            // First create or ensure the user exists
            // Convert userId to numeric if possible, or use a default
            const uid = parseInt(userId) || 1;
            const name = `User ${userId}`; // Default name if not provided
            // Create/update the user first
            await this.setUser(deviceId, uid, userId, name);
            // Start enrollment mode using executeCmd
            // According to ZKTeco protocol, CMD_STARTENROLL (61 or 0x3d) initiates enrollment
            const enrollData = Buffer.alloc(24);
            enrollData.writeUInt32LE(uid, 0); // User ID
            enrollData.writeUInt32LE(fingerId, 4); // Finger index (0-9)
            enrollData.writeUInt32LE(1, 8); // Flag (1 = valid)
            this.logger.log(`Starting enrollment process for user ${userId} (finger ${fingerId})`);
            // Use executeCmd to start enrollment if available
            let templateData;
            if (typeof zkDevice.executeCmd === 'function') {
                const result = await zkDevice.executeCmd('CMD_STARTENROLL', enrollData);
                // This is where we would typically wait for the enrollment result
                // But since the library doesn't have a direct method for this,
                // we'll need to implement a custom approach
                // For now, we'll create a placeholder template
                // In a real implementation, you would need to:
                // 1. Prompt the user to place their finger on the device
                // 2. Wait for the device to capture the fingerprint
                // 3. Retrieve the template data from the device
                // Mock template data (should be replaced with actual implementation)
                templateData = Buffer.from(`template-${userId}-${fingerId}-${Date.now()}`);
                this.logger.warn(`Note: This is a placeholder implementation. The ZKTeco-js library doesn't directly support fingerprint enrollment. Please check the device manual for specific enrollment procedures.`);
            }
            else {
                throw new Error('Device does not support direct fingerprint enrollment through this library. Consider using the device\'s physical interface for enrollment.');
            }
            // Create a template object
            const template = {
                id: `${userId}-${fingerId}`,
                userId,
                fingerId,
                template: Buffer.isBuffer(templateData) ? templateData : Buffer.from(templateData),
                provider: 'zkteco'
            };
            // Save template to database
            await this.templateRepository.save({
                userId,
                fingerId,
                template: Buffer.isBuffer(template.template)
                    ? template.template
                    : Buffer.from(template.template.toString()),
                provider: 'zkteco'
            });
            this.logger.log(`Successfully enrolled fingerprint for user ${userId} (finger ${fingerId})`);
            return template;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error enrolling user on device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to enroll user: ${errorMessage}`);
        }
    }
    /**
     * Verify a fingerprint template
     * @param deviceId Device identifier
     * @param template Template to verify
     * @returns True if verified
     */
    async verifyFingerprint(deviceId, template) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Verifying fingerprint for user ${template.userId} on device ${deviceId}`);
            // The method name depends on the library implementation
            let result;
            if (typeof zkDevice.verifyFingerprint === 'function') {
                result = await zkDevice.verifyFingerprint(template.userId, template.fingerId, template.template);
            }
            else if (typeof zkDevice.verify === 'function') {
                result = await zkDevice.verify(template.userId, template.fingerId, template.template);
            }
            else {
                throw new Error('Device does not support fingerprint verification');
            }
            this.logger.log(`Verification result for user ${template.userId}: ${result}`);
            return result === true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error verifying fingerprint on device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to verify fingerprint: ${errorMessage}`);
        }
    }
    /**
     * Get attendance records from a device
     * @param deviceId Device identifier
     * @param startDate Optional start date for filtering
     * @param endDate Optional end date for filtering
     * @returns Array of attendance records
     */
    async getAttendanceRecords(deviceId, startDate, endDate) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Getting attendance records from device ${deviceId}`);
            // Use the getAttendances method
            const records = await zkDevice.getAttendances();
            if (!records || !Array.isArray(records)) {
                return [];
            }
            // Convert records to a standard format
            const standardizedRecords = records.map(record => ({
                userId: record.userId || '',
                timestamp: new Date(record.timestamp),
                punchType: record.status,
                punchMethod: punch_method_enum_1.PunchMethod.MANUAL, // Default value for punch method
                deviceId: deviceId, // Required field - use the current device ID
                isSynced: false, // Default value for new records
                retrievedAt: new Date(), // Set current time as retrieval time
            }));
            // Filter by date if provided
            let filteredRecords = standardizedRecords;
            if (startDate || endDate) {
                filteredRecords = standardizedRecords.filter(record => {
                    if (startDate && record.timestamp < startDate)
                        return false;
                    if (endDate && record.timestamp > endDate)
                        return false;
                    return true;
                });
            }
            this.logger.log(`Found ${filteredRecords.length} attendance records on device ${deviceId}`);
            return filteredRecords;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error getting attendance records from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to get attendance records: ${errorMessage}`);
        }
    }
    /**
     * Clear all attendance records from a device
     * @param deviceId Device identifier
     * @returns True if cleared successfully
     */
    async clearAttendanceRecords(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            // Use the clearAttendanceLog method
            await zkDevice.clearAttendanceLog();
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error clearing attendance records from device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to clear attendance records: ${errorMessage}`);
        }
    }
    /**
     * Restart a device
     * @param deviceId Device identifier
     * @returns True if restart initiated successfully
     */
    async restartDevice(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Restarting device ${deviceId}`);
            // The method name depends on the library implementation
            if (typeof zkDevice.restart === 'function') {
                await zkDevice.restart();
            }
            else if (typeof zkDevice.restartDevice === 'function') {
                await zkDevice.restartDevice();
            }
            else {
                throw new Error('Device does not support restart');
            }
            this.logger.log(`Successfully initiated restart for device ${deviceId}`);
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error restarting device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to restart device: ${errorMessage}`);
        }
    }
    /**
     * Unlock the device door
     * @param deviceId Device identifier
     * @returns True if unlock command sent successfully
     */
    async unlockDoor(deviceId) {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Unlocking door for device ${deviceId}`);
            // The method name depends on the library implementation
            if (typeof zkDevice.executeCmd === 'function') {
                // Execute the unlock command
                // Note: CMD.CMD_UNLOCK would need to be defined or imported
                await zkDevice.executeCmd('CMD_UNLOCK', '');
            }
            else if (typeof zkDevice.unlockDoor === 'function') {
                await zkDevice.unlockDoor();
            }
            else {
                throw new Error('Device does not support door unlock');
            }
            this.logger.log(`Successfully unlocked door for device ${deviceId}`);
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error unlocking door for device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to unlock door: ${errorMessage}`);
        }
    }
    /**
     * Execute a custom command on the device
     * @param deviceId Device identifier
     * @param command Command to execute
     * @param data Optional data for the command
     * @returns Command result
     */
    async executeCommand(deviceId, command, data = '') {
        const zkDevice = this.getConnectedDevice(deviceId);
        try {
            this.logger.log(`Executing command ${command} on device ${deviceId}`);
            if (typeof zkDevice.executeCmd !== 'function') {
                throw new Error('Device does not support custom commands');
            }
            const result = await zkDevice.executeCmd(command, data);
            this.logger.log(`Successfully executed command ${command} on device ${deviceId}`);
            return result;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error executing command on device ${deviceId}: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to execute command: ${errorMessage}`);
        }
    }
    /**
     * Sync users between two devices
     * @param sourceDeviceId Source device ID
     * @param targetDeviceId Target device ID
     * @returns Number of users synced
     */
    async syncUsers(sourceDeviceId, targetDeviceId) {
        try {
            this.logger.log(`Syncing users from device ${sourceDeviceId} to ${targetDeviceId}`);
            // Get users from source device
            const users = await this.getUserDetails(sourceDeviceId);
            if (!users || users.length === 0) {
                this.logger.warn(`No users found on source device ${sourceDeviceId}`);
                return 0;
            }
            // Get target device
            const targetDevice = this.getConnectedDevice(targetDeviceId);
            // Transfer each user to target device
            let syncedCount = 0;
            for (const user of users) {
                try {
                    await this.setUser(targetDeviceId, parseInt(user.userId) || 0, // Use numeric ID if possible
                    user.userId, user.name, user.password, user.role, parseInt(user.cardNumber || '0') || 0);
                    syncedCount++;
                }
                catch (userError) {
                    const errorMessage = userError instanceof Error ? userError.message : String(userError);
                    this.logger.warn(`Failed to sync user ${user.userId}: ${errorMessage}`);
                }
            }
            this.logger.log(`Successfully synced ${syncedCount} users from ${sourceDeviceId} to ${targetDeviceId}`);
            return syncedCount;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error(`Error syncing users: ${errorMessage}`);
            throw new base_biometrics_service_1.BiometricException(`Failed to sync users: ${errorMessage}`);
        }
    }
};
exports.ZKTecoBiometricsService = ZKTecoBiometricsService;
exports.ZKTecoBiometricsService = ZKTecoBiometricsService = __decorate([
    (0, common_1.Injectable)(),
    __param(1, (0, typeorm_1.InjectRepository)(biometric_device_entity_1.BiometricDevice)),
    __param(3, (0, typeorm_1.InjectRepository)(biometric_template_entity_1.BiometricTemplate)),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof biometrics_polling_service_1.BiometricsPollingService !== "undefined" && biometrics_polling_service_1.BiometricsPollingService) === "function" ? _c : Object, typeof (_d = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _d : Object, typeof (_e = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _e : Object])
], ZKTecoBiometricsService);


/***/ }),
/* 254 */
/***/ ((module) => {

"use strict";
module.exports = require("zkteco-js");

/***/ }),
/* 255 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancePunchesModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const attendance_punches_controller_1 = __webpack_require__(256);
const attendance_punches_service_1 = __webpack_require__(257);
const attendance_punch_entity_1 = __webpack_require__(73);
let AttendancePunchesModule = class AttendancePunchesModule {
};
exports.AttendancePunchesModule = AttendancePunchesModule;
exports.AttendancePunchesModule = AttendancePunchesModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([attendance_punch_entity_1.AttendancePunch])],
        providers: [attendance_punches_service_1.AttendancePunchesService],
        exports: [attendance_punches_service_1.AttendancePunchesService],
        controllers: [attendance_punches_controller_1.AttendancePunchesController],
    })
], AttendancePunchesModule);


/***/ }),
/* 256 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancePunchesController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const attendance_punches_service_1 = __webpack_require__(257);
const attendance_punch_dto_1 = __webpack_require__(258);
const attendance_punch_entity_1 = __webpack_require__(73);
class AttendancePunchesController extends (0, create_controller_factory_1.createController)(attendance_punch_entity_1.AttendancePunch, attendance_punches_service_1.AttendancePunchesService, attendance_punch_dto_1.GetAttendancePunchDto) {
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async update(id, entityDto, updatedById) {
        return await super.update(id, entityDto, updatedById);
    }
    async delete(id) {
        return await super.delete(id);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
}
exports.AttendancePunchesController = AttendancePunchesController;


/***/ }),
/* 257 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancePunchesService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const attendance_punch_entity_1 = __webpack_require__(73);
let AttendancePunchesService = class AttendancePunchesService extends base_service_1.BaseService {
    constructor(attendancePunchesRepository, usersService) {
        super(attendancePunchesRepository, usersService);
        this.attendancePunchesRepository = attendancePunchesRepository;
        this.usersService = usersService;
    }
};
exports.AttendancePunchesService = AttendancePunchesService;
exports.AttendancePunchesService = AttendancePunchesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(attendance_punch_entity_1.AttendancePunch)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], AttendancePunchesService);


/***/ }),
/* 258 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAttendancePunchDto = exports.UpdateAttendancePunchDto = exports.AttendancePunchDto = void 0;
const base_dto_1 = __webpack_require__(101);
const punch_method_enum_1 = __webpack_require__(74);
const punch_type_enum_1 = __webpack_require__(75);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class AttendancePunchDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.AttendancePunchDto = AttendancePunchDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Attendance record this punch is associated with',
        example: '123e4567-e89b-12d3-a456-426614174000',
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(4),
    __metadata("design:type", String)
], AttendancePunchDto.prototype, "attendanceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Biometric device used for this punch',
        example: '123e4567-e89b-12d3-a456-426614174000',
        type: String
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(4),
    __metadata("design:type", String)
], AttendancePunchDto.prototype, "biometricDeviceId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of attendance punch (IN/OUT)',
        enum: punch_type_enum_1.PunchType,
        enumName: 'PunchType'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(punch_type_enum_1.PunchType),
    __metadata("design:type", typeof (_a = typeof punch_type_enum_1.PunchType !== "undefined" && punch_type_enum_1.PunchType) === "function" ? _a : Object)
], AttendancePunchDto.prototype, "punchType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Method used for punch (FINGERPRINT/MANUAL/etc)',
        enum: punch_method_enum_1.PunchMethod,
        enumName: 'PunchMethod'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(punch_method_enum_1.PunchMethod),
    __metadata("design:type", typeof (_b = typeof punch_method_enum_1.PunchMethod !== "undefined" && punch_method_enum_1.PunchMethod) === "function" ? _b : Object)
], AttendancePunchDto.prototype, "punchMethod", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Timestamp of the punch',
        example: '2023-07-21T08:30:00Z',
        type: Date
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsDateString)(),
    (0, class_transformer_1.Type)(() => Date),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], AttendancePunchDto.prototype, "time", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employee identification number',
        example: 12345,
        type: Number
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], AttendancePunchDto.prototype, "employeeNumber", void 0);
class UpdateAttendancePunchDto extends (0, swagger_1.PartialType)(AttendancePunchDto) {
}
exports.UpdateAttendancePunchDto = UpdateAttendancePunchDto;
class GetAttendancePunchDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateAttendancePunchDto, 'attendance punch') {
}
exports.GetAttendancePunchDto = GetAttendancePunchDto;


/***/ }),
/* 259 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancesController = void 0;
const authorize_decorator_1 = __webpack_require__(26);
const generalresponse_dto_1 = __webpack_require__(86);
const action_enum_1 = __webpack_require__(40);
const create_controller_factory_1 = __webpack_require__(18);
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const attendances_service_1 = __webpack_require__(260);
const attendance_dto_1 = __webpack_require__(264);
const attendance_entity_1 = __webpack_require__(52);
class AttendancesController extends (0, create_controller_factory_1.createController)(attendance_entity_1.Attendance, attendances_service_1.AttendancesService, attendance_dto_1.GetAttendanceDto, undefined, attendance_dto_1.UpdateAttendanceDto) {
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async delete(id) {
        return await super.delete(id);
    }
    async deleteMany(ids, hardDelete) {
        await super.deleteMany(ids, hardDelete);
    }
    async processAttendanceRecords() {
        try {
            await this.baseService.processAttendanceRecords();
            return {
                message: 'Attendance records processed successfully',
                statusCode: common_1.HttpStatus.OK
            };
        }
        catch (error) {
            return {
                message: `Failed to process attendance records: ${error.message}`,
                statusCode: common_1.HttpStatus.INTERNAL_SERVER_ERROR
            };
        }
    }
}
exports.AttendancesController = AttendancesController;
__decorate([
    (0, common_1.Post)('process'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.MANAGE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Manually process attendance records',
        description: 'Triggers processing of attendance records for undertime, overtime, missing checkouts, rest days, and absences'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Attendance records processed successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.UNAUTHORIZED,
        description: 'User is not authorized to process attendance records'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'An error occurred while processing attendance records'
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], AttendancesController.prototype, "processAttendanceRecords", null);


/***/ }),
/* 260 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendancesService = void 0;
const attendance_status_enum_1 = __webpack_require__(50);
const holiday_type_enum_1 = __webpack_require__(69);
const notification_type_enum_1 = __webpack_require__(83);
const request_status_enum_1 = __webpack_require__(51);
const attendance_event_1 = __webpack_require__(236);
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const event_emitter_1 = __webpack_require__(139);
const schedule_1 = __webpack_require__(131);
const typeorm_1 = __webpack_require__(16);
const date_fns_1 = __webpack_require__(155);
const typeorm_2 = __webpack_require__(25);
const employees_service_1 = __webpack_require__(104);
const notifications_service_1 = __webpack_require__(261);
const schedules_service_1 = __webpack_require__(153);
const attendance_entity_1 = __webpack_require__(52);
const final_work_hour_entity_1 = __webpack_require__(58);
const work_time_request_entity_1 = __webpack_require__(49);
const work_time_requests_service_1 = __webpack_require__(263);
let AttendancesService = class AttendancesService extends base_service_1.BaseService {
    constructor(attendancesRepository, usersService, workTimeRequestsService, notificationsService, employeesService, schedulesService, eventEmitter) {
        super(attendancesRepository, usersService);
        this.attendancesRepository = attendancesRepository;
        this.usersService = usersService;
        this.workTimeRequestsService = workTimeRequestsService;
        this.notificationsService = notificationsService;
        this.employeesService = employeesService;
        this.schedulesService = schedulesService;
        this.eventEmitter = eventEmitter;
    }
    getEmployeeAttendanceToday(employeeId, punchTime) {
        return this.attendancesRepository.findOne({
            where: {
                employee: { id: employeeId },
                timeIn: (0, typeorm_2.Between)((0, date_fns_1.startOfDay)(punchTime), (0, date_fns_1.endOfDay)(punchTime))
            },
            relations: { employee: true }
        });
    }
    // Run at midnight
    async processAttendanceRecords() {
        const yesterday = (0, date_fns_1.subDays)(new Date(), 1);
        const yesterdayFormatted = (0, date_fns_1.format)(yesterday, 'yyyy-MM-dd');
        this.logger.log(`Processing attendance records for ${yesterdayFormatted}`);
        // Process employees with under time
        await this.handleUnderTimeEmployees();
        // Process employees with over time
        await this.handleOverTimeEmployees();
        // Process employees with check-in but no check-out
        await this.handleMissingCheckOuts();
        // Process employees worked on rest day
        await this.handleRestDayEmployees();
        // Process employees that has no attendance record or absent
        await this.handleAbsentEmployees();
        this.logger.log(`Completed processing attendance records`);
        // Get all attendance records for the day that has no final work hours yet
        const attendances = await this.attendancesRepository.find({
            where: {
                isProcessed: false,
                schedule: {
                    endTime: (0, typeorm_2.LessThan)((0, date_fns_1.format)(new Date(), 'HH:mm:ss')) // Ensure the schedule end time has already passed
                }
            },
            relations: { schedule: true }
        });
        // mark attendance records as processed
        for (const attendance of attendances) {
            attendance.isProcessed = true;
        }
        await this.attendancesRepository.save(attendances);
        // Emit event for attendance processing
        this.eventEmitter.emit(attendance_event_1.ATTENDANCE_EVENTS.ATTENDANCE_PROCESSED, new attendance_event_1.AttendanceProcessedEvent(attendances));
    }
    async handleUnderTimeEmployees() {
        this.logger.log(`Handling under time employees`);
        // Find all unprocessed undertime attendance records
        const attendances = await this.attendancesRepository.find({
            where: {
                isProcessed: false,
                statuses: (0, typeorm_2.ArrayContains)([attendance_status_enum_1.AttendanceStatus.UNDER_TIME]), // Filter for UNDERTIME status
                schedule: {
                    endTime: (0, typeorm_2.LessThan)((0, date_fns_1.format)(new Date(), 'HH:mm:ss')) // Ensure the schedule end time has already passed
                }
            },
            relations: { employee: { user: true }, schedule: true }
        });
        for (const attendance of attendances) {
            try {
                this.logger.log(`Processing under time for employee ${attendance.employee.user.email}`);
                const formattedAttendanceDate = (0, date_fns_1.format)(attendance.createdAt, 'yyyy-MM-dd');
                // Calculate total undertime minutes
                const scheduleEndTime = new Date(`${formattedAttendanceDate}T${attendance.schedule.endTime}`);
                const timeOut = attendance.timeOut ? new Date(attendance.timeOut) : new Date(attendance.schedule.endTime);
                // Calculate undertime (when employee leaves before scheduled end time)
                let undertimeMinutes = Math.floor((scheduleEndTime.getTime() - timeOut.getTime()) / (1000 * 60));
                // Create work time request
                const workTimeRequest = new work_time_request_entity_1.WorkTimeRequest({
                    attendance: attendance,
                    type: attendance_status_enum_1.AttendanceStatus.UNDER_TIME,
                    duration: undertimeMinutes,
                    status: request_status_enum_1.RequestStatus.PENDING,
                    dayType: attendance.dayType,
                    createdBy: attendance.employee.id,
                    employee: attendance.employee
                });
                await this.workTimeRequestsService.save(workTimeRequest);
                await this.notificationsService.create({
                    title: 'Early Check-out',
                    message: `You left ${undertimeMinutes} minutes early on ${formattedAttendanceDate}.`,
                    type: notification_type_enum_1.NotificationType.WARNING,
                    category: 'ATTENDANCE',
                    user: { id: attendance.employee.user.id },
                });
            }
            catch (error) {
                this.logger.error(`Error processing under time for attendance ${attendance.id}: ${error.message}`, error.stack);
            }
        }
    }
    async handleOverTimeEmployees() {
        this.logger.log(`Handling over time employees`);
        // Find all unprocessed overtime attendance records
        const attendances = await this.attendancesRepository.find({
            where: {
                isProcessed: false,
                statuses: (0, typeorm_2.ArrayContains)([attendance_status_enum_1.AttendanceStatus.OVERTIME]), // Filter for OVERTIME status
                schedule: {
                    endTime: (0, typeorm_2.LessThan)((0, date_fns_1.format)(new Date(), 'HH:mm:ss')) // Ensure the schedule end time has already passed
                }
            },
            relations: { employee: { user: true }, schedule: true }
        });
        for (const attendance of attendances) {
            try {
                this.logger.log(`Processing over time for employee ${attendance.employee.user.email}`);
                const formattedAttendanceDate = (0, date_fns_1.format)(attendance.createdAt, 'yyyy-MM-dd');
                // Calculate total overtime minutes
                const scheduleEndTime = new Date(`${formattedAttendanceDate}T${attendance.schedule.endTime}`);
                const timeOut = attendance.timeOut ? new Date(attendance.timeOut) : new Date(attendance.schedule.endTime);
                // Calculate overtime (when employee leaves after scheduled end time)
                let overtimeMinutes = Math.floor((timeOut.getTime() - scheduleEndTime.getTime()) / (1000 * 60));
                // Create work time request
                const workTimeRequest = new work_time_request_entity_1.WorkTimeRequest({
                    attendance: attendance,
                    type: attendance_status_enum_1.AttendanceStatus.OVERTIME,
                    duration: overtimeMinutes,
                    status: request_status_enum_1.RequestStatus.PENDING,
                    dayType: attendance.dayType,
                    createdBy: attendance.employee.id,
                    employee: attendance.employee
                });
                await this.workTimeRequestsService.save(workTimeRequest);
                await this.notificationsService.create({
                    title: 'Overtime Alert',
                    message: `You worked ${overtimeMinutes} minutes of overtime on ${formattedAttendanceDate}.`,
                    type: notification_type_enum_1.NotificationType.INFO,
                    category: 'ATTENDANCE',
                    user: { id: attendance.employee.user.id },
                });
            }
            catch (error) {
                this.logger.error(`Error processing over time for attendance ${attendance.id}: ${error.message}`, error.stack);
            }
        }
    }
    async handleMissingCheckOuts() {
        this.logger.log(`Handling missing check-outs`);
        // Find all attendance records for the day that have timeIn but no timeOut
        const incompleteAttendances = await this.attendancesRepository.find({
            where: {
                isProcessed: false,
                timeIn: (0, typeorm_2.Not)((0, typeorm_2.IsNull)()),
                timeOut: (0, typeorm_2.IsNull)(),
                schedule: {
                    endTime: (0, typeorm_2.LessThan)((0, date_fns_1.format)(new Date(), 'HH:mm:ss')) // Ensure the schedule end time has already passed
                }
            },
            relations: { employee: { user: true }, schedule: true }
        });
        for (const attendance of incompleteAttendances) {
            try {
                const formattedAttendanceDate = (0, date_fns_1.format)(attendance.createdAt, 'yyyy-MM-dd');
                this.logger.log(`Employee ${attendance.employee.user.email} has no check-out for ${formattedAttendanceDate}`);
                // Update attendance with NO_CHECKED_OUT status
                attendance.statuses = [...attendance.statuses || [], attendance_status_enum_1.AttendanceStatus.NO_CHECKED_OUT];
                await this.save(attendance);
                // create new work time request
                await this.workTimeRequestsService.create({
                    attendance,
                    type: attendance_status_enum_1.AttendanceStatus.NO_CHECKED_OUT,
                    status: request_status_enum_1.RequestStatus.PENDING,
                    dayType: attendance.dayType,
                    createdBy: attendance.employee.id,
                    employee: { id: attendance.employee.id },
                });
                await this.notificationsService.create({
                    title: 'Missing Check-Out Alert',
                    message: `You forgot to check-out in ${formattedAttendanceDate}. Please check your attendance record.`,
                    type: notification_type_enum_1.NotificationType.DANGER,
                    category: 'ATTENDANCE',
                    user: { id: attendance.employee.user.id },
                });
            }
            catch (error) {
                this.logger.error(`Error processing missing check-out for attendance ${attendance.id}: ${error.message}`);
            }
        }
    }
    async handleRestDayEmployees() {
        var _a, _b;
        this.logger.log(`Handling rest day attendances`);
        // Find all attendance records for the day where employees worked on their rest day
        // and have clocked out (timeOut is not null)
        const restDayAttendances = await this.attendancesRepository.find({
            where: {
                isProcessed: false,
                timeIn: (0, typeorm_2.Not)((0, typeorm_2.IsNull)()),
                timeOut: (0, typeorm_2.Not)((0, typeorm_2.IsNull)()), // Only process completed shifts
                schedule: {
                    endTime: (0, typeorm_2.LessThan)((0, date_fns_1.format)(new Date(), 'HH:mm:ss')), // Ensure the schedule end time has already passed
                    restDay: true,
                },
            },
            relations: { employee: { user: true }, schedule: true }
        });
        for (const attendance of restDayAttendances) {
            try {
                const formattedDate = (0, date_fns_1.format)(attendance.createdAt, 'yyyy-MM-dd');
                this.logger.log(`Processing rest day work for employee ${attendance.employee.user.email} on ${formattedDate}`);
                // Calculate total hours worked
                const timeIn = attendance.timeIn ? new Date(attendance.timeIn) : new Date();
                const timeOut = attendance.timeOut ? new Date(attendance.timeOut) : new Date();
                const breakTimeMinutes = attendance.schedule.breakTime || 0;
                // Calculate total minutes worked (excluding break)
                const totalWorkMinutes = (0, date_fns_1.differenceInMinutes)(timeOut, timeIn) - breakTimeMinutes;
                const totalWorkHours = totalWorkMinutes / 60;
                // Check if the employee worked a full shift (9+ hours including break)
                // This translates to 8+ hours of actual work time
                if (totalWorkHours >= 8) {
                    this.logger.log(`Employee ${attendance.employee.id} worked ${totalWorkHours.toFixed(2)} hours on rest day - eligible for offset`);
                    // Add OFFSET status
                    if (!((_a = attendance.statuses) === null || _a === void 0 ? void 0 : _a.includes(attendance_status_enum_1.AttendanceStatus.OFFSET))) {
                        attendance.statuses = [...attendance.statuses || [], attendance_status_enum_1.AttendanceStatus.OFFSET];
                    }
                    // Grant offset leave credit to the employee
                    // attendance.employee.offsetLeaveCredits += 1;
                    // await this.employeesService.save(attendance.employee);
                    await this.workTimeRequestsService.create({
                        attendance,
                        type: attendance_status_enum_1.AttendanceStatus.OFFSET,
                        status: request_status_enum_1.RequestStatus.PENDING,
                        dayType: attendance.dayType,
                        createdBy: attendance.employee.id,
                        employee: { id: attendance.employee.id },
                    });
                    // Notify the employee about offset earned
                    await this.notificationsService.create({
                        title: 'Rest Day Offset Requested',
                        message: `You are qualified for 1 offset leave credit for working on your rest day (${formattedDate}).`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                }
                else {
                    this.logger.log(`Employee ${attendance.employee.id} worked ${totalWorkHours.toFixed(2)} hours on rest day - eligible for overtime`);
                    // Add OVERTIME status
                    if (!((_b = attendance.statuses) === null || _b === void 0 ? void 0 : _b.includes(attendance_status_enum_1.AttendanceStatus.OVERTIME))) {
                        attendance.statuses = [...attendance.statuses || [], attendance_status_enum_1.AttendanceStatus.OVERTIME];
                    }
                    // Notify the employee about overtime
                    await this.notificationsService.create({
                        title: 'Rest Day Overtime',
                        message: `Your ${totalWorkHours.toFixed(2)} hours worked on rest day (${formattedDate}) will be counted as overtime.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: attendance.employee.user.id },
                    });
                    // Create a work time request for overtime
                    await this.workTimeRequestsService.create({
                        attendance: { id: attendance.id },
                        type: attendance_status_enum_1.AttendanceStatus.OVERTIME,
                        dayType: attendance.dayType,
                        duration: totalWorkMinutes,
                        status: request_status_enum_1.RequestStatus.PENDING,
                        employee: { id: attendance.employee.id },
                    });
                }
                // Save the updated attendance record
                await this.save(attendance);
            }
            catch (error) {
                this.logger.error(`Error processing rest day for attendance ${attendance.id}: ${error.message}`, error.stack);
            }
        }
    }
    async handleAbsentEmployees() {
        var _a;
        // Find all schedules for the given date that should have attendance
        const absentSchedules = await this.schedulesService.getRepository().find({
            where: {
                attendance: (0, typeorm_2.IsNull)(),
                restDay: false,
                date: (0, typeorm_2.LessThan)(new Date()),
                endTime: (0, typeorm_2.LessThan)((0, date_fns_1.format)(new Date(), 'HH:mm:ss')), // Ensure the schedule end time has already passed
            },
            relations: { employee: { user: true }, attendance: true }
        });
        // Process each absent employee
        for (const schedule of absentSchedules) {
            try {
                let dayType;
                const isRestDay = schedule.restDay;
                const holidayType = (_a = schedule.holiday) === null || _a === void 0 ? void 0 : _a.type;
                if (isRestDay && holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
                    dayType = final_work_hour_entity_1.DayType.REGULAR_HOLIDAY_REST_DAY;
                }
                else if (isRestDay && (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING)) {
                    dayType = final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY_REST_DAY;
                }
                else if (isRestDay) {
                    dayType = final_work_hour_entity_1.DayType.REST_DAY;
                }
                else if (holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
                    dayType = final_work_hour_entity_1.DayType.REGULAR_HOLIDAY;
                }
                else if (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING || holidayType === holiday_type_enum_1.HolidayType.SPECIAL_WORKING) {
                    dayType = final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY;
                }
                else {
                    dayType = final_work_hour_entity_1.DayType.REGULAR_DAY;
                }
                // Create new attendance record with absent status
                const attendance = new attendance_entity_1.Attendance({});
                attendance.employee = schedule.employee;
                attendance.schedule = schedule;
                attendance.dayType = dayType;
                attendance.statuses = [attendance_status_enum_1.AttendanceStatus.ABSENT];
                const savedAttendance = await this.attendancesRepository.save(attendance);
                // Create work time request for the absence
                const workTimeRequest = new work_time_request_entity_1.WorkTimeRequest({});
                workTimeRequest.employee = schedule.employee;
                workTimeRequest.attendance = savedAttendance;
                workTimeRequest.type = attendance_status_enum_1.AttendanceStatus.ABSENT;
                workTimeRequest.status = request_status_enum_1.RequestStatus.PENDING;
                workTimeRequest.dayType = dayType;
                workTimeRequest.createdBy = schedule.employee.id;
                await this.workTimeRequestsService.save(workTimeRequest);
                // Notify the employee about their recorded absence
                await this.notificationsService.create({
                    user: { id: schedule.employee.user.id },
                    title: 'Absence Recorded',
                    category: 'ATTENDANCE',
                    message: `You were marked absent for ${(0, date_fns_1.format)(schedule.date, 'MMMM dd, yyyy')}`,
                    type: notification_type_enum_1.NotificationType.DANGER
                });
            }
            catch (error) {
                this.logger.error(`Error processing absence for employee ${schedule.employee.id}: ${error.message}`, error.stack);
            }
        }
    }
};
exports.AttendancesService = AttendancesService;
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_DAY_AT_MIDNIGHT),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AttendancesService.prototype, "processAttendanceRecords", null);
exports.AttendancesService = AttendancesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(attendance_entity_1.Attendance)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof work_time_requests_service_1.WorkTimeRequestsService !== "undefined" && work_time_requests_service_1.WorkTimeRequestsService) === "function" ? _c : Object, typeof (_d = typeof notifications_service_1.NotificationsService !== "undefined" && notifications_service_1.NotificationsService) === "function" ? _d : Object, typeof (_e = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _e : Object, typeof (_f = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _f : Object, typeof (_g = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _g : Object])
], AttendancesService);


/***/ }),
/* 261 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NotificationsService_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationsService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const bull_1 = __webpack_require__(4);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const bull_2 = __webpack_require__(158);
const typeorm_2 = __webpack_require__(25);
const notification_entity_1 = __webpack_require__(82);
const notifications_gateway_1 = __webpack_require__(262);
let NotificationsService = NotificationsService_1 = class NotificationsService extends base_service_1.BaseService {
    constructor(notificationRepo, usersService, notificationsGateway, notificationsQueue) {
        super(notificationRepo, usersService);
        this.notificationRepo = notificationRepo;
        this.usersService = usersService;
        this.notificationsGateway = notificationsGateway;
        this.notificationsQueue = notificationsQueue;
        this.notificationLogger = new common_1.Logger(NotificationsService_1.name);
    }
    async create(createDto, createdBy) {
        const notification = await super.create(createDto, createdBy);
        this.notificationsGateway.emitToUser(notification, notification.user.id);
        // Queue for processing instead of immediate sending
        await this.notificationsQueue.add('processNotification', {
            notificationId: notification.id,
            userId: notification.user.id,
        });
        return notification;
    }
    async update(id, updateDto, updatedBy) {
        const notification = await super.update(id, updateDto, updatedBy);
        // Queue for processing if not just updating read status
        if (!updateDto.read) {
            await this.notificationsQueue.add('processNotification', {
                notificationId: notification.id,
                userId: notification.user.id,
                isUpdate: true
            });
        }
        else {
            // Just emit read status update via WebSocket
            this.notificationsGateway.emitToUser(notification, notification.user.id);
        }
        return notification;
    }
    async getNotificationsByIds(ids) {
        const notifications = await this.notificationRepo.findBy({ id: (0, typeorm_2.In)(ids) });
        if (notifications.length !== ids.length) {
            const missingIds = ids.filter(id => !notifications.some(notification => notification.id === id));
            this.notificationLogger.warn(`Missing notifications for IDs: ${missingIds.join(', ')}`);
        }
        return notifications;
    }
    async createBulkNotifications(dto, createdBy) {
        const notifications = dto.recipients.map(recipient => {
            // Log a warning if recipient.id is missing
            if (!recipient.id) {
                this.notificationLogger.warn(`Recipient id is missing for recipient: ${JSON.stringify(recipient)}`);
            }
            return this.notificationRepo.create(Object.assign(Object.assign({}, dto), { user: { id: recipient.id }, read: false, createdBy }));
        });
        // Save all to database
        const savedNotifications = await this.notificationRepo.save(notifications);
        // Group by user
        const notificationsByUser = new Map();
        savedNotifications.forEach(notification => {
            const userId = notification.user.id;
            if (!notificationsByUser.has(userId)) {
                notificationsByUser.set(userId, []);
            }
            notificationsByUser.get(userId).push(notification.id);
        });
        // Queue batch processing jobs
        for (const [userId, notificationIds] of notificationsByUser.entries()) {
            await this.notificationsQueue.add('processBatch', {
                notificationIds,
                userId
            });
        }
        return savedNotifications;
    }
};
exports.NotificationsService = NotificationsService;
exports.NotificationsService = NotificationsService = NotificationsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(notification_entity_1.Notification)),
    __param(3, (0, bull_1.InjectQueue)('notifications')),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof notifications_gateway_1.NotificationsGateway !== "undefined" && notifications_gateway_1.NotificationsGateway) === "function" ? _c : Object, typeof (_d = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _d : Object])
], NotificationsService);


/***/ }),
/* 262 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationsGateway = void 0;
const create_gateway_factory_1 = __webpack_require__(109);
class NotificationsGateway extends (0, create_gateway_factory_1.createGateway)('notifications') {
}
exports.NotificationsGateway = NotificationsGateway;


/***/ }),
/* 263 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeRequestsService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const work_time_request_entity_1 = __webpack_require__(49);
let WorkTimeRequestsService = class WorkTimeRequestsService extends base_service_1.BaseService {
    constructor(workTimeRequestsRepository, usersService) {
        super(workTimeRequestsRepository, usersService);
        this.workTimeRequestsRepository = workTimeRequestsRepository;
        this.usersService = usersService;
    }
};
exports.WorkTimeRequestsService = WorkTimeRequestsService;
exports.WorkTimeRequestsService = WorkTimeRequestsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(work_time_request_entity_1.WorkTimeRequest)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], WorkTimeRequestsService);


/***/ }),
/* 264 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAttendanceDto = exports.UpdateAttendanceDto = exports.CreateAttendanceDto = exports.AttendanceDto = void 0;
const base_dto_1 = __webpack_require__(101);
const attendance_status_enum_1 = __webpack_require__(50);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class AttendanceDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.AttendanceDto = AttendanceDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employee ID',
        example: '123e4567-e89b-12d3-a456-426614174000'
    }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], AttendanceDto.prototype, "employeeId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'List of attendance statuses',
        type: [String],
        enum: attendance_status_enum_1.AttendanceStatus,
        example: [attendance_status_enum_1.AttendanceStatus.CHECKED_IN, attendance_status_enum_1.AttendanceStatus.LATE]
    }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsEnum)(attendance_status_enum_1.AttendanceStatus, { each: true }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Array)
], AttendanceDto.prototype, "statuses", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Time when employee clocked in',
        example: '2023-01-01T09:00:00Z',
        type: Date
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], AttendanceDto.prototype, "timeIn", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Time when employee clocked out',
        example: '2023-01-01T17:00:00Z',
        type: Date,
        required: false,
        nullable: true
    }),
    (0, class_validator_1.IsDate)(),
    (0, class_transformer_1.Type)(() => Date),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], AttendanceDto.prototype, "timeOut", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Schedule ID',
        example: '123e4567-e89b-12d3-a456-426614174000'
    }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], AttendanceDto.prototype, "scheduleId", void 0);
class CreateAttendanceDto extends AttendanceDto {
}
exports.CreateAttendanceDto = CreateAttendanceDto;
class UpdateAttendanceDto extends (0, swagger_1.PartialType)(AttendanceDto) {
}
exports.UpdateAttendanceDto = UpdateAttendanceDto;
class GetAttendanceDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateAttendanceDto, 'attendance') {
}
exports.GetAttendanceDto = GetAttendanceDto;


/***/ }),
/* 265 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FinalWorkHoursModule = void 0;
const bull_1 = __webpack_require__(4);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const final_work_hour_entity_1 = __webpack_require__(58);
const final_work_hours_controller_1 = __webpack_require__(266);
const final_work_hours_service_1 = __webpack_require__(268);
const work_hour_calculation_service_1 = __webpack_require__(269);
let FinalWorkHoursModule = class FinalWorkHoursModule {
};
exports.FinalWorkHoursModule = FinalWorkHoursModule;
exports.FinalWorkHoursModule = FinalWorkHoursModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([final_work_hour_entity_1.FinalWorkHour]),
            bull_1.BullModule.registerQueue({
                name: 'work-hour-calculation'
            }),
        ],
        providers: [final_work_hours_service_1.FinalWorkHoursService, work_hour_calculation_service_1.WorkHourCalculationService],
        exports: [final_work_hours_service_1.FinalWorkHoursService, work_hour_calculation_service_1.WorkHourCalculationService],
        controllers: [final_work_hours_controller_1.FinalWorkHoursController],
    })
], FinalWorkHoursModule);


/***/ }),
/* 266 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FinalWorkHoursController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const final_work_hour_dto_1 = __webpack_require__(267);
const final_work_hour_entity_1 = __webpack_require__(58);
const final_work_hours_service_1 = __webpack_require__(268);
class FinalWorkHoursController extends (0, create_controller_factory_1.createController)(final_work_hour_entity_1.FinalWorkHour, final_work_hours_service_1.FinalWorkHoursService, final_work_hour_dto_1.GetFinalWorkHourDto, undefined, final_work_hour_dto_1.UpdateFinalWorkHourDto) {
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async delete(id) {
        return await super.delete(id);
    }
}
exports.FinalWorkHoursController = FinalWorkHoursController;


/***/ }),
/* 267 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFinalWorkHourDto = exports.UpdateFinalWorkHourDto = exports.FinalWorkHourDto = void 0;
const base_dto_1 = __webpack_require__(101);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
const swagger_2 = __webpack_require__(8);
class FinalWorkHourDto extends (0, swagger_2.PartialType)(base_dto_1.BaseDto) {
}
exports.FinalWorkHourDto = FinalWorkHourDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the final-work-hour' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FinalWorkHourDto.prototype, "name", void 0);
class UpdateFinalWorkHourDto extends (0, swagger_2.PartialType)(FinalWorkHourDto) {
}
exports.UpdateFinalWorkHourDto = UpdateFinalWorkHourDto;
class GetFinalWorkHourDto extends (0, create_get_dto_factory_1.createGetDto)(FinalWorkHourDto) {
}
exports.GetFinalWorkHourDto = GetFinalWorkHourDto;


/***/ }),
/* 268 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FinalWorkHoursService = void 0;
const holiday_type_enum_1 = __webpack_require__(69);
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const final_work_hour_entity_1 = __webpack_require__(58);
let FinalWorkHoursService = class FinalWorkHoursService extends base_service_1.BaseService {
    constructor(finalWorkHoursRepository, usersService) {
        super(finalWorkHoursRepository, usersService);
        this.finalWorkHoursRepository = finalWorkHoursRepository;
        this.usersService = usersService;
    }
    /**
     * Calculates and categorizes work hours based on day type
     * No pay calculations included - strictly time tracking
     */
    calculateWorkHoursBreakdown(finalWorkHour) {
        var _a;
        const result = {
            regularDayHours: 0,
            restDayHours: 0,
            specialHolidayHours: 0,
            regularHolidayHours: 0,
            overtimeRegularDayHours: 0,
            overtimeRestDayHours: 0,
            overtimeSpecialHolidayHours: 0,
            overtimeRegularHolidayHours: 0,
            nightDifferentialHours: 0,
            dayType: final_work_hour_entity_1.DayType.REGULAR_DAY,
            totalRegularHours: 0,
            totalOvertimeHours: 0,
            totalHours: 0
        };
        // Extract schedule information
        const { schedule } = finalWorkHour.attendance;
        const isRestDay = schedule.restDay === true;
        const holidayType = (_a = schedule.holiday) === null || _a === void 0 ? void 0 : _a.type;
        // Calculate regular and overtime hours
        const regularHours = this.calculateHours(finalWorkHour.timeIn, finalWorkHour.timeOut, schedule.shift.defaultBreakTime);
        const overtimeHours = finalWorkHour.overTimeOut ?
            this.calculateHours(finalWorkHour.timeOut, finalWorkHour.overTimeOut, schedule.shift.defaultBreakTime) : 0;
        // Calculate night differential hours
        const nightDiffHours = this.calculateNightDifferentialHours(finalWorkHour.timeIn, finalWorkHour.timeOut, finalWorkHour.overTimeOut);
        // Categorize hours based on day type
        if (isRestDay && holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
            result.dayType = final_work_hour_entity_1.DayType.REGULAR_HOLIDAY_REST_DAY;
            result.regularHolidayHours = regularHours;
            result.overtimeRegularHolidayHours = overtimeHours;
        }
        else if (isRestDay && (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING)) {
            result.dayType = final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY_REST_DAY;
            result.specialHolidayHours = regularHours;
            result.overtimeSpecialHolidayHours = overtimeHours;
        }
        else if (isRestDay) {
            result.dayType = final_work_hour_entity_1.DayType.REST_DAY;
            result.restDayHours = regularHours;
            result.overtimeRestDayHours = overtimeHours;
        }
        else if (holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
            result.dayType = final_work_hour_entity_1.DayType.REGULAR_HOLIDAY;
            result.regularHolidayHours = regularHours;
            result.overtimeRegularHolidayHours = overtimeHours;
        }
        else if (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING || holidayType === holiday_type_enum_1.HolidayType.SPECIAL_WORKING) {
            result.dayType = final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY;
            result.specialHolidayHours = regularHours;
            result.overtimeSpecialHolidayHours = overtimeHours;
        }
        else {
            result.dayType = final_work_hour_entity_1.DayType.REGULAR_DAY;
            result.regularDayHours = regularHours;
            result.overtimeRegularDayHours = overtimeHours;
        }
        // Store night differential hours
        result.nightDifferentialHours = nightDiffHours;
        // Calculate totals
        result.totalRegularHours = result.regularDayHours +
            result.restDayHours +
            result.specialHolidayHours +
            result.regularHolidayHours;
        result.totalOvertimeHours = result.overtimeRegularDayHours +
            result.overtimeRestDayHours +
            result.overtimeSpecialHolidayHours +
            result.overtimeRegularHolidayHours;
        result.totalHours = result.totalRegularHours + result.totalOvertimeHours;
        return result;
    }
    /**
     * Calculate night differential hours worked
     */
    calculateNightDifferentialHours(timeIn, timeOut, overTimeOut) {
        const NIGHT_DIFF_START_HOUR = 22; // 10:00 PM
        const NIGHT_DIFF_END_HOUR = 6; // 6:00 AM
        let nightDiffHours = 0;
        const timeInLocal = new Date(timeIn);
        const timeOutLocal = new Date(timeOut);
        const overTimeOutLocal = overTimeOut ? new Date(overTimeOut) : null;
        const finalTimeOut = overTimeOutLocal || timeOutLocal;
        // Check each hour between timeIn and finalTimeOut
        let currentHour = new Date(timeInLocal);
        while (currentHour < finalTimeOut) {
            const nextHour = new Date(currentHour);
            nextHour.setHours(nextHour.getHours() + 1);
            const hourEnd = new Date(Math.min(nextHour.getTime(), finalTimeOut.getTime()));
            const hourDiff = this.calculateHours(currentHour, hourEnd, 6);
            // Check if this hour falls within night differential period
            const hour = currentHour.getHours();
            if (hour >= NIGHT_DIFF_START_HOUR || hour < NIGHT_DIFF_END_HOUR) {
                nightDiffHours += hourDiff;
            }
            currentHour = nextHour;
        }
        return Math.round(nightDiffHours * 100) / 100; // Round to 2 decimal places
    }
    /**
     * Calculate hours between two time points, subtracting break time
     * @param start Start date and time
     * @param end End date and time
     * @param breakTimeDuration Break time in minutes
     * @returns Number of hours worked, rounded to 2 decimal places
     */
    calculateHours(start, end, breakTimeDuration) {
        // Calculate the time difference in milliseconds
        const diffMs = end.getTime() - start.getTime();
        // Convert to hours
        const diffHours = diffMs / (1000 * 60 * 60);
        // Convert break time from minutes to hours and subtract
        const breakTimeHours = breakTimeDuration / 60;
        const totalHours = diffHours - breakTimeHours;
        // Round to 2 decimal places
        return Math.round(totalHours * 100) / 100;
    }
    /**
     * Updates a FinalWorkHour entity with calculated hours breakdown
     */
    async updateWorkHoursBreakdown(finalWorkHourId, createdBy) {
        const finalWorkHour = await this.findOneByOrFail({ id: finalWorkHourId }, { relations: { attendance: { schedule: { holiday: true } } } });
        const breakdown = this.calculateWorkHoursBreakdown(finalWorkHour);
        // Update the record with calculated hours
        return this.update(finalWorkHourId, {
            regularDayHours: breakdown.regularDayHours,
            restDayHours: breakdown.restDayHours,
            specialHolidayHours: breakdown.specialHolidayHours,
            regularHolidayHours: breakdown.regularHolidayHours,
            overtimeRegularDayHours: breakdown.overtimeRegularDayHours,
            overtimeRestDayHours: breakdown.overtimeRestDayHours,
            overtimeSpecialHolidayHours: breakdown.overtimeSpecialHolidayHours,
            overtimeRegularHolidayHours: breakdown.overtimeRegularHolidayHours,
            nightDifferentialHours: breakdown.nightDifferentialHours,
            dayType: breakdown.dayType,
            totalRegularHours: breakdown.totalRegularHours,
            totalOvertimeHours: breakdown.totalOvertimeHours,
            totalHours: breakdown.totalHours,
        }, createdBy);
    }
};
exports.FinalWorkHoursService = FinalWorkHoursService;
exports.FinalWorkHoursService = FinalWorkHoursService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(final_work_hour_entity_1.FinalWorkHour)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], FinalWorkHoursService);


/***/ }),
/* 269 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var WorkHourCalculationService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkHourCalculationService = void 0;
const attendance_event_1 = __webpack_require__(236);
const bull_1 = __webpack_require__(4);
const common_1 = __webpack_require__(5);
const event_emitter_1 = __webpack_require__(139);
const bull_2 = __webpack_require__(158);
const uuid_1 = __webpack_require__(112);
let WorkHourCalculationService = WorkHourCalculationService_1 = class WorkHourCalculationService {
    constructor(workHourQueue, eventEmitter) {
        this.workHourQueue = workHourQueue;
        this.eventEmitter = eventEmitter;
        this.logger = new common_1.Logger(WorkHourCalculationService_1.name);
    }
    //   async addGenerationJob(data: ScheduleGenerationJob): Promise<Job<ScheduleGenerationJob>> {
    //       this.logger.log(`Adding schedule generation job for ${data.employeeIds.length} employees in group ${data.groupId}`);
    //       return this.scheduleQueue.add('generate', data);
    //     }
    async queueFinalWorkHoursCalculation(attendanceIds, processedBy) {
        // Generate a batch ID for tracking
        const batchId = (0, uuid_1.v4)();
        // Emit the event first
        this.eventEmitter.emit(attendance_event_1.ATTENDANCE_EVENTS.FINAL_WORK_HOURS_CALCULATION, new attendance_event_1.FinalWorkHoursCalculationEvent(attendanceIds, batchId, processedBy));
        // Queue the job with high priority
        await this.workHourQueue.add('calculate-final-work-hours', {
            attendanceIds,
            batchId,
            processedBy
        }, {
            priority: 1,
            attempts: 3,
            backoff: {
                type: 'exponential',
                delay: 5000
            },
            removeOnComplete: true,
            jobId: `final-work-hours-${batchId}`
        });
        this.logger.log(`Queued final work hours calculation for batch ${batchId} with ${attendanceIds.length} attendances`);
        return batchId;
    }
};
exports.WorkHourCalculationService = WorkHourCalculationService;
exports.WorkHourCalculationService = WorkHourCalculationService = WorkHourCalculationService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, bull_1.InjectQueue)('work-hour-calculation')),
    __metadata("design:paramtypes", [typeof (_a = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _a : Object, typeof (_b = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _b : Object])
], WorkHourCalculationService);


/***/ }),
/* 270 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AttendanceListener_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttendanceListener = void 0;
const attendance_status_enum_1 = __webpack_require__(50);
const holiday_type_enum_1 = __webpack_require__(69);
const notification_type_enum_1 = __webpack_require__(83);
const request_status_enum_1 = __webpack_require__(51);
const schedule_status_1 = __webpack_require__(54);
const attendance_event_1 = __webpack_require__(236);
const attendance_punches_service_1 = __webpack_require__(257);
const attendances_service_1 = __webpack_require__(260);
const biometric_devices_service_1 = __webpack_require__(226);
const employees_service_1 = __webpack_require__(104);
const employee_entity_1 = __webpack_require__(43);
const notifications_service_1 = __webpack_require__(261);
const schedule_entity_1 = __webpack_require__(53);
const schedules_service_1 = __webpack_require__(153);
const common_1 = __webpack_require__(5);
const event_emitter_1 = __webpack_require__(139);
const date_fns_1 = __webpack_require__(155);
const final_work_hour_entity_1 = __webpack_require__(58);
const work_hour_calculation_service_1 = __webpack_require__(269);
const work_time_requests_service_1 = __webpack_require__(263);
let AttendanceListener = AttendanceListener_1 = class AttendanceListener {
    constructor(attendancesService, attendancePunchesService, employeesService, schedulesService, biometricDevicesService, notificationsService, workTimeRequestsService, workHourCalculationService) {
        this.attendancesService = attendancesService;
        this.attendancePunchesService = attendancePunchesService;
        this.employeesService = employeesService;
        this.schedulesService = schedulesService;
        this.biometricDevicesService = biometricDevicesService;
        this.notificationsService = notificationsService;
        this.workTimeRequestsService = workTimeRequestsService;
        this.workHourCalculationService = workHourCalculationService;
        this.logger = new common_1.Logger(AttendanceListener_1.name);
        this.GRACE_PERIOD_MINUTES = 5; // Consider late after 5 minutes
        this.OVER_TIME_THRESHOLD_MINUTES = 30; // Consider overtime if more than 30 minutes
        this.UNDER_TIME_THRESHOLD_MINUTES = 0; // Consider under time if less than 30 minutes
    }
    async handleAttendanceRecorded(event) {
        var _a, _b, _c;
        // Get the biometric device entity
        const biometricDevice = await this.biometricDevicesService.findOneBy({ deviceId: event.deviceId });
        if (!biometricDevice) {
            this.logger.error(`Biometric device with ID ${event.deviceId} not found`);
            return;
        }
        // Process each attendance record
        for (const record of event.attendances) {
            try {
                // Validate userId is a proper number before parsing
                if (!record.userId || !/^\d+$/.test(record.userId)) {
                    this.logger.warn(`Invalid user ID format: "${record.userId}". Must be numeric.`);
                    continue;
                }
                const employeeNumber = parseInt(record.userId, 10);
                if (isNaN(employeeNumber)) {
                    this.logger.warn(`Failed to parse employee number from: "${record.userId}"`);
                    continue;
                }
                // Find employee by biometric ID
                const employee = await this.employeesService.findOneBy({
                    employeeNumber
                }, { relations: { user: true } });
                if (!employee) {
                    this.logger.warn(`No employee found with biometric ID ${record.userId}`);
                    continue;
                }
                const punchTime = new Date(record.timestamp);
                const punchDate = (0, date_fns_1.format)(punchTime, 'yyyy-MM-dd');
                const punchTimeStr = (0, date_fns_1.format)(punchTime, 'HH:mm:ss');
                const punchType = record.punchType;
                // Find today's schedule for the employee
                const todaySchedule = await this.schedulesService.getEmployeeScheduleToday(employee.id);
                let attendanceStatuses = [];
                if (!todaySchedule) {
                    this.logger.warn(`No schedule found for employee ${employee.id} on ${punchDate}`);
                    // Notify employee
                    await this.notificationsService.create({
                        title: 'No Schedule Found',
                        message: `You have no schedule for today (${punchDate}). Your attendance will not be recorded. Please communicate with your HR/Supervisor.`,
                        type: notification_type_enum_1.NotificationType.WARNING,
                        category: 'ATTENDANCE',
                        user: { id: employee.user.id },
                    });
                    continue;
                }
                let dayType;
                const isRestDay = todaySchedule.restDay;
                const holidayType = (_a = todaySchedule.holiday) === null || _a === void 0 ? void 0 : _a.type;
                if (isRestDay && holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
                    dayType = final_work_hour_entity_1.DayType.REGULAR_HOLIDAY_REST_DAY;
                }
                else if (isRestDay && (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING)) {
                    dayType = final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY_REST_DAY;
                }
                else if (isRestDay) {
                    dayType = final_work_hour_entity_1.DayType.REST_DAY;
                }
                else if (holidayType === holiday_type_enum_1.HolidayType.REGULAR) {
                    dayType = final_work_hour_entity_1.DayType.REGULAR_HOLIDAY;
                }
                else if (holidayType === holiday_type_enum_1.HolidayType.SPECIAL_NON_WORKING || holidayType === holiday_type_enum_1.HolidayType.SPECIAL_WORKING) {
                    dayType = final_work_hour_entity_1.DayType.SPECIAL_HOLIDAY;
                }
                else {
                    dayType = final_work_hour_entity_1.DayType.REGULAR_DAY;
                }
                if (todaySchedule.status === schedule_status_1.ScheduleStatus.LEAVE) {
                    this.logger.log(`Employee ${employee.id} is on leave today`);
                    // Notify employee
                    await this.notificationsService.create({
                        title: 'Leave Notification',
                        message: `You are on leave today (${punchDate}). Your attendance will be recorded.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: employee.user.id },
                    });
                }
                if (todaySchedule.holiday) {
                    this.logger.log(`Employee ${employee.id} checked in on a holiday (${todaySchedule.holiday.name})`);
                    // Notify employee
                    await this.notificationsService.create({
                        title: 'Holiday Check-in',
                        message: `You checked in on a holiday (${todaySchedule.holiday.name}) on ${punchDate} at ${punchTimeStr}.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: employee.user.id },
                    });
                }
                if (todaySchedule.restDay) {
                    this.logger.log(`Employee ${employee.id} is on rest day but checking in`);
                    // notify employee
                    await this.notificationsService.create({
                        title: 'Rest Day Check-in',
                        message: `You are on a rest day but checked in on ${punchDate} at ${punchTimeStr}.`,
                        type: notification_type_enum_1.NotificationType.INFO,
                        category: 'ATTENDANCE',
                        user: { id: employee.user.id },
                    });
                }
                const { startTime, endTime } = todaySchedule;
                const effectiveStartTime = startTime;
                const effectiveEndTime = endTime;
                const shiftStartTime = (0, date_fns_1.parseISO)(`${punchDate}T${effectiveStartTime}`);
                const shiftEndTime = (0, date_fns_1.parseISO)(`${punchDate}T${effectiveEndTime}`);
                const middleTime = new Date(shiftStartTime.getTime() +
                    (shiftEndTime.getTime() - shiftStartTime.getTime()) / 2);
                // Find attendance for today if it exists
                let existingAttendance = await this.attendancesService.findOneBy({
                    employee: new employee_entity_1.Employee({ id: employee.id }),
                    schedule: new schedule_entity_1.Schedule({ id: todaySchedule.id }),
                });
                // If no existing attendance create an attendance
                if (!existingAttendance) {
                    this.logger.log(`Creating new attendance for employee ${employee.user.email} on ${punchDate}`);
                    existingAttendance = await this.attendancesService.create({
                        employee: { id: employee.id },
                        schedule: { id: todaySchedule.id },
                        dayType,
                        createdBy: employee.user.id,
                    });
                }
                // Determine check-in status based on middle time threshold
                if ((0, date_fns_1.isBefore)(punchTime, middleTime)) {
                    // log
                    this.logger.log(`Employee ${employee.user.email} checked in before middle time on ${punchDate} at ${punchTimeStr}`);
                    if (!existingAttendance.timeIn) {
                        // log
                        this.logger.log(`Employee ${employee.user.email} is checking in`);
                        attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.CHECKED_IN);
                        // Check if late
                        if ((0, date_fns_1.isAfter)(punchTime, shiftStartTime)) {
                            const minutesLate = (0, date_fns_1.differenceInMinutes)(punchTime, shiftStartTime);
                            if (minutesLate > this.GRACE_PERIOD_MINUTES) {
                                attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.LATE);
                                this.logger.log(`Employee ${employee.user.email} is late by ${minutesLate} minutes`);
                                // Create work time request for late arrival
                                await this.createWorkTimeRequest(dayType, employee.id, attendance_status_enum_1.AttendanceStatus.LATE, existingAttendance.id, minutesLate);
                                // Notify employee
                                await this.notificationsService.create({
                                    title: 'Late Check-in',
                                    message: `You are late by ${minutesLate} minutes on ${punchDate} at ${punchTimeStr}.`,
                                    type: notification_type_enum_1.NotificationType.WARNING,
                                    category: 'ATTENDANCE',
                                    user: { id: employee.user.id },
                                });
                            }
                        }
                        existingAttendance.timeIn = punchTime;
                        existingAttendance.statuses = attendanceStatuses;
                    }
                    else {
                        this.logger.log(`Employee ${employee.user.email} already checked in`);
                        // notify employee
                        await this.notificationsService.create({
                            title: 'Already Checked In',
                            message: `You tried to check in but you have already checked in on ${punchDate} at ${punchTimeStr}.`,
                            type: notification_type_enum_1.NotificationType.INFO,
                            category: 'ATTENDANCE',
                            user: { id: employee.user.id },
                        });
                    }
                }
                else {
                    attendanceStatuses = existingAttendance.statuses || [];
                    // log
                    if (!existingAttendance.timeIn && !((_b = existingAttendance.statuses) === null || _b === void 0 ? void 0 : _b.includes(attendance_status_enum_1.AttendanceStatus.NO_CHECKED_IN))) {
                        attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.NO_CHECKED_IN);
                        // Create work time request for no check in
                        await this.createWorkTimeRequest(dayType, employee.id, attendance_status_enum_1.AttendanceStatus.NO_CHECKED_IN, existingAttendance.id);
                        // Notify employee
                        await this.notificationsService.create({
                            title: 'No Check-in',
                            message: `You did not check in on ${punchDate} at ${punchTimeStr}.`,
                            type: notification_type_enum_1.NotificationType.WARNING,
                            category: 'ATTENDANCE',
                            user: { id: employee.user.id },
                        });
                    }
                    // Check if employee is undertime
                    if ((0, date_fns_1.isBefore)(punchTime, shiftEndTime)) {
                        // log
                        this.logger.log(`Employee ${employee.user.email} is leaving early on ${punchDate} at ${punchTimeStr}`);
                        const minutesEarly = (0, date_fns_1.differenceInMinutes)(shiftEndTime, punchTime);
                        if (minutesEarly > this.UNDER_TIME_THRESHOLD_MINUTES) {
                            attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.UNDER_TIME);
                            this.logger.log(`Employee ${employee.id} is leaving ${minutesEarly} minutes early`);
                            // move this to cron job
                            // // Create work time request for under time
                            // await this.createWorkTimeRequest(dayType, employee.id, AttendanceStatus.UNDER_TIME, existingAttendance.id, minutesEarly);
                            // // Notify management
                            // await this.notificationsService.create({
                            //   title: 'Early Check-out',
                            //   message: `You are leaving ${minutesEarly} minutes early on ${punchDate} at ${punchTimeStr}.`,
                            //   type: NotificationType.WARNING,
                            //   category: 'ATTENDANCE',
                            //   user: { id: employee.user.id },
                            // });
                        }
                    }
                    else {
                        // remove undertime and checked out status
                        attendanceStatuses = attendanceStatuses.filter(status => status !== attendance_status_enum_1.AttendanceStatus.CHECKED_OUT);
                        attendanceStatuses = attendanceStatuses.filter(status => status !== attendance_status_enum_1.AttendanceStatus.UNDER_TIME);
                        // Check if employee is overtime
                        const minutesOvertime = (0, date_fns_1.differenceInMinutes)(punchTime, shiftEndTime);
                        if (minutesOvertime > this.OVER_TIME_THRESHOLD_MINUTES) {
                            if (!((_c = existingAttendance.statuses) === null || _c === void 0 ? void 0 : _c.includes(attendance_status_enum_1.AttendanceStatus.OVERTIME))) {
                                attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.OVERTIME);
                            }
                            this.logger.log(`Employee ${employee.id} worked ${minutesOvertime} minutes overtime`);
                            // move this to cron job              
                            // Create work time request for overtime
                            // await this.createWorkTimeRequest(dayType, employee.id, AttendanceStatus.OVERTIME, existingAttendance.id, minutesOvertime);
                            // // Notify employee
                            // await this.notificationsService.create({
                            //   title: 'Overtime Alert',
                            //   message: `You worked ${minutesOvertime} minutes overtime on ${punchDate} at ${punchTimeStr}.`,
                            //   type: NotificationType.INFO,
                            //   category: 'ATTENDANCE',
                            //   user: { id: employee.user.id },
                            // });
                        }
                    }
                    attendanceStatuses.push(attendance_status_enum_1.AttendanceStatus.CHECKED_OUT);
                    existingAttendance.statuses = [...attendanceStatuses];
                    existingAttendance.updatedBy = employee.user.id;
                    existingAttendance.timeOut = punchTime;
                }
                await this.attendancesService.save(existingAttendance);
                // Create attendance punch record
                await this.attendancePunchesService.create({
                    attendance: { id: existingAttendance.id },
                    time: punchTime,
                    punchType: record.punchType,
                    punchMethod: record.punchMethod,
                    employeeNumber,
                    biometricDevice: { id: biometricDevice.id },
                    createdBy: employee.user.id,
                });
                this.logger.log(`Successfully processed ${record.punchMethod} punch for employee ${employee.user.email} at ${punchTimeStr} with status ${existingAttendance.statuses}`);
            }
            catch (error) {
                if (error instanceof Error) {
                    this.logger.error(`Error processing attendance record: ${error.message}`, error.stack);
                }
                else {
                    this.logger.error(`Error processing attendance record: ${String(error)}`);
                }
            }
        }
    }
    async handleAttendanceProcessedEvent(event) {
        this.logger.log(`Handling attendance processed event for ${event.attendances.length} attendances`);
        if (event.attendances.length === 0) {
            return;
        }
        // Extract attendance IDs
        const attendanceIds = event.attendances.map(attendance => attendance.id);
        // Queue the attendances for final work hour calculation
        const batchId = await this.workHourCalculationService.queueFinalWorkHoursCalculation(attendanceIds, 'SYSTEM' // Since this is triggered by a system process
        );
        this.logger.log(`Queued ${attendanceIds.length} attendances for final work hours calculation. Batch ID: ${batchId}`);
    }
    // Helper methods for notifications and work time requests
    async createWorkTimeRequest(dayType, employeeId, type, attendanceId, duration) {
        try {
            await this.workTimeRequestsService.create({
                attendance: { id: attendanceId },
                type,
                duration,
                dayType,
                status: request_status_enum_1.RequestStatus.PENDING,
                createdBy: employeeId,
                employee: { id: employeeId },
            });
            this.logger.log(`Created work time request for employee ${employeeId} for type ${type}`);
        }
        catch (error) {
            this.logger.error(`Failed to create work time request: ${error.message}`);
        }
    }
};
exports.AttendanceListener = AttendanceListener;
__decorate([
    (0, event_emitter_1.OnEvent)(attendance_event_1.ATTENDANCE_EVENTS.ATTENDANCE_RECORDED),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_j = typeof attendance_event_1.AttendanceRecordedEvent !== "undefined" && attendance_event_1.AttendanceRecordedEvent) === "function" ? _j : Object]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], AttendanceListener.prototype, "handleAttendanceRecorded", null);
__decorate([
    (0, event_emitter_1.OnEvent)(attendance_event_1.ATTENDANCE_EVENTS.ATTENDANCE_PROCESSED),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_l = typeof attendance_event_1.AttendanceProcessedEvent !== "undefined" && attendance_event_1.AttendanceProcessedEvent) === "function" ? _l : Object]),
    __metadata("design:returntype", Promise)
], AttendanceListener.prototype, "handleAttendanceProcessedEvent", null);
exports.AttendanceListener = AttendanceListener = AttendanceListener_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof attendances_service_1.AttendancesService !== "undefined" && attendances_service_1.AttendancesService) === "function" ? _a : Object, typeof (_b = typeof attendance_punches_service_1.AttendancePunchesService !== "undefined" && attendance_punches_service_1.AttendancePunchesService) === "function" ? _b : Object, typeof (_c = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _c : Object, typeof (_d = typeof schedules_service_1.SchedulesService !== "undefined" && schedules_service_1.SchedulesService) === "function" ? _d : Object, typeof (_e = typeof biometric_devices_service_1.BiometricDevicesService !== "undefined" && biometric_devices_service_1.BiometricDevicesService) === "function" ? _e : Object, typeof (_f = typeof notifications_service_1.NotificationsService !== "undefined" && notifications_service_1.NotificationsService) === "function" ? _f : Object, typeof (_g = typeof work_time_requests_service_1.WorkTimeRequestsService !== "undefined" && work_time_requests_service_1.WorkTimeRequestsService) === "function" ? _g : Object, typeof (_h = typeof work_hour_calculation_service_1.WorkHourCalculationService !== "undefined" && work_hour_calculation_service_1.WorkHourCalculationService) === "function" ? _h : Object])
], AttendanceListener);


/***/ }),
/* 271 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeRequestsModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const work_time_request_entity_1 = __webpack_require__(49);
const work_time_requests_controller_1 = __webpack_require__(272);
const work_time_requests_service_1 = __webpack_require__(263);
const work_time_responses_module_1 = __webpack_require__(274);
let WorkTimeRequestsModule = class WorkTimeRequestsModule {
};
exports.WorkTimeRequestsModule = WorkTimeRequestsModule;
exports.WorkTimeRequestsModule = WorkTimeRequestsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([work_time_request_entity_1.WorkTimeRequest]),
            work_time_responses_module_1.WorkTimeResponsesModule,
        ],
        providers: [work_time_requests_service_1.WorkTimeRequestsService],
        exports: [
            work_time_requests_service_1.WorkTimeRequestsService,
            work_time_responses_module_1.WorkTimeResponsesModule,
        ],
        controllers: [work_time_requests_controller_1.WorkTimeRequestsController],
    })
], WorkTimeRequestsModule);


/***/ }),
/* 272 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeRequestsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const work_time_request_dto_1 = __webpack_require__(273);
const work_time_request_entity_1 = __webpack_require__(49);
const work_time_requests_service_1 = __webpack_require__(263);
class WorkTimeRequestsController extends (0, create_controller_factory_1.createController)(work_time_request_entity_1.WorkTimeRequest, work_time_requests_service_1.WorkTimeRequestsService, work_time_request_dto_1.GetWorkTimeRequestDto, work_time_request_dto_1.WorkTimeRequestDto, work_time_request_dto_1.UpdateWorkTimeRequestDto) {
    async delete(id) {
        return await super.delete(id);
    }
}
exports.WorkTimeRequestsController = WorkTimeRequestsController;


/***/ }),
/* 273 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetWorkTimeRequestDto = exports.UpdateWorkTimeRequestDto = exports.WorkTimeRequestDto = void 0;
const base_dto_1 = __webpack_require__(101);
const attendance_status_enum_1 = __webpack_require__(50);
const request_status_enum_1 = __webpack_require__(51);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class WorkTimeRequestDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.WorkTimeRequestDto = WorkTimeRequestDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Status of the work time request',
        enum: request_status_enum_1.RequestStatus,
        default: request_status_enum_1.RequestStatus.PENDING,
        example: request_status_enum_1.RequestStatus.PENDING
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(request_status_enum_1.RequestStatus),
    __metadata("design:type", typeof (_a = typeof request_status_enum_1.RequestStatus !== "undefined" && request_status_enum_1.RequestStatus) === "function" ? _a : Object)
], WorkTimeRequestDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of attendance',
        enum: attendance_status_enum_1.AttendanceStatus,
        example: attendance_status_enum_1.AttendanceStatus.OVERTIME
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsEnum)(attendance_status_enum_1.AttendanceStatus),
    __metadata("design:type", typeof (_b = typeof attendance_status_enum_1.AttendanceStatus !== "undefined" && attendance_status_enum_1.AttendanceStatus) === "function" ? _b : Object)
], WorkTimeRequestDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID of the linked attendance record',
        example: '123e4567-e89b-12d3-a456-426614174000'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], WorkTimeRequestDto.prototype, "attendanceId", void 0);
class UpdateWorkTimeRequestDto extends (0, swagger_1.PartialType)(WorkTimeRequestDto) {
}
exports.UpdateWorkTimeRequestDto = UpdateWorkTimeRequestDto;
class GetWorkTimeRequestDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateWorkTimeRequestDto, 'work time request') {
}
exports.GetWorkTimeRequestDto = GetWorkTimeRequestDto;


/***/ }),
/* 274 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeResponsesModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const work_time_response_entity_1 = __webpack_require__(78);
const work_time_responses_controller_1 = __webpack_require__(275);
const work_time_responses_service_1 = __webpack_require__(277);
let WorkTimeResponsesModule = class WorkTimeResponsesModule {
};
exports.WorkTimeResponsesModule = WorkTimeResponsesModule;
exports.WorkTimeResponsesModule = WorkTimeResponsesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([work_time_response_entity_1.WorkTimeResponse])
        ],
        providers: [work_time_responses_service_1.WorkTimeResponsesService],
        exports: [work_time_responses_service_1.WorkTimeResponsesService],
        controllers: [work_time_responses_controller_1.WorkTimeResponsesController],
    })
], WorkTimeResponsesModule);


/***/ }),
/* 275 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeResponsesController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const work_time_response_dto_1 = __webpack_require__(276);
const work_time_response_entity_1 = __webpack_require__(78);
const work_time_responses_service_1 = __webpack_require__(277);
class WorkTimeResponsesController extends (0, create_controller_factory_1.createController)(work_time_response_entity_1.WorkTimeResponse, work_time_responses_service_1.WorkTimeResponsesService, work_time_response_dto_1.GetWorkTimeResponseDto, work_time_response_dto_1.WorkTimeResponseDto, work_time_response_dto_1.UpdateWorkTimeResponseDto) {
    async delete(id) {
        return await super.delete(id);
    }
}
exports.WorkTimeResponsesController = WorkTimeResponsesController;


/***/ }),
/* 276 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetWorkTimeResponseDto = exports.UpdateWorkTimeResponseDto = exports.WorkTimeResponseDto = void 0;
const base_dto_1 = __webpack_require__(101);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class WorkTimeResponseDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.WorkTimeResponseDto = WorkTimeResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Approval status of the work time request',
        example: true
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Boolean)
], WorkTimeResponseDto.prototype, "approved", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Response message for the work time request',
        example: 'Your work time request has been approved.'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], WorkTimeResponseDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID of the related work time request',
        example: '123e4567-e89b-12d3-a456-426614174000'
    }),
    (0, class_validator_1.IsUUID)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], WorkTimeResponseDto.prototype, "workTimeRequestId", void 0);
class UpdateWorkTimeResponseDto extends (0, swagger_1.PartialType)(WorkTimeResponseDto) {
}
exports.UpdateWorkTimeResponseDto = UpdateWorkTimeResponseDto;
class GetWorkTimeResponseDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateWorkTimeResponseDto, 'work time response') {
}
exports.GetWorkTimeResponseDto = GetWorkTimeResponseDto;


/***/ }),
/* 277 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkTimeResponsesService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const work_time_response_entity_1 = __webpack_require__(78);
let WorkTimeResponsesService = class WorkTimeResponsesService extends base_service_1.BaseService {
    constructor(workTimeResponsesRepository, usersService) {
        super(workTimeResponsesRepository, usersService);
        this.workTimeResponsesRepository = workTimeResponsesRepository;
        this.usersService = usersService;
    }
};
exports.WorkTimeResponsesService = WorkTimeResponsesService;
exports.WorkTimeResponsesService = WorkTimeResponsesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(work_time_response_entity_1.WorkTimeResponse)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], WorkTimeResponsesService);


/***/ }),
/* 278 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentsModule = void 0;
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const typeorm_1 = __webpack_require__(16);
const document_types_module_1 = __webpack_require__(279);
const documents_controller_1 = __webpack_require__(283);
const documents_service_1 = __webpack_require__(284);
const document_entity_1 = __webpack_require__(48);
let DocumentsModule = class DocumentsModule {
};
exports.DocumentsModule = DocumentsModule;
exports.DocumentsModule = DocumentsModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([document_entity_1.Document]), document_types_module_1.DocumentTypesModule,
            core_1.RouterModule.register([
                {
                    path: 'documents',
                    module: DocumentsModule,
                    children: [
                        {
                            path: 'types',
                            module: document_types_module_1.DocumentTypesModule,
                        }
                    ]
                },
            ]),
        ],
        providers: [documents_service_1.DocumentsService],
        exports: [documents_service_1.DocumentsService, document_types_module_1.DocumentTypesModule],
        controllers: [documents_controller_1.DocumentsController],
    })
], DocumentsModule);


/***/ }),
/* 279 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentTypesModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const document_types_controller_1 = __webpack_require__(280);
const document_types_service_1 = __webpack_require__(281);
const document_type_entity_1 = __webpack_require__(79);
let DocumentTypesModule = class DocumentTypesModule {
};
exports.DocumentTypesModule = DocumentTypesModule;
exports.DocumentTypesModule = DocumentTypesModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([document_type_entity_1.DocumentType])],
        providers: [document_types_service_1.DocumentTypesService],
        exports: [document_types_service_1.DocumentTypesService],
        controllers: [document_types_controller_1.DocumentTypesController],
    })
], DocumentTypesModule);


/***/ }),
/* 280 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentTypesController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const document_types_service_1 = __webpack_require__(281);
const document_type_dto_1 = __webpack_require__(282);
const document_type_entity_1 = __webpack_require__(79);
class DocumentTypesController extends (0, create_controller_factory_1.createController)(document_type_entity_1.DocumentType, document_types_service_1.DocumentTypesService, document_type_dto_1.GetDocumentTypeDto, document_type_dto_1.DocumentTypeDto, document_type_dto_1.UpdateDocumentTypeDto) {
}
exports.DocumentTypesController = DocumentTypesController;


/***/ }),
/* 281 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentTypesService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const document_type_entity_1 = __webpack_require__(79);
let DocumentTypesService = class DocumentTypesService extends base_service_1.BaseService {
    constructor(documentTypesRepository, usersService) {
        super(documentTypesRepository, usersService);
        this.documentTypesRepository = documentTypesRepository;
        this.usersService = usersService;
    }
};
exports.DocumentTypesService = DocumentTypesService;
exports.DocumentTypesService = DocumentTypesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(document_type_entity_1.DocumentType)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], DocumentTypesService);


/***/ }),
/* 282 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDocumentTypeDto = exports.UpdateDocumentTypeDto = exports.DocumentTypeDto = void 0;
const base_dto_1 = __webpack_require__(101);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class DocumentTypeDto extends base_dto_1.BaseDto {
    constructor() {
        super(...arguments);
        this.active = false;
        this.requiredForApplicants = true;
        this.requiredForEmployees = true;
    }
}
exports.DocumentTypeDto = DocumentTypeDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the document type', example: 'Contract' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DocumentTypeDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Description of the document type', required: false, example: 'Legal contract documents' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DocumentTypeDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Indicates if the document type is active', example: true }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], DocumentTypeDto.prototype, "active", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Indicates if the document type is required for applicants', example: true }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], DocumentTypeDto.prototype, "requiredForApplicants", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Indicates if the document type is required for employees', example: true }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], DocumentTypeDto.prototype, "requiredForEmployees", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Unique identifier for the parent document type', required: false, example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], DocumentTypeDto.prototype, "parentId", void 0);
class UpdateDocumentTypeDto extends (0, swagger_1.PartialType)(DocumentTypeDto) {
}
exports.UpdateDocumentTypeDto = UpdateDocumentTypeDto;
class GetDocumentTypeDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateDocumentTypeDto, 'document type') {
}
exports.GetDocumentTypeDto = GetDocumentTypeDto;


/***/ }),
/* 283 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const documents_service_1 = __webpack_require__(284);
const document_dto_1 = __webpack_require__(285);
const document_entity_1 = __webpack_require__(48);
class DocumentsController extends (0, create_controller_factory_1.createController)(document_entity_1.Document, documents_service_1.DocumentsService, document_dto_1.GetDocumentDto, document_dto_1.DocumentDto, document_dto_1.UpdateDocumentDto) {
}
exports.DocumentsController = DocumentsController;


/***/ }),
/* 284 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentsService = void 0;
const base_service_1 = __webpack_require__(31);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const users_service_1 = __webpack_require__(30);
const document_entity_1 = __webpack_require__(48);
let DocumentsService = class DocumentsService extends base_service_1.BaseService {
    constructor(documentsRepository, usersService) {
        super(documentsRepository, usersService);
        this.documentsRepository = documentsRepository;
        this.usersService = usersService;
    }
};
exports.DocumentsService = DocumentsService;
exports.DocumentsService = DocumentsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(document_entity_1.Document)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], DocumentsService);


/***/ }),
/* 285 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDocumentDto = exports.UpdateDocumentDto = exports.DocumentDto = void 0;
const base_dto_1 = __webpack_require__(101);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class DocumentDto extends base_dto_1.BaseDto {
}
exports.DocumentDto = DocumentDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the document', example: 'Contract.pdf' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DocumentDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Description of the document', required: false, example: 'Legal contract document' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DocumentDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'File key for storage reference', example: 'documents/contract.pdf' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DocumentDto.prototype, "fileKey", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Size of the document in bytes', example: 102400 }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], DocumentDto.prototype, "size", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'MIME type of the document', example: 'application/pdf' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DocumentDto.prototype, "mimeType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User ID associated with the document', required: false, example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], DocumentDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Document type ID', example: '123e4567-e89b-12d3-a456-426614174000' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], DocumentDto.prototype, "documentTypeId", void 0);
class UpdateDocumentDto extends (0, swagger_1.PartialType)(DocumentDto) {
}
exports.UpdateDocumentDto = UpdateDocumentDto;
class GetDocumentDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateDocumentDto, 'document') {
}
exports.GetDocumentDto = GetDocumentDto;


/***/ }),
/* 286 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilesModule = void 0;
const common_1 = __webpack_require__(5);
const file_provider_config_1 = __webpack_require__(287);
const files_controller_1 = __webpack_require__(296);
let FilesModule = class FilesModule {
};
exports.FilesModule = FilesModule;
exports.FilesModule = FilesModule = __decorate([
    (0, common_1.Module)({
        providers: [...file_provider_config_1.fileProviders],
        controllers: [files_controller_1.FilesController],
    })
], FilesModule);


/***/ }),
/* 287 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fileProviders = exports.fileProviderConfig = exports.FILE_SERVICE = void 0;
const config_1 = __webpack_require__(6);
const local_file_service_1 = __webpack_require__(288);
exports.FILE_SERVICE = 'FILE_SERVICE';
exports.fileProviderConfig = {
    provide: exports.FILE_SERVICE,
    useFactory: (configService) => {
        // Read provider from options or config
        const fileProvider = configService.get('FILE_PROVIDER') ||
            'local';
        // Select the appropriate implementation based on provider
        switch (fileProvider.toLowerCase()) {
            case 'cloudflare':
                // return new CloudflareFileService(configService);
                throw new Error('Cloudflare provider not implemented yet');
            case 's3':
                // return new S3FileService(configService);
                throw new Error('S3 provider not implemented yet');
            case 'local':
            default:
                return new local_file_service_1.LocalFileService(configService);
        }
    },
    inject: [config_1.ConfigService],
};
exports.fileProviders = [exports.fileProviderConfig, local_file_service_1.LocalFileService];


/***/ }),
/* 288 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalFileService = void 0;
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const fs = __importStar(__webpack_require__(125));
const fs_1 = __webpack_require__(125);
const mime = __importStar(__webpack_require__(289));
const path_1 = __importDefault(__webpack_require__(127));
const file_list_options_dto_1 = __webpack_require__(290);
const base_file_service_1 = __webpack_require__(291);
let LocalFileService = class LocalFileService extends base_file_service_1.BaseFileService {
    constructor(configService) {
        const uploadDir = configService.getOrThrow('FILE_DIRECTORY');
        const baseUrl = configService.getOrThrow('FILE_BASE_URL');
        super(uploadDir, baseUrl);
        this.configService = configService;
        this.chunkUploads = new Map();
        this.uploadDir = uploadDir; // Keep for backward compatibility
        this.baseUrl = baseUrl; // Keep for backward compatibility
        this.tempDir = path_1.default.join(this.uploadDir, 'temp');
        // Ensure upload directories exist
        if (!fs.existsSync(this.uploadDir)) {
            fs.mkdirSync(this.uploadDir, { recursive: true });
        }
        // Ensure temp directory exists
        if (!fs.existsSync(this.tempDir)) {
            fs.mkdirSync(this.tempDir, { recursive: true });
        }
        // Create a dir for tracking upload metadata
        this.metadataDir = path_1.default.join(this.uploadDir, 'metadata');
        if (!fs.existsSync(this.metadataDir)) {
            fs.mkdirSync(this.metadataDir, { recursive: true });
        }
    }
    // Replace chunkUploads in-memory map with file-based storage
    async initiateChunkedUpload(fileInfo) {
        try {
            const uploadId = crypto.randomUUID();
            // Store metadata in a file instead of memory
            const metadataPath = path_1.default.join(this.metadataDir, `${uploadId}.json`);
            await fs_1.promises.writeFile(metadataPath, JSON.stringify({
                info: fileInfo,
                chunks: [],
                chunkPaths: Array(fileInfo.totalChunks).fill(''),
                createdAt: new Date().toISOString()
            }));
            this.logger.log(`Initiated chunked upload ${uploadId} for ${fileInfo.filename}`);
            return uploadId;
        }
        catch (error) {
            throw error;
        }
    }
    // Update getChunkUploadData helper
    async getChunkUploadData(uploadId) {
        const metadataPath = path_1.default.join(this.metadataDir, `${uploadId}.json`);
        if (!fs.existsSync(metadataPath)) {
            throw new Error(`Upload with ID ${uploadId} not found`);
        }
        const data = JSON.parse(await fs_1.promises.readFile(metadataPath, 'utf8'));
        // Convert chunks array back to Set for backwards compatibility
        data.chunks = new Set(data.chunks);
        return data;
    }
    // Update saveChunkUploadData helper
    async saveChunkUploadData(uploadId, data) {
        const metadataPath = path_1.default.join(this.metadataDir, `${uploadId}.json`);
        // Convert Set back to array for storage
        const toSave = Object.assign(Object.assign({}, data), { chunks: Array.from(data.chunks) });
        await fs_1.promises.writeFile(metadataPath, JSON.stringify(toSave));
    }
    async uploadChunk(uploadId, chunkNumber, chunk) {
        try {
            // Get upload tracking data
            const uploadData = this.chunkUploads.get(uploadId);
            if (!uploadData) {
                throw new Error(`Upload with ID ${uploadId} not found`);
            }
            // Validate chunk number
            if (chunkNumber < 0 || chunkNumber >= uploadData.info.totalChunks) {
                throw new Error(`Invalid chunk number ${chunkNumber}. Must be between 0 and ${uploadData.info.totalChunks - 1}`);
            }
            // Create a temporary file for this chunk
            const chunkFileName = `${uploadId}_chunk_${chunkNumber}`;
            const chunkPath = path_1.default.join(this.tempDir, chunkFileName);
            // Write the chunk to disk
            await fs_1.promises.writeFile(chunkPath, chunk);
            // Update tracking data
            uploadData.chunks.add(chunkNumber);
            uploadData.chunkPaths[chunkNumber] = chunkPath;
            // Prepare result
            const result = {
                uploadId,
                chunkNumber,
                receivedSize: chunk.length,
                totalChunksReceived: uploadData.chunks.size,
                completed: uploadData.chunks.size === uploadData.info.totalChunks
            };
            this.logger.log(`Received chunk ${chunkNumber} for upload ${uploadId} (${uploadData.chunks.size}/${uploadData.info.totalChunks})`);
            return result;
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error uploading chunk: ${err.message}`, err.stack);
            throw error;
        }
    }
    async completeChunkedUpload(uploadId) {
        try {
            // Get upload tracking data
            const uploadData = this.chunkUploads.get(uploadId);
            if (!uploadData) {
                throw new Error(`Upload with ID ${uploadId} not found`);
            }
            // Verify all chunks have been received
            if (uploadData.chunks.size !== uploadData.info.totalChunks) {
                throw new Error(`Cannot complete upload: received ${uploadData.chunks.size} of ${uploadData.info.totalChunks} chunks`);
            }
            // Create target directory if needed
            const folder = uploadData.info.folder || '';
            const targetDir = path_1.default.join(this.uploadDir, folder);
            if (folder && !fs.existsSync(targetDir)) {
                fs.mkdirSync(targetDir, { recursive: true });
            }
            // Generate final filename and path
            const fileName = this.generateUniqueFileName(uploadData.info.filename);
            const finalPath = path_1.default.join(targetDir, fileName);
            const fileKey = folder ? `${folder}/${fileName}` : fileName;
            // Combine chunks into the final file
            const writeStream = fs.createWriteStream(finalPath);
            // Process chunks in order
            for (let i = 0; i < uploadData.info.totalChunks; i++) {
                const chunkPath = uploadData.chunkPaths[i];
                if (!chunkPath) {
                    throw new Error(`Missing chunk ${i} for upload ${uploadId}`);
                }
                // Read chunk and append to final file
                const chunkData = await fs_1.promises.readFile(chunkPath);
                writeStream.write(chunkData);
                // Delete temporary chunk file
                await fs_1.promises.unlink(chunkPath).catch(err => this.logger.warn(`Failed to delete chunk file: ${err.message}`));
            }
            // Close the write stream
            await new Promise((resolve, reject) => {
                writeStream.on('finish', resolve);
                writeStream.on('error', reject);
                writeStream.end();
            });
            // Get file stats
            const stats = await fs_1.promises.stat(finalPath);
            // Create metadata
            const metadata = {
                key: fileKey,
                originalName: uploadData.info.filename,
                size: stats.size,
                mimeType: uploadData.info.mimeType,
                url: `${this.baseUrl}/${fileKey}`,
                createdAt: stats.birthtime,
                lastModified: stats.mtime,
                metadata: uploadData.info.metadata
            };
            // Clean up upload tracking data
            this.chunkUploads.delete(uploadId);
            this.logger.log(`Completed chunked upload ${uploadId}, created file ${fileKey}`);
            return metadata;
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error completing chunked upload: ${err.message}`, err.stack);
            // Try to clean up any temporary files if possible
            try {
                const uploadData = this.chunkUploads.get(uploadId);
                if (uploadData) {
                    for (const chunkPath of uploadData.chunkPaths) {
                        if (chunkPath && fs.existsSync(chunkPath)) {
                            await fs_1.promises.unlink(chunkPath).catch(() => { });
                        }
                    }
                }
            }
            catch (_a) { }
            throw error;
        }
    }
    async uploadFile(file, options) {
        const folder = (options === null || options === void 0 ? void 0 : options.folder) || '';
        const finalDir = path_1.default.join(this.uploadDir, folder);
        // Create folder if it doesn't exist
        if (folder && !fs.existsSync(finalDir)) {
            fs.mkdirSync(finalDir, { recursive: true });
        }
        const fileName = this.generateUniqueFileName(file.originalname);
        const filePath = path_1.default.join(finalDir, fileName);
        const fileKey = folder ? `${folder}/${fileName}` : fileName;
        // Write file
        await fs_1.promises.writeFile(filePath, file.buffer);
        // Get file stats
        const stats = await fs_1.promises.stat(filePath);
        const url = await this.getFileUrl(fileKey, options === null || options === void 0 ? void 0 : options.token);
        const metadata = {
            key: fileKey,
            originalName: file.originalname,
            size: file.size,
            mimeType: file.mimetype,
            url,
            createdAt: stats.birthtime,
            lastModified: stats.mtime,
            encoding: file.encoding,
            metadata: options === null || options === void 0 ? void 0 : options.metadata,
        };
        return metadata;
    }
    async uploadFiles(files, options) {
        const results = [];
        for (const file of files) {
            const result = await this.uploadFile(file, options);
            results.push(result);
        }
        return results;
    }
    async getFileMetadata(fileKey, authorization) {
        const filePath = path_1.default.join(this.uploadDir, fileKey);
        if (!fs.existsSync(filePath)) {
            throw new Error(`File ${fileKey} not found`);
        }
        const stats = await fs_1.promises.stat(filePath);
        const mimeType = mime.lookup(filePath) || 'application/octet-stream';
        const originalName = path_1.default.basename(fileKey);
        const url = await this.getFileUrl(fileKey, authorization);
        return {
            key: fileKey,
            originalName,
            size: stats.size,
            mimeType,
            url,
            createdAt: stats.birthtime,
            lastModified: stats.mtime,
        };
    }
    async deleteFile(fileKey) {
        const filePath = path_1.default.join(this.uploadDir, fileKey);
        if (!fs.existsSync(filePath)) {
            return false;
        }
        await fs_1.promises.unlink(filePath);
        return true;
    }
    async fileExists(fileKey) {
        try {
            const filePath = path_1.default.join(this.uploadDir, fileKey);
            return fs.existsSync(filePath);
        }
        catch (error) {
            return false;
        }
    }
    async listFiles(options, authorization) {
        try {
            // Set default options
            const opts = Object.assign({ limit: 100, includeDirs: true, recursive: false, sortDirection: 'asc' }, options);
            // Resolve base directory
            const baseDir = opts.prefix
                ? path_1.default.join(this.uploadDir, opts.prefix)
                : this.uploadDir;
            // Check if directory exists
            if (!fs.existsSync(baseDir)) {
                return {
                    files: [],
                    directories: [],
                    count: 0,
                    prefix: opts.prefix,
                    hasMore: false,
                    totalSize: 0,
                };
            }
            // Initialize result containers
            const files = [];
            const directories = [];
            let totalSize = 0;
            // Helper function to check if file matches filters
            const matchesFilters = async (filePath, stats) => {
                // Extension filter
                if (opts.extensions) {
                    const fileExt = path_1.default.extname(filePath).toLowerCase().replace('.', '');
                    const allowedExts = opts.extensions.split(',').map(e => e.trim().toLowerCase());
                    if (!allowedExts.includes(fileExt))
                        return false;
                }
                // Size filter
                if (opts.size) {
                    if (opts.size.min !== undefined && stats.size < opts.size.min)
                        return false;
                    if (opts.size.max !== undefined && stats.size > opts.size.max)
                        return false;
                }
                // Create date filter
                if (opts.createdAt) {
                    const createTime = stats.birthtime.getTime();
                    if (opts.createdAt.from && createTime < new Date(opts.createdAt.from).getTime())
                        return false;
                    if (opts.createdAt.to && createTime > new Date(opts.createdAt.to).getTime())
                        return false;
                }
                // Modified date filter
                if (opts.modifiedAt) {
                    const modTime = stats.mtime.getTime();
                    if (opts.modifiedAt.from && modTime < new Date(opts.modifiedAt.from).getTime())
                        return false;
                    if (opts.modifiedAt.to && modTime > new Date(opts.modifiedAt.to).getTime())
                        return false;
                }
                // MIME type filter
                if (opts.mimeType) {
                    const fileMime = mime.lookup(filePath) || 'application/octet-stream';
                    if (!fileMime.includes(opts.mimeType))
                        return false;
                }
                // Text search filter
                if (opts.searchTerm) {
                    const fileName = path_1.default.basename(filePath).toLowerCase();
                    if (!fileName.includes(opts.searchTerm.toLowerCase()))
                        return false;
                }
                return true;
            };
            // Function to process directory content
            const processDirectory = async (dirPath, relPath = '') => {
                const items = await fs_1.promises.readdir(dirPath);
                // Process directories first
                if (opts.includeDirs) {
                    for (const item of items) {
                        const itemPath = path_1.default.join(dirPath, item);
                        const stats = await fs_1.promises.stat(itemPath);
                        if (stats.isDirectory()) {
                            const dirRelPath = relPath ? `${relPath}/${item}` : item;
                            const dirKey = opts.prefix ? `${opts.prefix}/${dirRelPath}` : dirRelPath;
                            // Skip if this is the root of a recursive search
                            if (dirPath === baseDir) {
                                // Calculate directory size and item count (can be expensive for large dirs)
                                let dirSize = 0;
                                let itemCount = 0;
                                try {
                                    const dirItems = await fs_1.promises.readdir(itemPath);
                                    itemCount = dirItems.length;
                                    // Optionally calculate directory size
                                    // This can be expensive, so we might want to make it optional
                                    if (opts.includeSizes) {
                                        dirSize = await this.calculateDirectorySize(itemPath);
                                    }
                                }
                                catch (err) {
                                    const error = err;
                                    this.logger.warn(`Error reading directory ${dirKey}: ${error.message}`);
                                }
                                directories.push({
                                    key: dirKey,
                                    name: item,
                                    createdAt: stats.birthtime,
                                    lastModified: stats.mtime,
                                    itemCount,
                                    size: dirSize
                                });
                            }
                            // If recursive, process subdirectories
                            if (opts.recursive) {
                                await processDirectory(itemPath, dirRelPath);
                            }
                        }
                    }
                }
                // Process files
                for (const item of items) {
                    const itemPath = path_1.default.join(dirPath, item);
                    const stats = await fs_1.promises.stat(itemPath);
                    if (stats.isFile()) {
                        const fileRelPath = relPath ? `${relPath}/${item}` : item;
                        const fileKey = opts.prefix ? `${opts.prefix}/${fileRelPath}` : fileRelPath;
                        // Apply filters
                        if (await matchesFilters(itemPath, stats)) {
                            totalSize += stats.size;
                            files.push({
                                key: fileKey,
                                originalName: item,
                                size: stats.size,
                                mimeType: mime.lookup(itemPath) || 'application/octet-stream',
                                url: opts.includeUrls ? await this.getFileUrl(fileKey) : undefined,
                                createdAt: stats.birthtime,
                                lastModified: stats.mtime,
                            });
                        }
                    }
                }
            };
            // Process main directory and all subdirectories if recursive
            await processDirectory(baseDir);
            // Generate breadcrumbs
            const breadcrumbs = [];
            if (opts.prefix) {
                const segments = opts.prefix.split('/');
                let currentPath = '';
                breadcrumbs.push({ name: 'Home', path: '' });
                for (let i = 0; i < segments.length; i++) {
                    currentPath = currentPath ? `${currentPath}/${segments[i]}` : segments[i];
                    breadcrumbs.push({
                        name: segments[i],
                        path: currentPath
                    });
                }
            }
            // Calculate parent directory
            let parentDir = undefined;
            if (opts.prefix) {
                const segments = opts.prefix.split('/');
                segments.pop();
                parentDir = segments.join('/');
            }
            // Apply sorting
            const sortItems = (a, b) => {
                var _a, _b, _c, _d, _e, _f;
                const direction = opts.sortDirection === file_list_options_dto_1.SortDirection.DESC ? -1 : 1;
                switch (opts.sortBy) {
                    case file_list_options_dto_1.FileSortField.NAME:
                        return ((_a = a.originalName) === null || _a === void 0 ? void 0 : _a.localeCompare(b.originalName || b.name)) * direction;
                    case file_list_options_dto_1.FileSortField.SIZE:
                        return ((a.size || 0) - (b.size || 0)) * direction;
                    case file_list_options_dto_1.FileSortField.DATE_CREATED:
                        return (((_b = a.createdAt) === null || _b === void 0 ? void 0 : _b.getTime()) - ((_c = b.createdAt) === null || _c === void 0 ? void 0 : _c.getTime())) * direction;
                    case file_list_options_dto_1.FileSortField.DATE_MODIFIED:
                        return (((_d = a.lastModified) === null || _d === void 0 ? void 0 : _d.getTime()) - ((_e = b.lastModified) === null || _e === void 0 ? void 0 : _e.getTime())) * direction;
                    case file_list_options_dto_1.FileSortField.TYPE:
                        const aType = a.mimeType || '';
                        const bType = b.mimeType || '';
                        return aType.localeCompare(bType) * direction;
                    default:
                        return ((_f = a.originalName) === null || _f === void 0 ? void 0 : _f.localeCompare(b.originalName || b.name)) * direction;
                }
            };
            // Sort files and directories
            files.sort(sortItems);
            directories.sort(sortItems);
            // Apply pagination
            let hasMore = false;
            let nextMarker = undefined;
            // Calculate actual limit considering marker-based pagination
            let startIdx = 0;
            const combinedItems = [...directories, ...files];
            if (opts.marker) {
                // Find the index after the marker
                startIdx = combinedItems.findIndex(item => (item.key || '') === opts.marker) + 1;
                if (startIdx <= 0)
                    startIdx = 0;
            }
            // Slice the results based on pagination
            const endIdx = opts.limit ? startIdx + opts.limit : combinedItems.length;
            const paginatedItems = combinedItems.slice(startIdx, endIdx);
            // Calculate if there are more results and next marker
            hasMore = endIdx < combinedItems.length;
            if (hasMore && paginatedItems.length > 0) {
                nextMarker = paginatedItems[paginatedItems.length - 1].key;
            }
            // Separate files and directories again
            const paginatedFiles = paginatedItems
                .filter(item => 'originalName' in item);
            const paginatedDirs = paginatedItems
                .filter(item => !('originalName' in item));
            return {
                files: paginatedFiles,
                directories: opts.includeDirs ? paginatedDirs : undefined,
                count: paginatedFiles.length + ((paginatedDirs === null || paginatedDirs === void 0 ? void 0 : paginatedDirs.length) || 0),
                prefix: opts.prefix,
                hasMore,
                nextMarker,
                totalSize,
                parentDir,
                breadcrumbs: breadcrumbs.length > 0 ? breadcrumbs : undefined
            };
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error listing files: ${err.message}`, err.stack);
            throw error;
        }
    }
    // Helper method to calculate directory size
    async calculateDirectorySize(dirPath) {
        let totalSize = 0;
        const items = await fs_1.promises.readdir(dirPath);
        for (const item of items) {
            const itemPath = path_1.default.join(dirPath, item);
            const stats = await fs_1.promises.stat(itemPath);
            if (stats.isFile()) {
                totalSize += stats.size;
            }
            else if (stats.isDirectory()) {
                totalSize += await this.calculateDirectorySize(itemPath);
            }
        }
        return totalSize;
    }
    async createDirectory(dirPath) {
        try {
            const fullPath = path_1.default.join(this.uploadDir, dirPath);
            if (fs.existsSync(fullPath)) {
                throw new Error(`Directory ${dirPath} already exists`);
            }
            await fs_1.promises.mkdir(fullPath, { recursive: true });
            const stats = await fs_1.promises.stat(fullPath);
            return {
                key: dirPath,
                name: path_1.default.basename(dirPath),
                createdAt: stats.birthtime,
                lastModified: stats.mtime,
                itemCount: 0,
                size: 0
            };
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error creating directory: ${err.message}`, err.stack);
            throw error;
        }
    }
    async deleteDirectory(dirPath, recursive = false) {
        try {
            const fullPath = path_1.default.join(this.uploadDir, dirPath);
            if (!fs.existsSync(fullPath)) {
                return false;
            }
            const stats = await fs_1.promises.stat(fullPath);
            if (!stats.isDirectory()) {
                throw new Error(`Path ${dirPath} is not a directory`);
            }
            // Check if directory is empty
            const items = await fs_1.promises.readdir(fullPath);
            if (items.length > 0 && !recursive) {
                throw new Error(`Directory ${dirPath} is not empty. Use recursive=true to delete anyway.`);
            }
            await fs_1.promises.rm(fullPath, { recursive, force: true });
            return true;
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error deleting directory: ${err.message}`, err.stack);
            throw error;
        }
    }
    async renameDirectory(oldPath, newPath) {
        try {
            const oldFullPath = path_1.default.join(this.uploadDir, oldPath);
            const newFullPath = path_1.default.join(this.uploadDir, newPath);
            if (!fs.existsSync(oldFullPath)) {
                throw new Error(`Directory ${oldPath} does not exist`);
            }
            if (fs.existsSync(newFullPath)) {
                throw new Error(`Target directory ${newPath} already exists`);
            }
            const stats = await fs_1.promises.stat(oldFullPath);
            if (!stats.isDirectory()) {
                throw new Error(`Path ${oldPath} is not a directory`);
            }
            await fs_1.promises.rename(oldFullPath, newFullPath);
            const newStats = await fs_1.promises.stat(newFullPath);
            const items = await fs_1.promises.readdir(newFullPath);
            return {
                key: newPath,
                name: path_1.default.basename(newPath),
                createdAt: newStats.birthtime,
                lastModified: newStats.mtime,
                itemCount: items.length,
                size: await this.calculateDirectorySize(newFullPath)
            };
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error renaming directory: ${err.message}`, err.stack);
            throw error;
        }
    }
    async getFileStream(fileKey) {
        const filePath = path_1.default.join(this.uploadDir, fileKey);
        if (!fs.existsSync(filePath)) {
            throw new Error(`File ${fileKey} not found`);
        }
        return fs.createReadStream(filePath);
    }
    async getFileBuffer(fileKey) {
        const filePath = path_1.default.join(this.uploadDir, fileKey);
        if (!fs.existsSync(filePath)) {
            throw new Error(`File ${fileKey} not found`);
        }
        return fs_1.promises.readFile(filePath);
    }
    async getFileUrl(fileKey, authorization) {
        // Local storage doesn't support presigned URLs with expiration
        // Just return a direct URL
        const encodedFileKey = encodeURIComponent(fileKey);
        const token = (authorization === null || authorization === void 0 ? void 0 : authorization.replace(/^Bearer\s+/i, '')) || '';
        return `${this.baseUrl}/${encodedFileKey}?token=${token}`;
    }
    async getContentType(fileKey) {
        const filePath = path_1.default.join(this.uploadDir, fileKey);
        return mime.lookup(filePath) || 'application/octet-stream';
    }
};
exports.LocalFileService = LocalFileService;
exports.LocalFileService = LocalFileService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], LocalFileService);


/***/ }),
/* 289 */
/***/ ((module) => {

"use strict";
module.exports = require("mime-types");

/***/ }),
/* 290 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileListOptions = exports.SizeRangeFilter = exports.DateRangeFilter = exports.SortDirection = exports.FileSortField = void 0;
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
var FileSortField;
(function (FileSortField) {
    FileSortField["NAME"] = "name";
    FileSortField["SIZE"] = "size";
    FileSortField["DATE_CREATED"] = "createdAt";
    FileSortField["DATE_MODIFIED"] = "lastModified";
    FileSortField["TYPE"] = "mimeType";
})(FileSortField || (exports.FileSortField = FileSortField = {}));
var SortDirection;
(function (SortDirection) {
    SortDirection["ASC"] = "asc";
    SortDirection["DESC"] = "desc";
})(SortDirection || (exports.SortDirection = SortDirection = {}));
class DateRangeFilter {
}
exports.DateRangeFilter = DateRangeFilter;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Start date for range filter' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], DateRangeFilter.prototype, "from", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'End date for range filter' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], DateRangeFilter.prototype, "to", void 0);
class SizeRangeFilter {
}
exports.SizeRangeFilter = SizeRangeFilter;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Minimum file size in bytes' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], SizeRangeFilter.prototype, "min", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Maximum file size in bytes' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], SizeRangeFilter.prototype, "max", void 0);
class FileListOptions {
    constructor() {
        this.includeDirs = true;
        this.includeSizes = true;
        this.recursive = false;
        this.sortDirection = SortDirection.ASC;
    }
}
exports.FileListOptions = FileListOptions;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Directory path to list files from' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FileListOptions.prototype, "prefix", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Maximum number of items to return' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_transformer_1.Type)(() => Number),
    __metadata("design:type", Number)
], FileListOptions.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Pagination marker/cursor' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FileListOptions.prototype, "marker", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether to include file URLs in response' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    (0, class_transformer_1.Type)(() => Boolean),
    __metadata("design:type", Boolean)
], FileListOptions.prototype, "includeUrls", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether to include directories in results' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    (0, class_transformer_1.Type)(() => Boolean),
    __metadata("design:type", Boolean)
], FileListOptions.prototype, "includeDirs", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether to include file sizes in response' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    (0, class_transformer_1.Type)(() => Boolean),
    __metadata("design:type", Boolean)
], FileListOptions.prototype, "includeSizes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether to recursively traverse directories' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    (0, class_transformer_1.Type)(() => Boolean),
    __metadata("design:type", Boolean)
], FileListOptions.prototype, "recursive", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        enum: FileSortField,
        description: 'Field to sort by'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(FileSortField),
    __metadata("design:type", String)
], FileListOptions.prototype, "sortBy", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        enum: SortDirection,
        description: 'Sort direction'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(SortDirection),
    __metadata("design:type", String)
], FileListOptions.prototype, "sortDirection", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Search term for filename' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FileListOptions.prototype, "searchTerm", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'File extensions to filter by (comma-separated)' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FileListOptions.prototype, "extensions", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by file size' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => SizeRangeFilter),
    __metadata("design:type", SizeRangeFilter)
], FileListOptions.prototype, "size", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by creation date' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => DateRangeFilter),
    __metadata("design:type", DateRangeFilter)
], FileListOptions.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by modification date' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => DateRangeFilter),
    __metadata("design:type", DateRangeFilter)
], FileListOptions.prototype, "modifiedAt", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by MIME type' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FileListOptions.prototype, "mimeType", void 0);


/***/ }),
/* 291 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseFileService = void 0;
const common_1 = __webpack_require__(5);
const crypto = __importStar(__webpack_require__(292));
const csv_writer_1 = __webpack_require__(293);
const ExcelJS = __importStar(__webpack_require__(294));
const fs = __importStar(__webpack_require__(125));
const path = __importStar(__webpack_require__(127));
const pdfkit_1 = __importDefault(__webpack_require__(295));
let BaseFileService = class BaseFileService {
    constructor(uploadDir, baseUrl) {
        this.logger = new common_1.Logger(this.constructor.name);
        this.uploadDir = uploadDir || '';
        this.baseUrl = baseUrl || '';
    }
    // Common implementable methods
    async streamFile(fileKey, res, inline = null) {
        var _a;
        try {
            // Check if file exists first to handle 404 gracefully
            if (!(await this.fileExists(fileKey))) {
                res.status(404).send('File not found');
                return;
            }
            const contentType = await this.getContentType(fileKey);
            const metadata = await this.getFileMetadata(fileKey);
            const filename = path.basename(fileKey);
            const fileSize = metadata.size;
            const filePath = path.join(this.uploadDir, fileKey);
            // Auto-detect if inline should be true based on content type if not explicitly set
            if (inline === null) {
                inline = contentType.startsWith('video/') ||
                    contentType.startsWith('audio/') ||
                    contentType === 'application/pdf' ||
                    contentType.startsWith('image/');
            }
            // Set common headers
            res.setHeader('Access-Control-Allow-Origin', '*');
            res.setHeader('Access-Control-Allow-Headers', 'Range');
            res.setHeader('Accept-Ranges', 'bytes');
            // Set cache control based on file type
            if (contentType.startsWith('image/')) {
                // Cache images longer
                res.setHeader('Cache-Control', 'public, max-age=86400, immutable');
            }
            else if (contentType.startsWith('video/') || contentType.startsWith('audio/')) {
                // Streaming media cache
                res.setHeader('Cache-Control', 'public, max-age=3600');
            }
            else {
                // Default cache for documents and other files
                res.setHeader('Cache-Control', 'public, max-age=3600, must-revalidate');
            }
            // Set content type and disposition
            res.setHeader('Content-Type', contentType);
            res.setHeader('Content-Disposition', `${inline ? 'inline' : 'attachment'}; filename="${encodeURIComponent(filename)}"`);
            // Get range header from request
            const range = res.req.headers.range;
            // Apply range requests for videos, audio, and large files
            const isRangeSupported = contentType.startsWith('video/') ||
                contentType.startsWith('audio/') ||
                contentType === 'application/pdf' ||
                fileSize > 10 * 1024 * 1024; // 10MB+
            // If no range header or range not supported for this file type, send entire file
            if (!range || !isRangeSupported) {
                res.setHeader('Content-Length', fileSize);
                const stream = await this.getFileStream(fileKey);
                return new Promise((resolve, reject) => {
                    stream.pipe(res)
                        .on('finish', () => resolve())
                        .on('error', (err) => {
                        this.logger.error(`Error streaming file: ${err.message}`, err.stack);
                        reject(err);
                    });
                });
            }
            // Handle range request
            const parts = range.replace(/bytes=/, '').split('-');
            const start = parseInt(parts[0], 10);
            const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
            // Validate range request
            if (isNaN(start) || isNaN(end) || start >= fileSize || end >= fileSize) {
                // Return 416 Range Not Satisfiable if range is invalid
                res.status(416);
                res.setHeader('Content-Range', `bytes */${fileSize}`);
                res.end();
                return;
            }
            const chunkSize = end - start + 1;
            // Set partial content headers
            res.status(206);
            res.setHeader('Content-Range', `bytes ${start}-${end}/${fileSize}`);
            res.setHeader('Content-Length', chunkSize);
            // Create read stream with range
            const stream = fs.createReadStream(filePath, { start, end });
            return new Promise((resolve, reject) => {
                stream.pipe(res)
                    .on('finish', () => resolve())
                    .on('error', (err) => {
                    this.logger.error(`Error streaming file range: ${err.message}`, err.stack);
                    reject(err);
                });
            });
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error streaming file: ${err.message}`, err.stack);
            // If headers haven't been sent yet, send appropriate error response
            if (!res.headersSent) {
                if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.includes('not found')) {
                    res.status(404).send('File not found');
                }
                else {
                    res.status(500).send('Error streaming file');
                }
            }
            else {
                // If headers were sent, just end the response
                res.end();
            }
            throw error;
        }
    }
    async downloadFile(fileKey, res) {
        try {
            return this.streamFile(fileKey, res, false);
        }
        catch (error) {
            const err = error;
            this.logger.error(`Error downloading file: ${err.message}`, err.stack);
            throw error;
        }
    }
    generateUniqueFileName(originalName) {
        const timestamp = Date.now();
        const randomString = crypto.randomBytes(8).toString('hex');
        const extension = path.extname(originalName);
        const sanitizedName = path.basename(originalName, extension)
            .replace(/[^a-zA-Z0-9]/g, '-')
            .substring(0, 40);
        return `${sanitizedName}-${timestamp}-${randomString}${extension}`;
    }
    async exportToCsv(data, options) {
        const columns = (options === null || options === void 0 ? void 0 : options.columns) || Object.keys(data[0] || {}).map(id => ({ id, title: id }));
        const csvStringifier = (0, csv_writer_1.createObjectCsvStringifier)({ header: columns });
        const headers = csvStringifier.getHeaderString();
        const records = csvStringifier.stringifyRecords(data);
        return Buffer.from(headers + records);
    }
    async exportToExcel(data, options) {
        var _a;
        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet((options === null || options === void 0 ? void 0 : options.sheetName) || 'Data');
        const columns = ((_a = options === null || options === void 0 ? void 0 : options.columns) === null || _a === void 0 ? void 0 : _a.map(col => ({
            header: col.title,
            key: col.id,
            width: 15
        }))) || Object.keys(data[0] || {}).map(id => ({
            header: id,
            key: id,
            width: 15
        }));
        worksheet.columns = columns;
        if (options === null || options === void 0 ? void 0 : options.headerStyle) {
            worksheet.getRow(1).font = options.headerStyle;
        }
        data.forEach(item => {
            worksheet.addRow(item);
        });
        return await workbook.xlsx.writeBuffer();
    }
    async exportToPdf(data, options) {
        return new Promise((resolve) => {
            const buffers = [];
            const doc = new pdfkit_1.default({
                margin: 50,
                size: 'A4',
                layout: (options === null || options === void 0 ? void 0 : options.orientation) || 'portrait'
            });
            doc.on('data', buffers.push.bind(buffers));
            doc.on('end', () => {
                resolve(Buffer.concat(buffers));
            });
            // Add title
            doc.fontSize(16).text((options === null || options === void 0 ? void 0 : options.filename) || 'Data Export', {
                align: 'center'
            });
            doc.moveDown();
            // Create a simple table
            const columns = (options === null || options === void 0 ? void 0 : options.columns) || Object.keys(data[0] || {}).map(id => ({ id, title: id }));
            const tableTop = 150;
            const tableLeft = 50;
            let rowTop = tableTop;
            // Draw header
            doc.fontSize(12);
            columns.forEach((column, i) => {
                const leftPos = tableLeft + (i * 100);
                doc.font('Helvetica-Bold').text(column.title, leftPos, rowTop);
            });
            // Draw rows
            rowTop += 20;
            data.forEach(row => {
                columns.forEach((column, i) => {
                    const leftPos = tableLeft + (i * 100);
                    doc.font('Helvetica').text(String(row[column.id] || ''), leftPos, rowTop);
                });
                rowTop += 20;
                // Add new page if needed
                if (rowTop > 700) {
                    doc.addPage();
                    rowTop = 50;
                }
            });
            doc.end();
        });
    }
    /**
     * Validates file against size and type constraints
     * Utility method for implementations to use during upload operations
     */
    validateFile(file, options) {
        // Check file size if max size specified
        if ((options === null || options === void 0 ? void 0 : options.maxSizeBytes) && file.size > options.maxSizeBytes) {
            throw new Error(`File size exceeds the limit of ${options.maxSizeBytes} bytes`);
        }
        // Check file type if allowed types specified
        if ((options === null || options === void 0 ? void 0 : options.allowedTypes) && options.allowedTypes.length > 0) {
            const mimeType = options.contentType || file.mimetype;
            if (!options.allowedTypes.includes(mimeType)) {
                throw new Error(`File type ${mimeType} not allowed`);
            }
        }
        return true;
    }
};
exports.BaseFileService = BaseFileService;
exports.BaseFileService = BaseFileService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [String, String])
], BaseFileService);


/***/ }),
/* 292 */
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),
/* 293 */
/***/ ((module) => {

"use strict";
module.exports = require("csv-writer");

/***/ }),
/* 294 */
/***/ ((module) => {

"use strict";
module.exports = require("exceljs");

/***/ }),
/* 295 */
/***/ ((module) => {

"use strict";
module.exports = require("pdfkit");

/***/ }),
/* 296 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var FilesController_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilesController = void 0;
const authorize_decorator_1 = __webpack_require__(26);
const current_user_decorator_1 = __webpack_require__(97);
const common_1 = __webpack_require__(5);
const platform_express_1 = __webpack_require__(297);
const swagger_1 = __webpack_require__(8);
const express_1 = __webpack_require__(205);
const file_provider_config_1 = __webpack_require__(287);
const directory_metadata_dto_1 = __webpack_require__(298);
const file_list_response_dto_1 = __webpack_require__(299);
const file_meta_data_dto_1 = __webpack_require__(300);
const file_service_interface_1 = __webpack_require__(301);
let FilesController = FilesController_1 = class FilesController {
    constructor(fileService) {
        this.fileService = fileService;
        this.logger = new common_1.Logger(FilesController_1.name);
    }
    async uploadFile(file, req, folder, userId) {
        if (!file) {
            throw new common_1.BadRequestException('No file provided');
        }
        try {
            const authorization = req.headers.authorization;
            this.logger.debug(`Authorization header: ${authorization}`);
            return await this.fileService.uploadFile(file, {
                folder,
                token: authorization,
                metadata: { uploadedBy: userId || 'anonymous' }
            });
        }
        catch (error) {
            if (error instanceof Error) {
                throw new common_1.BadRequestException(`File upload failed: ${error.message}`);
            }
            throw new common_1.BadRequestException('File upload failed');
        }
    }
    async uploadMultiple(files, req, folder, userId) {
        if (!files || files.length === 0) {
            throw new common_1.BadRequestException('No files provided');
        }
        try {
            const authorization = req.headers.authorization;
            return await this.fileService.uploadFiles(files, {
                folder,
                token: authorization,
                metadata: { uploadedBy: userId || 'anonymous' }
            });
        }
        catch (error) {
            if (error instanceof Error) {
                throw new common_1.BadRequestException(`Files upload failed: ${error.message}`);
            }
            throw new common_1.BadRequestException('Files upload failed');
        }
    }
    async getFileMetadata(key, request) {
        try {
            const authorization = request.headers.authorization;
            return await this.fileService.getFileMetadata(key, authorization);
        }
        catch (error) {
            throw new common_1.NotFoundException(`File not found: ${key}`);
        }
    }
    async downloadFile(key, res) {
        try {
            await this.fileService.downloadFile(key, res);
        }
        catch (error) {
            throw new common_1.NotFoundException(`File not found: ${key}`);
        }
    }
    async streamFile(key, res) {
        try {
            // Check if file exists first before starting to stream
            if (!(await this.fileService.fileExists(key))) {
                res.status(404).send(`File not found: ${key}`);
                return;
            }
            // Stream the file - no try/catch here to prevent header modifications after streaming
            await this.fileService.streamFile(key, res, true);
        }
        catch (error) {
            // Only set status and send error if headers haven't been sent yet
            if (!res.headersSent) {
                res.status(500).send('Error streaming file');
            }
        }
    }
    async getFileUrl(key, req) {
        try {
            const authorization = req.headers.authorization;
            const url = await this.fileService.getFileUrl(key, authorization);
            return { url };
        }
        catch (error) {
            throw new common_1.NotFoundException(`File not found: ${key}`);
        }
    }
    async listFiles(req, prefix, limit, marker, includeUrls, includeDirs, includeSizes, recursive, sortBy, sortDirection, searchTerm, extensions) {
        var _a, _b;
        // Transform boolean strings to actual booleans
        const boolFromString = (val) => {
            if (val === 'true')
                return true;
            if (val === 'false')
                return false;
            return val === true;
        };
        const options = {
            prefix,
            limit: limit ? parseInt(String(limit), 10) : undefined,
            marker,
            includeUrls: boolFromString(includeUrls),
            includeDirs: includeDirs !== undefined ? boolFromString(includeDirs) : true,
            recursive: boolFromString(recursive),
            sortBy: sortBy,
            sortDirection: sortDirection || 'asc',
            searchTerm,
            extensions
        };
        try {
            const authorization = req.headers.authorization;
            const result = await this.fileService.listFiles(options, authorization);
            // If the result is already in the correct format, return it directly
            if ('directories' in result) {
                return result;
            }
            // Otherwise, build the response in the correct format
            // This is for backward compatibility with implementations that don't return directories
            return {
                files: Array.isArray(result) ? result : (result.files || []),
                directories: result.directories || [],
                count: Array.isArray(result) ? result.length : (result.count || ((_a = result.files) === null || _a === void 0 ? void 0 : _a.length) || 0),
                prefix: options.prefix,
                hasMore: Array.isArray(result)
                    ? result.length === options.limit
                    : (result.hasMore || (((_b = result.files) === null || _b === void 0 ? void 0 : _b.length) === options.limit)),
                nextMarker: result.nextMarker,
                totalSize: result.totalSize,
                parentDir: result.parentDir,
                breadcrumbs: result.breadcrumbs
            };
        }
        catch (error) {
            if (error instanceof Error) {
                throw new common_1.BadRequestException(`Failed to list files: ${error.message}`);
            }
            throw new common_1.BadRequestException('Failed to list files');
        }
    }
    async deleteFile(key) {
        const success = await this.fileService.deleteFile(key);
        return { success };
    }
    async fileExists(key) {
        const exists = await this.fileService.fileExists(key);
        return { exists };
    }
    async createDirectory(dirPath, userId) {
        if (!dirPath) {
            throw new common_1.BadRequestException('No directory path provided');
        }
        try {
            return await this.fileService.createDirectory(dirPath);
        }
        catch (error) {
            if (error instanceof Error) {
                throw new common_1.BadRequestException(`Directory creation failed: ${error.message}`);
            }
            throw new common_1.BadRequestException('Directory creation failed');
        }
    }
    async deleteDirectory(dirPath, recursive = false, userId) {
        try {
            const success = await this.fileService.deleteDirectory(dirPath, recursive);
            return { success };
        }
        catch (error) {
            if (error instanceof Error) {
                throw new common_1.BadRequestException(`Directory deletion failed: ${error.message}`);
            }
            throw new common_1.BadRequestException('Directory deletion failed');
        }
    }
    async renameDirectory(dirPath, newPath, userId) {
        if (!newPath) {
            throw new common_1.BadRequestException('No new path provided');
        }
        try {
            return await this.fileService.renameDirectory(dirPath, newPath);
        }
        catch (error) {
            if (error instanceof Error) {
                throw new common_1.BadRequestException(`Directory rename failed: ${error.message}`);
            }
            throw new common_1.BadRequestException('Directory rename failed');
        }
    }
};
exports.FilesController = FilesController;
__decorate([
    (0, common_1.Post)('upload'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Upload a single file' }),
    (0, swagger_1.ApiConsumes)('multipart/form-data'),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                file: {
                    type: 'string',
                    format: 'binary',
                    description: 'File to upload'
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'File uploaded successfully',
        type: file_meta_data_dto_1.FileMetadata
    }),
    (0, common_1.UseInterceptors)((0, platform_express_1.FileInterceptor)('file')),
    __param(0, (0, common_1.UploadedFile)()),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, common_1.Query)('folder')),
    __param(3, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof Express !== "undefined" && (_b = Express.Multer) !== void 0 && _b.File) === "function" ? _c : Object, typeof (_d = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _d : Object, String, String]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], FilesController.prototype, "uploadFile", null);
__decorate([
    (0, common_1.Post)('upload-multiple'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Upload multiple files' }),
    (0, swagger_1.ApiConsumes)('multipart/form-data'),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                files: {
                    type: 'array',
                    items: {
                        type: 'string',
                        format: 'binary'
                    },
                    description: 'Files to upload (max 10)'
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Files uploaded successfully',
        type: [file_meta_data_dto_1.FileMetadata]
    }),
    (0, common_1.UseInterceptors)((0, platform_express_1.FilesInterceptor)('files', 10)),
    __param(0, (0, common_1.UploadedFiles)()),
    __param(1, (0, common_1.Req)()),
    __param(2, (0, common_1.Query)('folder')),
    __param(3, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, typeof (_f = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _f : Object, String, String]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], FilesController.prototype, "uploadMultiple", null);
__decorate([
    (0, common_1.Get)('metadata/:key'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get file metadata' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'File key' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'File metadata retrieved successfully',
        type: file_meta_data_dto_1.FileMetadata
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'File not found' }),
    __param(0, (0, common_1.Param)('key')),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_h = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _h : Object]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], FilesController.prototype, "getFileMetadata", null);
__decorate([
    (0, common_1.Get)('download/:key'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Download a file' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'File key' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'File download' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'File not found' }),
    __param(0, (0, common_1.Param)('key')),
    __param(1, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_k = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _k : Object]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], FilesController.prototype, "downloadFile", null);
__decorate([
    (0, common_1.Get)('stream/:key'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Stream a file (for browser viewing)' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'File key' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'File stream' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'File not found' })
    // This properly disables all interceptors for this route
    ,
    (0, common_1.UseInterceptors)()
    // Important! Add this to bypass global interceptors
    ,
    (0, common_1.Version)(common_1.VERSION_NEUTRAL),
    __param(0, (0, common_1.Param)('key')),
    __param(1, (0, common_1.Res)({ passthrough: false })),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_m = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _m : Object]),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], FilesController.prototype, "streamFile", null);
__decorate([
    (0, common_1.Get)('url/:key'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get a temporary URL for a file with user current token' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'File key' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'File URL',
        schema: {
            type: 'object',
            properties: {
                url: { type: 'string' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('key')),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_p = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _p : Object]),
    __metadata("design:returntype", typeof (_q = typeof Promise !== "undefined" && Promise) === "function" ? _q : Object)
], FilesController.prototype, "getFileUrl", null);
__decorate([
    (0, common_1.Get)('list'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'List files and directories' }),
    (0, swagger_1.ApiQuery)({
        name: 'prefix',
        required: false,
        description: 'Directory path to list files from'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'limit',
        required: false,
        description: 'Maximum number of items to return'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'marker',
        required: false,
        description: 'Pagination marker/cursor for fetching next page'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'includeUrls',
        required: false,
        type: Boolean,
        description: 'Whether to include file URLs in response'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'includeDirs',
        required: false,
        type: Boolean,
        description: 'Whether to include directories in results'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'includeSizes',
        required: false,
        type: Boolean,
        description: 'Whether to include file sizes in response'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'recursive',
        required: false,
        type: Boolean,
        description: 'Whether to recursively list files in subdirectories'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'sortBy',
        required: false,
        enum: ['name', 'size', 'createdAt', 'lastModified', 'mimeType'],
        description: 'Field to sort by'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'sortDirection',
        required: false,
        enum: ['asc', 'desc'],
        description: 'Sort direction (asc or desc)'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'searchTerm',
        required: false,
        description: 'Filter files by filename search term'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'extensions',
        required: false,
        description: 'Filter by file extensions (comma-separated)'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Files and directories listed successfully',
        type: file_list_response_dto_1.FileListResponseDto
    }),
    __param(0, (0, common_1.Req)()),
    __param(1, (0, common_1.Query)('prefix')),
    __param(2, (0, common_1.Query)('limit')),
    __param(3, (0, common_1.Query)('marker')),
    __param(4, (0, common_1.Query)('includeUrls')),
    __param(5, (0, common_1.Query)('includeDirs')),
    __param(6, (0, common_1.Query)('includeSizes')),
    __param(7, (0, common_1.Query)('recursive')),
    __param(8, (0, common_1.Query)('sortBy')),
    __param(9, (0, common_1.Query)('sortDirection')),
    __param(10, (0, common_1.Query)('searchTerm')),
    __param(11, (0, common_1.Query)('extensions')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_r = typeof express_1.Request !== "undefined" && express_1.Request) === "function" ? _r : Object, String, Number, String, Boolean, Boolean, Boolean, Boolean, String, String, String, String]),
    __metadata("design:returntype", typeof (_s = typeof Promise !== "undefined" && Promise) === "function" ? _s : Object)
], FilesController.prototype, "listFiles", null);
__decorate([
    (0, common_1.Delete)(':key'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Delete a file' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'File key' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'File deleted successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_t = typeof Promise !== "undefined" && Promise) === "function" ? _t : Object)
], FilesController.prototype, "deleteFile", null);
__decorate([
    (0, common_1.Get)('validate/:key'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Check if a file exists' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'File key' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'File existence status',
        schema: {
            type: 'object',
            properties: {
                exists: { type: 'boolean' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_u = typeof Promise !== "undefined" && Promise) === "function" ? _u : Object)
], FilesController.prototype, "fileExists", null);
__decorate([
    (0, common_1.Post)('directories'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new directory' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                path: {
                    type: 'string',
                    description: 'Directory path to create'
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Directory created successfully',
        type: directory_metadata_dto_1.DirectoryMetadata
    }),
    __param(0, (0, common_1.Body)('path')),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_v = typeof Promise !== "undefined" && Promise) === "function" ? _v : Object)
], FilesController.prototype, "createDirectory", null);
__decorate([
    (0, common_1.Delete)('directories/:path(*)'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Delete a directory' }),
    (0, swagger_1.ApiParam)({ name: 'path', description: 'Directory path to delete' }),
    (0, swagger_1.ApiQuery)({
        name: 'recursive',
        required: false,
        description: 'Whether to recursively delete non-empty directories'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Directory deleted successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('path')),
    __param(1, (0, common_1.Query)('recursive')),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Boolean, String]),
    __metadata("design:returntype", typeof (_w = typeof Promise !== "undefined" && Promise) === "function" ? _w : Object)
], FilesController.prototype, "deleteDirectory", null);
__decorate([
    (0, common_1.Put)('directories/:path(*)'),
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Rename a directory' }),
    (0, swagger_1.ApiParam)({ name: 'path', description: 'Current directory path' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                newPath: {
                    type: 'string',
                    description: 'New directory path'
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Directory renamed successfully',
        type: directory_metadata_dto_1.DirectoryMetadata
    }),
    __param(0, (0, common_1.Param)('path')),
    __param(1, (0, common_1.Body)('newPath')),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", typeof (_x = typeof Promise !== "undefined" && Promise) === "function" ? _x : Object)
], FilesController.prototype, "renameDirectory", null);
exports.FilesController = FilesController = FilesController_1 = __decorate([
    (0, swagger_1.ApiTags)('Files'),
    (0, common_1.Controller)('files'),
    __param(0, (0, common_1.Inject)(file_provider_config_1.FILE_SERVICE)),
    __metadata("design:paramtypes", [typeof (_a = typeof file_service_interface_1.IFileService !== "undefined" && file_service_interface_1.IFileService) === "function" ? _a : Object])
], FilesController);


/***/ }),
/* 297 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/platform-express");

/***/ }),
/* 298 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirectoryMetadata = void 0;
const swagger_1 = __webpack_require__(8);
class DirectoryMetadata {
}
exports.DirectoryMetadata = DirectoryMetadata;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Directory path/key' }),
    __metadata("design:type", String)
], DirectoryMetadata.prototype, "key", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Directory name' }),
    __metadata("design:type", String)
], DirectoryMetadata.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Directory creation date' }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], DirectoryMetadata.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Last modified date' }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], DirectoryMetadata.prototype, "lastModified", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Item count in directory' }),
    __metadata("design:type", Number)
], DirectoryMetadata.prototype, "itemCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Total size of all files in directory' }),
    __metadata("design:type", Number)
], DirectoryMetadata.prototype, "size", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether this is a parent directory link' }),
    __metadata("design:type", Boolean)
], DirectoryMetadata.prototype, "isParent", void 0);


/***/ }),
/* 299 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileListResponseDto = void 0;
const swagger_1 = __webpack_require__(8);
const directory_metadata_dto_1 = __webpack_require__(298);
const file_meta_data_dto_1 = __webpack_require__(300);
class FileListResponseDto {
}
exports.FileListResponseDto = FileListResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({ type: [file_meta_data_dto_1.FileMetadata], description: 'List of files' }),
    __metadata("design:type", Array)
], FileListResponseDto.prototype, "files", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ type: [directory_metadata_dto_1.DirectoryMetadata], description: 'List of directories' }),
    __metadata("design:type", Array)
], FileListResponseDto.prototype, "directories", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total count of files in result' }),
    __metadata("design:type", Number)
], FileListResponseDto.prototype, "count", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Current directory/prefix' }),
    __metadata("design:type", String)
], FileListResponseDto.prototype, "prefix", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether there are more results available' }),
    __metadata("design:type", Boolean)
], FileListResponseDto.prototype, "hasMore", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Pagination marker for next page' }),
    __metadata("design:type", String)
], FileListResponseDto.prototype, "nextMarker", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Total size of all files in bytes' }),
    __metadata("design:type", Number)
], FileListResponseDto.prototype, "totalSize", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Parent directory path' }),
    __metadata("design:type", String)
], FileListResponseDto.prototype, "parentDir", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Breadcrumb navigation path segments' }),
    __metadata("design:type", typeof (_a = typeof Array !== "undefined" && Array) === "function" ? _a : Object)
], FileListResponseDto.prototype, "breadcrumbs", void 0);


/***/ }),
/* 300 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileMetadata = void 0;
class FileMetadata {
}
exports.FileMetadata = FileMetadata;


/***/ }),
/* 301 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),
/* 302 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsModule = void 0;
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const activity_logs_module_1 = __webpack_require__(303);
const system_logs_module_1 = __webpack_require__(306);
let LogsModule = class LogsModule {
};
exports.LogsModule = LogsModule;
exports.LogsModule = LogsModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            core_1.RouterModule.register([
                {
                    path: 'logs',
                    module: LogsModule,
                    children: [
                        {
                            path: 'activity',
                            module: activity_logs_module_1.ActivityLogsModule,
                        },
                        {
                            path: 'system',
                            module: system_logs_module_1.SystemLogsModule,
                        }
                    ],
                },
            ]),
            activity_logs_module_1.ActivityLogsModule,
            system_logs_module_1.SystemLogsModule,
        ],
        exports: [activity_logs_module_1.ActivityLogsModule, system_logs_module_1.SystemLogsModule],
    })
], LogsModule);


/***/ }),
/* 303 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivityLogsModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const activity_logs_controller_1 = __webpack_require__(304);
const activity_logs_service_1 = __webpack_require__(92);
const activity_log_entity_1 = __webpack_require__(80);
let ActivityLogsModule = class ActivityLogsModule {
};
exports.ActivityLogsModule = ActivityLogsModule;
exports.ActivityLogsModule = ActivityLogsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([activity_log_entity_1.ActivityLog]),
        ],
        controllers: [activity_logs_controller_1.ActivityLogsController],
        providers: [activity_logs_service_1.ActivityLogsService],
        exports: [activity_logs_service_1.ActivityLogsService],
    })
], ActivityLogsModule);


/***/ }),
/* 304 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivityLogsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const activity_logs_service_1 = __webpack_require__(92);
const activity_log_dto_1 = __webpack_require__(305);
const activity_log_entity_1 = __webpack_require__(80);
class ActivityLogsController extends (0, create_controller_factory_1.createController)(activity_log_entity_1.ActivityLog, activity_logs_service_1.ActivityLogsService, activity_log_dto_1.GetActivityLogDto) {
}
exports.ActivityLogsController = ActivityLogsController;


/***/ }),
/* 305 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetActivityLogDto = exports.UpdateActivityLogDto = exports.ActivityLogDto = void 0;
const base_dto_1 = __webpack_require__(101);
const action_enum_1 = __webpack_require__(40);
const log_level_enum_1 = __webpack_require__(81);
const create_get_dto_factory_1 = __webpack_require__(103);
const user_entity_1 = __webpack_require__(47);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class ActivityLogDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
    constructor() {
        super(...arguments);
        this.logLevel = log_level_enum_1.LogLevel.LOG;
    }
}
exports.ActivityLogDto = ActivityLogDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        enum: action_enum_1.Action,
        description: 'The action performed in the activity log',
        example: action_enum_1.Action.CREATE
    }),
    (0, class_validator_1.IsEnum)(action_enum_1.Action),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof action_enum_1.Action !== "undefined" && action_enum_1.Action) === "function" ? _a : Object)
], ActivityLogDto.prototype, "action", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        type: String,
        description: 'The subject involved in the activity',
        example: 'User profile'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ActivityLogDto.prototype, "subject", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        enum: log_level_enum_1.LogLevel,
        description: 'The log level of the activity',
        default: log_level_enum_1.LogLevel.LOG,
        example: log_level_enum_1.LogLevel.LOG
    }),
    (0, class_validator_1.IsEnum)(log_level_enum_1.LogLevel),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_b = typeof log_level_enum_1.LogLevel !== "undefined" && log_level_enum_1.LogLevel) === "function" ? _b : Object)
], ActivityLogDto.prototype, "logLevel", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        type: () => user_entity_1.User,
        description: 'The user who performed the action'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => user_entity_1.User),
    __metadata("design:type", typeof (_c = typeof user_entity_1.User !== "undefined" && user_entity_1.User) === "function" ? _c : Object)
], ActivityLogDto.prototype, "user", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        type: String,
        description: 'Additional message about the activity',
        example: 'User profile was updated successfully'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ActivityLogDto.prototype, "message", void 0);
class UpdateActivityLogDto extends (0, swagger_1.PartialType)(ActivityLogDto) {
}
exports.UpdateActivityLogDto = UpdateActivityLogDto;
class GetActivityLogDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateActivityLogDto, "activity log") {
}
exports.GetActivityLogDto = GetActivityLogDto;


/***/ }),
/* 306 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemLogsModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const system_log_entity_1 = __webpack_require__(307);
const system_logger_service_1 = __webpack_require__(308);
const system_logs_controller_1 = __webpack_require__(310);
const system_logs_service_1 = __webpack_require__(309);
let SystemLogsModule = class SystemLogsModule {
};
exports.SystemLogsModule = SystemLogsModule;
exports.SystemLogsModule = SystemLogsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([system_log_entity_1.SystemLog]),
        ],
        controllers: [system_logs_controller_1.SystemLogsController],
        providers: [system_logs_service_1.SystemLogsService, system_logger_service_1.SystemLogger],
        exports: [system_logs_service_1.SystemLogsService],
    })
], SystemLogsModule);


/***/ }),
/* 307 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemLog = void 0;
const log_level_enum_1 = __webpack_require__(81);
const base_entity_1 = __webpack_require__(34);
const typeorm_1 = __webpack_require__(25);
let SystemLog = class SystemLog extends base_entity_1.BaseEntity {
};
exports.SystemLog = SystemLog;
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: log_level_enum_1.LogLevel,
        default: log_level_enum_1.LogLevel.LOG,
    }),
    (0, typeorm_1.Index)('idx_system_log_level'),
    __metadata("design:type", typeof (_a = typeof log_level_enum_1.LogLevel !== "undefined" && log_level_enum_1.LogLevel) === "function" ? _a : Object)
], SystemLog.prototype, "level", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'varchar',
        length: 255,
        nullable: false,
    }),
    (0, typeorm_1.Index)('idx_system_log_location'),
    __metadata("design:type", String)
], SystemLog.prototype, "location", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'text',
        nullable: false,
    }),
    __metadata("design:type", String)
], SystemLog.prototype, "message", void 0);
exports.SystemLog = SystemLog = __decorate([
    (0, typeorm_1.Entity)('system-logs')
], SystemLog);


/***/ }),
/* 308 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemLogger = void 0;
const log_level_enum_1 = __webpack_require__(81);
const common_1 = __webpack_require__(5);
const system_logs_service_1 = __webpack_require__(309);
let SystemLogger = class SystemLogger extends common_1.ConsoleLogger {
    constructor(systemLogsService) {
        super();
        this.systemLogsService = systemLogsService;
        // Add a batch queue and process periodically
        this.logQueue = [];
        this.isBatchProcessing = false;
        this.batchSize = 10; // Configurable batch size
        // Define an array of log patterns to ignore (context + message patterns)
        this.ignoredLogPatterns = [
            { context: 'RouterExplorer', messagePattern: 'Mapped {' },
            { context: 'RoutesResolver', messagePattern: 'Controller' },
            { context: 'InstanceLoader', messagePattern: 'Starting' },
        ];
    }
    // Helper method to check if a log should be ignored
    shouldIgnoreLog(message, context) {
        if (!context)
            return false;
        return this.ignoredLogPatterns.some(pattern => context === pattern.context);
    }
    log(message, context) {
        if (!this.shouldIgnoreLog(message, context)) {
            super.log(message, context);
            this.saveLog(message, context, log_level_enum_1.LogLevel.LOG);
        }
    }
    error(message, trace, context) {
        if (!this.shouldIgnoreLog(message, context)) {
            super.error(message, trace, context);
            const fullMessage = trace ? `${message}\n${trace}` : message;
            this.saveLog(fullMessage, context, log_level_enum_1.LogLevel.ERROR);
        }
    }
    warn(message, context) {
        if (!this.shouldIgnoreLog(message, context)) {
            super.warn(message, context);
            this.saveLog(message, context, log_level_enum_1.LogLevel.WARN);
        }
    }
    debug(message, context) {
        // if (!this.shouldIgnoreLog(message, context)) {
        //     super.debug(message, context);
        //     this.saveLog(message, context, LogLevel.DEBUG);
        // }
    }
    verbose(message, context) {
        if (!this.shouldIgnoreLog(message, context)) {
            super.verbose(message, context);
            this.saveLog(message, context, log_level_enum_1.LogLevel.VERBOSE);
        }
    }
    /**
     * Save the log message to the database if the logs service is available
     */
    saveLog(message, context = 'Application', level) {
        if (!this.systemLogsService)
            return;
        // Convert objects/arrays to strings to ensure proper storage
        const formattedMessage = message === null ? 'null' :
            typeof message === 'object'
                ? JSON.stringify(message, this.getCircularReplacer())
                : String(message);
        this.logQueue.push({
            level,
            location: context,
            message: formattedMessage
        });
        if (this.logQueue.length >= this.batchSize && !this.isBatchProcessing) {
            this.processBatch();
        }
    }
    processBatch() {
        if (this.logQueue.length === 0)
            return;
        this.isBatchProcessing = true;
        const batch = this.logQueue.splice(0, this.batchSize);
        Promise.all(batch.map(log => this.systemLogsService.create(log)))
            .catch(err => console.error('Failed to process log batch:', err))
            .finally(() => {
            this.isBatchProcessing = false;
            if (this.logQueue.length >= this.batchSize) {
                this.processBatch();
            }
        });
    }
    // Helper function to handle circular references
    getCircularReplacer() {
        const seen = new WeakSet();
        return (key, value) => {
            if (typeof value === 'object' && value !== null) {
                if (seen.has(value)) {
                    return '[Circular Reference]';
                }
                seen.add(value);
            }
            return value;
        };
    }
};
exports.SystemLogger = SystemLogger;
exports.SystemLogger = SystemLogger = __decorate([
    (0, common_1.Injectable)({ scope: common_1.Scope.TRANSIENT }),
    __metadata("design:paramtypes", [typeof (_a = typeof system_logs_service_1.SystemLogsService !== "undefined" && system_logs_service_1.SystemLogsService) === "function" ? _a : Object])
], SystemLogger);


/***/ }),
/* 309 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemLogsService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const schedule_1 = __webpack_require__(131);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const system_log_entity_1 = __webpack_require__(307);
let SystemLogsService = class SystemLogsService extends base_service_1.BaseService {
    constructor(systemLogsRepository, usersService) {
        super(systemLogsRepository, usersService);
        this.systemLogsRepository = systemLogsRepository;
        this.usersService = usersService;
    }
    async cleanUpOldLogs() {
        try {
            this.logger.log('Starting cleanup of old system logs');
            const daysToKeep = 30; // Keep logs for 30 days
            const deletedCount = await this.clearOldSystemLogs(daysToKeep);
            this.logger.log(`Successfully cleaned up ${deletedCount} old system logs`);
        }
        catch (error) {
            this.logger.error(`Error cleaning up old logs: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async clearOldSystemLogs(daysToKeep = 30) {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
        const result = await this.systemLogsRepository
            .createQueryBuilder()
            .delete()
            .where('createdAt < :cutoffDate', { cutoffDate })
            .execute();
        return result.affected || 0;
    }
};
exports.SystemLogsService = SystemLogsService;
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_DAY_AT_2AM),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SystemLogsService.prototype, "cleanUpOldLogs", null);
exports.SystemLogsService = SystemLogsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(system_log_entity_1.SystemLog)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], SystemLogsService);


/***/ }),
/* 310 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemLogsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const system_log_dto_1 = __webpack_require__(311);
const system_log_entity_1 = __webpack_require__(307);
const system_logs_service_1 = __webpack_require__(309);
class SystemLogsController extends (0, create_controller_factory_1.createController)(system_log_entity_1.SystemLog, system_logs_service_1.SystemLogsService, system_log_dto_1.GetSystemLogDto) {
}
exports.SystemLogsController = SystemLogsController;


/***/ }),
/* 311 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetSystemLogDto = exports.UpdateSystemLogDto = exports.SystemLogDto = void 0;
const base_dto_1 = __webpack_require__(101);
const log_level_enum_1 = __webpack_require__(81);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class SystemLogDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.SystemLogDto = SystemLogDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Log level',
        enum: log_level_enum_1.LogLevel,
        example: log_level_enum_1.LogLevel.LOG,
        required: true
    }),
    (0, class_validator_1.IsEnum)(log_level_enum_1.LogLevel),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof log_level_enum_1.LogLevel !== "undefined" && log_level_enum_1.LogLevel) === "function" ? _a : Object)
], SystemLogDto.prototype, "level", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Log message content',
        example: 'User login successful',
        required: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], SystemLogDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Source of the log (component/module)',
        example: 'AuthService',
        required: true
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], SystemLogDto.prototype, "location", void 0);
class UpdateSystemLogDto extends (0, swagger_1.PartialType)(SystemLogDto) {
}
exports.UpdateSystemLogDto = UpdateSystemLogDto;
class GetSystemLogDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateSystemLogDto, "system log") {
}
exports.GetSystemLogDto = GetSystemLogDto;


/***/ }),
/* 312 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationsModule = void 0;
const bull_1 = __webpack_require__(4);
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const typeorm_1 = __webpack_require__(16);
const notification_entity_1 = __webpack_require__(82);
const notifications_gateway_1 = __webpack_require__(262);
const notifications_controller_1 = __webpack_require__(313);
const notifications_service_1 = __webpack_require__(261);
const notifications_processor_1 = __webpack_require__(315);
const push_subscriptions_module_1 = __webpack_require__(321);
const user_connection_service_1 = __webpack_require__(318);
const web_push_service_1 = __webpack_require__(319);
let NotificationsModule = class NotificationsModule {
};
exports.NotificationsModule = NotificationsModule;
exports.NotificationsModule = NotificationsModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([notification_entity_1.Notification]),
            push_subscriptions_module_1.PushSubscriptionsModule,
            bull_1.BullModule.registerQueue({
                name: 'notifications',
            }),
            core_1.RouterModule.register([
                {
                    path: 'notifications',
                    module: NotificationsModule,
                    children: [
                        {
                            path: 'push',
                            module: push_subscriptions_module_1.PushSubscriptionsModule,
                        }
                    ]
                },
            ]),
        ],
        providers: [
            notifications_service_1.NotificationsService,
            notifications_gateway_1.NotificationsGateway,
            notifications_processor_1.NotificationsProcessor,
            web_push_service_1.WebPushService,
            user_connection_service_1.UserConnectionService,
        ],
        exports: [
            notifications_service_1.NotificationsService,
            notifications_gateway_1.NotificationsGateway,
            push_subscriptions_module_1.PushSubscriptionsModule,
            web_push_service_1.WebPushService,
            user_connection_service_1.UserConnectionService,
        ],
        controllers: [notifications_controller_1.NotificationsController],
    })
], NotificationsModule);


/***/ }),
/* 313 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationsController = void 0;
const current_user_decorator_1 = __webpack_require__(97);
const override_decorator_1 = __webpack_require__(98);
const create_controller_factory_1 = __webpack_require__(18);
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const notification_dto_1 = __webpack_require__(314);
const notification_entity_1 = __webpack_require__(82);
const notifications_service_1 = __webpack_require__(261);
class NotificationsController extends (0, create_controller_factory_1.createController)(notification_entity_1.Notification, notifications_service_1.NotificationsService, notification_dto_1.GetNotificationDto, notification_dto_1.NotificationDto, notification_dto_1.UpdateNotificationDto) {
    constructor(notificationsService, notificationsGateway) {
        super(notificationsService);
        this.notificationsService = notificationsService;
        this.notificationsGateway = notificationsGateway;
    }
    async create(createNotificationDto, createdById) {
        return await this.notificationsService.createBulkNotifications(createNotificationDto, createdById);
    }
    async markAsRead(id, userId) {
        return await this.notificationsService.update(id, { read: true, readAt: new Date() }, userId);
    }
}
exports.NotificationsController = NotificationsController;
__decorate([
    (0, override_decorator_1.Override)(),
    (0, swagger_1.ApiOperation)({
        summary: 'Send a Notification to Multiple Users',
        description: 'Creates a notification for multiple recipients at once and queues them for delivery'
    }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof notification_dto_1.NotificationDto !== "undefined" && notification_dto_1.NotificationDto) === "function" ? _a : Object, String]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "create", null);
__decorate([
    (0, common_1.Patch)(':id/read'),
    (0, swagger_1.ApiOperation)({ summary: 'Mark a notification as read' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Notification ID' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Notification marked as read',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                unreadCount: { type: 'number' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "markAsRead", null);


/***/ }),
/* 314 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetNotificationDto = exports.UpdateNotificationDto = exports.NotificationDto = void 0;
const base_dto_1 = __webpack_require__(101);
const reference_dto_1 = __webpack_require__(102);
const notification_type_enum_1 = __webpack_require__(83);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class NotificationDto extends base_dto_1.BaseDto {
    constructor() {
        super(...arguments);
        this.type = notification_type_enum_1.NotificationType.INFO;
    }
}
exports.NotificationDto = NotificationDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Notification title',
        example: 'New Payment Received'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Notification message content',
        example: 'You have received a new payment of $500'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Icon or image URL for the notification',
        example: 'https://example.com/icons/payment.png',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationDto.prototype, "iconOrImage", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The type of notification',
        enum: notification_type_enum_1.NotificationType,
        example: notification_type_enum_1.NotificationType.INFO,
        default: notification_type_enum_1.NotificationType.INFO
    }),
    (0, class_validator_1.IsEnum)(notification_type_enum_1.NotificationType),
    __metadata("design:type", typeof (_a = typeof notification_type_enum_1.NotificationType !== "undefined" && notification_type_enum_1.NotificationType) === "function" ? _a : Object)
], NotificationDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Optional link related to notification',
        example: '/payments/123',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationDto.prototype, "link", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The category of notification',
        example: 'payment',
        required: true
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationDto.prototype, "category", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Optional ID of the target recipient',
        example: '123e4567-e89b-12d3-a456-426614174099',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationDto.prototype, "targetId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Additional metadata for the notification',
        example: { amount: 500, currency: 'USD' },
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_b = typeof Record !== "undefined" && Record) === "function" ? _b : Object)
], NotificationDto.prototype, "metadata", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Recipients of the notification.',
        type: [reference_dto_1.ReferenceDto]
    }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => reference_dto_1.ReferenceDto),
    __metadata("design:type", Array)
], NotificationDto.prototype, "recipients", void 0);
class UpdateNotificationDto extends (0, swagger_1.PartialType)(NotificationDto) {
}
exports.UpdateNotificationDto = UpdateNotificationDto;
class GetNotificationDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateNotificationDto, 'notification') {
}
exports.GetNotificationDto = GetNotificationDto;


/***/ }),
/* 315 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NotificationsProcessor_1;
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationsProcessor = void 0;
const bull_1 = __webpack_require__(4);
const common_1 = __webpack_require__(5);
const bull_2 = __webpack_require__(158);
const notifications_gateway_1 = __webpack_require__(262);
const notifications_service_1 = __webpack_require__(261);
const push_subscriptions_service_1 = __webpack_require__(316);
const user_connection_service_1 = __webpack_require__(318);
const web_push_service_1 = __webpack_require__(319);
let NotificationsProcessor = NotificationsProcessor_1 = class NotificationsProcessor {
    constructor(notificationsService, notificationsGateway, webPushService, pushSubscriptionService, userConnectionService) {
        this.notificationsService = notificationsService;
        this.notificationsGateway = notificationsGateway;
        this.webPushService = webPushService;
        this.pushSubscriptionService = pushSubscriptionService;
        this.userConnectionService = userConnectionService;
        this.logger = new common_1.Logger(NotificationsProcessor_1.name);
        // Rate limiting cache by user
        this.userRateLimits = new Map();
        // Maximum notifications per minute
        this.MAX_NOTIFICATIONS_PER_MINUTE = 10;
    }
    async handleProcessNotification(job) {
        const { notificationId, userId, isUpdate } = job.data;
        try {
            // Check rate limiting
            if (this.isRateLimited(userId, notificationId)) {
                this.logger.debug(`Rate limited notification ${notificationId} for user ${userId}`);
                return;
            }
            const notification = await this.notificationsService.findOneByOrFail({ id: notificationId });
            // Check if user is online
            const isUserOnline = this.userConnectionService.isUserOnline(userId);
            if (isUserOnline) {
                // Send via WebSocket
                this.notificationsGateway.emitToUser(notification, userId);
                this.logger.debug(`Sent notification ${notificationId} to online user ${userId} via WebSocket`);
            }
            else {
                // User is offline, send via Web Push
                await this.sendPushNotification(userId, notification);
            }
            return { success: true };
        }
        catch (error) {
            this.logger.error(`Failed to process notification ${notificationId}: ${error.message}`);
            throw error; // Let Bull retry
        }
    }
    async handleProcessBatch(job) {
        const { notificationIds, userId } = job.data;
        try {
            // Apply rate limiting
            const allowedIds = this.applyBatchRateLimit(userId, notificationIds);
            if (allowedIds.length === 0) {
                this.logger.debug(`All notifications rate limited for user ${userId}`);
                return;
            }
            // Get notifications from database
            const notifications = await this.notificationsService.getNotificationsByIds(allowedIds);
            if (notifications.length === 0) {
                this.logger.warn(`No notifications found for batch`);
                return;
            }
            // Check if user is online
            const isUserOnline = this.userConnectionService.isUserOnline(userId);
            if (isUserOnline) {
                // Send via WebSocket
                this.notificationsGateway.pingUser(userId);
                this.logger.debug(`Sent batch of ${notifications.length} notifications via WebSocket`);
            }
            else {
                // User is offline, send as grouped push notification if possible
                if (notifications.length === 1) {
                    // Single notification
                    await this.sendPushNotification(userId, notifications[0]);
                }
                else {
                    // Group notifications
                    await this.sendGroupedPushNotification(userId, notifications);
                }
            }
        }
        catch (error) {
            this.logger.error(`Failed to process batch notifications: ${error.message}`);
            throw error; // Let Bull retry
        }
    }
    //   @Process('processUserOnline')
    //   async handleUserOnline(job: Job<{ userId: string }>) {
    //     const { userId } = job.data;
    //     try {
    //       // Reset rate limiting for this user
    //       this.resetRateLimit(userId);
    //       // Get recent unread notifications (limited to reasonable number)
    //       const unreadNotifications = await this.notificationsService.getUnreadNotificationsForUser(userId, 15);
    //       if (unreadNotifications.length > 0) {
    //         // Send batch to user
    //         this.notificationsGateway.emitBatchToUser(unreadNotifications, userId);
    //         this.logger.debug(`Sent ${unreadNotifications.length} unread notifications to user ${userId} who just came online`);
    //       }
    //     } catch (error: any) {
    //       this.logger.error(`Failed to process user online event: ${error.message}`);
    //     }
    //   }
    /**
     * Send a push notification
     */
    async sendPushNotification(userId, notification) {
        // Get user's push subscriptions
        const subscriptions = await this.pushSubscriptionService.getUserSubscriptions(userId);
        if (!subscriptions || subscriptions.length === 0) {
            this.logger.debug(`No push subscriptions found for user ${userId}`);
            return;
        }
        // Format payload for Web Push
        const payload = {
            title: notification.title,
            body: notification.body,
            icon: '/assets/icons/icon-192x192.png', // Customize with your app's icon
            badge: '/assets/icons/badge-72x72.png', // Customize with your app's badge
            data: {
                notificationId: notification.id,
                url: notification.url || '/',
                type: notification.type,
                createdAt: notification.createdAt
            },
            actions: this.getNotificationActions(notification)
        };
        // Send to all user subscriptions
        const sendPromises = subscriptions.map(async (sub) => {
            try {
                const subscription = {
                    endpoint: sub.endpoint,
                    keys: {
                        p256dh: sub.p256dh,
                        auth: sub.auth
                    }
                };
                await this.webPushService.sendPushNotification(subscription, payload);
            }
            catch (error) {
                if (error.code === 'SUBSCRIPTION_EXPIRED') {
                    // Remove expired subscription
                    await this.pushSubscriptionService.removeExpiredSubscription(sub.endpoint);
                }
                else {
                    this.logger.error(`Failed to send to subscription: ${error.message}`);
                }
            }
        });
        await Promise.all(sendPromises);
    }
    /**
     * Send grouped push notification
     */
    async sendGroupedPushNotification(userId, notifications) {
        const subscriptions = await this.pushSubscriptionService.getUserSubscriptions(userId);
        if (!subscriptions || subscriptions.length === 0) {
            return;
        }
        // Group by type if available
        const typeGroups = new Map();
        notifications.forEach(notification => {
            const type = notification.type || 'general';
            if (!typeGroups.has(type)) {
                typeGroups.set(type, []);
            }
            typeGroups.get(type).push(notification);
        });
        // For each type, send a grouped notification
        for (const [type, items] of typeGroups.entries()) {
            if (items.length === 1) {
                // Just one notification of this type, send normally
                await this.sendPushNotification(userId, items[0]);
                continue;
            }
            // Create a grouped notification
            const payload = {
                title: `${items.length} new ${type} notifications`,
                body: items.length > 3
                    ? `${items[0].body.substring(0, 30)}... and ${items.length - 1} more`
                    : items.map(n => n.body.substring(0, 30)).join('\n'),
                icon: '/assets/icons/icon-192x192.png',
                badge: '/assets/icons/badge-72x72.png',
                data: {
                    notificationIds: items.map(n => n.id),
                    url: '/notifications',
                    type,
                    count: items.length
                },
                actions: [
                    { action: 'view', title: 'View All' },
                    { action: 'dismiss', title: 'Dismiss' }
                ]
            };
            // Send to all subscriptions
            const sendPromises = subscriptions.map(async (sub) => {
                try {
                    const subscription = {
                        endpoint: sub.endpoint,
                        keys: {
                            p256dh: sub.p256dh,
                            auth: sub.auth
                        }
                    };
                    await this.webPushService.sendPushNotification(subscription, payload);
                }
                catch (error) {
                    if (error.code === 'SUBSCRIPTION_EXPIRED') {
                        await this.pushSubscriptionService.removeExpiredSubscription(sub.endpoint);
                    }
                }
            });
            await Promise.all(sendPromises);
        }
    }
    /**
     * Get appropriate actions based on notification type
     */
    getNotificationActions(notification) {
        // Default actions
        const actions = [
            { action: 'view', title: 'View' },
            { action: 'dismiss', title: 'Dismiss' }
        ];
        // Add custom actions based on notification type
        switch (notification.type) {
            case 'comment':
                actions.push({ action: 'reply', title: 'Reply' });
                break;
            case 'message':
                actions.push({ action: 'reply', title: 'Reply' });
                break;
            case 'task':
                actions.push({ action: 'complete', title: 'Complete' });
                break;
        }
        return actions.slice(0, 2); // Most browsers only support 2 actions
    }
    /**
     * Check if notification should be rate limited
     */
    isRateLimited(userId, notificationId) {
        const now = new Date();
        if (!this.userRateLimits.has(userId)) {
            this.userRateLimits.set(userId, {
                count: 1,
                lastReset: now,
                pendingIds: []
            });
            return false;
        }
        const userLimit = this.userRateLimits.get(userId);
        // Reset if it's been over a minute
        if (now.getTime() - userLimit.lastReset.getTime() > 60000) {
            userLimit.count = 1;
            userLimit.lastReset = now;
            userLimit.pendingIds = [];
            return false;
        }
        // Check if under limit
        if (userLimit.count < this.MAX_NOTIFICATIONS_PER_MINUTE) {
            userLimit.count++;
            return false;
        }
        // Rate limited - store for later
        userLimit.pendingIds.push(notificationId);
        return true;
    }
    /**
     * Apply rate limiting to a batch of notifications
     */
    applyBatchRateLimit(userId, notificationIds) {
        const now = new Date();
        if (!this.userRateLimits.has(userId)) {
            this.userRateLimits.set(userId, {
                count: 0,
                lastReset: now,
                pendingIds: []
            });
        }
        const userLimit = this.userRateLimits.get(userId);
        // Reset if it's been over a minute
        if (now.getTime() - userLimit.lastReset.getTime() > 60000) {
            userLimit.count = 0;
            userLimit.lastReset = now;
            userLimit.pendingIds = [];
        }
        // How many can we send now?
        const available = this.MAX_NOTIFICATIONS_PER_MINUTE - userLimit.count;
        if (available <= 0) {
            // Rate limit all
            userLimit.pendingIds.push(...notificationIds);
            return [];
        }
        if (notificationIds.length <= available) {
            // Can send all
            userLimit.count += notificationIds.length;
            return notificationIds;
        }
        // Send what we can, queue the rest
        const toSend = notificationIds.slice(0, available);
        const toQueue = notificationIds.slice(available);
        userLimit.count += toSend.length;
        userLimit.pendingIds.push(...toQueue);
        return toSend;
    }
    /**
     * Reset rate limit for a user
     */
    resetRateLimit(userId) {
        this.userRateLimits.delete(userId);
    }
};
exports.NotificationsProcessor = NotificationsProcessor;
__decorate([
    (0, bull_1.Process)('processNotification'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_f = typeof bull_2.Job !== "undefined" && bull_2.Job) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], NotificationsProcessor.prototype, "handleProcessNotification", null);
__decorate([
    (0, bull_1.Process)('processBatch'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_g = typeof bull_2.Job !== "undefined" && bull_2.Job) === "function" ? _g : Object]),
    __metadata("design:returntype", Promise)
], NotificationsProcessor.prototype, "handleProcessBatch", null);
exports.NotificationsProcessor = NotificationsProcessor = NotificationsProcessor_1 = __decorate([
    (0, common_1.Injectable)(),
    (0, bull_1.Processor)('notifications'),
    __metadata("design:paramtypes", [typeof (_a = typeof notifications_service_1.NotificationsService !== "undefined" && notifications_service_1.NotificationsService) === "function" ? _a : Object, typeof (_b = typeof notifications_gateway_1.NotificationsGateway !== "undefined" && notifications_gateway_1.NotificationsGateway) === "function" ? _b : Object, typeof (_c = typeof web_push_service_1.WebPushService !== "undefined" && web_push_service_1.WebPushService) === "function" ? _c : Object, typeof (_d = typeof push_subscriptions_service_1.PushSubscriptionsService !== "undefined" && push_subscriptions_service_1.PushSubscriptionsService) === "function" ? _d : Object, typeof (_e = typeof user_connection_service_1.UserConnectionService !== "undefined" && user_connection_service_1.UserConnectionService) === "function" ? _e : Object])
], NotificationsProcessor);


/***/ }),
/* 316 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushSubscriptionsService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const push_subscription_entity_1 = __webpack_require__(317);
let PushSubscriptionsService = class PushSubscriptionsService extends base_service_1.BaseService {
    constructor(pushSubscriptionsRepository, usersService) {
        super(pushSubscriptionsRepository, usersService);
        this.pushSubscriptionsRepository = pushSubscriptionsRepository;
        this.usersService = usersService;
    }
    /**
     * Save a new push subscription for a user
     */
    async saveSubscription(userId, subscription) {
        // First check if already exists
        const existing = await this.pushSubscriptionsRepository.findOne({
            where: {
                endpoint: subscription.endpoint,
                userId
            }
        });
        if (existing) {
            // Update keys if needed
            existing.p256dh = subscription.keys.p256dh;
            existing.auth = subscription.keys.auth;
            return this.pushSubscriptionsRepository.save(existing);
        }
        // Create new subscription
        const newSubscription = this.pushSubscriptionsRepository.create({
            userId,
            endpoint: subscription.endpoint,
            p256dh: subscription.keys.p256dh,
            auth: subscription.keys.auth
        });
        return this.pushSubscriptionsRepository.save(newSubscription);
    }
    /**
     * Remove a subscription
     */
    async removeSubscription(userId, endpoint) {
        await this.pushSubscriptionsRepository.delete({
            userId,
            endpoint
        });
    }
    /**
     * Get all subscriptions for a user
     */
    async getUserSubscriptions(userId) {
        return this.pushSubscriptionsRepository.find({
            where: { userId }
        });
    }
    /**
     * Remove expired subscription
     */
    async removeExpiredSubscription(endpoint) {
        await this.pushSubscriptionsRepository.delete({ endpoint });
        this.logger.debug(`Removed expired subscription: ${endpoint}`);
    }
};
exports.PushSubscriptionsService = PushSubscriptionsService;
exports.PushSubscriptionsService = PushSubscriptionsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(push_subscription_entity_1.PushSubscription)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], PushSubscriptionsService);


/***/ }),
/* 317 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushSubscription = void 0;
const base_entity_1 = __webpack_require__(34);
const typeorm_1 = __webpack_require__(25);
let PushSubscription = class PushSubscription extends base_entity_1.BaseEntity {
};
exports.PushSubscription = PushSubscription;
__decorate([
    (0, typeorm_1.Column)({ unique: true }),
    __metadata("design:type", String)
], PushSubscription.prototype, "endpoint", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], PushSubscription.prototype, "p256dh", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", String)
], PushSubscription.prototype, "auth", void 0);
exports.PushSubscription = PushSubscription = __decorate([
    (0, typeorm_1.Entity)('push-subscriptions')
], PushSubscription);


/***/ }),
/* 318 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserConnectionService = void 0;
const bull_1 = __webpack_require__(4);
const common_1 = __webpack_require__(5);
const bull_2 = __webpack_require__(158);
let UserConnectionService = class UserConnectionService {
    constructor(notificationsQueue) {
        this.notificationsQueue = notificationsQueue;
        // Track online users
        this.onlineUsers = new Set();
    }
    /**
     * Mark a user as online
     */
    async userConnected(userId) {
        if (!this.onlineUsers.has(userId)) {
            this.onlineUsers.add(userId);
            // Queue job to send unread notifications
            await this.notificationsQueue.add('handleUserOnline', {
                userId
            }, {
                delay: 1000 // small delay to ensure connection is stable
            });
        }
    }
    /**
     * Mark a user as offline
     */
    userDisconnected(userId) {
        this.onlineUsers.delete(userId);
    }
    /**
     * Check if user is online
     */
    isUserOnline(userId) {
        return this.onlineUsers.has(userId);
    }
};
exports.UserConnectionService = UserConnectionService;
exports.UserConnectionService = UserConnectionService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, bull_1.InjectQueue)('notifications')),
    __metadata("design:paramtypes", [typeof (_a = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _a : Object])
], UserConnectionService);


/***/ }),
/* 319 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var WebPushService_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebPushService = void 0;
const common_1 = __webpack_require__(5);
const config_1 = __webpack_require__(6);
const webPush = __importStar(__webpack_require__(320));
let WebPushService = WebPushService_1 = class WebPushService {
    constructor(configService) {
        this.configService = configService;
        this.logger = new common_1.Logger(WebPushService_1.name);
        this.initialized = false;
        this.initialize();
    }
    initialize() {
        try {
            const publicKey = this.configService.get('WEB_PUSH_PUBLIC_KEY');
            const privateKey = this.configService.get('WEB_PUSH_PRIVATE_KEY');
            if (!publicKey || !privateKey) {
                this.logger.warn('Web Push keys not configured. Run: npx web-push generate-vapid-keys');
                return;
            }
            // Set VAPID details
            webPush.setVapidDetails(`mailto:${this.configService.getOrThrow('WEB_PUSH_CONTACT_EMAIL')}`, publicKey, privateKey);
            this.initialized = true;
            this.logger.log('Web Push initialized');
        }
        catch (error) {
            this.logger.error(`Failed to initialize Web Push: ${error.message}`);
        }
    }
    /**
     * Send push notification to a subscription
     */
    async sendPushNotification(subscription, payload) {
        if (!this.initialized) {
            this.logger.warn('Web Push not initialized, skipping notification');
            return false;
        }
        try {
            await webPush.sendNotification(subscription, JSON.stringify(payload));
            return true;
        }
        catch (error) {
            // Check for specific errors
            if (error.statusCode === 410) {
                this.logger.warn(`Subscription has expired or been unsubscribed: ${error.message}`);
                // Return an identifier so we know to remove this subscription
                throw { code: 'SUBSCRIPTION_EXPIRED', subscription };
            }
            this.logger.error(`Failed to send push notification: ${error.message}`);
            throw error;
        }
    }
    /**
     * Generate VAPID keys (for initial setup)
     */
    generateVapidKeys() {
        return webPush.generateVAPIDKeys();
    }
    /**
     * Get public key for clients to use
     */
    getPublicKey() {
        return this.configService.get('WEB_PUSH_PUBLIC_KEY', '');
    }
};
exports.WebPushService = WebPushService;
exports.WebPushService = WebPushService = WebPushService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], WebPushService);


/***/ }),
/* 320 */
/***/ ((module) => {

"use strict";
module.exports = require("web-push");

/***/ }),
/* 321 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushSubscriptionsModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const push_subscriptions_controller_1 = __webpack_require__(322);
const push_subscriptions_service_1 = __webpack_require__(316);
const push_subscription_entity_1 = __webpack_require__(317);
let PushSubscriptionsModule = class PushSubscriptionsModule {
};
exports.PushSubscriptionsModule = PushSubscriptionsModule;
exports.PushSubscriptionsModule = PushSubscriptionsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([push_subscription_entity_1.PushSubscription]),
        ],
        providers: [push_subscriptions_service_1.PushSubscriptionsService],
        exports: [push_subscriptions_service_1.PushSubscriptionsService],
        controllers: [push_subscriptions_controller_1.PushSubscriptionsController],
    })
], PushSubscriptionsModule);


/***/ }),
/* 322 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushSubscriptionsController = void 0;
const authorize_decorator_1 = __webpack_require__(26);
const current_user_decorator_1 = __webpack_require__(97);
const create_controller_factory_1 = __webpack_require__(18);
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const push_subscription_dto_1 = __webpack_require__(323);
const push_subscription_entity_1 = __webpack_require__(317);
const push_subscriptions_service_1 = __webpack_require__(316);
class PushSubscriptionsController extends (0, create_controller_factory_1.createController)(push_subscription_entity_1.PushSubscription, // Entity name for Swagger documentation
push_subscriptions_service_1.PushSubscriptionsService, // The service handling PushSubscription-related operations
push_subscription_dto_1.GetPushSubscriptionDto) {
    constructor(webPushService, pushSubscriptionsService) {
        super(pushSubscriptionsService);
        this.webPushService = webPushService;
        this.pushSubscriptionsService = pushSubscriptionsService;
    }
    async create(entityDto, createdById) {
        return await super.create(entityDto, createdById);
    }
    async update(id, entityDto, updatedById) {
        return await super.update(id, entityDto, updatedById);
    }
    async delete(id) {
        return await super.delete(id);
    }
    async deleteMany(ids, hardDelete) {
        return await super.deleteMany(ids, hardDelete);
    }
    async softDelete(id, deletedBy) {
        return await super.softDelete(id, deletedBy);
    }
    getPublicKey() {
        return { publicKey: this.webPushService.getPublicKey() };
    }
    async subscribe(subscription, userId) {
        await this.pushSubscriptionsService.saveSubscription(userId, subscription);
        return { success: true };
    }
    async unsubscribe(subscription, userId) {
        await this.pushSubscriptionsService.removeSubscription(userId, subscription.endpoint);
        return { success: true };
    }
}
exports.PushSubscriptionsController = PushSubscriptionsController;
__decorate([
    (0, swagger_1.ApiOperation)({
        summary: 'Get VAPID public key for push notification subscription',
        description: 'Returns the VAPID public key required for subscribing to push notifications in the browser'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Successfully returned the VAPID public key',
        schema: {
            type: 'object',
            properties: {
                publicKey: {
                    type: 'string',
                    description: 'VAPID public key used for push notification subscription',
                    example: 'BLC8GOevpcpjQiLkO7JmVClQjycvTCYWm6Cq_a-JwvO9B4emcQJwX06KBQeg1ocOcIob5-J_WN5c9Ow0hUvNYoA'
                }
            }
        }
    }),
    (0, common_1.Get)('vapid-public-key'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PushSubscriptionsController.prototype, "getPublicKey", null);
__decorate([
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Subscribe to push notifications' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Subscription saved successfully' }),
    (0, common_1.Post)('subscribe'),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof push_subscription_entity_1.PushSubscription !== "undefined" && push_subscription_entity_1.PushSubscription) === "function" ? _a : Object, String]),
    __metadata("design:returntype", Promise)
], PushSubscriptionsController.prototype, "subscribe", null);
__decorate([
    (0, authorize_decorator_1.Authorize)(),
    (0, swagger_1.ApiOperation)({ summary: 'Unsubscribe from push notifications' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Unsubscribed successfully' }),
    (0, common_1.Post)('unsubscribe'),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", Promise)
], PushSubscriptionsController.prototype, "unsubscribe", null);


/***/ }),
/* 323 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPushSubscriptionDto = exports.UpdatePushSubscriptionDto = exports.PushSubscriptionDto = void 0;
const base_dto_1 = __webpack_require__(101);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
class PushSubscriptionDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
}
exports.PushSubscriptionDto = PushSubscriptionDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the push-subscription' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PushSubscriptionDto.prototype, "name", void 0);
class UpdatePushSubscriptionDto extends (0, swagger_1.PartialType)(PushSubscriptionDto) {
}
exports.UpdatePushSubscriptionDto = UpdatePushSubscriptionDto;
class GetPushSubscriptionDto extends (0, create_get_dto_factory_1.createGetDto)(UpdatePushSubscriptionDto, 'push subscription') {
}
exports.GetPushSubscriptionDto = GetPushSubscriptionDto;


/***/ }),
/* 324 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationManagementModule = void 0;
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const typeorm_1 = __webpack_require__(16);
const branches_module_1 = __webpack_require__(325);
const departments_module_1 = __webpack_require__(329);
const organization_entity_1 = __webpack_require__(42);
const organizations_controller_1 = __webpack_require__(333);
const organizations_service_1 = __webpack_require__(335);
let OrganizationManagementModule = class OrganizationManagementModule {
};
exports.OrganizationManagementModule = OrganizationManagementModule;
exports.OrganizationManagementModule = OrganizationManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([organization_entity_1.Organization]),
            branches_module_1.BranchesModule,
            departments_module_1.DepartmentsModule,
            core_1.RouterModule.register([
                {
                    path: 'organizations',
                    module: OrganizationManagementModule,
                    children: [
                        {
                            path: 'branches',
                            module: branches_module_1.BranchesModule,
                            children: [
                                {
                                    path: 'departments',
                                    module: departments_module_1.DepartmentsModule
                                }
                            ],
                        }
                    ]
                },
            ]),
        ],
        providers: [organizations_service_1.OrganizationsService],
        exports: [
            organizations_service_1.OrganizationsService,
            branches_module_1.BranchesModule,
        ],
        controllers: [organizations_controller_1.OrganizationsController],
    })
], OrganizationManagementModule);


/***/ }),
/* 325 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BranchesModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const branches_controller_1 = __webpack_require__(326);
const branches_service_1 = __webpack_require__(327);
const departments_module_1 = __webpack_require__(329);
const branch_entity_1 = __webpack_require__(41);
let BranchesModule = class BranchesModule {
};
exports.BranchesModule = BranchesModule;
exports.BranchesModule = BranchesModule = __decorate([
    (0, common_1.Module)({
        imports: [typeorm_1.TypeOrmModule.forFeature([branch_entity_1.Branch]),
            departments_module_1.DepartmentsModule],
        controllers: [branches_controller_1.BranchesController],
        providers: [branches_service_1.BranchesService],
        exports: [branches_service_1.BranchesService, departments_module_1.DepartmentsModule],
    })
], BranchesModule);


/***/ }),
/* 326 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BranchesController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const branches_service_1 = __webpack_require__(327);
const branch_dto_1 = __webpack_require__(328);
const branch_entity_1 = __webpack_require__(41);
class BranchesController extends (0, create_controller_factory_1.createController)(branch_entity_1.Branch, branches_service_1.BranchesService, branch_dto_1.GetBranchDto, branch_dto_1.BranchDto, branch_dto_1.UpdateBranchDto) {
}
exports.BranchesController = BranchesController;


/***/ }),
/* 327 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BranchesService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const branch_entity_1 = __webpack_require__(41);
let BranchesService = class BranchesService extends base_service_1.BaseService {
    constructor(branchesRepository, usersService) {
        super(branchesRepository, usersService);
        this.branchesRepository = branchesRepository;
        this.usersService = usersService;
    }
};
exports.BranchesService = BranchesService;
exports.BranchesService = BranchesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(branch_entity_1.Branch)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], BranchesService);


/***/ }),
/* 328 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBranchDto = exports.UpdateBranchDto = exports.BranchDto = void 0;
const create_get_dto_factory_1 = __webpack_require__(103);
const address_dto_1 = __webpack_require__(119);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class BranchDto {
}
exports.BranchDto = BranchDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Organization ID associated with the branch' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], BranchDto.prototype, "organizationId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The name of the branch',
        example: 'Acme Corporation',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], BranchDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Description of the branch',
        example: 'Leading provider of innovative solutions',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.MaxLength)(500),
    __metadata("design:type", String)
], BranchDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'URL or path to the branch logo',
        example: 'https://example.com/logo.png',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], BranchDto.prototype, "logo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique alias/slug for the branch',
        example: 'acme-corp',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(50),
    __metadata("design:type", String)
], BranchDto.prototype, "alias", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Address information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => address_dto_1.AddressDto),
    __metadata("design:type", typeof (_a = typeof address_dto_1.AddressDto !== "undefined" && address_dto_1.AddressDto) === "function" ? _a : Object)
], BranchDto.prototype, "address", void 0);
class UpdateBranchDto extends (0, swagger_1.PartialType)(BranchDto) {
}
exports.UpdateBranchDto = UpdateBranchDto;
class GetBranchDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateBranchDto, 'branch') {
}
exports.GetBranchDto = GetBranchDto;


/***/ }),
/* 329 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DepartmentsModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const departments_controller_1 = __webpack_require__(330);
const departments_service_1 = __webpack_require__(331);
const department_entity_1 = __webpack_require__(36);
let DepartmentsModule = class DepartmentsModule {
};
exports.DepartmentsModule = DepartmentsModule;
exports.DepartmentsModule = DepartmentsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([department_entity_1.Department]),
        ],
        providers: [departments_service_1.DepartmentsService],
        controllers: [departments_controller_1.DepartmentsController],
        exports: [departments_service_1.DepartmentsService],
    })
], DepartmentsModule);


/***/ }),
/* 330 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DepartmentsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const departments_service_1 = __webpack_require__(331);
const department_dto_1 = __webpack_require__(332);
const department_entity_1 = __webpack_require__(36);
class DepartmentsController extends (0, create_controller_factory_1.createController)(department_entity_1.Department, departments_service_1.DepartmentsService, department_dto_1.GetDepartmentDto, department_dto_1.DepartmentDto, department_dto_1.UpdateDepartmentDto) {
}
exports.DepartmentsController = DepartmentsController;


/***/ }),
/* 331 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DepartmentsService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const department_entity_1 = __webpack_require__(36);
let DepartmentsService = class DepartmentsService extends base_service_1.BaseService {
    constructor(departmentsRepository, usersService) {
        super(departmentsRepository, usersService);
        this.departmentsRepository = departmentsRepository;
        this.usersService = usersService;
    }
};
exports.DepartmentsService = DepartmentsService;
exports.DepartmentsService = DepartmentsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(department_entity_1.Department)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], DepartmentsService);


/***/ }),
/* 332 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDepartmentDto = exports.UpdateDepartmentDto = exports.DepartmentDto = void 0;
const create_get_dto_factory_1 = __webpack_require__(103);
const address_dto_1 = __webpack_require__(119);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class DepartmentDto {
}
exports.DepartmentDto = DepartmentDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Branch ID associated with the branch' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsUUID)(),
    __metadata("design:type", String)
], DepartmentDto.prototype, "branchId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The name of the Department',
        example: 'Acme Corporation',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], DepartmentDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Description of the Department',
        example: 'Leading provider of innovative solutions',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.MaxLength)(500),
    __metadata("design:type", String)
], DepartmentDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'URL or path to the Department logo',
        example: 'https://example.com/logo.png',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], DepartmentDto.prototype, "logo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique alias/slug for the Department',
        example: 'acme-corp',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(50),
    __metadata("design:type", String)
], DepartmentDto.prototype, "alias", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Address information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => address_dto_1.AddressDto),
    __metadata("design:type", typeof (_a = typeof address_dto_1.AddressDto !== "undefined" && address_dto_1.AddressDto) === "function" ? _a : Object)
], DepartmentDto.prototype, "address", void 0);
class UpdateDepartmentDto extends (0, swagger_1.PartialType)(DepartmentDto) {
}
exports.UpdateDepartmentDto = UpdateDepartmentDto;
class GetDepartmentDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateDepartmentDto, 'department') {
}
exports.GetDepartmentDto = GetDepartmentDto;


/***/ }),
/* 333 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const organization_dto_1 = __webpack_require__(334);
const organization_entity_1 = __webpack_require__(42);
const organizations_service_1 = __webpack_require__(335);
class OrganizationsController extends (0, create_controller_factory_1.createController)(organization_entity_1.Organization, organizations_service_1.OrganizationsService, organization_dto_1.GetOrganizationDto, organization_dto_1.OrganizationDto, organization_dto_1.UpdateOrganizationDto) {
}
exports.OrganizationsController = OrganizationsController;


/***/ }),
/* 334 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetOrganizationDto = exports.UpdateOrganizationDto = exports.OrganizationDto = void 0;
const create_get_dto_factory_1 = __webpack_require__(103);
const address_dto_1 = __webpack_require__(119);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class OrganizationDto {
}
exports.OrganizationDto = OrganizationDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'The name of the organization',
        example: 'Acme Corporation',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], OrganizationDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Description of the organization',
        example: 'Leading provider of innovative solutions',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.MaxLength)(500),
    __metadata("design:type", String)
], OrganizationDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'URL or path to the organization logo',
        example: 'https://example.com/logo.png',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], OrganizationDto.prototype, "logo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique alias/slug for the organization',
        example: 'acme-corp',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(50),
    __metadata("design:type", String)
], OrganizationDto.prototype, "alias", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Address information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => address_dto_1.AddressDto),
    __metadata("design:type", typeof (_a = typeof address_dto_1.AddressDto !== "undefined" && address_dto_1.AddressDto) === "function" ? _a : Object)
], OrganizationDto.prototype, "address", void 0);
class UpdateOrganizationDto extends (0, swagger_1.PartialType)(OrganizationDto) {
}
exports.UpdateOrganizationDto = UpdateOrganizationDto;
class GetOrganizationDto extends (0, create_get_dto_factory_1.createGetDto)(UpdateOrganizationDto, 'organization') {
}
exports.GetOrganizationDto = GetOrganizationDto;


/***/ }),
/* 335 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationsService = void 0;
const base_service_1 = __webpack_require__(31);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const users_service_1 = __webpack_require__(30);
const organization_entity_1 = __webpack_require__(42);
let OrganizationsService = class OrganizationsService extends base_service_1.BaseService {
    constructor(organizationsRepository, usersService) {
        super(organizationsRepository, usersService);
        this.organizationsRepository = organizationsRepository;
        this.usersService = usersService;
    }
};
exports.OrganizationsService = OrganizationsService;
exports.OrganizationsService = OrganizationsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(organization_entity_1.Organization)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], OrganizationsService);


/***/ }),
/* 336 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollManagementModule = void 0;
const common_1 = __webpack_require__(5);
const core_1 = __webpack_require__(7);
const typeorm_1 = __webpack_require__(16);
const final_work_hours_module_1 = __webpack_require__(265);
const employee_management_module_1 = __webpack_require__(15);
const cutoffs_module_1 = __webpack_require__(128);
const payroll_entity_1 = __webpack_require__(63);
const payroll_item_types_module_1 = __webpack_require__(337);
const payroll_items_module_1 = __webpack_require__(341);
const payrolls_controller_1 = __webpack_require__(345);
const payrolls_service_1 = __webpack_require__(346);
let PayrollManagementModule = class PayrollManagementModule {
};
exports.PayrollManagementModule = PayrollManagementModule;
exports.PayrollManagementModule = PayrollManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([payroll_entity_1.Payroll]),
            core_1.RouterModule.register([
                {
                    path: 'payrolls',
                    module: PayrollManagementModule,
                    children: [
                        {
                            path: 'payroll-items',
                            module: payroll_items_module_1.PayrollItemsModule
                        },
                        {
                            path: 'payroll-item-types',
                            module: payroll_item_types_module_1.PayrollItemTypesModule
                        },
                        {
                            path: 'cutoffs',
                            module: cutoffs_module_1.CutoffsModule
                        }
                    ]
                }
            ]),
            payroll_items_module_1.PayrollItemsModule,
            payroll_item_types_module_1.PayrollItemTypesModule,
            cutoffs_module_1.CutoffsModule,
            employee_management_module_1.EmployeeManagementModule,
            final_work_hours_module_1.FinalWorkHoursModule,
        ],
        providers: [payrolls_service_1.PayrollsService],
        exports: [
            payrolls_service_1.PayrollsService,
            payroll_items_module_1.PayrollItemsModule,
            payroll_item_types_module_1.PayrollItemTypesModule,
            cutoffs_module_1.CutoffsModule,
        ],
        controllers: [payrolls_controller_1.PayrollsController],
    })
], PayrollManagementModule);


/***/ }),
/* 337 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemTypesModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const payroll_item_type_entity_1 = __webpack_require__(66);
const payroll_item_types_controller_1 = __webpack_require__(338);
const payroll_item_types_service_1 = __webpack_require__(340);
let PayrollItemTypesModule = class PayrollItemTypesModule {
};
exports.PayrollItemTypesModule = PayrollItemTypesModule;
exports.PayrollItemTypesModule = PayrollItemTypesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([payroll_item_type_entity_1.PayrollItemType]),
        ],
        providers: [payroll_item_types_service_1.PayrollItemTypesService],
        exports: [payroll_item_types_service_1.PayrollItemTypesService],
        controllers: [payroll_item_types_controller_1.PayrollItemTypesController],
    })
], PayrollItemTypesModule);


/***/ }),
/* 338 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemTypesController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const payroll_item_type_dto_1 = __webpack_require__(339);
const payroll_item_type_entity_1 = __webpack_require__(66);
const payroll_item_types_service_1 = __webpack_require__(340);
class PayrollItemTypesController extends (0, create_controller_factory_1.createController)(payroll_item_type_entity_1.PayrollItemType, payroll_item_types_service_1.PayrollItemTypesService, payroll_item_type_dto_1.GetPayrollItemTypeDto, payroll_item_type_dto_1.PayrollItemTypeDto, payroll_item_type_dto_1.UpdatePayrollItemTypeDto) {
}
exports.PayrollItemTypesController = PayrollItemTypesController;


/***/ }),
/* 339 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPayrollItemTypeDto = exports.UpdatePayrollItemTypeDto = exports.PayrollItemTypeDto = void 0;
const base_dto_1 = __webpack_require__(101);
const payroll_item_category_enum_1 = __webpack_require__(67);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const class_validator_1 = __webpack_require__(24);
class ValidationRulesDto {
}
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Minimum amount allowed', required: false, example: 100 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], ValidationRulesDto.prototype, "minAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Maximum amount allowed', required: false, example: 10000 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Max)(1000000),
    __metadata("design:type", Number)
], ValidationRulesDto.prototype, "maxAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Minimum salary required', required: false, example: 10000 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], ValidationRulesDto.prototype, "minSalary", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Maximum salary allowed', required: false, example: 100000 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Max)(10000000),
    __metadata("design:type", Number)
], ValidationRulesDto.prototype, "maxSalary", void 0);
class PayrollItemTypeDto extends (0, swagger_1.PartialType)(base_dto_1.BaseDto) {
    constructor() {
        super(...arguments);
        this.isActive = true;
        this.isSystemGenerated = false;
        this.isGovernmentMandated = false;
        this.hasEmployerShare = false;
        this.isPartOfTaxCalculation = false;
        this.isTaxable = true;
        this.isTaxDeductible = false;
        this.isDisplayedInPayslip = true;
        this.isRequired = true;
    }
}
exports.PayrollItemTypeDto = PayrollItemTypeDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the payroll item type' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PayrollItemTypeDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Description of the payroll item type', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PayrollItemTypeDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Category of the payroll item type',
        enum: payroll_item_category_enum_1.PayrollItemCategory,
        example: Object.values(payroll_item_category_enum_1.PayrollItemCategory)[0]
    }),
    (0, class_validator_1.IsEnum)(payroll_item_category_enum_1.PayrollItemCategory),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", typeof (_a = typeof payroll_item_category_enum_1.PayrollItemCategory !== "undefined" && payroll_item_category_enum_1.PayrollItemCategory) === "function" ? _a : Object)
], PayrollItemTypeDto.prototype, "category", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Default occurrence of the payroll item', example: 'Monthly' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PayrollItemTypeDto.prototype, "defaultOccurrence", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Unit of measurement for the payroll item', example: 'Hours' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PayrollItemTypeDto.prototype, "unit", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Formula used for computation', example: 'baseRate * hours' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PayrollItemTypeDto.prototype, "computationFormula", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Default amount for the payroll item',
        type: 'number',
        format: 'decimal',
        required: false,
        example: 1000.50
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({ maxDecimalPlaces: 2 }),
    __metadata("design:type", Number)
], PayrollItemTypeDto.prototype, "defaultAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether the payroll item is active', default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "isActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether the item is system generated', default: false }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "isSystemGenerated", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether the item is government mandated', default: false }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "isGovernmentMandated", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of government contribution (SSS, PHILHEALTH, PAGIBIG, etc.)',
        required: false,
        example: 'SSS'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PayrollItemTypeDto.prototype, "governmentContributionType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether the item has employer share', default: false }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "hasEmployerShare", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Employer formula percentage',
        required: false,
        example: '3.5%'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PayrollItemTypeDto.prototype, "employerFormulaPercentage", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether the item is part of tax calculation', default: false }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "isPartOfTaxCalculation", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether the item is taxable', default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "isTaxable", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether the item is tax deductible', default: false }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "isTaxDeductible", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether the item is displayed in payslip', default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "isDisplayedInPayslip", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Which employee types this item applies to',
        required: false,
        isArray: true,
        example: ['Regular', 'Contractual']
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsString)({ each: true }),
    __metadata("design:type", Array)
], PayrollItemTypeDto.prototype, "applicableTo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether the item is required', default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], PayrollItemTypeDto.prototype, "isRequired", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date when this item becomes effective',
        required: false,
        type: Date,
        example: '2023-01-01T00:00:00Z'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], PayrollItemTypeDto.prototype, "effectiveFrom", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date when this item expires',
        required: false,
        type: Date,
        example: '2024-12-31T23:59:59Z'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], PayrollItemTypeDto.prototype, "effectiveTo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Additional parameters for calculation',
        required: false,
        example: {
            thresholds: [5000, 10000, 15000],
            rates: [0.05, 0.1, 0.15]
        }
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsObject)(),
    __metadata("design:type", typeof (_d = typeof Record !== "undefined" && Record) === "function" ? _d : Object)
], PayrollItemTypeDto.prototype, "calculationParameters", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Validation rules for the payroll item',
        required: false,
        type: ValidationRulesDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => ValidationRulesDto),
    __metadata("design:type", ValidationRulesDto)
], PayrollItemTypeDto.prototype, "validationRules", void 0);
class UpdatePayrollItemTypeDto extends (0, swagger_1.PartialType)(PayrollItemTypeDto) {
}
exports.UpdatePayrollItemTypeDto = UpdatePayrollItemTypeDto;
class GetPayrollItemTypeDto extends (0, create_get_dto_factory_1.createGetDto)(UpdatePayrollItemTypeDto, 'payroll item type') {
}
exports.GetPayrollItemTypeDto = GetPayrollItemTypeDto;


/***/ }),
/* 340 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemTypesService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const payroll_item_type_entity_1 = __webpack_require__(66);
let PayrollItemTypesService = class PayrollItemTypesService extends base_service_1.BaseService {
    constructor(payrollItemTypesRepository, usersService) {
        super(payrollItemTypesRepository, usersService);
        this.payrollItemTypesRepository = payrollItemTypesRepository;
        this.usersService = usersService;
    }
};
exports.PayrollItemTypesService = PayrollItemTypesService;
exports.PayrollItemTypesService = PayrollItemTypesService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(payroll_item_type_entity_1.PayrollItemType)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], PayrollItemTypesService);


/***/ }),
/* 341 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemsModule = void 0;
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const payroll_item_entity_1 = __webpack_require__(65);
const payroll_items_controller_1 = __webpack_require__(342);
const payroll_items_service_1 = __webpack_require__(344);
let PayrollItemsModule = class PayrollItemsModule {
};
exports.PayrollItemsModule = PayrollItemsModule;
exports.PayrollItemsModule = PayrollItemsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            typeorm_1.TypeOrmModule.forFeature([payroll_item_entity_1.PayrollItem]),
        ],
        providers: [payroll_items_service_1.PayrollItemsService],
        exports: [payroll_items_service_1.PayrollItemsService],
        controllers: [payroll_items_controller_1.PayrollItemsController],
    })
], PayrollItemsModule);


/***/ }),
/* 342 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemsController = void 0;
const create_controller_factory_1 = __webpack_require__(18);
const payroll_dto_1 = __webpack_require__(343);
const payroll_item_entity_1 = __webpack_require__(65);
const payroll_items_service_1 = __webpack_require__(344);
class PayrollItemsController extends (0, create_controller_factory_1.createController)(payroll_item_entity_1.PayrollItem, payroll_items_service_1.PayrollItemsService, payroll_dto_1.GetPayrollDto, payroll_dto_1.PayrollDto, payroll_dto_1.UpdatePayrollDto) {
}
exports.PayrollItemsController = PayrollItemsController;


/***/ }),
/* 343 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPayrollDto = exports.UpdatePayrollDto = exports.PayrollDto = void 0;
const base_dto_1 = __webpack_require__(101);
const create_get_dto_factory_1 = __webpack_require__(103);
const swagger_1 = __webpack_require__(8);
const class_validator_1 = __webpack_require__(24);
const swagger_2 = __webpack_require__(8);
class PayrollDto extends (0, swagger_2.PartialType)(base_dto_1.BaseDto) {
}
exports.PayrollDto = PayrollDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the payroll' }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], PayrollDto.prototype, "name", void 0);
class UpdatePayrollDto extends (0, swagger_2.PartialType)(PayrollDto) {
}
exports.UpdatePayrollDto = UpdatePayrollDto;
class GetPayrollDto extends (0, create_get_dto_factory_1.createGetDto)(PayrollDto) {
}
exports.GetPayrollDto = GetPayrollDto;


/***/ }),
/* 344 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollItemsService = void 0;
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const typeorm_2 = __webpack_require__(25);
const payroll_item_entity_1 = __webpack_require__(65);
let PayrollItemsService = class PayrollItemsService extends base_service_1.BaseService {
    constructor(payrollItemsRepository, usersService) {
        super(payrollItemsRepository, usersService);
        this.payrollItemsRepository = payrollItemsRepository;
        this.usersService = usersService;
    }
};
exports.PayrollItemsService = PayrollItemsService;
exports.PayrollItemsService = PayrollItemsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(payroll_item_entity_1.PayrollItem)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], PayrollItemsService);


/***/ }),
/* 345 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollsController = void 0;
const authorize_decorator_1 = __webpack_require__(26);
const current_user_decorator_1 = __webpack_require__(97);
const generalresponse_dto_1 = __webpack_require__(86);
const action_enum_1 = __webpack_require__(40);
const create_controller_factory_1 = __webpack_require__(18);
const common_1 = __webpack_require__(5);
const swagger_1 = __webpack_require__(8);
const class_transformer_1 = __webpack_require__(23);
const express_1 = __webpack_require__(205);
const payroll_dto_1 = __webpack_require__(343);
const payroll_entity_1 = __webpack_require__(63);
const payrolls_service_1 = __webpack_require__(346);
class PayrollsController extends (0, create_controller_factory_1.createController)(payroll_entity_1.Payroll, payrolls_service_1.PayrollsService, payroll_dto_1.GetPayrollDto, payroll_dto_1.PayrollDto, payroll_dto_1.UpdatePayrollDto) {
    constructor(payrollsService) {
        super(payrollsService);
        this.payrollsService = payrollsService;
    }
    async processPayrollForEmployee(employeeId, cutoffId, userId) {
        const payroll = await this.payrollsService.processPayrollForEmployee(employeeId, cutoffId, userId);
        return payroll;
    }
    async processPayrollForCutoff(cutoffId, userId) {
        const payrolls = await this.payrollsService.processPayrollForCutoff(cutoffId, userId);
        return payrolls;
    }
    async getPayrollDetails(id) {
        return await this.payrollsService.getPayrollDetails(id);
    }
    async generatePayslipData(id) {
        return await this.payrollsService.generatePayslipData(id);
    }
    async downloadPayslip(id, res) {
        const payroll = await this.payrollsService.findOneByOrFail({ id });
        const employee = payroll.employee;
        const payslipData = await this.payrollsService.generatePayslipData(id);
        // You would need to implement PDF generation logic here
        // For example: const pdfBuffer = await generatePayslipPdf(payslipData);
        const fileName = `Payslip_${employee.employeeNumber}_${payroll.cutoff.startDate.toISOString().slice(0, 10)}.pdf`;
        // Set headers and send file
        // res.setHeader('Content-Type', 'application/pdf');
        // res.setHeader('Content-Disposition', `attachment; filename=${fileName}`);
        // res.send(pdfBuffer);
        // For now, just return JSON as placeholder
        res.json({
            message: 'PDF generation to be implemented',
            payslipData,
            fileName
        });
    }
    async approvePayroll(id, userId) {
        await this.payrollsService.update(id, {
            status: 'APPROVED',
            approvedAt: new Date(),
            approvedBy: userId
        }, userId);
        return {
            message: 'Payroll approved successfully'
        };
    }
    async releasePayroll(id, releaseData, userId) {
        await this.payrollsService.update(id, {
            status: 'RELEASED',
            releasedAt: new Date(),
            releasedBy: userId,
            paymentMethod: releaseData.paymentMethod,
            paymentDate: releaseData.paymentDate || new Date(),
            bankReferenceNumber: releaseData.bankReferenceNumber,
            bankAccount: releaseData.bankAccount,
            checkNumber: releaseData.checkNumber
        }, userId);
        return {
            message: 'Payroll released successfully'
        };
    }
    async rejectPayroll(id, reason, userId) {
        await this.payrollsService.update(id, {
            status: 'REJECTED',
            notes: `Rejected: ${reason}`,
            updatedBy: userId
        }, userId);
        return {
            message: 'Payroll rejected successfully'
        };
    }
    async getEmployeePayrolls(employeeId, year, month) {
        // Build filter criteria
        const criteria = {
            employee: { id: employeeId }
        };
        // Convert month and year to cutoff date range if provided
        if (year || month) {
            criteria.cutoff = {};
            if (year && month) {
                const startDate = new Date(year, month - 1, 1);
                const endDate = new Date(year, month, 0);
                criteria.cutoff.startDate = { gte: startDate };
                criteria.cutoff.endDate = { lte: endDate };
            }
            else if (year) {
                const startDate = new Date(year, 0, 1);
                const endDate = new Date(year, 11, 31);
                criteria.cutoff.startDate = { gte: startDate };
                criteria.cutoff.endDate = { lte: endDate };
            }
        }
        const payrolls = await this.payrollsService.getRepository().findBy(Object.assign(Object.assign({}, criteria), { relations: {
                cutoff: true
            }, order: {
                cutoff: {
                    startDate: 'DESC'
                }
            } }));
        return (0, class_transformer_1.plainToInstance)(payroll_dto_1.GetPayrollDto, payrolls);
    }
}
exports.PayrollsController = PayrollsController;
__decorate([
    (0, common_1.Post)('process/employee/:employeeId/cutoff/:cutoffId'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.CREATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Process payroll for a specific employee and cutoff',
        description: 'Generates and calculates a complete payroll for an employee for a given cutoff period'
    }),
    (0, swagger_1.ApiParam)({
        name: 'employeeId',
        description: 'ID of the employee to process payroll for',
        required: true
    }),
    (0, swagger_1.ApiParam)({
        name: 'cutoffId',
        description: 'ID of the cutoff period to process',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        description: 'Payroll successfully processed',
        type: payroll_dto_1.GetPayrollDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid request or payroll already processed'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Employee or cutoff not found'
    }),
    __param(0, (0, common_1.Param)('employeeId')),
    __param(1, (0, common_1.Param)('cutoffId')),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], PayrollsController.prototype, "processPayrollForEmployee", null);
__decorate([
    (0, common_1.Post)('process/cutoff/:cutoffId'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.CREATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Process payroll for all employees in a cutoff',
        description: 'Batch process payrolls for all eligible employees in a specified cutoff period'
    }),
    (0, swagger_1.ApiParam)({
        name: 'cutoffId',
        description: 'ID of the cutoff period to process payrolls for',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        description: 'Payrolls successfully processed',
        type: [payroll_dto_1.GetPayrollDto]
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid request, cutoff not active, or no eligible employees'
    }),
    __param(0, (0, common_1.Param)('cutoffId')),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], PayrollsController.prototype, "processPayrollForCutoff", null);
__decorate([
    (0, common_1.Get)(':id/details'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({
        summary: 'Get detailed payroll information',
        description: 'Retrieves comprehensive payroll details including all calculated components'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to get details for',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payroll details retrieved successfully'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Payroll not found'
    }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], PayrollsController.prototype, "getPayrollDetails", null);
__decorate([
    (0, common_1.Get)(':id/payslip'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({
        summary: 'Get payslip data',
        description: 'Generates structured payslip data for an existing payroll'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to generate payslip for',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payslip data generated successfully'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Payroll not found'
    }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], PayrollsController.prototype, "generatePayslipData", null);
__decorate([
    (0, common_1.Get)(':id/payslip/download'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({
        summary: 'Download payslip as PDF',
        description: 'Generates and downloads a PDF payslip for the specified payroll'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to generate PDF payslip for',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'PDF generated and downloaded successfully'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Payroll not found'
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_e = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _e : Object]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], PayrollsController.prototype, "downloadPayslip", null);
__decorate([
    (0, common_1.Post)(':id/approve'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Approve a payroll',
        description: 'Changes the status of a payroll to APPROVED'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to approve',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payroll approved successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Payroll not found'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Payroll cannot be approved (invalid status)'
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], PayrollsController.prototype, "approvePayroll", null);
__decorate([
    (0, common_1.Post)(':id/release'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Release a payroll',
        description: 'Marks a payroll as RELEASED, indicating it has been sent for payment'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to release',
        required: true
    }),
    (0, swagger_1.ApiBody)({
        schema: {
            properties: {
                paymentMethod: { type: 'string' },
                paymentDate: { type: 'string', format: 'date-time' },
                bankReferenceNumber: { type: 'string' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payroll released successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], PayrollsController.prototype, "releasePayroll", null);
__decorate([
    (0, common_1.Post)(':id/reject'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.UPDATE }),
    (0, swagger_1.ApiOperation)({
        summary: 'Reject a payroll',
        description: 'Marks a payroll as REJECTED'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID of the payroll to reject',
        required: true
    }),
    (0, swagger_1.ApiQuery)({
        name: 'reason',
        required: true,
        description: 'Reason for rejection'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Payroll rejected successfully',
        type: generalresponse_dto_1.GeneralResponseDto
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Query)('reason')),
    __param(2, (0, current_user_decorator_1.CurrentUser)('sub')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], PayrollsController.prototype, "rejectPayroll", null);
__decorate([
    (0, common_1.Get)('employee/:employeeId'),
    (0, authorize_decorator_1.Authorize)({ endpointType: action_enum_1.Action.READ }),
    (0, swagger_1.ApiOperation)({
        summary: 'Get all payrolls for an employee',
        description: 'Retrieves all payrolls for a specific employee'
    }),
    (0, swagger_1.ApiParam)({
        name: 'employeeId',
        description: 'ID of the employee',
        required: true
    }),
    (0, swagger_1.ApiQuery)({
        name: 'year',
        required: false,
        description: 'Filter by year'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'month',
        required: false,
        description: 'Filter by month (1-12)'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Employee payrolls retrieved successfully',
        type: [payroll_dto_1.GetPayrollDto]
    }),
    __param(0, (0, common_1.Param)('employeeId')),
    __param(1, (0, common_1.Query)('year')),
    __param(2, (0, common_1.Query)('month')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number, Number]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], PayrollsController.prototype, "getEmployeePayrolls", null);


/***/ }),
/* 346 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PayrollsService_1;
var _a, _b, _c, _d, _e, _f, _g, _h;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayrollsService = void 0;
const cutoff_status_enum_1 = __webpack_require__(56);
const cutoff_type_enum_1 = __webpack_require__(57);
const payroll_item_category_enum_1 = __webpack_require__(67);
const payroll_status_enum_1 = __webpack_require__(64);
const role_scope_type_enum_1 = __webpack_require__(38);
const utility_helper_1 = __webpack_require__(87);
const base_service_1 = __webpack_require__(31);
const users_service_1 = __webpack_require__(30);
const final_work_hours_service_1 = __webpack_require__(268);
const common_1 = __webpack_require__(5);
const typeorm_1 = __webpack_require__(16);
const mathjs_1 = __webpack_require__(347);
const typeorm_2 = __webpack_require__(25);
const employees_service_1 = __webpack_require__(104);
const cutoffs_service_1 = __webpack_require__(130);
const payroll_entity_1 = __webpack_require__(63);
const payroll_item_types_service_1 = __webpack_require__(340);
const payroll_item_entity_1 = __webpack_require__(65);
const payroll_items_service_1 = __webpack_require__(344);
// Add these types to your system using PayrollItemType entity
const salaryCompensationTypes = [
    {
        name: 'Monthly Salary',
        category: payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION,
        unit: 'PHP',
        computationFormula: 'return Amount;', // Simply return the configured amount
        isSystemGenerated: true,
        isRequired: true
    },
    {
        name: 'Daily Rate',
        category: payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION,
        unit: 'PHP',
        computationFormula: 'return Amount * WorkingDaysInPeriod;',
        isSystemGenerated: true,
        isRequired: true
    },
    {
        name: 'Hourly Rate',
        category: payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION,
        unit: 'PHP',
        computationFormula: 'return Amount * WorkHoursInPeriod;',
        isSystemGenerated: true,
        isRequired: true
    }
];
const sssEmployeeContribution = {
    name: 'SSS Employee Contribution',
    description: 'Social Security System employee contribution',
    category: payroll_item_category_enum_1.PayrollItemCategory.GOVERNMENT,
    defaultOccurrence: 'MONTHLY',
    unit: 'PHP',
    computationFormula: `
    // 2023 SSS Contribution Table
    const msw = Employee.MonthlyRate;
    let contribution = 0;
    
    if (msw <= 3249.99) contribution = 135;
    else if (msw <= 3749.99) contribution = 157.50;
    else if (msw <= 4249.99) contribution = 180;
    else if (msw <= 4749.99) contribution = 202.50;
    // ... more brackets
    else if (msw >= 24750) contribution = 1125;
    
    return contribution;
  `,
    isSystemGenerated: true,
    isGovernmentMandated: true,
    governmentContributionType: 'SSS',
    hasEmployerShare: true,
    employerFormulaPercentage: `
    // 2023 SSS Employer Contribution Table
    const msw = Employee.MonthlyRate;
    let contribution = 0;
    
    if (msw <= 3249.99) contribution = 315;
    else if (msw <= 3749.99) contribution = 367.50;
    else if (msw <= 4249.99) contribution = 420;
    // ... more brackets
    else if (msw >= 24750) contribution = 2625;
    
    return contribution;
  `,
    isPartOfTaxCalculation: true,
    isTaxable: false,
    isTaxDeductible: true,
    isDisplayedInPayslip: true,
    isRequired: true,
    calculationParameters: {
        sssTable: '2023',
        includingEC: true,
        includingMPF: false
    }
};
const philhealthContribution = {
    name: 'PhilHealth Contribution',
    description: 'Philippine Health Insurance Corporation contribution',
    category: payroll_item_category_enum_1.PayrollItemCategory.GOVERNMENT,
    defaultOccurrence: 'MONTHLY',
    unit: 'PHP',
    computationFormula: `
    // 2023 PhilHealth Contribution - shared equally by employer and employee
    const msw = Employee.MonthlyRate;
    let totalContribution = 0;
    
    if (msw <= 10000) totalContribution = 400;
    else if (msw <= 59999.99) totalContribution = msw * 0.04;
    else totalContribution = 2400;
    
    return totalContribution / 2; // Employee share only
  `,
    isSystemGenerated: true,
    isGovernmentMandated: true,
    governmentContributionType: 'PHILHEALTH',
    hasEmployerShare: true,
    employerFormulaPercentage: `return Amount;`, // Equal share: employee and employer
    isPartOfTaxCalculation: true,
    isTaxable: false,
    isTaxDeductible: true,
    isDisplayedInPayslip: true,
    isRequired: true,
    calculationParameters: {
        philhealthTable: '2023',
        premiumRate: 4 // percent
    }
};
const pagibigContribution = {
    name: 'Pag-IBIG Contribution',
    description: 'Home Development Mutual Fund contribution',
    category: payroll_item_category_enum_1.PayrollItemCategory.GOVERNMENT,
    defaultOccurrence: 'MONTHLY',
    unit: 'PHP',
    computationFormula: `
    // Pag-IBIG Contribution - 2% of monthly salary
    const msw = Math.min(Employee.MonthlyRate, 5000);
    return msw * 0.02;
  `,
    isSystemGenerated: true,
    isGovernmentMandated: true,
    governmentContributionType: 'PAGIBIG',
    hasEmployerShare: true,
    employerFormulaPercentage: `
    // Employer share is also 2% of monthly salary
    const msw = Math.min(Employee.MonthlyRate, 5000);
    return msw * 0.02;
  `,
    isPartOfTaxCalculation: true,
    isTaxable: false,
    isTaxDeductible: true,
    isDisplayedInPayslip: true,
    isRequired: true,
    calculationParameters: {
        pagibigTable: '2023',
        rate: 2 // percent
    }
};
const withholdingTax = {
    name: 'Withholding Tax',
    description: 'BIR withholding tax for compensation income',
    category: payroll_item_category_enum_1.PayrollItemCategory.TAX,
    defaultOccurrence: 'MONTHLY',
    unit: 'PHP',
    computationFormula: `
    // 2023 Withholding Tax Table
    // Get taxable income (after deducting government contributions)
    const taxableIncome = TaxableIncome;
    let tax = 0;
    
    if (taxableIncome <= 20833) tax = 0;
    else if (taxableIncome <= 33332) tax = (taxableIncome - 20833) * 0.15;
    else if (taxableIncome <= 66666) tax = 1875 + (taxableIncome - 33333) * 0.20;
    else if (taxableIncome <= 166666) tax = 8541.80 + (taxableIncome - 66667) * 0.25;
    else if (taxableIncome <= 666666) tax = 33541.80 + (taxableIncome - 166667) * 0.30;
    else tax = 183541.80 + (taxableIncome - 666667) * 0.35;
    
    return tax;
  `,
    isSystemGenerated: true,
    isGovernmentMandated: true,
    governmentContributionType: 'TAX',
    hasEmployerShare: false,
    isPartOfTaxCalculation: false, // Not part of taxable income computation
    isTaxable: false,
    isTaxDeductible: false,
    isDisplayedInPayslip: true,
    isRequired: true,
    calculationParameters: {
        taxTable: '2023',
        applicableTaxExemptions: ['de_minimis', 'thirteenth_month']
    }
};
let PayrollsService = PayrollsService_1 = class PayrollsService extends base_service_1.BaseService {
    constructor(payrollsRepository, dataSource, employeesService, cutoffsService, finalWorkHoursService, payrollItemsService, payrollItemTypesService, usersService) {
        super(payrollsRepository, usersService);
        this.payrollsRepository = payrollsRepository;
        this.dataSource = dataSource;
        this.employeesService = employeesService;
        this.cutoffsService = cutoffsService;
        this.finalWorkHoursService = finalWorkHoursService;
        this.payrollItemsService = payrollItemsService;
        this.payrollItemTypesService = payrollItemTypesService;
        this.usersService = usersService;
        this.logger = new common_1.Logger(PayrollsService_1.name);
        this.RestDayPayMultiplier = 1.3;
        this.HolidayPayMultiplier = 2.0;
        this.SpecialHolidayPayMultiplier = 1.3;
        this.OvertimePayMultiplier = 1.25;
        this.HolidayOvertimePayMultiplier = 2.3;
        this.SpecialHolidayOvertimePayMultiplier = 1.3;
        this.RestDayOvertimePayMultiplier = 1.69;
        this.NightDifferentialPayMultiplier = 0.1;
    }
    /**
     * Calculate rates based on monthly salary and cutoff period
     */
    calculateRates(employee, cutoff) {
        const monthlyRate = employee.monthlyRate;
        const businessDaysInPeriod = utility_helper_1.UtilityHelper.getBusinessDays(cutoff.startDate, cutoff.endDate);
        const businessDaysInMonth = utility_helper_1.UtilityHelper.getBusinessDaysInMonth(cutoff.startDate);
        // Calculate daily rate based on cutoff type
        let dailyRate;
        switch (cutoff.cutoffType) {
            case cutoff_type_enum_1.CutoffType.DAILY:
                dailyRate = monthlyRate / businessDaysInMonth;
                break;
            case cutoff_type_enum_1.CutoffType.WEEKLY:
                dailyRate = (monthlyRate / 4) / businessDaysInPeriod;
                break;
            case cutoff_type_enum_1.CutoffType.BI_WEEKLY:
                dailyRate = (monthlyRate / 2) / businessDaysInPeriod;
                break;
            case cutoff_type_enum_1.CutoffType.MONTHLY:
            default:
                dailyRate = monthlyRate / businessDaysInMonth;
                break;
        }
        // Standard 8-hour workday in Philippines
        const hourlyRate = dailyRate / 8;
        return { monthlyRate, dailyRate, hourlyRate };
    }
    calculateRatesBase(employee, cutoff, baseCompensationItem) {
        const compensationType = baseCompensationItem.payrollItemType.name;
        const amount = baseCompensationItem.amount;
        // Calculate days in period
        const businessDaysInPeriod = utility_helper_1.UtilityHelper.getBusinessDays(cutoff.startDate, cutoff.endDate);
        const businessDaysInMonth = utility_helper_1.UtilityHelper.getBusinessDaysInMonth(cutoff.startDate);
        // Initialize with default values
        let monthlyRate = 0;
        let dailyRate = 0;
        let hourlyRate = 0;
        // Calculate based on compensation type
        switch (compensationType) {
            case 'Monthly Salary':
                monthlyRate = amount;
                dailyRate = amount / businessDaysInMonth;
                hourlyRate = dailyRate / 8; // Assuming 8-hour workday
                break;
            case 'Daily Rate':
                dailyRate = amount;
                monthlyRate = dailyRate * businessDaysInMonth;
                hourlyRate = dailyRate / 8;
                break;
            case 'Hourly Rate':
                hourlyRate = amount;
                dailyRate = hourlyRate * 8;
                monthlyRate = dailyRate * businessDaysInMonth;
                break;
            default:
                throw new Error(`Unknown compensation type: ${compensationType}`);
        }
        return { monthlyRate, dailyRate, hourlyRate };
    }
    /**
     * Calculate basic pay components from work hours
     */
    calculateBasicPay(payroll, finalWorkHours) {
        const rates = this.calculateRates(payroll.employee, payroll.cutoff);
        // Set rates
        payroll.monthlyRate = rates.monthlyRate;
        payroll.dailyRate = rates.dailyRate;
        payroll.hourlyRate = rates.hourlyRate;
        // Reset hour totals
        payroll.totalRegularHours = 0;
        payroll.totalHolidayHours = 0;
        payroll.totalSpecialHolidayHours = 0;
        payroll.totalRestDayHours = 0;
        payroll.totalOvertimeHours = 0;
        payroll.totalHolidayOvertimeHours = 0;
        payroll.totalSpecialHolidayOvertimeHours = 0;
        payroll.totalRestDayOvertimeHours = 0;
        payroll.totalNightDifferentialHours = 0;
        // Reset pay components
        payroll.basicPay = 0;
        payroll.overtimePay = 0;
        payroll.holidayPay = 0;
        payroll.holidayOvertimePay = 0;
        payroll.specialHolidayPay = 0;
        payroll.specialHolidayOvertimePay = 0;
        payroll.restDayPay = 0;
        payroll.restDayOvertimePay = 0;
        payroll.nightDifferentialPay = 0;
        // Process each work hour record
        for (const workHour of finalWorkHours) {
            // Aggregate regular hours
            payroll.totalRegularHours += +workHour.regularDayHours || 0;
            payroll.totalHolidayHours += +workHour.specialHolidayHours || 0;
            payroll.totalSpecialHolidayHours += +workHour.regularHolidayHours || 0;
            payroll.totalRestDayHours += +workHour.restDayHours || 0;
            // Aggregate overtime hours
            payroll.totalOvertimeHours += +workHour.overtimeRegularDayHours || 0;
            payroll.totalHolidayOvertimeHours += +workHour.overtimeRegularHolidayHours || 0;
            payroll.totalSpecialHolidayOvertimeHours += +workHour.overtimeSpecialHolidayHours || 0;
            payroll.totalRestDayOvertimeHours += +workHour.overtimeRestDayHours || 0;
            // Night differential
            payroll.totalNightDifferentialHours += +workHour.nightDifferentialHours || 0;
        }
        // Calculate pay components with proper rate multipliers according to Philippine labor laws
        // 1. Basic regular day pay (1.0x)
        payroll.basicPay = payroll.totalRegularHours * payroll.hourlyRate;
        // 2. Rest day pay (1.3x)
        payroll.restDayPay = payroll.totalRestDayHours * payroll.hourlyRate * this.RestDayPayMultiplier;
        // 3. Holiday pay (2.0x)
        payroll.holidayPay = payroll.totalHolidayHours * payroll.hourlyRate * this.HolidayPayMultiplier;
        // 4. Special holiday pay (1.3x)
        payroll.specialHolidayPay = payroll.totalSpecialHolidayHours * payroll.hourlyRate * this.SpecialHolidayPayMultiplier;
        // 5. Overtime regular pay (1.25x)
        payroll.overtimePay = payroll.totalOvertimeHours * payroll.hourlyRate * this.OvertimePayMultiplier;
        // 6. Overtime holiday pay (2.6x)
        payroll.holidayOvertimePay = payroll.totalHolidayOvertimeHours * payroll.hourlyRate * this.HolidayOvertimePayMultiplier;
        // 7. Overtime special holiday pay (1.3x)
        payroll.specialHolidayOvertimePay = payroll.totalSpecialHolidayOvertimeHours * payroll.hourlyRate * this.SpecialHolidayOvertimePayMultiplier;
        // 8. Overtime rest day pay (1.69x)
        payroll.restDayOvertimePay = payroll.totalRestDayOvertimeHours * payroll.hourlyRate * this.RestDayOvertimePayMultiplier;
        // 9. Night differential (10% of hourly rate)
        payroll.nightDifferentialPay = payroll.totalNightDifferentialHours * payroll.hourlyRate * this.NightDifferentialPayMultiplier;
        // 10. Initial gross pay from basic components
        payroll.grossPay = payroll.basicPay + payroll.restDayPay + payroll.holidayPay
            + payroll.specialHolidayPay + payroll.overtimePay
            + payroll.holidayOvertimePay + payroll.specialHolidayOvertimePay
            + payroll.restDayOvertimePay + payroll.nightDifferentialPay;
        // 11. Total hours worked
        // 12. Initial taxable income (will be adjusted for non-taxable items)
        payroll.taxableIncome = payroll.grossPay;
    }
    /**
     * Evaluate formula for a payroll item
     */
    async evaluateFormula(formula, payroll, parameters) {
        try {
            // Create comprehensive scope for formula evaluation
            const scope = Object.assign({ 
                // Employee data
                MonthlyRate: payroll.monthlyRate, DailyRate: payroll.dailyRate, HourlyRate: payroll.hourlyRate, 
                // Work hours
                RegularHours: payroll.totalRegularHours, HolidayHours: payroll.totalHolidayHours, SpecialHolidayHours: payroll.totalSpecialHolidayHours, RestDayHours: payroll.totalRestDayHours, NightDiffHours: payroll.totalNightDifferentialHours, OvertimeHours: payroll.totalOvertimeHours, HolidayOvertimeHours: payroll.totalHolidayOvertimeHours, SpecialHolidayOvertimeHours: payroll.totalSpecialHolidayOvertimeHours, RestDayOvertimeHours: payroll.totalRestDayOvertimeHours, 
                // Pay components
                BasicPay: payroll.basicPay, HolidayPay: payroll.holidayPay, SpecialHolidayPay: payroll.specialHolidayPay, RestDayPay: payroll.restDayPay, NightDifferentialPay: payroll.nightDifferentialPay, OvertimePay: payroll.overtimePay, HolidayOvertimePay: payroll.holidayOvertimePay, SpecialHolidayOvertimePay: payroll.specialHolidayOvertimePay, RestDayOvertimePay: payroll.restDayOvertimePay, 
                // Totals
                GrossPay: payroll.grossPay, TaxableIncome: payroll.taxableIncome }, parameters);
            // Execute formula
            const result = (0, mathjs_1.evaluate)(formula, scope);
            const numericResult = parseFloat(Number(result).toFixed(2));
            return {
                result: numericResult,
                details: {
                    formula,
                    scope: Object.assign({}, scope),
                    result: numericResult
                }
            };
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger.error(`Error evaluating formula: ${formula}`, error.stack);
                return {
                    result: 0,
                    details: {
                        formula,
                        error: error.message,
                        result: 0
                    }
                };
            }
            else {
                this.logger.error(`Error evaluating formula: ${formula}`, String(error));
                return {
                    result: 0,
                    details: {
                        formula,
                        error: String(error),
                        result: 0
                    }
                };
            }
        }
    }
    /**
     * Process all payroll items for an employee
     */
    async processPayrollItems(payroll, userId) {
        var _a;
        // Get all payroll item types
        const allPayrollItemTypes = await this.payrollItemTypesService.getRepository().find({
            where: { isActive: true, isDeleted: false },
            order: { category: 'ASC', name: 'ASC' }
        });
        // Get employee's assigned payroll items including base compensation
        const employeePayrollItems = await this.payrollItemsService.getRepository().find({
            where: {
                employee: { id: payroll.employee.id },
                isDeleted: false
            },
            relations: {
                payrollItemType: true
            }
        });
        // Find base compensation - Prioritize compensation items
        const baseCompensationItem = employeePayrollItems.find(item => item.payrollItemType.category === payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION);
        if (!baseCompensationItem) {
            throw new Error(`No base compensation defined for employee ${payroll.employee.id}`);
        }
        // Clear existing payroll items if reprocessing
        if ((_a = payroll.payrollItems) === null || _a === void 0 ? void 0 : _a.length) {
            for (const item of payroll.payrollItems) {
                await this.payrollItemsService.delete(item.id);
            }
        }
        // Order for processing categories
        const processingOrder = [
            payroll_item_category_enum_1.PayrollItemCategory.COMPENSATION,
            payroll_item_category_enum_1.PayrollItemCategory.ALLOWANCE,
            payroll_item_category_enum_1.PayrollItemCategory.BONUS,
            payroll_item_category_enum_1.PayrollItemCategory.COMMISSION,
            payroll_item_category_enum_1.PayrollItemCategory.TIP,
            payroll_item_category_enum_1.PayrollItemCategory.BENEFIT,
            payroll_item_category_enum_1.PayrollItemCategory.DEDUCTION,
            payroll_item_category_enum_1.PayrollItemCategory.REIMBURSEMENT,
            payroll_item_category_enum_1.PayrollItemCategory.TAX,
            payroll_item_category_enum_1.PayrollItemCategory.OTHER,
        ];
        const newPayrollItems = [];
        const calculationLog = [];
        // First, track original values for reference
        const originalValues = {
            grossPay: payroll.grossPay,
            taxableIncome: payroll.taxableIncome
        };
        // Process each category in order
        for (const category of processingOrder) {
            // Get item types for this category
            const categoryItemTypes = allPayrollItemTypes.filter(type => type.category === category);
            for (const itemType of categoryItemTypes) {
                // Check if this item type is assigned to employee or is system-generated
                const employeeItem = employeePayrollItems.find(item => item.payrollItemType.id === itemType.id);
                // If not assigned and not system-generated, skip
                if (!employeeItem && !itemType.isSystemGenerated) {
                    continue;
                }
                // Create new payroll item
                const payrollItem = new payroll_item_entity_1.PayrollItem({});
                payrollItem.employee = payroll.employee;
                payrollItem.payrollItemType = itemType;
                payrollItem.payroll = payroll;
                payrollItem.occurrence = (employeeItem === null || employeeItem === void 0 ? void 0 : employeeItem.occurrence) || itemType.defaultOccurrence;
                payrollItem.parameters = (employeeItem === null || employeeItem === void 0 ? void 0 : employeeItem.parameters) || {};
                // Evaluate the formula
                const { result, details } = await this.evaluateFormula(itemType.computationFormula, payroll, payrollItem.parameters);
                payrollItem.amount = result;
                payrollItem.calculationDetails = details;
                // For government-mandated contributions with employer share
                if (itemType.isGovernmentMandated && itemType.hasEmployerShare && itemType.employerFormulaPercentage) {
                    const { result: employerAmount } = await this.evaluateFormula(itemType.employerFormulaPercentage, payroll, Object.assign(Object.assign({}, payrollItem.parameters), { Amount: result }));
                    payrollItem.employerAmount = employerAmount;
                }
                // Save the payroll item
                const savedItem = await this.payrollItemsService.create(payrollItem, userId);
                newPayrollItems.push(savedItem);
                // Track calculation
                calculationLog.push({
                    itemType: itemType.name,
                    category: itemType.category,
                    formula: itemType.computationFormula,
                    amount: result,
                    parameters: payrollItem.parameters
                });
                // Update payroll totals based on this item
                this.updatePayrollTotals(payroll, savedItem);
            }
        }
        // Save calculated totals and details
        payroll.calculationDetails = {
            items: calculationLog,
            original: originalValues,
            final: {
                grossPay: payroll.grossPay,
                taxableIncome: payroll.taxableIncome,
                totalAllowances: payroll.totalAllowances,
                totalBonuses: payroll.totalBonuses,
                totalBenefits: payroll.totalBenefits,
                totalDeductions: payroll.totalDeductions,
                totalGovernmentContributions: payroll.totalGovernmentContributions,
                totalTaxes: payroll.totalTaxes,
                netPay: payroll.netPay
            }
        };
        return newPayrollItems;
    }
    /**
   * Generate a detailed view of a payroll for an employee
   */
    async getPayrollDetails(payrollId) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const payroll = await this.findOneByOrFail({ id: payrollId }, {
            relations: {
                employee: {
                    user: {
                        profile: true
                    },
                    roles: {
                        department: true,
                        branch: true,
                        organization: true,
                    }
                },
                cutoff: true,
                payrollItems: {
                    payrollItemType: true
                }
            }
        });
        // Get the employee's highest scope role
        const highestRole = this.getHighestScopeRole(payroll.employee.roles || []);
        // Determine organizational position based on roles and entity relationships
        const position = this.determineEmployeePosition(payroll.employee);
        // Get government contributions using the entity's getter methods
        const sssContribution = payroll.sssContribution;
        const philHealthContribution = payroll.philHealthContribution;
        const pagIbigContribution = payroll.pagIbigContribution;
        const withHoldingTax = payroll.withHoldingTax;
        // Group items by category for display
        const itemsByCategory = this.groupPayrollItemsByCategory(payroll.payrollItems || []);
        // Format dates
        const startDate = payroll.cutoff.startDate.toLocaleDateString();
        const endDate = payroll.cutoff.endDate.toLocaleDateString();
        return {
            payrollId: payroll.id,
            employee: {
                id: payroll.employee.id,
                name: `${(_a = payroll.employee.user.profile) === null || _a === void 0 ? void 0 : _a.firstName} ${(_b = payroll.employee.user.profile) === null || _b === void 0 ? void 0 : _b.lastName}`,
                employeeNumber: payroll.employee.employeeNumber,
                position: position,
                department: ((_c = highestRole === null || highestRole === void 0 ? void 0 : highestRole.department) === null || _c === void 0 ? void 0 : _c.name) || 'N/A',
                branch: ((_d = highestRole === null || highestRole === void 0 ? void 0 : highestRole.branch) === null || _d === void 0 ? void 0 : _d.name) || 'N/A',
                organization: ((_e = highestRole === null || highestRole === void 0 ? void 0 : highestRole.organization) === null || _e === void 0 ? void 0 : _e.name) || 'N/A',
            },
            cutoff: {
                id: payroll.cutoff.id,
                period: `${startDate} - ${endDate}`,
                type: payroll.cutoff.cutoffType
            },
            rates: {
                monthly: payroll.monthlyRate,
                daily: payroll.dailyRate,
                hourly: payroll.hourlyRate
            },
            workHours: {
                regular: payroll.totalRegularHours,
                overtime: payroll.totalOvertimeHours,
                holiday: payroll.totalHolidayHours,
                specialHoliday: payroll.totalSpecialHolidayHours,
                restDay: payroll.totalRestDayHours,
                nightDifferential: payroll.totalNightDifferentialHours,
                holidayOvertime: payroll.totalHolidayOvertimeHours,
                specialHolidayOvertime: payroll.totalSpecialHolidayOvertimeHours,
                restDayOvertime: payroll.totalRestDayOvertimeHours,
                total: (payroll.totalRegularHours +
                    payroll.totalOvertimeHours +
                    payroll.totalHolidayHours +
                    payroll.totalSpecialHolidayHours +
                    payroll.totalRestDayHours +
                    payroll.totalHolidayOvertimeHours +
                    payroll.totalSpecialHolidayOvertimeHours +
                    payroll.totalRestDayOvertimeHours)
            },
            earnings: {
                basicPay: payroll.basicPay,
                overtimePay: payroll.overtimePay,
                holidayPay: payroll.holidayPay,
                holidayOvertimePay: payroll.holidayOvertimePay,
                specialHolidayPay: payroll.specialHolidayPay,
                specialHolidayOvertimePay: payroll.specialHolidayOvertimePay,
                restDayPay: payroll.restDayPay,
                restDayOvertimePay: payroll.restDayOvertimePay,
                nightDifferentialPay: payroll.nightDifferentialPay,
                allowances: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.ALLOWANCE] || [],
                bonuses: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.BONUS] || [],
                commissions: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.COMMISSION] || [],
                tips: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.TIP] || [],
            },
            deductions: {
                governmentContributions: {
                    sss: {
                        employee: sssContribution.employee,
                        employer: sssContribution.employer,
                        total: sssContribution.total
                    },
                    philhealth: {
                        employee: philHealthContribution.employee,
                        employer: philHealthContribution.employer,
                        total: philHealthContribution.total
                    },
                    pagibig: {
                        employee: pagIbigContribution.employee,
                        employer: pagIbigContribution.employer,
                        total: pagIbigContribution.total
                    },
                    tax: withHoldingTax
                },
                otherDeductions: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.DEDUCTION] || []
            },
            totals: {
                grossPay: payroll.grossPay,
                taxableIncome: payroll.taxableIncome,
                totalDeductions: (payroll.totalDeductions +
                    payroll.totalGovernmentContributions +
                    payroll.totalTaxes),
                netPay: payroll.netPay
            },
            benefits: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.BENEFIT] || [],
            reimbursements: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.REIMBURSEMENT] || [],
            status: payroll.status,
            paymentDetails: {
                method: payroll.paymentMethod,
                bankAccount: payroll.bankAccount,
                checkNumber: payroll.checkNumber,
                referenceNumber: payroll.bankReferenceNumber,
                paymentDate: (_f = payroll.paymentDate) === null || _f === void 0 ? void 0 : _f.toLocaleDateString(),
            },
            processing: {
                processedAt: (_g = payroll.processedAt) === null || _g === void 0 ? void 0 : _g.toLocaleDateString(),
                processedBy: payroll.processedBy,
                approvedAt: (_h = payroll.approvedAt) === null || _h === void 0 ? void 0 : _h.toLocaleDateString(),
                approvedBy: payroll.approvedBy,
                releasedAt: (_j = payroll.releasedAt) === null || _j === void 0 ? void 0 : _j.toLocaleDateString(),
                releasedBy: payroll.releasedBy,
            },
            notes: payroll.notes,
        };
    }
    /**
     * Get the highest scope role from the employee's roles
     */
    getHighestScopeRole(roles) {
        if (!roles.length)
            return undefined;
        // Define scope priority (higher number = higher priority)
        const scopePriority = {
            [role_scope_type_enum_1.RoleScopeType.GLOBAL]: 5,
            [role_scope_type_enum_1.RoleScopeType.ORGANIZATION]: 4,
            [role_scope_type_enum_1.RoleScopeType.BRANCH]: 3,
            [role_scope_type_enum_1.RoleScopeType.DEPARTMENT]: 2,
            [role_scope_type_enum_1.RoleScopeType.OWNED]: 1
        };
        // Sort roles by scope priority (highest first)
        const sortedRoles = [...roles].sort((a, b) => scopePriority[b.scope] - scopePriority[a.scope]);
        return sortedRoles[0];
    }
    /**
     * Determine the employee's position based on roles and organizational relationships
     */
    determineEmployeePosition(employee) {
        var _a, _b, _c;
        if (!employee.roles || employee.roles.length === 0) {
            return 'Staff';
        }
        const highestRole = this.getHighestScopeRole(employee.roles);
        if (!highestRole)
            return 'Staff';
        // Construct position based on role scope and name
        let positionPrefix = '';
        switch (highestRole.scope) {
            case role_scope_type_enum_1.RoleScopeType.GLOBAL:
                positionPrefix = 'Executive';
                break;
            case role_scope_type_enum_1.RoleScopeType.ORGANIZATION:
                positionPrefix = ((_a = highestRole.organization) === null || _a === void 0 ? void 0 : _a.name) || 'Organizational';
                break;
            case role_scope_type_enum_1.RoleScopeType.BRANCH:
                positionPrefix = ((_b = highestRole.branch) === null || _b === void 0 ? void 0 : _b.name) || 'Branch';
                break;
            case role_scope_type_enum_1.RoleScopeType.DEPARTMENT:
                positionPrefix = ((_c = highestRole.department) === null || _c === void 0 ? void 0 : _c.name) || 'Department';
                break;
            case role_scope_type_enum_1.RoleScopeType.OWNED:
                positionPrefix = 'Team';
                break;
        }
        return `${positionPrefix} ${highestRole.name}`;
    }
    /**
     * Helper method to group payroll items by category
     */
    groupPayrollItemsByCategory(payrollItems) {
        const result = {};
        payrollItems.forEach(item => {
            const category = item.payrollItemType.category;
            if (!result[category]) {
                result[category] = [];
            }
            result[category].push({
                id: item.id,
                name: item.payrollItemType.name,
                amount: item.amount,
                employerAmount: item.employerAmount || 0,
                total: item.amount + (item.employerAmount || 0),
                isGovernmentMandated: item.payrollItemType.isGovernmentMandated,
                isTaxable: item.isTaxable,
                govType: item.payrollItemType.governmentContributionType,
                description: item.payrollItemType.description
            });
        });
        return result;
    }
    /**
     * Update payroll totals based on a single payroll item
     */
    updatePayrollTotals(payroll, item) {
        const category = item.payrollItemType.category;
        const amount = +item.amount;
        // Update category totals
        switch (category) {
            case payroll_item_category_enum_1.PayrollItemCategory.ALLOWANCE:
                payroll.totalAllowances += amount;
                payroll.grossPay += amount;
                // Update taxable income if this allowance is taxable
                if (item.isTaxable) {
                    payroll.taxableIncome += amount;
                }
                break;
            case payroll_item_category_enum_1.PayrollItemCategory.BONUS:
                payroll.totalBonuses += amount;
                payroll.grossPay += amount;
                // Update taxable income if this bonus is taxable (some bonuses like 13th month up to 90k are non-taxable)
                if (item.isTaxable) {
                    payroll.taxableIncome += amount;
                }
                break;
            case payroll_item_category_enum_1.PayrollItemCategory.BENEFIT:
                payroll.totalBenefits += amount;
                // Benefits typically aren't part of gross pay
                break;
            case payroll_item_category_enum_1.PayrollItemCategory.DEDUCTION:
                payroll.totalDeductions += amount;
                // Deductions don't affect gross pay, only net pay
                break;
            case payroll_item_category_enum_1.PayrollItemCategory.TAX:
                payroll.totalTaxes += amount;
                // Taxes don't affect taxable income
                break;
            default:
                // For other categories like REIMBURSEMENT, COMMISSION, etc.
                // Handle based on specific rules
                // For government contributions
                if (item.payrollItemType.isGovernmentMandated) {
                    payroll.totalGovernmentContributions += amount;
                    // Government contributions typically reduce taxable income
                    if (item.payrollItemType.isTaxDeductible) {
                        payroll.taxableIncome -= amount;
                    }
                    // // Update specific contribution tracking for reporting
                    // if (item.payrollItemType.governmentContributionType) {
                    //   const type = item.payrollItemType.governmentContributionType.toLowerCase();
                    //   if (type.includes('sss')) {
                    //     payroll.sssEmployeeContribution = amount;
                    //     if (item.employerAmount) {
                    //       payroll.sssEmployerContribution = +item.employerAmount;
                    //     }
                    //   } else if (type.includes('philhealth')) {
                    //     payroll.philHealthEmployeeContribution = amount;
                    //     if (item.employerAmount) {
                    //       payroll.philHealthEmployerContribution = +item.employerAmount;
                    //     }
                    //   } else if (type.includes('pagibig')) {
                    //     payroll.pagIbigEmployeeContribution = amount;
                    //     if (item.employerAmount) {
                    //       payroll.pagIbigContribution = +item.employerAmount;
                    //     }
                    //   } else if (type.includes('tax')) {
                    //     payroll.withHoldingTax = amount;
                    //   }
                    // }
                }
                break;
        }
        // Ensure taxable income doesn't go negative
        payroll.taxableIncome = Math.max(0, payroll.taxableIncome);
        // Update net pay
        payroll.netPay = payroll.grossPay + payroll.totalBenefits -
            payroll.totalDeductions - payroll.totalGovernmentContributions -
            payroll.totalTaxes;
    }
    /**
     * Process payroll for a single employee
     */
    async processPayrollForEmployee(employeeId, cutoffId, userId) {
        return this.dataSource.transaction(async (transactionManager) => {
            // Check if payroll already exists for this employee and cutoff
            const existingPayroll = await transactionManager.findOne(payroll_entity_1.Payroll, {
                where: {
                    employee: { id: employeeId },
                    cutoff: { id: cutoffId }
                },
                relations: {
                    employee: true,
                    cutoff: true,
                    payrollItems: {
                        payrollItemType: true
                    }
                }
            });
            // If exists and already processed, prevent re-processing
            if (existingPayroll && ![payroll_status_enum_1.PayrollStatus.DRAFT, payroll_status_enum_1.PayrollStatus.ERROR].includes(existingPayroll.status)) {
                throw new common_1.BadRequestException(`Payroll for this employee and cutoff already processed with status: ${existingPayroll.status}`);
            }
            // Get employee and cutoff data
            const employee = await this.employeesService.findOneByOrFail({ id: employeeId });
            const cutoff = await this.cutoffsService.findOneByOrFail({ id: cutoffId });
            if (cutoff.status !== cutoff_status_enum_1.CutoffStatus.PENDING) {
                throw new common_1.BadRequestException('Cutoff is not pending');
            }
            // Get final work hours for this employee and cutoff
            const finalWorkHours = await this.finalWorkHoursService.getRepository().findBy({
                employee: { id: employeeId },
                cutoff: { id: cutoffId },
                isApproved: true,
                isProcessed: false
            });
            if (!finalWorkHours.length) {
                throw new common_1.BadRequestException('No approved work hours found for this cutoff period');
            }
            // Use existing payroll or create new one
            const payroll = existingPayroll || new payroll_entity_1.Payroll({});
            // Set core properties
            payroll.employee = employee;
            payroll.cutoff = cutoff;
            payroll.status = payroll_status_enum_1.PayrollStatus.PROCESSING;
            // Calculate basic pay from work hours
            this.calculateBasicPay(payroll, finalWorkHours);
            // Save payroll to get an ID if new
            const savedPayroll = await transactionManager.save(payroll);
            // Process all payroll items
            const payrollItems = await this.processPayrollItems(savedPayroll, userId);
            savedPayroll.payrollItems = payrollItems;
            // Mark work hours as processed
            for (const workHour of finalWorkHours) {
                await this.finalWorkHoursService.update(workHour.id, { isProcessed: true }, userId);
            }
            // Finalize payroll
            savedPayroll.processedAt = new Date();
            savedPayroll.processedBy = userId;
            savedPayroll.status = payroll_status_enum_1.PayrollStatus.APPROVED;
            // Save the final payroll
            return await transactionManager.save(savedPayroll);
        });
    }
    /**
     * Process payroll for all eligible employees in a cutoff
     */
    async processPayrollForCutoff(cutoffId, userId) {
        const cutoff = await this.cutoffsService.findOneByOrFail({ id: cutoffId });
        if (cutoff.status !== cutoff_status_enum_1.CutoffStatus.PENDING) {
            throw new common_1.BadRequestException('Cutoff is not in pending status');
        }
        // Get all employees with approved work hours for this cutoff
        const workHours = await this.finalWorkHoursService.getRepository().findBy({
            cutoff: { id: cutoffId },
            isApproved: true,
            isProcessed: false
        });
        if (!workHours.length) {
            throw new common_1.BadRequestException('No approved work hours found for this cutoff period');
        }
        // Get unique employee IDs
        const employeeIds = [...new Set(workHours.map(wh => wh.employee.id))];
        // Process payroll for each employee
        const payrolls = [];
        const errors = [];
        for (const employeeId of employeeIds) {
            try {
                const payroll = await this.processPayrollForEmployee(employeeId, cutoffId, userId);
                payrolls.push(payroll);
            }
            catch (error) {
                if (error instanceof Error) {
                    this.logger.error(`Error processing payroll for employee ${employeeId}: ${error.message}`, error.stack);
                    errors.push({ employeeId, error: error.message });
                }
                else {
                    this.logger.error(`Error processing payroll for employee ${employeeId}: ${String(error)}`);
                    errors.push({ employeeId, error: String(error) });
                }
            }
        }
        this.logger.log(`Processed ${payrolls.length} payrolls successfully. ${errors.length} errors.`);
        return payrolls;
    }
    /**
     * Generate payslip data for a specific payroll
     */
    async generatePayslipData(payrollId) {
        var _a, _b, _c, _d;
        const payroll = await this.findOneBy({ id: payrollId }, {
            relations: {
                employee: true,
                cutoff: true,
                payrollItems: {
                    payrollItemType: true
                }
            }
        });
        if (!payroll) {
            throw new common_1.NotFoundException(`Payroll with ID ${payrollId} not found`);
        }
        // Group payroll items by category for organized display
        const itemsByCategory = {};
        for (const item of payroll.payrollItems || []) {
            const category = item.payrollItemType.category;
            if (!itemsByCategory[category]) {
                itemsByCategory[category] = [];
            }
            itemsByCategory[category].push({
                name: item.payrollItemType.name,
                amount: item.amount,
                isDisplayed: item.payrollItemType.isDisplayedInPayslip !== false
            });
        }
        // Format dates
        const startDate = payroll.cutoff.startDate.toLocaleDateString();
        const endDate = payroll.cutoff.endDate.toLocaleDateString();
        // Build payslip data
        return {
            employee: {
                name: `${(_a = payroll.employee.user.profile) === null || _a === void 0 ? void 0 : _a.firstName} ${(_b = payroll.employee.user.profile) === null || _b === void 0 ? void 0 : _b.lastName}`,
                employeeNumber: payroll.employee.employeeNumber,
                // position: payroll.employee.roles?.name || '',
                // department: payroll.employee.departmentId?.name || ''
            },
            payPeriod: `${startDate} - ${endDate}`,
            rates: {
                monthly: payroll.monthlyRate,
                daily: payroll.dailyRate,
                hourly: payroll.hourlyRate
            },
            workHours: {
                regular: payroll.totalRegularHours,
                overtime: payroll.totalOvertimeHours,
                holiday: payroll.totalHolidayHours,
                restDay: payroll.totalRestDayHours,
                nightDifferential: payroll.totalNightDifferentialHours
            },
            earnings: {
                basicPay: payroll.basicPay,
                overtimePay: payroll.overtimePay,
                holidayPay: payroll.holidayPay,
                restDayPay: payroll.restDayPay,
                nightDifferentialPay: payroll.nightDifferentialPay,
                allowances: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.ALLOWANCE] || [],
                bonuses: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.BONUS] || [],
                commissions: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.COMMISSION] || [],
                tips: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.TIP] || [],
                others: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.OTHER] || []
            },
            deductions: {
                taxes: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.TAX] || [],
                governmentContributions: ((_c = payroll.payrollItems) === null || _c === void 0 ? void 0 : _c.filter(item => item.payrollItemType.isGovernmentMandated).map(item => ({
                    name: item.payrollItemType.name,
                    amount: item.amount,
                    employerAmount: item.employerAmount || 0,
                    total: item.amount + (item.employerAmount || 0)
                }))) || [],
                otherDeductions: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.DEDUCTION] || []
            },
            totals: {
                grossPay: payroll.grossPay,
                totalDeductions: payroll.totalDeductions +
                    payroll.totalGovernmentContributions +
                    payroll.totalTaxes,
                netPay: payroll.netPay
            },
            benefits: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.BENEFIT] || [],
            reimbursements: itemsByCategory[payroll_item_category_enum_1.PayrollItemCategory.REIMBURSEMENT] || [],
            year: new Date().getFullYear(),
            payrollDate: ((_d = payroll.processedAt) === null || _d === void 0 ? void 0 : _d.toLocaleDateString()) || new Date().toLocaleDateString()
        };
    }
};
exports.PayrollsService = PayrollsService;
exports.PayrollsService = PayrollsService = PayrollsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(payroll_entity_1.Payroll)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.DataSource !== "undefined" && typeorm_2.DataSource) === "function" ? _b : Object, typeof (_c = typeof employees_service_1.EmployeesService !== "undefined" && employees_service_1.EmployeesService) === "function" ? _c : Object, typeof (_d = typeof cutoffs_service_1.CutoffsService !== "undefined" && cutoffs_service_1.CutoffsService) === "function" ? _d : Object, typeof (_e = typeof final_work_hours_service_1.FinalWorkHoursService !== "undefined" && final_work_hours_service_1.FinalWorkHoursService) === "function" ? _e : Object, typeof (_f = typeof payroll_items_service_1.PayrollItemsService !== "undefined" && payroll_items_service_1.PayrollItemsService) === "function" ? _f : Object, typeof (_g = typeof payroll_item_types_service_1.PayrollItemTypesService !== "undefined" && payroll_item_types_service_1.PayrollItemTypesService) === "function" ? _g : Object, typeof (_h = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _h : Object])
], PayrollsService);


/***/ }),
/* 347 */
/***/ ((module) => {

"use strict";
module.exports = require("mathjs");

/***/ }),
/* 348 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var HttpExceptionFilter_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpExceptionFilter = void 0;
const common_1 = __webpack_require__(5);
const crypto = __importStar(__webpack_require__(292));
/**
 * HttpExceptionFilter is a global filter that handles all exceptions thrown in the application.
 * It logs the error details, sanitizes sensitive information, and sends a user-friendly response to the client.
 */
let HttpExceptionFilter = HttpExceptionFilter_1 = class HttpExceptionFilter {
    constructor() {
        this.logger = new common_1.Logger(HttpExceptionFilter_1.name);
        this.errorCount = new Map();
        this.SENSITIVE_PATTERNS = [
            /(?:confirm)?password/i,
            /token/i,
            /credit.?card/i,
            /secret/i,
            /ssn/i,
            /social.?security.?number/i,
            /api.?key/i,
            /private.?key/i,
            /pin/i,
            /passcode/i
        ];
    }
    /**
     * Catches and handles exceptions thrown in the application.
     * @param exception - The exception that was thrown.
     * @param host - The arguments host containing request and response objects.
     */
    catch(exception, host) {
        const ctx = host.switchToHttp();
        const response = ctx.getResponse();
        const request = ctx.getRequest();
        const traceId = crypto.randomUUID();
        // Determine error details
        const status = this.getHttpStatus(exception);
        const error = this.normalizeError(exception);
        const timestamp = new Date().toISOString();
        // Get client IP with fallbacks
        const clientIp = request.socket.remoteAddress ||
            request.ip ||
            'unknown';
        // Track error frequency
        this.trackErrorFrequency(clientIp, status);
        // Prepare client response
        const clientResponse = {
            statusCode: status,
            timestamp,
            traceId,
            path: request.url,
            detail: error.name,
            message: exception instanceof common_1.HttpException
                ? exception.getResponse().message || error.message
                : this.getClientMessage(error.message, status),
        };
        response.status(status).json(clientResponse);
    }
    /**
     * Determines the HTTP status code from the exception.
     * @param exception - The exception to evaluate.
     * @returns The HTTP status code.
     */
    getHttpStatus(exception) {
        if (exception instanceof common_1.HttpException) {
            return exception.getStatus();
        }
        return common_1.HttpStatus.INTERNAL_SERVER_ERROR;
    }
    /**
     * Normalizes the exception to an Error object.
     * @param exception - The exception to normalize.
     * @returns The normalized Error object.
     */
    normalizeError(exception) {
        if (exception instanceof Error) {
            return exception;
        }
        return new Error(String(exception));
    }
    /**
     * Sanitizes sensitive headers from the request.
     * @param headers - The headers to sanitize.
     * @returns The sanitized headers.
     */
    sanitizeHeaders(headers) {
        const sanitized = Object.assign({}, headers);
        const sensitiveHeaders = ['authorization', 'cookie', 'x-auth-token'];
        sensitiveHeaders.forEach(header => {
            if (header in sanitized) {
                sanitized[header] = '[REDACTED]';
            }
        });
        return sanitized;
    }
    /**
     * Generates a user-friendly message for the client.
     * @param message - The original error message.
     * @param status - The HTTP status code.
     * @returns The user-friendly message.
     */
    getClientMessage(message, status) {
        return this.sanitizeSensitiveData(message);
    }
    /**
     * Sanitizes sensitive data in the error message.
     * @param message - The message to sanitize.
     * @returns The sanitized message.
     */
    sanitizeSensitiveData(message) {
        let sanitized = message;
        this.SENSITIVE_PATTERNS.forEach(pattern => {
            sanitized = sanitized.replace(pattern, '[REDACTED]');
        });
        return sanitized;
    }
    /**
     * Tracks the frequency of errors from a specific IP address.
     * @param ip - The IP address of the client.
     * @param status - The HTTP status code of the error.
     */
    trackErrorFrequency(ip, status) {
        const key = `${ip}:${status}`;
        const count = (this.errorCount.get(key) || 0) + 1;
        this.errorCount.set(key, count);
        if (count > 10) {
            this.logger.warn({
                type: 'POTENTIAL_ATTACK',
                ip,
                errorCount: count,
                status,
            });
        }
    }
    /**
     * Logs the error details.
     * @param errorContext - The context of the error to log.
     */
    logError(errorContext) {
        if (errorContext.status >= 500) {
            this.logger.error(errorContext);
        }
        else {
            this.logger.warn(errorContext);
        }
    }
};
exports.HttpExceptionFilter = HttpExceptionFilter;
exports.HttpExceptionFilter = HttpExceptionFilter = HttpExceptionFilter_1 = __decorate([
    (0, common_1.Catch)()
], HttpExceptionFilter);


/***/ }),
/* 349 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransformInterceptor = void 0;
const common_1 = __webpack_require__(5);
const class_transformer_1 = __webpack_require__(23);
const operators_1 = __webpack_require__(233);
/**
 * A NestJS interceptor that transforms the response data.
 *
 * This interceptor converts class instances in the response to plain JavaScript objects
 * using the `instanceToPlain` function from class-transformer.
 * It's particularly useful when working with class-transformer decorated entities
 * to ensure proper serialization of response data.
 *
 * @implements {NestInterceptor}
 *
 * @example
 * ```typescript
 * @UseInterceptors(TransformInterceptor)
 * @Get()
 * findAll() {
 *   return this.service.findAll();
 * }
 * ```
 */
let TransformInterceptor = class TransformInterceptor {
    intercept(context, next) {
        return next.handle().pipe((0, operators_1.map)((data) => (0, class_transformer_1.instanceToPlain)(data)));
    }
};
exports.TransformInterceptor = TransformInterceptor;
exports.TransformInterceptor = TransformInterceptor = __decorate([
    (0, common_1.Injectable)()
], TransformInterceptor);


/***/ }),
/* 350 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.swaggerCustomOptions = exports.swaggerConfig = exports.getLocalIpAddress = void 0;
const config_1 = __webpack_require__(6);
const swagger_1 = __webpack_require__(8);
const os_1 = __webpack_require__(351);
// Initialize ConfigService
const configService = new config_1.ConfigService();
// Get local IP address
const getLocalIpAddress = () => {
    var _a;
    const nets = (0, os_1.networkInterfaces)();
    for (const name of Object.keys(nets)) {
        for (const net of (_a = nets[name]) !== null && _a !== void 0 ? _a : []) {
            // Skip over non-IPv4 and internal (loopback) addresses
            if (net.family === 'IPv4' && !net.internal) {
                return net.address;
            }
        }
    }
    return 'localhost'; // Fallback
};
exports.getLocalIpAddress = getLocalIpAddress;
const localIp = (0, exports.getLocalIpAddress)();
const port = configService.get('PORT') || '3000';
exports.swaggerConfig = new swagger_1.DocumentBuilder()
    .setTitle('Dowinn HR Management System API')
    .setDescription('API Documentation')
    .setVersion('1.0')
    .addBearerAuth({
    type: 'http',
    scheme: 'bearer',
    bearerFormat: 'JWT',
    name: 'Authorization',
    description: 'Enter JWT token',
    in: 'header',
}, 'access-token')
    .addServer(configService.getOrThrow('APP_URL'), "Local Development Server")
    .addServer(`http://${localIp}:${port}`, "LAN Development Server") // Use ConfigService to get server URL
    .build();
exports.swaggerCustomOptions = {
    explorer: true,
    customSiteTitle: 'HR Management System',
    customCssUrl: '/swagger/theme-flattop.css',
    customCss: '',
    customJs: '',
    customfavIcon: '',
    swaggerOptions: {
        persistAuthorization: true,
        docExpansion: 'none',
        filter: true,
        displayRequestDuration: true,
        supportedSubmitMethods: ['get', 'put', 'post', 'delete', 'options', 'head', 'patch', 'trace'],
        // Disable CSP
        defaultModelsExpandDepth: -1,
        defaultModelExpandDepth: 1,
        csp: false, // This disables Content Security Policy
        tagGroups: [
            {
                name: 'Account Management',
                tags: ['Auth', 'Users', 'Profile', 'Sessions'],
            },
            {
                name: 'Employee Management',
                tags: ['Employees', 'Roles', 'Permissions'],
            }
        ]
    }
};


/***/ }),
/* 351 */
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(0);
/******/ 	
/******/ })()
;